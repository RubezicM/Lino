/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@glidejs/glide/dist/glide.js":
/*!***************************************************!*\
  !*** ./node_modules/@glidejs/glide/dist/glide.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

/*!
 * Glide.js v3.3.0
 * (c) 2013-2019 Jędrzej Chałubek <jedrzej.chalubek@gmail.com> (http://jedrzejchalubek.com/)
 * Released under the MIT License.
 */
(function (global, factory) {
  ( false ? undefined : _typeof2(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function () {
  'use strict';

  var defaults = {
    /**
     * Type of the movement.
     *
     * Available types:
     * `slider` - Rewinds slider to the start/end when it reaches the first or last slide.
     * `carousel` - Changes slides without starting over when it reaches the first or last slide.
     *
     * @type {String}
     */
    type: 'slider',

    /**
     * Start at specific slide number defined with zero-based index.
     *
     * @type {Number}
     */
    startAt: 0,

    /**
     * A number of slides visible on the single viewport.
     *
     * @type {Number}
     */
    perView: 1,

    /**
     * Focus currently active slide at a specified position in the track.
     *
     * Available inputs:
     * `center` - Current slide will be always focused at the center of a track.
     * `0,1,2,3...` - Current slide will be focused on the specified zero-based index.
     *
     * @type {String|Number}
     */
    focusAt: 0,

    /**
     * A size of the gap added between slides.
     *
     * @type {Number}
     */
    gap: 10,

    /**
     * Change slides after a specified interval. Use `false` for turning off autoplay.
     *
     * @type {Number|Boolean}
     */
    autoplay: false,

    /**
     * Stop autoplay on mouseover event.
     *
     * @type {Boolean}
     */
    hoverpause: true,

    /**
     * Allow for changing slides with left and right keyboard arrows.
     *
     * @type {Boolean}
     */
    keyboard: true,

    /**
     * Stop running `perView` number of slides from the end. Use this
     * option if you don't want to have an empty space after
     * a slider. Works only with `slider` type and a
     * non-centered `focusAt` setting.
     *
     * @type {Boolean}
     */
    bound: false,

    /**
     * Minimal swipe distance needed to change the slide. Use `false` for turning off a swiping.
     *
     * @type {Number|Boolean}
     */
    swipeThreshold: 80,

    /**
     * Minimal mouse drag distance needed to change the slide. Use `false` for turning off a dragging.
     *
     * @type {Number|Boolean}
     */
    dragThreshold: 120,

    /**
     * A maximum number of slides to which movement will be made on swiping or dragging. Use `false` for unlimited.
     *
     * @type {Number|Boolean}
     */
    perTouch: false,

    /**
     * Moving distance ratio of the slides on a swiping and dragging.
     *
     * @type {Number}
     */
    touchRatio: 0.5,

    /**
     * Angle required to activate slides moving on swiping or dragging.
     *
     * @type {Number}
     */
    touchAngle: 45,

    /**
     * Duration of the animation in milliseconds.
     *
     * @type {Number}
     */
    animationDuration: 400,

    /**
     * Allows looping the `slider` type. Slider will rewind to the first/last slide when it's at the start/end.
     *
     * @type {Boolean}
     */
    rewind: true,

    /**
     * Duration of the rewinding animation of the `slider` type in milliseconds.
     *
     * @type {Number}
     */
    rewindDuration: 800,

    /**
     * Easing function for the animation.
     *
     * @type {String}
     */
    animationTimingFunc: 'cubic-bezier(.165, .840, .440, 1)',

    /**
     * Throttle costly events at most once per every wait milliseconds.
     *
     * @type {Number}
     */
    throttle: 10,

    /**
     * Moving direction mode.
     *
     * Available inputs:
     * - 'ltr' - left to right movement,
     * - 'rtl' - right to left movement.
     *
     * @type {String}
     */
    direction: 'ltr',

    /**
     * The distance value of the next and previous viewports which
     * have to peek in the current view. Accepts number and
     * pixels as a string. Left and right peeking can be
     * set up separately with a directions object.
     *
     * For example:
     * `100` - Peek 100px on the both sides.
     * { before: 100, after: 50 }` - Peek 100px on the left side and 50px on the right side.
     *
     * @type {Number|String|Object}
     */
    peek: 0,

    /**
     * Collection of options applied at specified media breakpoints.
     * For example: display two slides per view under 800px.
     * `{
     *   '800px': {
     *     perView: 2
     *   }
     * }`
     */
    breakpoints: {},

    /**
     * Collection of internally used HTML classes.
     *
     * @todo Refactor `slider` and `carousel` properties to single `type: { slider: '', carousel: '' }` object
     * @type {Object}
     */
    classes: {
      direction: {
        ltr: 'glide--ltr',
        rtl: 'glide--rtl'
      },
      slider: 'glide--slider',
      carousel: 'glide--carousel',
      swipeable: 'glide--swipeable',
      dragging: 'glide--dragging',
      cloneSlide: 'glide__slide--clone',
      activeNav: 'glide__bullet--active',
      activeSlide: 'glide__slide--active',
      disabledArrow: 'glide__arrow--disabled'
    }
  };
  /**
   * Outputs warning message to the bowser console.
   *
   * @param  {String} msg
   * @return {Void}
   */

  function warn(msg) {
    console.error("[Glide warn]: " + msg);
  }

  var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
    return _typeof2(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
  };

  var classCallCheck = function classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + _typeof2(superClass));
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (_typeof2(call) === "object" || typeof call === "function") ? call : self;
  };
  /**
   * Converts value entered as number
   * or string to integer value.
   *
   * @param {String} value
   * @returns {Number}
   */


  function toInt(value) {
    return parseInt(value);
  }
  /**
   * Converts value entered as number
   * or string to flat value.
   *
   * @param {String} value
   * @returns {Number}
   */


  function toFloat(value) {
    return parseFloat(value);
  }
  /**
   * Indicates whether the specified value is a string.
   *
   * @param  {*}   value
   * @return {Boolean}
   */


  function isString(value) {
    return typeof value === 'string';
  }
  /**
   * Indicates whether the specified value is an object.
   *
   * @param  {*} value
   * @return {Boolean}
   *
   * @see https://github.com/jashkenas/underscore
   */


  function isObject(value) {
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    return type === 'function' || type === 'object' && !!value; // eslint-disable-line no-mixed-operators
  }
  /**
   * Indicates whether the specified value is a number.
   *
   * @param  {*} value
   * @return {Boolean}
   */


  function isNumber(value) {
    return typeof value === 'number';
  }
  /**
   * Indicates whether the specified value is a function.
   *
   * @param  {*} value
   * @return {Boolean}
   */


  function isFunction(value) {
    return typeof value === 'function';
  }
  /**
   * Indicates whether the specified value is undefined.
   *
   * @param  {*} value
   * @return {Boolean}
   */


  function isUndefined(value) {
    return typeof value === 'undefined';
  }
  /**
   * Indicates whether the specified value is an array.
   *
   * @param  {*} value
   * @return {Boolean}
   */


  function isArray(value) {
    return value.constructor === Array;
  }
  /**
   * Creates and initializes specified collection of extensions.
   * Each extension receives access to instance of glide and rest of components.
   *
   * @param {Object} glide
   * @param {Object} extensions
   *
   * @returns {Object}
   */


  function mount(glide, extensions, events) {
    var components = {};

    for (var name in extensions) {
      if (isFunction(extensions[name])) {
        components[name] = extensions[name](glide, components, events);
      } else {
        warn('Extension must be a function');
      }
    }

    for (var _name in components) {
      if (isFunction(components[_name].mount)) {
        components[_name].mount();
      }
    }

    return components;
  }
  /**
   * Defines getter and setter property on the specified object.
   *
   * @param  {Object} obj         Object where property has to be defined.
   * @param  {String} prop        Name of the defined property.
   * @param  {Object} definition  Get and set definitions for the property.
   * @return {Void}
   */


  function define(obj, prop, definition) {
    Object.defineProperty(obj, prop, definition);
  }
  /**
   * Sorts aphabetically object keys.
   *
   * @param  {Object} obj
   * @return {Object}
   */


  function sortKeys(obj) {
    return Object.keys(obj).sort().reduce(function (r, k) {
      r[k] = obj[k];
      return r[k], r;
    }, {});
  }
  /**
   * Merges passed settings object with default options.
   *
   * @param  {Object} defaults
   * @param  {Object} settings
   * @return {Object}
   */


  function mergeOptions(defaults, settings) {
    var options = _extends({}, defaults, settings); // `Object.assign` do not deeply merge objects, so we
    // have to do it manually for every nested object
    // in options. Although it does not look smart,
    // it's smaller and faster than some fancy
    // merging deep-merge algorithm script.


    if (settings.hasOwnProperty('classes')) {
      options.classes = _extends({}, defaults.classes, settings.classes);

      if (settings.classes.hasOwnProperty('direction')) {
        options.classes.direction = _extends({}, defaults.classes.direction, settings.classes.direction);
      }
    }

    if (settings.hasOwnProperty('breakpoints')) {
      options.breakpoints = _extends({}, defaults.breakpoints, settings.breakpoints);
    }

    return options;
  }

  var EventsBus = function () {
    /**
     * Construct a EventBus instance.
     *
     * @param {Object} events
     */
    function EventsBus() {
      var events = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      classCallCheck(this, EventsBus);
      this.events = events;
      this.hop = events.hasOwnProperty;
    }
    /**
     * Adds listener to the specifed event.
     *
     * @param {String|Array} event
     * @param {Function} handler
     */


    createClass(EventsBus, [{
      key: 'on',
      value: function on(event, handler) {
        if (isArray(event)) {
          for (var i = 0; i < event.length; i++) {
            this.on(event[i], handler);
          }
        } // Create the event's object if not yet created


        if (!this.hop.call(this.events, event)) {
          this.events[event] = [];
        } // Add the handler to queue


        var index = this.events[event].push(handler) - 1; // Provide handle back for removal of event

        return {
          remove: function remove() {
            delete this.events[event][index];
          }
        };
      }
      /**
       * Runs registered handlers for specified event.
       *
       * @param {String|Array} event
       * @param {Object=} context
       */

    }, {
      key: 'emit',
      value: function emit(event, context) {
        if (isArray(event)) {
          for (var i = 0; i < event.length; i++) {
            this.emit(event[i], context);
          }
        } // If the event doesn't exist, or there's no handlers in queue, just leave


        if (!this.hop.call(this.events, event)) {
          return;
        } // Cycle through events queue, fire!


        this.events[event].forEach(function (item) {
          item(context || {});
        });
      }
    }]);
    return EventsBus;
  }();

  var Glide = function () {
    /**
     * Construct glide.
     *
     * @param  {String} selector
     * @param  {Object} options
     */
    function Glide(selector) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      classCallCheck(this, Glide);
      this._c = {};
      this._t = [];
      this._e = new EventsBus();
      this.disabled = false;
      this.selector = selector;
      this.settings = mergeOptions(defaults, options);
      this.index = this.settings.startAt;
    }
    /**
     * Initializes glide.
     *
     * @param {Object} extensions Collection of extensions to initialize.
     * @return {Glide}
     */


    createClass(Glide, [{
      key: 'mount',
      value: function mount$$1() {
        var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        this._e.emit('mount.before');

        if (isObject(extensions)) {
          this._c = mount(this, extensions, this._e);
        } else {
          warn('You need to provide a object on `mount()`');
        }

        this._e.emit('mount.after');

        return this;
      }
      /**
       * Collects an instance `translate` transformers.
       *
       * @param  {Array} transformers Collection of transformers.
       * @return {Void}
       */

    }, {
      key: 'mutate',
      value: function mutate() {
        var transformers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        if (isArray(transformers)) {
          this._t = transformers;
        } else {
          warn('You need to provide a array on `mutate()`');
        }

        return this;
      }
      /**
       * Updates glide with specified settings.
       *
       * @param {Object} settings
       * @return {Glide}
       */

    }, {
      key: 'update',
      value: function update() {
        var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.settings = mergeOptions(this.settings, settings);

        if (settings.hasOwnProperty('startAt')) {
          this.index = settings.startAt;
        }

        this._e.emit('update');

        return this;
      }
      /**
       * Change slide with specified pattern. A pattern must be in the special format:
       * `>` - Move one forward
       * `<` - Move one backward
       * `={i}` - Go to {i} zero-based slide (eq. '=1', will go to second slide)
       * `>>` - Rewinds to end (last slide)
       * `<<` - Rewinds to start (first slide)
       *
       * @param {String} pattern
       * @return {Glide}
       */

    }, {
      key: 'go',
      value: function go(pattern) {
        this._c.Run.make(pattern);

        return this;
      }
      /**
       * Move track by specified distance.
       *
       * @param {String} distance
       * @return {Glide}
       */

    }, {
      key: 'move',
      value: function move(distance) {
        this._c.Transition.disable();

        this._c.Move.make(distance);

        return this;
      }
      /**
       * Destroy instance and revert all changes done by this._c.
       *
       * @return {Glide}
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        this._e.emit('destroy');

        return this;
      }
      /**
       * Start instance autoplaying.
       *
       * @param {Boolean|Number} interval Run autoplaying with passed interval regardless of `autoplay` settings
       * @return {Glide}
       */

    }, {
      key: 'play',
      value: function play() {
        var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (interval) {
          this.settings.autoplay = interval;
        }

        this._e.emit('play');

        return this;
      }
      /**
       * Stop instance autoplaying.
       *
       * @return {Glide}
       */

    }, {
      key: 'pause',
      value: function pause() {
        this._e.emit('pause');

        return this;
      }
      /**
       * Sets glide into a idle status.
       *
       * @return {Glide}
       */

    }, {
      key: 'disable',
      value: function disable() {
        this.disabled = true;
        return this;
      }
      /**
       * Sets glide into a active status.
       *
       * @return {Glide}
       */

    }, {
      key: 'enable',
      value: function enable() {
        this.disabled = false;
        return this;
      }
      /**
       * Adds cuutom event listener with handler.
       *
       * @param  {String|Array} event
       * @param  {Function} handler
       * @return {Glide}
       */

    }, {
      key: 'on',
      value: function on(event, handler) {
        this._e.on(event, handler);

        return this;
      }
      /**
       * Checks if glide is a precised type.
       *
       * @param  {String} name
       * @return {Boolean}
       */

    }, {
      key: 'isType',
      value: function isType(name) {
        return this.settings.type === name;
      }
      /**
       * Gets value of the core options.
       *
       * @return {Object}
       */

    }, {
      key: 'settings',
      get: function get$$1() {
        return this._o;
      }
      /**
       * Sets value of the core options.
       *
       * @param  {Object} o
       * @return {Void}
       */
      ,
      set: function set$$1(o) {
        if (isObject(o)) {
          this._o = o;
        } else {
          warn('Options must be an `object` instance.');
        }
      }
      /**
       * Gets current index of the slider.
       *
       * @return {Object}
       */

    }, {
      key: 'index',
      get: function get$$1() {
        return this._i;
      }
      /**
       * Sets current index a slider.
       *
       * @return {Object}
       */
      ,
      set: function set$$1(i) {
        this._i = toInt(i);
      }
      /**
       * Gets type name of the slider.
       *
       * @return {String}
       */

    }, {
      key: 'type',
      get: function get$$1() {
        return this.settings.type;
      }
      /**
       * Gets value of the idle status.
       *
       * @return {Boolean}
       */

    }, {
      key: 'disabled',
      get: function get$$1() {
        return this._d;
      }
      /**
       * Sets value of the idle status.
       *
       * @return {Boolean}
       */
      ,
      set: function set$$1(status) {
        this._d = !!status;
      }
    }]);
    return Glide;
  }();

  function Run(Glide, Components, Events) {
    var Run = {
      /**
       * Initializes autorunning of the glide.
       *
       * @return {Void}
       */
      mount: function mount() {
        this._o = false;
      },

      /**
       * Makes glides running based on the passed moving schema.
       *
       * @param {String} move
       */
      make: function make(move) {
        var _this = this;

        if (!Glide.disabled) {
          Glide.disable();
          this.move = move;
          Events.emit('run.before', this.move);
          this.calculate();
          Events.emit('run', this.move);
          Components.Transition.after(function () {
            if (_this.isStart()) {
              Events.emit('run.start', _this.move);
            }

            if (_this.isEnd()) {
              Events.emit('run.end', _this.move);
            }

            if (_this.isOffset('<') || _this.isOffset('>')) {
              _this._o = false;
              Events.emit('run.offset', _this.move);
            }

            Events.emit('run.after', _this.move);
            Glide.enable();
          });
        }
      },

      /**
       * Calculates current index based on defined move.
       *
       * @return {Void}
       */
      calculate: function calculate() {
        var move = this.move,
            length = this.length;
        var steps = move.steps,
            direction = move.direction;
        var countableSteps = isNumber(toInt(steps)) && toInt(steps) !== 0;

        switch (direction) {
          case '>':
            if (steps === '>') {
              Glide.index = length;
            } else if (this.isEnd()) {
              if (!(Glide.isType('slider') && !Glide.settings.rewind)) {
                this._o = true;
                Glide.index = 0;
              }
            } else if (countableSteps) {
              Glide.index += Math.min(length - Glide.index, -toInt(steps));
            } else {
              Glide.index++;
            }

            break;

          case '<':
            if (steps === '<') {
              Glide.index = 0;
            } else if (this.isStart()) {
              if (!(Glide.isType('slider') && !Glide.settings.rewind)) {
                this._o = true;
                Glide.index = length;
              }
            } else if (countableSteps) {
              Glide.index -= Math.min(Glide.index, toInt(steps));
            } else {
              Glide.index--;
            }

            break;

          case '=':
            Glide.index = steps;
            break;

          default:
            warn('Invalid direction pattern [' + direction + steps + '] has been used');
            break;
        }
      },

      /**
       * Checks if we are on the first slide.
       *
       * @return {Boolean}
       */
      isStart: function isStart() {
        return Glide.index === 0;
      },

      /**
       * Checks if we are on the last slide.
       *
       * @return {Boolean}
       */
      isEnd: function isEnd() {
        return Glide.index === this.length;
      },

      /**
       * Checks if we are making a offset run.
       *
       * @param {String} direction
       * @return {Boolean}
       */
      isOffset: function isOffset(direction) {
        return this._o && this.move.direction === direction;
      }
    };
    define(Run, 'move', {
      /**
       * Gets value of the move schema.
       *
       * @returns {Object}
       */
      get: function get() {
        return this._m;
      },

      /**
       * Sets value of the move schema.
       *
       * @returns {Object}
       */
      set: function set(value) {
        var step = value.substr(1);
        this._m = {
          direction: value.substr(0, 1),
          steps: step ? toInt(step) ? toInt(step) : step : 0
        };
      }
    });
    define(Run, 'length', {
      /**
       * Gets value of the running distance based
       * on zero-indexing number of slides.
       *
       * @return {Number}
       */
      get: function get() {
        var settings = Glide.settings;
        var length = Components.Html.slides.length; // If the `bound` option is acitve, a maximum running distance should be
        // reduced by `perView` and `focusAt` settings. Running distance
        // should end before creating an empty space after instance.

        if (Glide.isType('slider') && settings.focusAt !== 'center' && settings.bound) {
          return length - 1 - (toInt(settings.perView) - 1) + toInt(settings.focusAt);
        }

        return length - 1;
      }
    });
    define(Run, 'offset', {
      /**
       * Gets status of the offsetting flag.
       *
       * @return {Boolean}
       */
      get: function get() {
        return this._o;
      }
    });
    return Run;
  }
  /**
   * Returns a current time.
   *
   * @return {Number}
   */


  function now() {
    return new Date().getTime();
  }
  /**
   * Returns a function, that, when invoked, will only be triggered
   * at most once during a given window of time.
   *
   * @param {Function} func
   * @param {Number} wait
   * @param {Object=} options
   * @return {Function}
   *
   * @see https://github.com/jashkenas/underscore
   */


  function throttle(func, wait, options) {
    var timeout = void 0,
        context = void 0,
        args = void 0,
        result = void 0;
    var previous = 0;
    if (!options) options = {};

    var later = function later() {
      previous = options.leading === false ? 0 : now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function throttled() {
      var at = now();
      if (!previous && options.leading === false) previous = at;
      var remaining = wait - (at - previous);
      context = this;
      args = arguments;

      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }

        previous = at;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }

      return result;
    };

    throttled.cancel = function () {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  }

  var MARGIN_TYPE = {
    ltr: ['marginLeft', 'marginRight'],
    rtl: ['marginRight', 'marginLeft']
  };

  function Gaps(Glide, Components, Events) {
    var Gaps = {
      /**
       * Applies gaps between slides. First and last
       * slides do not receive it's edge margins.
       *
       * @param {HTMLCollection} slides
       * @return {Void}
       */
      apply: function apply(slides) {
        for (var i = 0, len = slides.length; i < len; i++) {
          var style = slides[i].style;
          var direction = Components.Direction.value;

          if (i !== 0) {
            style[MARGIN_TYPE[direction][0]] = this.value / 2 + 'px';
          } else {
            style[MARGIN_TYPE[direction][0]] = '';
          }

          if (i !== slides.length - 1) {
            style[MARGIN_TYPE[direction][1]] = this.value / 2 + 'px';
          } else {
            style[MARGIN_TYPE[direction][1]] = '';
          }
        }
      },

      /**
       * Removes gaps from the slides.
       *
       * @param {HTMLCollection} slides
       * @returns {Void}
      */
      remove: function remove(slides) {
        for (var i = 0, len = slides.length; i < len; i++) {
          var style = slides[i].style;
          style.marginLeft = '';
          style.marginRight = '';
        }
      }
    };
    define(Gaps, 'value', {
      /**
       * Gets value of the gap.
       *
       * @returns {Number}
       */
      get: function get() {
        return toInt(Glide.settings.gap);
      }
    });
    define(Gaps, 'grow', {
      /**
       * Gets additional dimentions value caused by gaps.
       * Used to increase width of the slides wrapper.
       *
       * @returns {Number}
       */
      get: function get() {
        return Gaps.value * (Components.Sizes.length - 1);
      }
    });
    define(Gaps, 'reductor', {
      /**
       * Gets reduction value caused by gaps.
       * Used to subtract width of the slides.
       *
       * @returns {Number}
       */
      get: function get() {
        var perView = Glide.settings.perView;
        return Gaps.value * (perView - 1) / perView;
      }
    });
    /**
     * Apply calculated gaps:
     * - after building, so slides (including clones) will receive proper margins
     * - on updating via API, to recalculate gaps with new options
     */

    Events.on(['build.after', 'update'], throttle(function () {
      Gaps.apply(Components.Html.wrapper.children);
    }, 30));
    /**
     * Remove gaps:
     * - on destroying to bring markup to its inital state
     */

    Events.on('destroy', function () {
      Gaps.remove(Components.Html.wrapper.children);
    });
    return Gaps;
  }
  /**
   * Finds siblings nodes of the passed node.
   *
   * @param  {Element} node
   * @return {Array}
   */


  function siblings(node) {
    if (node && node.parentNode) {
      var n = node.parentNode.firstChild;
      var matched = [];

      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== node) {
          matched.push(n);
        }
      }

      return matched;
    }

    return [];
  }
  /**
   * Checks if passed node exist and is a valid element.
   *
   * @param  {Element} node
   * @return {Boolean}
   */


  function exist(node) {
    if (node && node instanceof window.HTMLElement) {
      return true;
    }

    return false;
  }

  var TRACK_SELECTOR = '[data-glide-el="track"]';

  function Html(Glide, Components) {
    var Html = {
      /**
       * Setup slider HTML nodes.
       *
       * @param {Glide} glide
       */
      mount: function mount() {
        this.root = Glide.selector;
        this.track = this.root.querySelector(TRACK_SELECTOR);
        this.slides = Array.prototype.slice.call(this.wrapper.children).filter(function (slide) {
          return !slide.classList.contains(Glide.settings.classes.cloneSlide);
        });
      }
    };
    define(Html, 'root', {
      /**
       * Gets node of the glide main element.
       *
       * @return {Object}
       */
      get: function get() {
        return Html._r;
      },

      /**
       * Sets node of the glide main element.
       *
       * @return {Object}
       */
      set: function set(r) {
        if (isString(r)) {
          r = document.querySelector(r);
        }

        if (exist(r)) {
          Html._r = r;
        } else {
          warn('Root element must be a existing Html node');
        }
      }
    });
    define(Html, 'track', {
      /**
       * Gets node of the glide track with slides.
       *
       * @return {Object}
       */
      get: function get() {
        return Html._t;
      },

      /**
       * Sets node of the glide track with slides.
       *
       * @return {Object}
       */
      set: function set(t) {
        if (exist(t)) {
          Html._t = t;
        } else {
          warn('Could not find track element. Please use ' + TRACK_SELECTOR + ' attribute.');
        }
      }
    });
    define(Html, 'wrapper', {
      /**
       * Gets node of the slides wrapper.
       *
       * @return {Object}
       */
      get: function get() {
        return Html.track.children[0];
      }
    });
    return Html;
  }

  function Peek(Glide, Components, Events) {
    var Peek = {
      /**
       * Setups how much to peek based on settings.
       *
       * @return {Void}
       */
      mount: function mount() {
        this.value = Glide.settings.peek;
      }
    };
    define(Peek, 'value', {
      /**
       * Gets value of the peek.
       *
       * @returns {Number|Object}
       */
      get: function get() {
        return Peek._v;
      },

      /**
       * Sets value of the peek.
       *
       * @param {Number|Object} value
       * @return {Void}
       */
      set: function set(value) {
        if (isObject(value)) {
          value.before = toInt(value.before);
          value.after = toInt(value.after);
        } else {
          value = toInt(value);
        }

        Peek._v = value;
      }
    });
    define(Peek, 'reductor', {
      /**
       * Gets reduction value caused by peek.
       *
       * @returns {Number}
       */
      get: function get() {
        var value = Peek.value;
        var perView = Glide.settings.perView;

        if (isObject(value)) {
          return value.before / perView + value.after / perView;
        }

        return value * 2 / perView;
      }
    });
    /**
     * Recalculate peeking sizes on:
     * - when resizing window to update to proper percents
     */

    Events.on(['resize', 'update'], function () {
      Peek.mount();
    });
    return Peek;
  }

  function Move(Glide, Components, Events) {
    var Move = {
      /**
       * Constructs move component.
       *
       * @returns {Void}
       */
      mount: function mount() {
        this._o = 0;
      },

      /**
       * Calculates a movement value based on passed offset and currently active index.
       *
       * @param  {Number} offset
       * @return {Void}
       */
      make: function make() {
        var _this = this;

        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        this.offset = offset;
        Events.emit('move', {
          movement: this.value
        });
        Components.Transition.after(function () {
          Events.emit('move.after', {
            movement: _this.value
          });
        });
      }
    };
    define(Move, 'offset', {
      /**
       * Gets an offset value used to modify current translate.
       *
       * @return {Object}
       */
      get: function get() {
        return Move._o;
      },

      /**
       * Sets an offset value used to modify current translate.
       *
       * @return {Object}
       */
      set: function set(value) {
        Move._o = !isUndefined(value) ? toInt(value) : 0;
      }
    });
    define(Move, 'translate', {
      /**
       * Gets a raw movement value.
       *
       * @return {Number}
       */
      get: function get() {
        return Components.Sizes.slideWidth * Glide.index;
      }
    });
    define(Move, 'value', {
      /**
       * Gets an actual movement value corrected by offset.
       *
       * @return {Number}
       */
      get: function get() {
        var offset = this.offset;
        var translate = this.translate;

        if (Components.Direction.is('rtl')) {
          return translate + offset;
        }

        return translate - offset;
      }
    });
    /**
     * Make movement to proper slide on:
     * - before build, so glide will start at `startAt` index
     * - on each standard run to move to newly calculated index
     */

    Events.on(['build.before', 'run'], function () {
      Move.make();
    });
    return Move;
  }

  function Sizes(Glide, Components, Events) {
    var Sizes = {
      /**
       * Setups dimentions of slides.
       *
       * @return {Void}
       */
      setupSlides: function setupSlides() {
        var width = this.slideWidth + 'px';
        var slides = Components.Html.slides;

        for (var i = 0; i < slides.length; i++) {
          slides[i].style.width = width;
        }
      },

      /**
       * Setups dimentions of slides wrapper.
       *
       * @return {Void}
       */
      setupWrapper: function setupWrapper(dimention) {
        Components.Html.wrapper.style.width = this.wrapperSize + 'px';
      },

      /**
       * Removes applied styles from HTML elements.
       *
       * @returns {Void}
       */
      remove: function remove() {
        var slides = Components.Html.slides;

        for (var i = 0; i < slides.length; i++) {
          slides[i].style.width = '';
        }

        Components.Html.wrapper.style.width = '';
      }
    };
    define(Sizes, 'length', {
      /**
       * Gets count number of the slides.
       *
       * @return {Number}
       */
      get: function get() {
        return Components.Html.slides.length;
      }
    });
    define(Sizes, 'width', {
      /**
       * Gets width value of the glide.
       *
       * @return {Number}
       */
      get: function get() {
        return Components.Html.root.offsetWidth;
      }
    });
    define(Sizes, 'wrapperSize', {
      /**
       * Gets size of the slides wrapper.
       *
       * @return {Number}
       */
      get: function get() {
        return Sizes.slideWidth * Sizes.length + Components.Gaps.grow + Components.Clones.grow;
      }
    });
    define(Sizes, 'slideWidth', {
      /**
       * Gets width value of the single slide.
       *
       * @return {Number}
       */
      get: function get() {
        return Sizes.width / Glide.settings.perView - Components.Peek.reductor - Components.Gaps.reductor;
      }
    });
    /**
     * Apply calculated glide's dimensions:
     * - before building, so other dimentions (e.g. translate) will be calculated propertly
     * - when resizing window to recalculate sildes dimensions
     * - on updating via API, to calculate dimensions based on new options
     */

    Events.on(['build.before', 'resize', 'update'], function () {
      Sizes.setupSlides();
      Sizes.setupWrapper();
    });
    /**
     * Remove calculated glide's dimensions:
     * - on destoting to bring markup to its inital state
     */

    Events.on('destroy', function () {
      Sizes.remove();
    });
    return Sizes;
  }

  function Build(Glide, Components, Events) {
    var Build = {
      /**
       * Init glide building. Adds classes, sets
       * dimensions and setups initial state.
       *
       * @return {Void}
       */
      mount: function mount() {
        Events.emit('build.before');
        this.typeClass();
        this.activeClass();
        Events.emit('build.after');
      },

      /**
       * Adds `type` class to the glide element.
       *
       * @return {Void}
       */
      typeClass: function typeClass() {
        Components.Html.root.classList.add(Glide.settings.classes[Glide.settings.type]);
      },

      /**
       * Sets active class to current slide.
       *
       * @return {Void}
       */
      activeClass: function activeClass() {
        var classes = Glide.settings.classes;
        var slide = Components.Html.slides[Glide.index];

        if (slide) {
          slide.classList.add(classes.activeSlide);
          siblings(slide).forEach(function (sibling) {
            sibling.classList.remove(classes.activeSlide);
          });
        }
      },

      /**
       * Removes HTML classes applied at building.
       *
       * @return {Void}
       */
      removeClasses: function removeClasses() {
        var classes = Glide.settings.classes;
        Components.Html.root.classList.remove(classes[Glide.settings.type]);
        Components.Html.slides.forEach(function (sibling) {
          sibling.classList.remove(classes.activeSlide);
        });
      }
    };
    /**
     * Clear building classes:
     * - on destroying to bring HTML to its initial state
     * - on updating to remove classes before remounting component
     */

    Events.on(['destroy', 'update'], function () {
      Build.removeClasses();
    });
    /**
     * Remount component:
     * - on resizing of the window to calculate new dimentions
     * - on updating settings via API
     */

    Events.on(['resize', 'update'], function () {
      Build.mount();
    });
    /**
     * Swap active class of current slide:
     * - after each move to the new index
     */

    Events.on('move.after', function () {
      Build.activeClass();
    });
    return Build;
  }

  function Clones(Glide, Components, Events) {
    var Clones = {
      /**
       * Create pattern map and collect slides to be cloned.
       */
      mount: function mount() {
        this.items = [];

        if (Glide.isType('carousel')) {
          this.items = this.collect();
        }
      },

      /**
       * Collect clones with pattern.
       *
       * @return {Void}
       */
      collect: function collect() {
        var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var slides = Components.Html.slides;
        var _Glide$settings = Glide.settings,
            perView = _Glide$settings.perView,
            classes = _Glide$settings.classes;
        var peekIncrementer = +!!Glide.settings.peek;
        var part = perView + peekIncrementer;
        var start = slides.slice(0, part);
        var end = slides.slice(-part);

        for (var r = 0; r < Math.max(1, Math.floor(perView / slides.length)); r++) {
          for (var i = 0; i < start.length; i++) {
            var clone = start[i].cloneNode(true);
            clone.classList.add(classes.cloneSlide);
            items.push(clone);
          }

          for (var _i = 0; _i < end.length; _i++) {
            var _clone = end[_i].cloneNode(true);

            _clone.classList.add(classes.cloneSlide);

            items.unshift(_clone);
          }
        }

        return items;
      },

      /**
       * Append cloned slides with generated pattern.
       *
       * @return {Void}
       */
      append: function append() {
        var items = this.items;
        var _Components$Html = Components.Html,
            wrapper = _Components$Html.wrapper,
            slides = _Components$Html.slides;
        var half = Math.floor(items.length / 2);
        var prepend = items.slice(0, half).reverse();
        var append = items.slice(half, items.length);
        var width = Components.Sizes.slideWidth + 'px';

        for (var i = 0; i < append.length; i++) {
          wrapper.appendChild(append[i]);
        }

        for (var _i2 = 0; _i2 < prepend.length; _i2++) {
          wrapper.insertBefore(prepend[_i2], slides[0]);
        }

        for (var _i3 = 0; _i3 < items.length; _i3++) {
          items[_i3].style.width = width;
        }
      },

      /**
       * Remove all cloned slides.
       *
       * @return {Void}
       */
      remove: function remove() {
        var items = this.items;

        for (var i = 0; i < items.length; i++) {
          Components.Html.wrapper.removeChild(items[i]);
        }
      }
    };
    define(Clones, 'grow', {
      /**
       * Gets additional dimentions value caused by clones.
       *
       * @return {Number}
       */
      get: function get() {
        return (Components.Sizes.slideWidth + Components.Gaps.value) * Clones.items.length;
      }
    });
    /**
     * Append additional slide's clones:
     * - while glide's type is `carousel`
     */

    Events.on('update', function () {
      Clones.remove();
      Clones.mount();
      Clones.append();
    });
    /**
     * Append additional slide's clones:
     * - while glide's type is `carousel`
     */

    Events.on('build.before', function () {
      if (Glide.isType('carousel')) {
        Clones.append();
      }
    });
    /**
     * Remove clones HTMLElements:
     * - on destroying, to bring HTML to its initial state
     */

    Events.on('destroy', function () {
      Clones.remove();
    });
    return Clones;
  }

  var EventsBinder = function () {
    /**
     * Construct a EventsBinder instance.
     */
    function EventsBinder() {
      var listeners = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      classCallCheck(this, EventsBinder);
      this.listeners = listeners;
    }
    /**
     * Adds events listeners to arrows HTML elements.
     *
     * @param  {String|Array} events
     * @param  {Element|Window|Document} el
     * @param  {Function} closure
     * @param  {Boolean|Object} capture
     * @return {Void}
     */


    createClass(EventsBinder, [{
      key: 'on',
      value: function on(events, el, closure) {
        var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        if (isString(events)) {
          events = [events];
        }

        for (var i = 0; i < events.length; i++) {
          this.listeners[events[i]] = closure;
          el.addEventListener(events[i], this.listeners[events[i]], capture);
        }
      }
      /**
       * Removes event listeners from arrows HTML elements.
       *
       * @param  {String|Array} events
       * @param  {Element|Window|Document} el
       * @param  {Boolean|Object} capture
       * @return {Void}
       */

    }, {
      key: 'off',
      value: function off(events, el) {
        var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (isString(events)) {
          events = [events];
        }

        for (var i = 0; i < events.length; i++) {
          el.removeEventListener(events[i], this.listeners[events[i]], capture);
        }
      }
      /**
       * Destroy collected listeners.
       *
       * @returns {Void}
       */

    }, {
      key: 'destroy',
      value: function destroy() {
        delete this.listeners;
      }
    }]);
    return EventsBinder;
  }();

  function Resize(Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    var Resize = {
      /**
       * Initializes window bindings.
       */
      mount: function mount() {
        this.bind();
      },

      /**
       * Binds `rezsize` listener to the window.
       * It's a costly event, so we are debouncing it.
       *
       * @return {Void}
       */
      bind: function bind() {
        Binder.on('resize', window, throttle(function () {
          Events.emit('resize');
        }, Glide.settings.throttle));
      },

      /**
       * Unbinds listeners from the window.
       *
       * @return {Void}
       */
      unbind: function unbind() {
        Binder.off('resize', window);
      }
    };
    /**
     * Remove bindings from window:
     * - on destroying, to remove added EventListener
     */

    Events.on('destroy', function () {
      Resize.unbind();
      Binder.destroy();
    });
    return Resize;
  }

  var VALID_DIRECTIONS = ['ltr', 'rtl'];
  var FLIPED_MOVEMENTS = {
    '>': '<',
    '<': '>',
    '=': '='
  };

  function Direction(Glide, Components, Events) {
    var Direction = {
      /**
       * Setups gap value based on settings.
       *
       * @return {Void}
       */
      mount: function mount() {
        this.value = Glide.settings.direction;
      },

      /**
       * Resolves pattern based on direction value
       *
       * @param {String} pattern
       * @returns {String}
       */
      resolve: function resolve(pattern) {
        var token = pattern.slice(0, 1);

        if (this.is('rtl')) {
          return pattern.split(token).join(FLIPED_MOVEMENTS[token]);
        }

        return pattern;
      },

      /**
       * Checks value of direction mode.
       *
       * @param {String} direction
       * @returns {Boolean}
       */
      is: function is(direction) {
        return this.value === direction;
      },

      /**
       * Applies direction class to the root HTML element.
       *
       * @return {Void}
       */
      addClass: function addClass() {
        Components.Html.root.classList.add(Glide.settings.classes.direction[this.value]);
      },

      /**
       * Removes direction class from the root HTML element.
       *
       * @return {Void}
       */
      removeClass: function removeClass() {
        Components.Html.root.classList.remove(Glide.settings.classes.direction[this.value]);
      }
    };
    define(Direction, 'value', {
      /**
       * Gets value of the direction.
       *
       * @returns {Number}
       */
      get: function get() {
        return Direction._v;
      },

      /**
       * Sets value of the direction.
       *
       * @param {String} value
       * @return {Void}
       */
      set: function set(value) {
        if (VALID_DIRECTIONS.indexOf(value) > -1) {
          Direction._v = value;
        } else {
          warn('Direction value must be `ltr` or `rtl`');
        }
      }
    });
    /**
     * Clear direction class:
     * - on destroy to bring HTML to its initial state
     * - on update to remove class before reappling bellow
     */

    Events.on(['destroy', 'update'], function () {
      Direction.removeClass();
    });
    /**
     * Remount component:
     * - on update to reflect changes in direction value
     */

    Events.on('update', function () {
      Direction.mount();
    });
    /**
     * Apply direction class:
     * - before building to apply class for the first time
     * - on updating to reapply direction class that may changed
     */

    Events.on(['build.before', 'update'], function () {
      Direction.addClass();
    });
    return Direction;
  }
  /**
   * Reflects value of glide movement.
   *
   * @param  {Object} Glide
   * @param  {Object} Components
   * @return {Object}
   */


  function Rtl(Glide, Components) {
    return {
      /**
       * Negates the passed translate if glide is in RTL option.
       *
       * @param  {Number} translate
       * @return {Number}
       */
      modify: function modify(translate) {
        if (Components.Direction.is('rtl')) {
          return -translate;
        }

        return translate;
      }
    };
  }
  /**
   * Updates glide movement with a `gap` settings.
   *
   * @param  {Object} Glide
   * @param  {Object} Components
   * @return {Object}
   */


  function Gap(Glide, Components) {
    return {
      /**
       * Modifies passed translate value with number in the `gap` settings.
       *
       * @param  {Number} translate
       * @return {Number}
       */
      modify: function modify(translate) {
        return translate + Components.Gaps.value * Glide.index;
      }
    };
  }
  /**
   * Updates glide movement with width of additional clones width.
   *
   * @param  {Object} Glide
   * @param  {Object} Components
   * @return {Object}
   */


  function Grow(Glide, Components) {
    return {
      /**
       * Adds to the passed translate width of the half of clones.
       *
       * @param  {Number} translate
       * @return {Number}
       */
      modify: function modify(translate) {
        return translate + Components.Clones.grow / 2;
      }
    };
  }
  /**
   * Updates glide movement with a `peek` settings.
   *
   * @param  {Object} Glide
   * @param  {Object} Components
   * @return {Object}
   */


  function Peeking(Glide, Components) {
    return {
      /**
       * Modifies passed translate value with a `peek` setting.
       *
       * @param  {Number} translate
       * @return {Number}
       */
      modify: function modify(translate) {
        if (Glide.settings.focusAt >= 0) {
          var peek = Components.Peek.value;

          if (isObject(peek)) {
            return translate - peek.before;
          }

          return translate - peek;
        }

        return translate;
      }
    };
  }
  /**
   * Updates glide movement with a `focusAt` settings.
   *
   * @param  {Object} Glide
   * @param  {Object} Components
   * @return {Object}
   */


  function Focusing(Glide, Components) {
    return {
      /**
       * Modifies passed translate value with index in the `focusAt` setting.
       *
       * @param  {Number} translate
       * @return {Number}
       */
      modify: function modify(translate) {
        var gap = Components.Gaps.value;
        var width = Components.Sizes.width;
        var focusAt = Glide.settings.focusAt;
        var slideWidth = Components.Sizes.slideWidth;

        if (focusAt === 'center') {
          return translate - (width / 2 - slideWidth / 2);
        }

        return translate - slideWidth * focusAt - gap * focusAt;
      }
    };
  }
  /**
   * Applies diffrent transformers on translate value.
   *
   * @param  {Object} Glide
   * @param  {Object} Components
   * @return {Object}
   */


  function mutator(Glide, Components, Events) {
    /**
     * Merge instance transformers with collection of default transformers.
     * It's important that the Rtl component be last on the list,
     * so it reflects all previous transformations.
     *
     * @type {Array}
     */
    var TRANSFORMERS = [Gap, Grow, Peeking, Focusing].concat(Glide._t, [Rtl]);
    return {
      /**
       * Piplines translate value with registered transformers.
       *
       * @param  {Number} translate
       * @return {Number}
       */
      mutate: function mutate(translate) {
        for (var i = 0; i < TRANSFORMERS.length; i++) {
          var transformer = TRANSFORMERS[i];

          if (isFunction(transformer) && isFunction(transformer().modify)) {
            translate = transformer(Glide, Components, Events).modify(translate);
          } else {
            warn('Transformer should be a function that returns an object with `modify()` method');
          }
        }

        return translate;
      }
    };
  }

  function Translate(Glide, Components, Events) {
    var Translate = {
      /**
       * Sets value of translate on HTML element.
       *
       * @param {Number} value
       * @return {Void}
       */
      set: function set(value) {
        var transform = mutator(Glide, Components).mutate(value);
        Components.Html.wrapper.style.transform = 'translate3d(' + -1 * transform + 'px, 0px, 0px)';
      },

      /**
       * Removes value of translate from HTML element.
       *
       * @return {Void}
       */
      remove: function remove() {
        Components.Html.wrapper.style.transform = '';
      }
    };
    /**
     * Set new translate value:
     * - on move to reflect index change
     * - on updating via API to reflect possible changes in options
     */

    Events.on('move', function (context) {
      var gap = Components.Gaps.value;
      var length = Components.Sizes.length;
      var width = Components.Sizes.slideWidth;

      if (Glide.isType('carousel') && Components.Run.isOffset('<')) {
        Components.Transition.after(function () {
          Events.emit('translate.jump');
          Translate.set(width * (length - 1));
        });
        return Translate.set(-width - gap * length);
      }

      if (Glide.isType('carousel') && Components.Run.isOffset('>')) {
        Components.Transition.after(function () {
          Events.emit('translate.jump');
          Translate.set(0);
        });
        return Translate.set(width * length + gap * length);
      }

      return Translate.set(context.movement);
    });
    /**
     * Remove translate:
     * - on destroying to bring markup to its inital state
     */

    Events.on('destroy', function () {
      Translate.remove();
    });
    return Translate;
  }

  function Transition(Glide, Components, Events) {
    /**
     * Holds inactivity status of transition.
     * When true transition is not applied.
     *
     * @type {Boolean}
     */
    var disabled = false;
    var Transition = {
      /**
       * Composes string of the CSS transition.
       *
       * @param {String} property
       * @return {String}
       */
      compose: function compose(property) {
        var settings = Glide.settings;

        if (!disabled) {
          return property + ' ' + this.duration + 'ms ' + settings.animationTimingFunc;
        }

        return property + ' 0ms ' + settings.animationTimingFunc;
      },

      /**
       * Sets value of transition on HTML element.
       *
       * @param {String=} property
       * @return {Void}
       */
      set: function set() {
        var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';
        Components.Html.wrapper.style.transition = this.compose(property);
      },

      /**
       * Removes value of transition from HTML element.
       *
       * @return {Void}
       */
      remove: function remove() {
        Components.Html.wrapper.style.transition = '';
      },

      /**
       * Runs callback after animation.
       *
       * @param  {Function} callback
       * @return {Void}
       */
      after: function after(callback) {
        setTimeout(function () {
          callback();
        }, this.duration);
      },

      /**
       * Enable transition.
       *
       * @return {Void}
       */
      enable: function enable() {
        disabled = false;
        this.set();
      },

      /**
       * Disable transition.
       *
       * @return {Void}
       */
      disable: function disable() {
        disabled = true;
        this.set();
      }
    };
    define(Transition, 'duration', {
      /**
       * Gets duration of the transition based
       * on currently running animation type.
       *
       * @return {Number}
       */
      get: function get() {
        var settings = Glide.settings;

        if (Glide.isType('slider') && Components.Run.offset) {
          return settings.rewindDuration;
        }

        return settings.animationDuration;
      }
    });
    /**
     * Set transition `style` value:
     * - on each moving, because it may be cleared by offset move
     */

    Events.on('move', function () {
      Transition.set();
    });
    /**
     * Disable transition:
     * - before initial build to avoid transitioning from `0` to `startAt` index
     * - while resizing window and recalculating dimentions
     * - on jumping from offset transition at start and end edges in `carousel` type
     */

    Events.on(['build.before', 'resize', 'translate.jump'], function () {
      Transition.disable();
    });
    /**
     * Enable transition:
     * - on each running, because it may be disabled by offset move
     */

    Events.on('run', function () {
      Transition.enable();
    });
    /**
     * Remove transition:
     * - on destroying to bring markup to its inital state
     */

    Events.on('destroy', function () {
      Transition.remove();
    });
    return Transition;
  }
  /**
   * Test via a getter in the options object to see
   * if the passive property is accessed.
   *
   * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
   */


  var supportsPassive = false;

  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function get() {
        supportsPassive = true;
      }
    });
    window.addEventListener('testPassive', null, opts);
    window.removeEventListener('testPassive', null, opts);
  } catch (e) {}

  var supportsPassive$1 = supportsPassive;
  var START_EVENTS = ['touchstart', 'mousedown'];
  var MOVE_EVENTS = ['touchmove', 'mousemove'];
  var END_EVENTS = ['touchend', 'touchcancel', 'mouseup', 'mouseleave'];
  var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'mouseleave'];

  function Swipe(Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    var swipeSin = 0;
    var swipeStartX = 0;
    var swipeStartY = 0;
    var disabled = false;
    var capture = supportsPassive$1 ? {
      passive: true
    } : false;
    var Swipe = {
      /**
       * Initializes swipe bindings.
       *
       * @return {Void}
       */
      mount: function mount() {
        this.bindSwipeStart();
      },

      /**
       * Handler for `swipestart` event. Calculates entry points of the user's tap.
       *
       * @param {Object} event
       * @return {Void}
       */
      start: function start(event) {
        if (!disabled && !Glide.disabled) {
          this.disable();
          var swipe = this.touches(event);
          swipeSin = null;
          swipeStartX = toInt(swipe.pageX);
          swipeStartY = toInt(swipe.pageY);
          this.bindSwipeMove();
          this.bindSwipeEnd();
          Events.emit('swipe.start');
        }
      },

      /**
       * Handler for `swipemove` event. Calculates user's tap angle and distance.
       *
       * @param {Object} event
       */
      move: function move(event) {
        if (!Glide.disabled) {
          var _Glide$settings = Glide.settings,
              touchAngle = _Glide$settings.touchAngle,
              touchRatio = _Glide$settings.touchRatio,
              classes = _Glide$settings.classes;
          var swipe = this.touches(event);
          var subExSx = toInt(swipe.pageX) - swipeStartX;
          var subEySy = toInt(swipe.pageY) - swipeStartY;
          var powEX = Math.abs(subExSx << 2);
          var powEY = Math.abs(subEySy << 2);
          var swipeHypotenuse = Math.sqrt(powEX + powEY);
          var swipeCathetus = Math.sqrt(powEY);
          swipeSin = Math.asin(swipeCathetus / swipeHypotenuse);

          if (swipeSin * 180 / Math.PI < touchAngle) {
            event.stopPropagation();
            Components.Move.make(subExSx * toFloat(touchRatio));
            Components.Html.root.classList.add(classes.dragging);
            Events.emit('swipe.move');
          } else {
            return false;
          }
        }
      },

      /**
       * Handler for `swipeend` event. Finitializes user's tap and decides about glide move.
       *
       * @param {Object} event
       * @return {Void}
       */
      end: function end(event) {
        if (!Glide.disabled) {
          var settings = Glide.settings;
          var swipe = this.touches(event);
          var threshold = this.threshold(event);
          var swipeDistance = swipe.pageX - swipeStartX;
          var swipeDeg = swipeSin * 180 / Math.PI;
          var steps = Math.round(swipeDistance / Components.Sizes.slideWidth);
          this.enable();

          if (swipeDistance > threshold && swipeDeg < settings.touchAngle) {
            // While swipe is positive and greater than threshold move backward.
            if (settings.perTouch) {
              steps = Math.min(steps, toInt(settings.perTouch));
            }

            if (Components.Direction.is('rtl')) {
              steps = -steps;
            }

            Components.Run.make(Components.Direction.resolve('<' + steps));
          } else if (swipeDistance < -threshold && swipeDeg < settings.touchAngle) {
            // While swipe is negative and lower than negative threshold move forward.
            if (settings.perTouch) {
              steps = Math.max(steps, -toInt(settings.perTouch));
            }

            if (Components.Direction.is('rtl')) {
              steps = -steps;
            }

            Components.Run.make(Components.Direction.resolve('>' + steps));
          } else {
            // While swipe don't reach distance apply previous transform.
            Components.Move.make();
          }

          Components.Html.root.classList.remove(settings.classes.dragging);
          this.unbindSwipeMove();
          this.unbindSwipeEnd();
          Events.emit('swipe.end');
        }
      },

      /**
       * Binds swipe's starting event.
       *
       * @return {Void}
       */
      bindSwipeStart: function bindSwipeStart() {
        var _this = this;

        var settings = Glide.settings;

        if (settings.swipeThreshold) {
          Binder.on(START_EVENTS[0], Components.Html.wrapper, function (event) {
            _this.start(event);
          }, capture);
        }

        if (settings.dragThreshold) {
          Binder.on(START_EVENTS[1], Components.Html.wrapper, function (event) {
            _this.start(event);
          }, capture);
        }
      },

      /**
       * Unbinds swipe's starting event.
       *
       * @return {Void}
       */
      unbindSwipeStart: function unbindSwipeStart() {
        Binder.off(START_EVENTS[0], Components.Html.wrapper, capture);
        Binder.off(START_EVENTS[1], Components.Html.wrapper, capture);
      },

      /**
       * Binds swipe's moving event.
       *
       * @return {Void}
       */
      bindSwipeMove: function bindSwipeMove() {
        var _this2 = this;

        Binder.on(MOVE_EVENTS, Components.Html.wrapper, throttle(function (event) {
          _this2.move(event);
        }, Glide.settings.throttle), capture);
      },

      /**
       * Unbinds swipe's moving event.
       *
       * @return {Void}
       */
      unbindSwipeMove: function unbindSwipeMove() {
        Binder.off(MOVE_EVENTS, Components.Html.wrapper, capture);
      },

      /**
       * Binds swipe's ending event.
       *
       * @return {Void}
       */
      bindSwipeEnd: function bindSwipeEnd() {
        var _this3 = this;

        Binder.on(END_EVENTS, Components.Html.wrapper, function (event) {
          _this3.end(event);
        });
      },

      /**
       * Unbinds swipe's ending event.
       *
       * @return {Void}
       */
      unbindSwipeEnd: function unbindSwipeEnd() {
        Binder.off(END_EVENTS, Components.Html.wrapper);
      },

      /**
       * Normalizes event touches points accorting to different types.
       *
       * @param {Object} event
       */
      touches: function touches(event) {
        if (MOUSE_EVENTS.indexOf(event.type) > -1) {
          return event;
        }

        return event.touches[0] || event.changedTouches[0];
      },

      /**
       * Gets value of minimum swipe distance settings based on event type.
       *
       * @return {Number}
       */
      threshold: function threshold(event) {
        var settings = Glide.settings;

        if (MOUSE_EVENTS.indexOf(event.type) > -1) {
          return settings.dragThreshold;
        }

        return settings.swipeThreshold;
      },

      /**
       * Enables swipe event.
       *
       * @return {self}
       */
      enable: function enable() {
        disabled = false;
        Components.Transition.enable();
        return this;
      },

      /**
       * Disables swipe event.
       *
       * @return {self}
       */
      disable: function disable() {
        disabled = true;
        Components.Transition.disable();
        return this;
      }
    };
    /**
     * Add component class:
     * - after initial building
     */

    Events.on('build.after', function () {
      Components.Html.root.classList.add(Glide.settings.classes.swipeable);
    });
    /**
     * Remove swiping bindings:
     * - on destroying, to remove added EventListeners
     */

    Events.on('destroy', function () {
      Swipe.unbindSwipeStart();
      Swipe.unbindSwipeMove();
      Swipe.unbindSwipeEnd();
      Binder.destroy();
    });
    return Swipe;
  }

  function Images(Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    var Images = {
      /**
       * Binds listener to glide wrapper.
       *
       * @return {Void}
       */
      mount: function mount() {
        this.bind();
      },

      /**
       * Binds `dragstart` event on wrapper to prevent dragging images.
       *
       * @return {Void}
       */
      bind: function bind() {
        Binder.on('dragstart', Components.Html.wrapper, this.dragstart);
      },

      /**
       * Unbinds `dragstart` event on wrapper.
       *
       * @return {Void}
       */
      unbind: function unbind() {
        Binder.off('dragstart', Components.Html.wrapper);
      },

      /**
       * Event handler. Prevents dragging.
       *
       * @return {Void}
       */
      dragstart: function dragstart(event) {
        event.preventDefault();
      }
    };
    /**
     * Remove bindings from images:
     * - on destroying, to remove added EventListeners
     */

    Events.on('destroy', function () {
      Images.unbind();
      Binder.destroy();
    });
    return Images;
  }

  function Anchors(Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    /**
     * Holds detaching status of anchors.
     * Prevents detaching of already detached anchors.
     *
     * @private
     * @type {Boolean}
     */

    var detached = false;
    /**
     * Holds preventing status of anchors.
     * If `true` redirection after click will be disabled.
     *
     * @private
     * @type {Boolean}
     */

    var prevented = false;
    var Anchors = {
      /**
       * Setups a initial state of anchors component.
       *
       * @returns {Void}
       */
      mount: function mount() {
        /**
         * Holds collection of anchors elements.
         *
         * @private
         * @type {HTMLCollection}
         */
        this._a = Components.Html.wrapper.querySelectorAll('a');
        this.bind();
      },

      /**
       * Binds events to anchors inside a track.
       *
       * @return {Void}
       */
      bind: function bind() {
        Binder.on('click', Components.Html.wrapper, this.click);
      },

      /**
       * Unbinds events attached to anchors inside a track.
       *
       * @return {Void}
       */
      unbind: function unbind() {
        Binder.off('click', Components.Html.wrapper);
      },

      /**
       * Handler for click event. Prevents clicks when glide is in `prevent` status.
       *
       * @param  {Object} event
       * @return {Void}
       */
      click: function click(event) {
        if (prevented) {
          event.stopPropagation();
          event.preventDefault();
        }
      },

      /**
       * Detaches anchors click event inside glide.
       *
       * @return {self}
       */
      detach: function detach() {
        prevented = true;

        if (!detached) {
          for (var i = 0; i < this.items.length; i++) {
            this.items[i].draggable = false;
            this.items[i].setAttribute('data-href', this.items[i].getAttribute('href'));
            this.items[i].removeAttribute('href');
          }

          detached = true;
        }

        return this;
      },

      /**
       * Attaches anchors click events inside glide.
       *
       * @return {self}
       */
      attach: function attach() {
        prevented = false;

        if (detached) {
          for (var i = 0; i < this.items.length; i++) {
            this.items[i].draggable = true;
            this.items[i].setAttribute('href', this.items[i].getAttribute('data-href'));
          }

          detached = false;
        }

        return this;
      }
    };
    define(Anchors, 'items', {
      /**
       * Gets collection of the arrows HTML elements.
       *
       * @return {HTMLElement[]}
       */
      get: function get() {
        return Anchors._a;
      }
    });
    /**
     * Detach anchors inside slides:
     * - on swiping, so they won't redirect to its `href` attributes
     */

    Events.on('swipe.move', function () {
      Anchors.detach();
    });
    /**
     * Attach anchors inside slides:
     * - after swiping and transitions ends, so they can redirect after click again
     */

    Events.on('swipe.end', function () {
      Components.Transition.after(function () {
        Anchors.attach();
      });
    });
    /**
     * Unbind anchors inside slides:
     * - on destroying, to bring anchors to its initial state
     */

    Events.on('destroy', function () {
      Anchors.attach();
      Anchors.unbind();
      Binder.destroy();
    });
    return Anchors;
  }

  var NAV_SELECTOR = '[data-glide-el="controls[nav]"]';
  var CONTROLS_SELECTOR = '[data-glide-el^="controls"]';

  function Controls(Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    var capture = supportsPassive$1 ? {
      passive: true
    } : false;
    var Controls = {
      /**
       * Inits arrows. Binds events listeners
       * to the arrows HTML elements.
       *
       * @return {Void}
       */
      mount: function mount() {
        /**
         * Collection of navigation HTML elements.
         *
         * @private
         * @type {HTMLCollection}
         */
        this._n = Components.Html.root.querySelectorAll(NAV_SELECTOR);
        /**
         * Collection of controls HTML elements.
         *
         * @private
         * @type {HTMLCollection}
         */

        this._c = Components.Html.root.querySelectorAll(CONTROLS_SELECTOR);
        this.addBindings();
      },

      /**
       * Sets active class to current slide.
       *
       * @return {Void}
       */
      setActive: function setActive() {
        for (var i = 0; i < this._n.length; i++) {
          this.addClass(this._n[i].children);
        }
      },

      /**
       * Removes active class to current slide.
       *
       * @return {Void}
       */
      removeActive: function removeActive() {
        for (var i = 0; i < this._n.length; i++) {
          this.removeClass(this._n[i].children);
        }
      },

      /**
       * Toggles active class on items inside navigation.
       *
       * @param  {HTMLElement} controls
       * @return {Void}
       */
      addClass: function addClass(controls) {
        var settings = Glide.settings;
        var item = controls[Glide.index];

        if (item) {
          item.classList.add(settings.classes.activeNav);
          siblings(item).forEach(function (sibling) {
            sibling.classList.remove(settings.classes.activeNav);
          });
        }
      },

      /**
       * Removes active class from active control.
       *
       * @param  {HTMLElement} controls
       * @return {Void}
       */
      removeClass: function removeClass(controls) {
        var item = controls[Glide.index];

        if (item) {
          item.classList.remove(Glide.settings.classes.activeNav);
        }
      },

      /**
       * Adds handles to the each group of controls.
       *
       * @return {Void}
       */
      addBindings: function addBindings() {
        for (var i = 0; i < this._c.length; i++) {
          this.bind(this._c[i].children);
        }
      },

      /**
       * Removes handles from the each group of controls.
       *
       * @return {Void}
       */
      removeBindings: function removeBindings() {
        for (var i = 0; i < this._c.length; i++) {
          this.unbind(this._c[i].children);
        }
      },

      /**
       * Binds events to arrows HTML elements.
       *
       * @param {HTMLCollection} elements
       * @return {Void}
       */
      bind: function bind(elements) {
        for (var i = 0; i < elements.length; i++) {
          Binder.on('click', elements[i], this.click);
          Binder.on('touchstart', elements[i], this.click, capture);
        }
      },

      /**
       * Unbinds events binded to the arrows HTML elements.
       *
       * @param {HTMLCollection} elements
       * @return {Void}
       */
      unbind: function unbind(elements) {
        for (var i = 0; i < elements.length; i++) {
          Binder.off(['click', 'touchstart'], elements[i]);
        }
      },

      /**
       * Handles `click` event on the arrows HTML elements.
       * Moves slider in driection precised in
       * `data-glide-dir` attribute.
       *
       * @param {Object} event
       * @return {Void}
       */
      click: function click(event) {
        event.preventDefault();
        Components.Run.make(Components.Direction.resolve(event.currentTarget.getAttribute('data-glide-dir')));
      }
    };
    define(Controls, 'items', {
      /**
       * Gets collection of the controls HTML elements.
       *
       * @return {HTMLElement[]}
       */
      get: function get() {
        return Controls._c;
      }
    });
    /**
     * Swap active class of current navigation item:
     * - after mounting to set it to initial index
     * - after each move to the new index
     */

    Events.on(['mount.after', 'move.after'], function () {
      Controls.setActive();
    });
    /**
     * Remove bindings and HTML Classes:
     * - on destroying, to bring markup to its initial state
     */

    Events.on('destroy', function () {
      Controls.removeBindings();
      Controls.removeActive();
      Binder.destroy();
    });
    return Controls;
  }

  function Keyboard(Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    var Keyboard = {
      /**
       * Binds keyboard events on component mount.
       *
       * @return {Void}
       */
      mount: function mount() {
        if (Glide.settings.keyboard) {
          this.bind();
        }
      },

      /**
       * Adds keyboard press events.
       *
       * @return {Void}
       */
      bind: function bind() {
        Binder.on('keyup', document, this.press);
      },

      /**
       * Removes keyboard press events.
       *
       * @return {Void}
       */
      unbind: function unbind() {
        Binder.off('keyup', document);
      },

      /**
       * Handles keyboard's arrows press and moving glide foward and backward.
       *
       * @param  {Object} event
       * @return {Void}
       */
      press: function press(event) {
        if (event.keyCode === 39) {
          Components.Run.make(Components.Direction.resolve('>'));
        }

        if (event.keyCode === 37) {
          Components.Run.make(Components.Direction.resolve('<'));
        }
      }
    };
    /**
     * Remove bindings from keyboard:
     * - on destroying to remove added events
     * - on updating to remove events before remounting
     */

    Events.on(['destroy', 'update'], function () {
      Keyboard.unbind();
    });
    /**
     * Remount component
     * - on updating to reflect potential changes in settings
     */

    Events.on('update', function () {
      Keyboard.mount();
    });
    /**
     * Destroy binder:
     * - on destroying to remove listeners
     */

    Events.on('destroy', function () {
      Binder.destroy();
    });
    return Keyboard;
  }

  function Autoplay(Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    var Autoplay = {
      /**
       * Initializes autoplaying and events.
       *
       * @return {Void}
       */
      mount: function mount() {
        this.start();

        if (Glide.settings.hoverpause) {
          this.bind();
        }
      },

      /**
       * Starts autoplaying in configured interval.
       *
       * @param {Boolean|Number} force Run autoplaying with passed interval regardless of `autoplay` settings
       * @return {Void}
       */
      start: function start() {
        var _this = this;

        if (Glide.settings.autoplay) {
          if (isUndefined(this._i)) {
            this._i = setInterval(function () {
              _this.stop();

              Components.Run.make('>');

              _this.start();
            }, this.time);
          }
        }
      },

      /**
       * Stops autorunning of the glide.
       *
       * @return {Void}
       */
      stop: function stop() {
        this._i = clearInterval(this._i);
      },

      /**
       * Stops autoplaying while mouse is over glide's area.
       *
       * @return {Void}
       */
      bind: function bind() {
        var _this2 = this;

        Binder.on('mouseover', Components.Html.root, function () {
          _this2.stop();
        });
        Binder.on('mouseout', Components.Html.root, function () {
          _this2.start();
        });
      },

      /**
       * Unbind mouseover events.
       *
       * @returns {Void}
       */
      unbind: function unbind() {
        Binder.off(['mouseover', 'mouseout'], Components.Html.root);
      }
    };
    define(Autoplay, 'time', {
      /**
       * Gets time period value for the autoplay interval. Prioritizes
       * times in `data-glide-autoplay` attrubutes over options.
       *
       * @return {Number}
       */
      get: function get() {
        var autoplay = Components.Html.slides[Glide.index].getAttribute('data-glide-autoplay');

        if (autoplay) {
          return toInt(autoplay);
        }

        return toInt(Glide.settings.autoplay);
      }
    });
    /**
     * Stop autoplaying and unbind events:
     * - on destroying, to clear defined interval
     * - on updating via API to reset interval that may changed
     */

    Events.on(['destroy', 'update'], function () {
      Autoplay.unbind();
    });
    /**
     * Stop autoplaying:
     * - before each run, to restart autoplaying
     * - on pausing via API
     * - on destroying, to clear defined interval
     * - while starting a swipe
     * - on updating via API to reset interval that may changed
     */

    Events.on(['run.before', 'pause', 'destroy', 'swipe.start', 'update'], function () {
      Autoplay.stop();
    });
    /**
     * Start autoplaying:
     * - after each run, to restart autoplaying
     * - on playing via API
     * - while ending a swipe
     */

    Events.on(['run.after', 'play', 'swipe.end'], function () {
      Autoplay.start();
    });
    /**
     * Remount autoplaying:
     * - on updating via API to reset interval that may changed
     */

    Events.on('update', function () {
      Autoplay.mount();
    });
    /**
     * Destroy a binder:
     * - on destroying glide instance to clearup listeners
     */

    Events.on('destroy', function () {
      Binder.destroy();
    });
    return Autoplay;
  }
  /**
   * Sorts keys of breakpoint object so they will be ordered from lower to bigger.
   *
   * @param {Object} points
   * @returns {Object}
   */


  function sortBreakpoints(points) {
    if (isObject(points)) {
      return sortKeys(points);
    } else {
      warn('Breakpoints option must be an object');
    }

    return {};
  }

  function Breakpoints(Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    /**
     * Holds reference to settings.
     *
     * @type {Object}
     */

    var settings = Glide.settings;
    /**
     * Holds reference to breakpoints object in settings. Sorts breakpoints
     * from smaller to larger. It is required in order to proper
     * matching currently active breakpoint settings.
     *
     * @type {Object}
     */

    var points = sortBreakpoints(settings.breakpoints);
    /**
     * Cache initial settings before overwritting.
     *
     * @type {Object}
     */

    var defaults = _extends({}, settings);

    var Breakpoints = {
      /**
       * Matches settings for currectly matching media breakpoint.
       *
       * @param {Object} points
       * @returns {Object}
       */
      match: function match(points) {
        if (typeof window.matchMedia !== 'undefined') {
          for (var point in points) {
            if (points.hasOwnProperty(point)) {
              if (window.matchMedia('(max-width: ' + point + 'px)').matches) {
                return points[point];
              }
            }
          }
        }

        return defaults;
      }
    };
    /**
     * Overwrite instance settings with currently matching breakpoint settings.
     * This happens right after component initialization.
     */

    _extends(settings, Breakpoints.match(points));
    /**
     * Update glide with settings of matched brekpoint:
     * - window resize to update slider
     */


    Binder.on('resize', window, throttle(function () {
      Glide.settings = mergeOptions(settings, Breakpoints.match(points));
    }, Glide.settings.throttle));
    /**
     * Resort and update default settings:
     * - on reinit via API, so breakpoint matching will be performed with options
     */

    Events.on('update', function () {
      points = sortBreakpoints(points);
      defaults = _extends({}, settings);
    });
    /**
     * Unbind resize listener:
     * - on destroying, to bring markup to its initial state
     */

    Events.on('destroy', function () {
      Binder.off('resize', window);
    });
    return Breakpoints;
  }

  var COMPONENTS = {
    // Required
    Html: Html,
    Translate: Translate,
    Transition: Transition,
    Direction: Direction,
    Peek: Peek,
    Sizes: Sizes,
    Gaps: Gaps,
    Move: Move,
    Clones: Clones,
    Resize: Resize,
    Build: Build,
    Run: Run,
    // Optional
    Swipe: Swipe,
    Images: Images,
    Anchors: Anchors,
    Controls: Controls,
    Keyboard: Keyboard,
    Autoplay: Autoplay,
    Breakpoints: Breakpoints
  };

  var Glide$1 = function (_Core) {
    inherits(Glide$$1, _Core);

    function Glide$$1() {
      classCallCheck(this, Glide$$1);
      return possibleConstructorReturn(this, (Glide$$1.__proto__ || Object.getPrototypeOf(Glide$$1)).apply(this, arguments));
    }

    createClass(Glide$$1, [{
      key: 'mount',
      value: function mount() {
        var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return get(Glide$$1.prototype.__proto__ || Object.getPrototypeOf(Glide$$1.prototype), 'mount', this).call(this, _extends({}, COMPONENTS, extensions));
      }
    }]);
    return Glide$$1;
  }(Glide);

  return Glide$1;
});

/***/ }),

/***/ "./node_modules/mixitup/dist/mixitup.js":
/*!**********************************************!*\
  !*** ./node_modules/mixitup/dist/mixitup.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**!
 * MixItUp v3.3.1
 * A high-performance, dependency-free library for animated filtering, sorting and more
 * Build 94e0fbf6-cd0b-4987-b3c0-14b59b67b8a0
 *
 * @copyright Copyright 2014-2018 KunkaLabs Limited.
 * @author    KunkaLabs Limited.
 * @link      https://www.kunkalabs.com/mixitup/
 *
 * @license   Commercial use requires a commercial license.
 *            https://www.kunkalabs.com/mixitup/licenses/
 *
 *            Non-commercial use permitted under same terms as CC BY-NC 3.0 license.
 *            http://creativecommons.org/licenses/by-nc/3.0/
 */
(function (window) {
  'use strict';

  var _mixitup = null,
      h = null;

  (function () {
    var VENDORS = ['webkit', 'moz', 'o', 'ms'],
        canary = window.document.createElement('div'),
        i = -1; // window.requestAnimationFrame

    for (i = 0; i < VENDORS.length && !window.requestAnimationFrame; i++) {
      window.requestAnimationFrame = window[VENDORS[i] + 'RequestAnimationFrame'];
    } // Element.nextElementSibling


    if (typeof canary.nextElementSibling === 'undefined') {
      Object.defineProperty(window.Element.prototype, 'nextElementSibling', {
        get: function get() {
          var el = this.nextSibling;

          while (el) {
            if (el.nodeType === 1) {
              return el;
            }

            el = el.nextSibling;
          }

          return null;
        }
      });
    } // Element.matches


    (function (ElementPrototype) {
      ElementPrototype.matches = ElementPrototype.matches || ElementPrototype.machesSelector || ElementPrototype.mozMatchesSelector || ElementPrototype.msMatchesSelector || ElementPrototype.oMatchesSelector || ElementPrototype.webkitMatchesSelector || function (selector) {
        return Array.prototype.indexOf.call(this.parentElement.querySelectorAll(selector), this) > -1;
      };
    })(window.Element.prototype); // Object.keys
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys


    if (!Object.keys) {
      Object.keys = function () {
        var hasOwnProperty = Object.prototype.hasOwnProperty,
            hasDontEnumBug = false,
            dontEnums = [],
            dontEnumsLength = -1;
        hasDontEnumBug = !{
          toString: null
        }.propertyIsEnumerable('toString');
        dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
        dontEnumsLength = dontEnums.length;
        return function (obj) {
          var result = [],
              prop = '',
              i = -1;

          if (_typeof(obj) !== 'object' && (typeof obj !== 'function' || obj === null)) {
            throw new TypeError('Object.keys called on non-object');
          }

          for (prop in obj) {
            if (hasOwnProperty.call(obj, prop)) {
              result.push(prop);
            }
          }

          if (hasDontEnumBug) {
            for (i = 0; i < dontEnumsLength; i++) {
              if (hasOwnProperty.call(obj, dontEnums[i])) {
                result.push(dontEnums[i]);
              }
            }
          }

          return result;
        };
      }();
    } // Array.isArray
    // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray


    if (!Array.isArray) {
      Array.isArray = function (arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
      };
    } // Object.create
    // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/create


    if (typeof Object.create !== 'function') {
      Object.create = function (undefined) {
        var Temp = function Temp() {};

        return function (prototype, propertiesObject) {
          if (prototype !== Object(prototype) && prototype !== null) {
            throw TypeError('Argument must be an object, or null');
          }

          Temp.prototype = prototype || {};
          var result = new Temp();
          Temp.prototype = null;

          if (propertiesObject !== undefined) {
            Object.defineProperties(result, propertiesObject);
          }

          if (prototype === null) {
            /* jshint ignore:start */
            result.__proto__ = null;
            /* jshint ignore:end */
          }

          return result;
        };
      }();
    } // String.prototyoe.trim


    if (!String.prototype.trim) {
      String.prototype.trim = function () {
        return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
      };
    } // Array.prototype.indexOf
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf


    if (!Array.prototype.indexOf) {
      Array.prototype.indexOf = function (searchElement) {
        var n, k, t, len;

        if (this === null) {
          throw new TypeError();
        }

        t = Object(this);
        len = t.length >>> 0;

        if (len === 0) {
          return -1;
        }

        n = 0;

        if (arguments.length > 1) {
          n = Number(arguments[1]);

          if (n !== n) {
            n = 0;
          } else if (n !== 0 && n !== Infinity && n !== -Infinity) {
            n = (n > 0 || -1) * Math.floor(Math.abs(n));
          }
        }

        if (n >= len) {
          return -1;
        }

        for (k = n >= 0 ? n : Math.max(len - Math.abs(n), 0); k < len; k++) {
          if (k in t && t[k] === searchElement) {
            return k;
          }
        }

        return -1;
      };
    } // Function.prototype.bind
    // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind


    if (!Function.prototype.bind) {
      Function.prototype.bind = function (oThis) {
        var aArgs, self, FNOP, fBound;

        if (typeof this !== 'function') {
          throw new TypeError();
        }

        aArgs = Array.prototype.slice.call(arguments, 1);
        self = this;

        FNOP = function FNOP() {};

        fBound = function fBound() {
          return self.apply(this instanceof FNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
        };

        if (this.prototype) {
          FNOP.prototype = this.prototype;
        }

        fBound.prototype = new FNOP();
        return fBound;
      };
    } // Element.prototype.dispatchEvent


    if (!window.Element.prototype.dispatchEvent) {
      window.Element.prototype.dispatchEvent = function (event) {
        try {
          return this.fireEvent('on' + event.type, event);
        } catch (err) {}
      };
    }
  })();
  /**
   * The `mixitup()` "factory" function creates and returns individual instances
   * of MixItUp, known as "mixers", on which API methods can be called.
   *
   * When loading MixItUp via a script tag, the factory function is accessed
   * via the global variable `mixitup`. When using a module loading
   * system (e.g. ES2015, CommonJS, RequireJS), the factory function is
   * exported into your module when you require the MixItUp library.
   *
   * @example
   * mixitup(container [,config] [,foreignDoc])
   *
   * @example <caption>Example 1: Creating a mixer instance with an element reference</caption>
   * var containerEl = document.querySelector('.container');
   *
   * var mixer = mixitup(containerEl);
   *
   * @example <caption>Example 2: Creating a mixer instance with a selector string</caption>
   * var mixer = mixitup('.container');
   *
   * @example <caption>Example 3: Passing a configuration object</caption>
   * var mixer = mixitup(containerEl, {
   *     animation: {
   *         effects: 'fade scale(0.5)'
   *     }
   * });
   *
   * @example <caption>Example 4: Passing an iframe reference</caption>
   * var mixer = mixitup(containerEl, config, foreignDocument);
   *
   * @global
   * @namespace
   * @public
   * @kind        function
   * @since       3.0.0
   * @param       {(Element|string)}  container
   *      A DOM element or selector string representing the container(s) on which to instantiate MixItUp.
   * @param       {object}            [config]
   *      An optional "configuration object" used to customize the behavior of the MixItUp instance.
   * @param       {object}            [foreignDoc]
   *      An optional reference to a `document`, which can be used to control a MixItUp instance in an iframe.
   * @return      {mixitup.Mixer}
   *      A "mixer" object holding the MixItUp instance.
   */


  _mixitup = function mixitup(container, config, foreignDoc) {
    var el = null,
        returnCollection = false,
        instance = null,
        facade = null,
        doc = null,
        output = null,
        instances = [],
        id = '',
        elements = [],
        i = -1;
    doc = foreignDoc || window.document;

    if (returnCollection = arguments[3]) {
      // A non-documented 4th paramater enabling control of multiple instances
      returnCollection = typeof returnCollection === 'boolean';
    }

    if (typeof container === 'string') {
      elements = doc.querySelectorAll(container);
    } else if (container && _typeof(container) === 'object' && h.isElement(container, doc)) {
      elements = [container];
    } else if (container && _typeof(container) === 'object' && container.length) {
      // Although not documented, the container may also be an array-like list of
      // elements such as a NodeList or jQuery collection, is returnCollection is true
      elements = container;
    } else {
      throw new Error(_mixitup.messages.errorFactoryInvalidContainer());
    }

    if (elements.length < 1) {
      throw new Error(_mixitup.messages.errorFactoryContainerNotFound());
    }

    for (i = 0; el = elements[i]; i++) {
      if (i > 0 && !returnCollection) break;

      if (!el.id) {
        id = 'MixItUp' + h.randomHex();
        el.id = id;
      } else {
        id = el.id;
      }

      if (_mixitup.instances[id] instanceof _mixitup.Mixer) {
        instance = _mixitup.instances[id];

        if (!config || config && config.debug && config.debug.showWarnings !== false) {
          console.warn(_mixitup.messages.warningFactoryPreexistingInstance());
        }
      } else {
        instance = new _mixitup.Mixer();
        instance.attach(el, doc, id, config);
        _mixitup.instances[id] = instance;
      }

      facade = new _mixitup.Facade(instance);

      if (config && config.debug && config.debug.enable) {
        instances.push(instance);
      } else {
        instances.push(facade);
      }
    }

    if (returnCollection) {
      output = new _mixitup.Collection(instances);
    } else {
      // Return the first instance regardless
      output = instances[0];
    }

    return output;
  };
  /**
   * The `.use()` static method is used to extend the functionality of mixitup with compatible
   * extensions and libraries in an environment with modular scoping e.g. ES2015, CommonJS, or RequireJS.
   *
   * You need only call the `.use()` function once per project, per extension, as module loaders
   * will cache a single reference to MixItUp inclusive of all changes made.
   *
   * @example
   * mixitup.use(extension)
   *
   * @example <caption>Example 1: Extending MixItUp with the Pagination Extension</caption>
   *
   * import mixitup from 'mixitup';
   * import mixitupPagination from 'mixitup-pagination';
   *
   * mixitup.use(mixitupPagination);
   *
   * // All mixers created by the factory function in all modules will now
   * // have pagination functionality
   *
   * var mixer = mixitup('.container');
   *
   * @public
   * @name     use
   * @memberof mixitup
   * @kind     function
   * @static
   * @since    3.0.0
   * @param    {*}  extension   A reference to the extension or library to be used.
   * @return   {void}
   */


  _mixitup.use = function (extension) {
    _mixitup.Base.prototype.callActions.call(_mixitup, 'beforeUse', arguments); // Call the extension's factory function, passing
    // the mixitup factory as a paramater


    if (typeof extension === 'function' && extension.TYPE === 'mixitup-extension') {
      // Mixitup extension
      if (typeof _mixitup.extensions[extension.NAME] === 'undefined') {
        extension(_mixitup);
        _mixitup.extensions[extension.NAME] = extension;
      }
    } else if (extension.fn && extension.fn.jquery) {
      // jQuery
      _mixitup.libraries.$ = extension;
    }

    _mixitup.Base.prototype.callActions.call(_mixitup, 'afterUse', arguments);
  };

  _mixitup.instances = {};
  _mixitup.extensions = {};
  _mixitup.libraries = {};
  /**
   * @private
   */

  h = {
    /**
     * @private
     * @param   {HTMLElement}   el
     * @param   {string}        cls
     * @return  {boolean}
     */
    hasClass: function hasClass(el, cls) {
      return !!el.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
    },

    /**
     * @private
     * @param   {HTMLElement}   el
     * @param   {string}        cls
     * @return  {void}
     */
    addClass: function addClass(el, cls) {
      if (!this.hasClass(el, cls)) el.className += el.className ? ' ' + cls : cls;
    },

    /**
     * @private
     * @param   {HTMLElement}   el
     * @param   {string}        cls
     * @return  {void}
     */
    removeClass: function removeClass(el, cls) {
      if (this.hasClass(el, cls)) {
        var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)');
        el.className = el.className.replace(reg, ' ').trim();
      }
    },

    /**
     * Merges the properties of the source object onto the
     * target object. Alters the target object.
     *
     * @private
     * @param   {object}    destination
     * @param   {object}    source
     * @param   {boolean}   [deep=false]
     * @param   {boolean}   [handleErrors=false]
     * @return  {void}
     */
    extend: function extend(destination, source, deep, handleErrors) {
      var sourceKeys = [],
          key = '',
          i = -1;
      deep = deep || false;
      handleErrors = handleErrors || false;

      try {
        if (Array.isArray(source)) {
          for (i = 0; i < source.length; i++) {
            sourceKeys.push(i);
          }
        } else if (source) {
          sourceKeys = Object.keys(source);
        }

        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];

          if (!deep || _typeof(source[key]) !== 'object' || this.isElement(source[key])) {
            // All non-object properties, or all properties if shallow extend
            destination[key] = source[key];
          } else if (Array.isArray(source[key])) {
            // Arrays
            if (!destination[key]) {
              destination[key] = [];
            }

            this.extend(destination[key], source[key], deep, handleErrors);
          } else {
            // Objects
            if (!destination[key]) {
              destination[key] = {};
            }

            this.extend(destination[key], source[key], deep, handleErrors);
          }
        }
      } catch (err) {
        if (handleErrors) {
          this.handleExtendError(err, destination);
        } else {
          throw err;
        }
      }

      return destination;
    },

    /**
     * @private
     * @param   {Error}  err
     * @param   {object} destination
     * @return  {void}
     */
    handleExtendError: function handleExtendError(err, destination) {
      var re = /property "?(\w*)"?[,:] object/i,
          matches = null,
          erroneous = '',
          message = '',
          suggestion = '',
          probableMatch = '',
          key = '',
          mostMatchingChars = -1,
          i = -1;

      if (err instanceof TypeError && (matches = re.exec(err.message))) {
        erroneous = matches[1];

        for (key in destination) {
          i = 0;

          while (i < erroneous.length && erroneous.charAt(i) === key.charAt(i)) {
            i++;
          }

          if (i > mostMatchingChars) {
            mostMatchingChars = i;
            probableMatch = key;
          }
        }

        if (mostMatchingChars > 1) {
          suggestion = _mixitup.messages.errorConfigInvalidPropertySuggestion({
            probableMatch: probableMatch
          });
        }

        message = _mixitup.messages.errorConfigInvalidProperty({
          erroneous: erroneous,
          suggestion: suggestion
        });
        throw new TypeError(message);
      }

      throw err;
    },

    /**
     * @private
     * @param   {string} str
     * @return  {function}
     */
    template: function template(str) {
      var re = /\${([\w]*)}/g,
          dynamics = {},
          matches = null;

      while (matches = re.exec(str)) {
        dynamics[matches[1]] = new RegExp('\\${' + matches[1] + '}', 'g');
      }

      return function (data) {
        var key = '',
            output = str;
        data = data || {};

        for (key in dynamics) {
          output = output.replace(dynamics[key], typeof data[key] !== 'undefined' ? data[key] : '');
        }

        return output;
      };
    },

    /**
     * @private
     * @param   {HTMLElement}   el
     * @param   {string}        type
     * @param   {function}      fn
     * @param   {boolean}       useCapture
     * @return  {void}
     */
    on: function on(el, type, fn, useCapture) {
      if (!el) return;

      if (el.addEventListener) {
        el.addEventListener(type, fn, useCapture);
      } else if (el.attachEvent) {
        el['e' + type + fn] = fn;

        el[type + fn] = function () {
          el['e' + type + fn](window.event);
        };

        el.attachEvent('on' + type, el[type + fn]);
      }
    },

    /**
     * @private
     * @param   {HTMLElement}   el
     * @param   {string}        type
     * @param   {function}      fn
     * @return  {void}
     */
    off: function off(el, type, fn) {
      if (!el) return;

      if (el.removeEventListener) {
        el.removeEventListener(type, fn, false);
      } else if (el.detachEvent) {
        el.detachEvent('on' + type, el[type + fn]);
        el[type + fn] = null;
      }
    },

    /**
     * @private
     * @param   {string}      eventType
     * @param   {object}      detail
     * @param   {Document}    [doc]
     * @return  {CustomEvent}
     */
    getCustomEvent: function getCustomEvent(eventType, detail, doc) {
      var event = null;
      doc = doc || window.document;

      if (typeof window.CustomEvent === 'function') {
        event = new window.CustomEvent(eventType, {
          detail: detail,
          bubbles: true,
          cancelable: true
        });
      } else if (typeof doc.createEvent === 'function') {
        event = doc.createEvent('CustomEvent');
        event.initCustomEvent(eventType, true, true, detail);
      } else {
        event = doc.createEventObject(), event.type = eventType;
        event.returnValue = false;
        event.cancelBubble = false;
        event.detail = detail;
      }

      return event;
    },

    /**
     * @private
     * @param   {Event} e
     * @return  {Event}
     */
    getOriginalEvent: function getOriginalEvent(e) {
      if (e.touches && e.touches.length) {
        return e.touches[0];
      } else if (e.changedTouches && e.changedTouches.length) {
        return e.changedTouches[0];
      } else {
        return e;
      }
    },

    /**
     * @private
     * @param   {HTMLElement}   el
     * @param   {string}        selector
     * @return  {Number}
     */
    index: function index(el, selector) {
      var i = 0;

      while ((el = el.previousElementSibling) !== null) {
        if (!selector || el.matches(selector)) {
          ++i;
        }
      }

      return i;
    },

    /**
     * Converts a dash or snake-case string to camel case.
     *
     * @private
     * @param   {string}    str
     * @param   {boolean}   [isPascal]
     * @return  {string}
     */
    camelCase: function camelCase(str) {
      return str.toLowerCase().replace(/([_-][a-z])/g, function ($1) {
        return $1.toUpperCase().replace(/[_-]/, '');
      });
    },

    /**
     * Converts a dash or snake-case string to pascal case.
     *
     * @private
     * @param   {string}    str
     * @param   {boolean}   [isPascal]
     * @return  {string}
     */
    pascalCase: function pascalCase(str) {
      return (str = this.camelCase(str)).charAt(0).toUpperCase() + str.slice(1);
    },

    /**
     * Converts a camel or pascal-case string to dash case.
     *
     * @private
     * @param   {string}    str
     * @return  {string}
     */
    dashCase: function dashCase(str) {
      return str.replace(/([A-Z])/g, '-$1').replace(/^-/, '').toLowerCase();
    },

    /**
     * @private
     * @param   {HTMLElement}       el
     * @param   {HTMLHtmlElement}   [doc]
     * @return  {boolean}
     */
    isElement: function isElement(el, doc) {
      doc = doc || window.document;

      if (window.HTMLElement && el instanceof window.HTMLElement) {
        return true;
      } else if (doc.defaultView && doc.defaultView.HTMLElement && el instanceof doc.defaultView.HTMLElement) {
        return true;
      } else {
        return el !== null && el.nodeType === 1 && typeof el.nodeName === 'string';
      }
    },

    /**
     * @private
     * @param   {string}            htmlString
     * @param   {HTMLHtmlElement}   [doc]
     * @return  {DocumentFragment}
     */
    createElement: function createElement(htmlString, doc) {
      var frag = null,
          temp = null;
      doc = doc || window.document;
      frag = doc.createDocumentFragment();
      temp = doc.createElement('div');
      temp.innerHTML = htmlString.trim();

      while (temp.firstChild) {
        frag.appendChild(temp.firstChild);
      }

      return frag;
    },

    /**
     * @private
     * @param   {Node} node
     * @return  {void}
     */
    removeWhitespace: function removeWhitespace(node) {
      var deleting;

      while (node && node.nodeName === '#text') {
        deleting = node;
        node = node.previousSibling;
        deleting.parentElement && deleting.parentElement.removeChild(deleting);
      }
    },

    /**
     * @private
     * @param   {Array<*>}  a
     * @param   {Array<*>}  b
     * @return  {boolean}
     */
    isEqualArray: function isEqualArray(a, b) {
      var i = a.length;
      if (i !== b.length) return false;

      while (i--) {
        if (a[i] !== b[i]) return false;
      }

      return true;
    },

    /**
     * @private
     * @param   {object}  a
     * @param   {object}  b
     * @return  {boolean}
     */
    deepEquals: function deepEquals(a, b) {
      var key;

      if (_typeof(a) === 'object' && a && _typeof(b) === 'object' && b) {
        if (Object.keys(a).length !== Object.keys(b).length) return false;

        for (key in a) {
          if (!b.hasOwnProperty(key) || !this.deepEquals(a[key], b[key])) return false;
        }
      } else if (a !== b) {
        return false;
      }

      return true;
    },

    /**
     * @private
     * @param   {Array<*>}  oldArray
     * @return  {Array<*>}
     */
    arrayShuffle: function arrayShuffle(oldArray) {
      var newArray = oldArray.slice(),
          len = newArray.length,
          i = len,
          p = -1,
          t = [];

      while (i--) {
        p = ~~(Math.random() * len);
        t = newArray[i];
        newArray[i] = newArray[p];
        newArray[p] = t;
      }

      return newArray;
    },

    /**
     * @private
     * @param   {object}    list
     */
    arrayFromList: function arrayFromList(list) {
      var output, i;

      try {
        return Array.prototype.slice.call(list);
      } catch (err) {
        output = [];

        for (i = 0; i < list.length; i++) {
          output.push(list[i]);
        }

        return output;
      }
    },

    /**
     * @private
     * @param   {function}  func
     * @param   {Number}    wait
     * @param   {boolean}   immediate
     * @return  {function}
     */
    debounce: function debounce(func, wait, immediate) {
      var timeout;
      return function () {
        var self = this,
            args = arguments,
            callNow = immediate && !timeout,
            later = null;

        later = function later() {
          timeout = null;

          if (!immediate) {
            func.apply(self, args);
          }
        };

        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(self, args);
      };
    },

    /**
     * @private
     * @param   {HTMLElement}   element
     * @return  {object}
     */
    position: function position(element) {
      var xPosition = 0,
          yPosition = 0,
          offsetParent = element;

      while (element) {
        xPosition -= element.scrollLeft;
        yPosition -= element.scrollTop;

        if (element === offsetParent) {
          xPosition += element.offsetLeft;
          yPosition += element.offsetTop;
          offsetParent = element.offsetParent;
        }

        element = element.parentElement;
      }

      return {
        x: xPosition,
        y: yPosition
      };
    },

    /**
     * @private
     * @param   {object}    node1
     * @param   {object}    node2
     * @return  {Number}
     */
    getHypotenuse: function getHypotenuse(node1, node2) {
      var distanceX = node1.x - node2.x,
          distanceY = node1.y - node2.y;
      distanceX = distanceX < 0 ? distanceX * -1 : distanceX, distanceY = distanceY < 0 ? distanceY * -1 : distanceY;
      return Math.sqrt(Math.pow(distanceX, 2) + Math.pow(distanceY, 2));
    },

    /**
     * Calcuates the area of intersection between two rectangles and expresses it as
     * a ratio in comparison to the area of the first rectangle.
     *
     * @private
     * @param   {Rect}  box1
     * @param   {Rect}  box2
     * @return  {number}
     */
    getIntersectionRatio: function getIntersectionRatio(box1, box2) {
      var controlArea = box1.width * box1.height,
          intersectionX = -1,
          intersectionY = -1,
          intersectionArea = -1,
          ratio = -1;
      intersectionX = Math.max(0, Math.min(box1.left + box1.width, box2.left + box2.width) - Math.max(box1.left, box2.left));
      intersectionY = Math.max(0, Math.min(box1.top + box1.height, box2.top + box2.height) - Math.max(box1.top, box2.top));
      intersectionArea = intersectionY * intersectionX;
      ratio = intersectionArea / controlArea;
      return ratio;
    },

    /**
     * @private
     * @param   {object}            el
     * @param   {string}            selector
     * @param   {boolean}           [includeSelf]
     * @param   {HTMLHtmlElement}   [doc]
     * @return  {Element|null}
     */
    closestParent: function closestParent(el, selector, includeSelf, doc) {
      var parent = el.parentNode;
      doc = doc || window.document;

      if (includeSelf && el.matches(selector)) {
        return el;
      }

      while (parent && parent != doc.body) {
        if (parent.matches && parent.matches(selector)) {
          return parent;
        } else if (parent.parentNode) {
          parent = parent.parentNode;
        } else {
          return null;
        }
      }

      return null;
    },

    /**
     * @private
     * @param   {HTMLElement}       el
     * @param   {string}            selector
     * @param   {HTMLHtmlElement}   [doc]
     * @return  {NodeList}
     */
    children: function children(el, selector, doc) {
      var children = [],
          tempId = '';
      doc = doc || window.doc;

      if (el) {
        if (!el.id) {
          tempId = 'Temp' + this.randomHexKey();
          el.id = tempId;
        }

        children = doc.querySelectorAll('#' + el.id + ' > ' + selector);

        if (tempId) {
          el.removeAttribute('id');
        }
      }

      return children;
    },

    /**
     * Creates a clone of a provided array, with any empty strings removed.
     *
     * @private
     * @param   {Array<*>} originalArray
     * @return  {Array<*>}
     */
    clean: function clean(originalArray) {
      var cleanArray = [],
          i = -1;

      for (i = 0; i < originalArray.length; i++) {
        if (originalArray[i] !== '') {
          cleanArray.push(originalArray[i]);
        }
      }

      return cleanArray;
    },

    /**
     * Abstracts an ES6 promise into a q-like deferred interface for storage and deferred resolution.
     *
     * @private
     * @param  {object} libraries
     * @return {h.Deferred}
     */
    defer: function defer(libraries) {
      var deferred = null,
          promiseWrapper = null,
          $ = null;
      promiseWrapper = new this.Deferred();

      if (_mixitup.features.has.promises) {
        // ES6 native promise or polyfill
        promiseWrapper.promise = new Promise(function (resolve, reject) {
          promiseWrapper.resolve = resolve;
          promiseWrapper.reject = reject;
        });
      } else if (($ = window.jQuery || libraries.$) && typeof $.Deferred === 'function') {
        // jQuery
        deferred = $.Deferred();
        promiseWrapper.promise = deferred.promise();
        promiseWrapper.resolve = deferred.resolve;
        promiseWrapper.reject = deferred.reject;
      } else if (window.console) {
        // No implementation
        console.warn(_mixitup.messages.warningNoPromiseImplementation());
      }

      return promiseWrapper;
    },

    /**
     * @private
     * @param   {Array<Promise>}    tasks
     * @param   {object}            libraries
     * @return  {Promise<Array>}
     */
    all: function all(tasks, libraries) {
      var $ = null;

      if (_mixitup.features.has.promises) {
        return Promise.all(tasks);
      } else if (($ = window.jQuery || libraries.$) && typeof $.when === 'function') {
        return $.when.apply($, tasks).done(function () {
          // jQuery when returns spread arguments rather than an array or resolutions
          return arguments;
        });
      } // No implementation


      if (window.console) {
        console.warn(_mixitup.messages.warningNoPromiseImplementation());
      }

      return [];
    },

    /**
     * @private
     * @param   {HTMLElement}   el
     * @param   {string}        property
     * @param   {Array<string>} vendors
     * @return  {string}
     */
    getPrefix: function getPrefix(el, property, vendors) {
      var i = -1,
          prefix = '';
      if (h.dashCase(property) in el.style) return '';

      for (i = 0; prefix = vendors[i]; i++) {
        if (prefix + property in el.style) {
          return prefix.toLowerCase();
        }
      }

      return 'unsupported';
    },

    /**
     * @private
     * @return  {string}
     */
    randomHex: function randomHex() {
      return ('00000' + (Math.random() * 16777216 << 0).toString(16)).substr(-6).toUpperCase();
    },

    /**
     * @private
     * @param   {HTMLDocument}  [doc]
     * @return  {object}
     */
    getDocumentState: function getDocumentState(doc) {
      doc = _typeof(doc.body) === 'object' ? doc : window.document;
      return {
        scrollTop: window.pageYOffset,
        scrollLeft: window.pageXOffset,
        docHeight: doc.documentElement.scrollHeight,
        docWidth: doc.documentElement.scrollWidth,
        viewportHeight: doc.documentElement.clientHeight,
        viewportWidth: doc.documentElement.clientWidth
      };
    },

    /**
     * @private
     * @param   {object}    obj
     * @param   {function}  fn
     * @return  {function}
     */
    bind: function bind(obj, fn) {
      return function () {
        return fn.apply(obj, arguments);
      };
    },

    /**
     * @private
     * @param   {HTMLElement}   el
     * @return  {boolean}
     */
    isVisible: function isVisible(el) {
      var styles = null;
      if (el.offsetParent) return true;
      styles = window.getComputedStyle(el);

      if (styles.position === 'fixed' && styles.visibility !== 'hidden' && styles.opacity !== '0') {
        // Fixed elements report no offsetParent,
        // but may still be invisible
        return true;
      }

      return false;
    },

    /**
     * @private
     * @param   {object}    obj
     */
    seal: function seal(obj) {
      if (typeof Object.seal === 'function') {
        Object.seal(obj);
      }
    },

    /**
     * @private
     * @param   {object}    obj
     */
    freeze: function freeze(obj) {
      if (typeof Object.freeze === 'function') {
        Object.freeze(obj);
      }
    },

    /**
     * @private
     * @param   {string}    control
     * @param   {string}    specimen
     * @return  {boolean}
     */
    compareVersions: function compareVersions(control, specimen) {
      var controlParts = control.split('.'),
          specimenParts = specimen.split('.'),
          controlPart = -1,
          specimenPart = -1,
          i = -1;

      for (i = 0; i < controlParts.length; i++) {
        controlPart = parseInt(controlParts[i].replace(/[^\d.]/g, ''));
        specimenPart = parseInt(specimenParts[i].replace(/[^\d.]/g, '') || 0);

        if (specimenPart < controlPart) {
          return false;
        } else if (specimenPart > controlPart) {
          return true;
        }
      }

      return true;
    },

    /**
     * @private
     * @constructor
     */
    Deferred: function Deferred() {
      this.promise = null;
      this.resolve = null;
      this.reject = null;
      this.id = h.randomHex();
    },

    /**
     * @private
     * @param   {object}  obj
     * @return  {boolean}
     */
    isEmptyObject: function isEmptyObject(obj) {
      var key = '';

      if (typeof Object.keys === 'function') {
        return Object.keys(obj).length === 0;
      }

      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          return false;
        }
      }

      return true;
    },

    /**
     * @param   {mixitup.Config.ClassNames}   classNames
     * @param   {string}                      elementName
     * @param   {string}                      [modifier]
     * @return  {string}
     */
    getClassname: function getClassname(classNames, elementName, modifier) {
      var classname = '';
      classname += classNames.block;

      if (classname.length) {
        classname += classNames.delineatorElement;
      }

      classname += classNames['element' + this.pascalCase(elementName)];
      if (!modifier) return classname;

      if (classname.length) {
        classname += classNames.delineatorModifier;
      }

      classname += modifier;
      return classname;
    },

    /**
     * Returns the value of a property on a given object via its string key.
     *
     * @param   {object}    obj
     * @param   {string}    stringKey
     * @return  {*} value
     */
    getProperty: function getProperty(obj, stringKey) {
      var parts = stringKey.split('.'),
          returnCurrent = null,
          current = '',
          i = 0;

      if (!stringKey) {
        return obj;
      }

      returnCurrent = function returnCurrent(obj) {
        if (!obj) {
          return null;
        } else {
          return obj[current];
        }
      };

      while (i < parts.length) {
        current = parts[i];
        obj = returnCurrent(obj);
        i++;
      }

      if (typeof obj !== 'undefined') {
        return obj;
      } else {
        return null;
      }
    }
  };
  _mixitup.h = h;
  /**
   * The Base class adds instance methods to all other extensible MixItUp classes,
   * enabling the calling of any registered hooks.
   *
   * @constructor
   * @namespace
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.Base = function () {};

  _mixitup.Base.prototype = {
    constructor: _mixitup.Base,

    /**
     * Calls any registered hooks for the provided action.
     *
     * @memberof    mixitup.Base
     * @private
     * @instance
     * @since       2.0.0
     * @param       {string}    actionName
     * @param       {Array<*>}  args
     * @return      {void}
     */
    callActions: function callActions(actionName, args) {
      var self = this,
          hooks = self.constructor.actions[actionName],
          extensionName = '';
      if (!hooks || h.isEmptyObject(hooks)) return;

      for (extensionName in hooks) {
        hooks[extensionName].apply(self, args);
      }
    },

    /**
     * Calls any registered hooks for the provided filter.
     *
     * @memberof    mixitup.Base
     * @private
     * @instance
     * @since       2.0.0
     * @param       {string}    filterName
     * @param       {*}         input
     * @param       {Array<*>}  args
     * @return      {*}
     */
    callFilters: function callFilters(filterName, input, args) {
      var self = this,
          hooks = self.constructor.filters[filterName],
          output = input,
          extensionName = '';
      if (!hooks || h.isEmptyObject(hooks)) return output;
      args = args || [];

      for (extensionName in hooks) {
        args = h.arrayFromList(args);
        args.unshift(output);
        output = hooks[extensionName].apply(self, args);
      }

      return output;
    }
  };
  /**
   * The BaseStatic class holds a set of static methods which are then added to all other
   * extensible MixItUp classes as a means of integrating extensions via the addition of new
   * methods and/or actions and hooks.
   *
   * @constructor
   * @namespace
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.BaseStatic = function () {
    this.actions = {};
    this.filters = {};
    /**
     * Performs a shallow extend on the class's prototype, adding one or more new members to
     * the class in a single operation.
     *
     * @memberof    mixitup.BaseStatic
     * @public
     * @static
     * @since       2.1.0
     * @param       {object} extension
     * @return      {void}
     */

    this.extend = function (extension) {
      h.extend(this.prototype, extension);
    };
    /**
     * Registers a function to be called on the action hook of the provided name.
     *
     * @memberof    mixitup.BaseStatic
     * @public
     * @static
     * @since       2.1.0
     * @param       {string}    hookName
     * @param       {string}    extensionName
     * @param       {function}  func
     * @return      {void}
     */


    this.registerAction = function (hookName, extensionName, func) {
      (this.actions[hookName] = this.actions[hookName] || {})[extensionName] = func;
    };
    /**
     * Registers a function to be called on the filter of the provided name.
     *
     * @memberof    mixitup.BaseStatic
     * @public
     * @static
     * @since       2.1.0
     * @param       {string}    hookName
     * @param       {string}    extensionName
     * @param       {function}  func
     * @return      {void}
     */


    this.registerFilter = function (hookName, extensionName, func) {
      (this.filters[hookName] = this.filters[hookName] || {})[extensionName] = func;
    };
  };
  /**
   * The `mixitup.Features` class performs all feature and CSS prefix detection
   * neccessary for MixItUp to function correctly, as well as storing various
   * string and array constants. All feature decection is on evaluation of the
   * library and stored in a singleton instance for use by other internal classes.
   *
   * @constructor
   * @namespace
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */


  _mixitup.Features = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.boxSizingPrefix = '';
    this.transformPrefix = '';
    this.transitionPrefix = '';
    this.boxSizingPrefix = '';
    this.transformProp = '';
    this.transformRule = '';
    this.transitionProp = '';
    this.perspectiveProp = '';
    this.perspectiveOriginProp = '';
    this.has = new _mixitup.Has();
    this.canary = null;
    this.BOX_SIZING_PROP = 'boxSizing';
    this.TRANSITION_PROP = 'transition';
    this.TRANSFORM_PROP = 'transform';
    this.PERSPECTIVE_PROP = 'perspective';
    this.PERSPECTIVE_ORIGIN_PROP = 'perspectiveOrigin';
    this.VENDORS = ['Webkit', 'moz', 'O', 'ms'];
    this.TWEENABLE = ['opacity', 'width', 'height', 'marginRight', 'marginBottom', 'x', 'y', 'scale', 'translateX', 'translateY', 'translateZ', 'rotateX', 'rotateY', 'rotateZ'];
    this.callActions('afterConstruct');
  };

  _mixitup.BaseStatic.call(_mixitup.Features);

  _mixitup.Features.prototype = Object.create(_mixitup.Base.prototype);
  h.extend(_mixitup.Features.prototype,
  /** @lends mixitup.Features */
  {
    constructor: _mixitup.Features,

    /**
     * @private
     * @return  {void}
     */
    init: function init() {
      var self = this;
      self.callActions('beforeInit', arguments);
      self.canary = document.createElement('div');
      self.setPrefixes();
      self.runTests();
      self.callActions('beforeInit', arguments);
    },

    /**
     * @private
     * @return  {void}
     */
    runTests: function runTests() {
      var self = this;
      self.callActions('beforeRunTests', arguments);
      self.has.promises = typeof window.Promise === 'function';
      self.has.transitions = self.transitionPrefix !== 'unsupported';
      self.callActions('afterRunTests', arguments);
      h.freeze(self.has);
    },

    /**
     * @private
     * @return  {void}
     */
    setPrefixes: function setPrefixes() {
      var self = this;
      self.callActions('beforeSetPrefixes', arguments);
      self.transitionPrefix = h.getPrefix(self.canary, 'Transition', self.VENDORS);
      self.transformPrefix = h.getPrefix(self.canary, 'Transform', self.VENDORS);
      self.boxSizingPrefix = h.getPrefix(self.canary, 'BoxSizing', self.VENDORS);
      self.boxSizingProp = self.boxSizingPrefix ? self.boxSizingPrefix + h.pascalCase(self.BOX_SIZING_PROP) : self.BOX_SIZING_PROP;
      self.transitionProp = self.transitionPrefix ? self.transitionPrefix + h.pascalCase(self.TRANSITION_PROP) : self.TRANSITION_PROP;
      self.transformProp = self.transformPrefix ? self.transformPrefix + h.pascalCase(self.TRANSFORM_PROP) : self.TRANSFORM_PROP;
      self.transformRule = self.transformPrefix ? '-' + self.transformPrefix + '-' + self.TRANSFORM_PROP : self.TRANSFORM_PROP;
      self.perspectiveProp = self.transformPrefix ? self.transformPrefix + h.pascalCase(self.PERSPECTIVE_PROP) : self.PERSPECTIVE_PROP;
      self.perspectiveOriginProp = self.transformPrefix ? self.transformPrefix + h.pascalCase(self.PERSPECTIVE_ORIGIN_PROP) : self.PERSPECTIVE_ORIGIN_PROP;
      self.callActions('afterSetPrefixes', arguments);
    }
  });
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.Has = function () {
    this.transitions = false;
    this.promises = false;
    h.seal(this);
  }; // Assign a singleton instance to `mixitup.features` and initialise:


  _mixitup.features = new _mixitup.Features();

  _mixitup.features.init();
  /**
   * A group of properties defining the mixer's animation and effects settings.
   *
   * @constructor
   * @memberof    mixitup.Config
   * @name        animation
   * @namespace
   * @public
   * @since       2.0.0
   */


  _mixitup.ConfigAnimation = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    /**
     * A boolean dictating whether or not animation should be enabled for the MixItUp instance.
     * If `false`, all operations will occur instantly and syncronously, although callback
     * functions and any returned promises will still be fulfilled.
     *
     * @example <caption>Example: Create a mixer with all animations disabled</caption>
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         enable: false
     *     }
     * });
     *
     * @name        enable
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {boolean}
     * @default     true
     */

    this.enable = true;
    /**
     * A string of one or more space-seperated properties to which transitions will be
     * applied for all filtering animations.
     *
     * Properties can be listed any order or combination, although they will be applied in a specific
     * predefined order to produce consistent results.
     *
     * To learn more about available effects, experiment with our <a href="https://www.kunkalabs.com/mixitup/">
     * sandbox demo</a> and try out the "Export config" button in the Animation options drop down.
     *
     * @example <caption>Example: Apply "fade" and "translateZ" effects to all animations</caption>
     * // As targets are filtered in and out, they will fade between
     * // opacity 1 and 0 and transform between translateZ(-100px) and
     * // translateZ(0).
     *
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         effects: 'fade translateZ(-100px)'
     *     }
     * });
     *
     * @name        effects
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {string}
     * @default     'fade scale'
     */

    this.effects = 'fade scale';
    /**
     * A string of one or more space-seperated effects to be applied only to filter-in
     * animations, overriding `config.animation.effects` if set.
     *
     * @example <caption>Example: Apply downwards vertical translate to targets being filtered in</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         effectsIn: 'fade translateY(-100%)'
     *     }
     * });
     *
     * @name        effectsIn
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {string}
     * @default     ''
     */

    this.effectsIn = '';
    /**
     * A string of one or more space-seperated effects to be applied only to filter-out
     * animations, overriding `config.animation.effects` if set.
     *
     * @example <caption>Example: Apply upwards vertical translate to targets being filtered out</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         effectsOut: 'fade translateY(-100%)'
     *     }
     * });
     *
     * @name        effectsOut
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {string}
     * @default     ''
     */

    this.effectsOut = '';
    /**
     * An integer dictating the duration of all MixItUp animations in milliseconds, not
     * including any additional delay apllied via the `'stagger'` effect.
     *
     * @example <caption>Example: Apply an animation duration of 200ms to all mixitup animations</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         duration: 200
     *     }
     * });
     *
     * @name        duration
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {number}
     * @default     600
     */

    this.duration = 600;
    /**
     * A valid CSS3 transition-timing function or shorthand. For a full list of accepted
     * values, visit <a href="http://easings.net" target="_blank">easings.net</a>.
     *
     * @example <caption>Example 1: Apply "ease-in-out" easing to all animations</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         easing: 'ease-in-out'
     *     }
     * });
     *
     * @example <caption>Example 2: Apply a custom "cubic-bezier" easing function to all animations</caption>
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         easing: 'cubic-bezier(0.645, 0.045, 0.355, 1)'
     *     }
     * });
     *
     * @name        easing
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {string}
     * @default     'ease'
     */

    this.easing = 'ease';
    /**
     * A boolean dictating whether or not to apply perspective to the MixItUp container
     * during animations. By default, perspective is always applied and creates the
     * illusion of three-dimensional space for effects such as `translateZ`, `rotateX`,
     * and `rotateY`.
     *
     * You may wish to disable this and define your own perspective settings via CSS.
     *
     * @example <caption>Example: Prevent perspective from being applied to any 3D transforms</caption>
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         applyPerspective: false
     *     }
     * });
     *
     * @name        applyPerspective
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {bolean}
     * @default     true
     */

    this.applyPerspective = true;
    /**
     * The perspective distance value to be applied to the container during animations,
     * affecting any 3D-transform-based effects.
     *
     * @example <caption>Example: Set a perspective distance of 2000px</caption>
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         effects: 'rotateY(-25deg)',
     *         perspectiveDistance: '2000px'
     *     }
     * });
     *
     * @name        perspectiveDistance
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {string}
     * @default     '3000px'
     */

    this.perspectiveDistance = '3000px';
    /**
     * The perspective-origin value to be applied to the container during animations,
     * affecting any 3D-transform-based effects.
     *
     * @example <caption>Example: Set a perspective origin in the top-right of the container</caption>
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         effects: 'transateZ(-200px)',
     *         perspectiveOrigin: '100% 0'
     *     }
     * });
     *
     * @name        perspectiveOrigin
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {string}
     * @default     '50% 50%'
     */

    this.perspectiveOrigin = '50% 50%';
    /**
     * A boolean dictating whether or not to enable the queuing of operations.
     *
     * If `true` (default), and a control is clicked or an API call is made while another
     * operation is progress, the operation will go into the queue and will be automatically exectuted
     * when the previous operaitons is finished.
     *
     * If `false`, any requested operations will be ignored, and the `onMixBusy` callback and `mixBusy`
     * event will be fired. If `debug.showWarnings` is enabled, a console warning will also occur.
     *
     * @example <caption>Example: Disable queuing</caption>
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         queue: false
     *     }
     * });
     *
     * @name        queue
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {boolean}
     * @default     true
     */

    this.queue = true;
    /**
     * An integer dictacting the maximum number of operations allowed in the queue at
     * any time, when queuing is enabled.
     *
     * @example <caption>Example: Allow a maximum of 5 operations in the queue at any time</caption>
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         queueLimit: 5
     *     }
     * });
     *
     * @name        queueLimit
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {number}
     * @default     3
     */

    this.queueLimit = 3;
    /**
     * A boolean dictating whether or not to transition the height and width of the
     * container as elements are filtered in and out. If disabled, the container height
     * will change abruptly.
     *
     * It may be desirable to disable this on mobile devices as the CSS `height` and
     * `width` properties do not receive GPU-acceleration and can therefore cause stuttering.
     *
     * @example <caption>Example 1: Disable the transitioning of the container height and/or width</caption>
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         animateResizeContainer: false
     *     }
     * });
     *
     * @example <caption>Example 2: Disable the transitioning of the container height and/or width for mobile devices only</caption>
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         animateResizeContainer: myFeatureTests.isMobile ? false : true
     *     }
     * });
     *
     * @name        animateResizeContainer
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {boolean}
     * @default     true
     */

    this.animateResizeContainer = true;
    /**
     * A boolean dictating whether or not to transition the height and width of target
     * elements as they change throughout the course of an animation.
     *
     * This is often a must for flex-box grid layouts where the size of target elements may change
     * depending on final their position in relation to their siblings, or for `.changeLayout()`
     * operations where the size of targets change between layouts.
     *
     * NB: This feature requires additional calculations and manipulation to non-hardware-accelerated
     * properties which may adversely affect performance on slower devices, and is therefore
     * disabled by default.
     *
     * @example <caption>Example: Enable the transitioning of target widths and heights</caption>
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         animateResizeTargets: true
     *     }
     * });
     *
     * @name        animateResizeTargets
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {boolean}
     * @default     false
     */

    this.animateResizeTargets = false;
    /**
     * A custom function used to manipulate the order in which the stagger delay is
     * incremented when using the ‘stagger’ effect.
     *
     * When using the 'stagger' effect, the delay applied to each target element is incremented
     * based on its index. You may create a custom function to manipulate the order in which the
     * delay is incremented and create engaging non-linear stagger effects.
     *
     * The function receives the index of the target element as a parameter, and must
     * return an integer which serves as the multiplier for the stagger delay.
     *
     * @example <caption>Example 1: Stagger target elements by column in a 3-column grid</caption>
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         effects: 'fade stagger(100ms)',
     *         staggerSequence: function(i) {
     *             return i % 3;
     *         }
     *     }
     * });
     *
     * @example <caption>Example 2: Using an algorithm to produce a more complex sequence</caption>
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         effects: 'fade stagger(100ms)',
     *         staggerSequence: function(i) {
     *             return (2*i) - (5*((i/3) - ((1/3) * (i%3))));
     *         }
     *     }
     * });
     *
     * @name        staggerSequence
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {function}
     * @default     null
     */

    this.staggerSequence = null;
    /**
     * A boolean dictating whether or not to reverse the direction of `translate`
     * and `rotate` transforms for elements being filtered out.
     *
     * It can be used to create carousel-like animations where elements enter and exit
     * from opposite directions. If enabled, the effect `translateX(-100%)` for elements
     * being filtered in would become `translateX(100%)` for targets being filtered out.
     *
     * This functionality can also be achieved by providing seperate effects
     * strings for `config.animation.effectsIn` and `config.animation.effectsOut`.
     *
     * @example <caption>Example: Reverse the desired direction on any translate/rotate effect for targets being filtered out</caption>
     * // Elements being filtered in will be translated from '100%' to '0' while
     * // elements being filtered out will be translated from 0 to '-100%'
     *
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         effects: 'fade translateX(100%)',
     *         reverseOut: true,
     *         nudge: false // Disable nudging to create a carousel-like effect
     *     }
     * });
     *
     * @name        reverseOut
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {boolean}
     * @default     false
     */

    this.reverseOut = false;
    /**
     * A boolean dictating whether or not to "nudge" the animation path of targets
     * when they are being filtered in and out simulatenously.
     *
     * This has been the default behavior of MixItUp since version 1, but it
     * may be desirable to disable this effect when filtering directly from
     * one exclusive set of targets to a different exclusive set of targets,
     * to create a carousel-like effect, or a generally more subtle animation.
     *
     * @example <caption>Example: Disable the "nudging" of targets being filtered in and out simulatenously</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         nudge: false
     *     }
     * });
     *
     * @name        nudge
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {boolean}
     * @default     true
     */

    this.nudge = true;
    /**
     * A boolean dictating whether or not to clamp the height of the container while MixItUp's
     * geometry tests are carried out before an operation.
     *
     * To prevent scroll-bar flicker, clamping is turned on by default. But in the case where the
     * height of the container might affect its vertical positioning in the viewport
     * (e.g. a vertically-centered container), this should be turned off to ensure accurate
     * test results and a smooth animation.
     *
     * @example <caption>Example: Disable container height-clamping</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         clampHeight: false
     *     }
     * });
     *
     * @name        clampHeight
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {boolean}
     * @default     true
     */

    this.clampHeight = true;
    /**
     * A boolean dictating whether or not to clamp the width of the container while MixItUp's
     * geometry tests are carried out before an operation.
     *
     * To prevent scroll-bar flicker, clamping is turned on by default. But in the case where the
     * width of the container might affect its horitzontal positioning in the viewport
     * (e.g. a horizontall-centered container), this should be turned off to ensure accurate
     * test results and a smooth animation.
     *
     * @example <caption>Example: Disable container width-clamping</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     animation: {
     *         clampWidth: false
     *     }
     * });
     *
     * @name        clampWidth
     * @memberof    mixitup.Config.animation
     * @instance
     * @type        {boolean}
     * @default     true
     */

    this.clampWidth = true;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.ConfigAnimation);

  _mixitup.ConfigAnimation.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.ConfigAnimation.prototype.constructor = _mixitup.ConfigAnimation;
  /**
   * A group of properties relating to the behavior of the Mixer.
   *
   * @constructor
   * @memberof    mixitup.Config
   * @name        behavior
   * @namespace
   * @public
   * @since       3.1.12
   */

  _mixitup.ConfigBehavior = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    /**
     * A boolean dictating whether to allow "live" sorting of the mixer.
     *
     * Because of the expensive nature of sorting, MixItUp makes use of several
     * internal optimizations to skip redundant sorting operations, such as when
     * the newly requested sort command is the same as the active one. The caveat
     * to this optimization is that "live" edits to the value of a target's sorting
     * attribute will be ignored when requesting a re-sort by the same attribute.
     *
     * By setting to `behavior.liveSort` to `true`, the mixer will always re-sort
     * regardless of whether or not the sorting attribute and order have changed.
     *
     * @example <caption>Example: Enabling `liveSort` to allow for re-sorting</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     behavior: {
     *         liveSort: true
     *     },
     *     load: {
     *         sort: 'edited:desc'
     *     }
     * });
     *
     * var target = containerEl.children[3];
     *
     * console.log(target.getAttribute('data-edited')); // '2015-04-24'
     *
     * target.setAttribute('data-edited', '2017-08-10'); // Update the target's edited date
     *
     * mixer.sort('edited:desc')
     *     .then(function(state) {
     *         // The target is now at the top of the list
     *
     *         console.log(state.targets[0] === target); // true
     *     });
     *
     * @name        liveSort
     * @memberof    mixitup.Config.behavior
     * @instance
     * @type        {boolean}
     * @default     false
     */

    this.liveSort = false;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.ConfigBehavior);

  _mixitup.ConfigBehavior.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.ConfigBehavior.prototype.constructor = _mixitup.ConfigBehavior;
  /**
   * A group of optional callback functions to be invoked at various
   * points within the lifecycle of a mixer operation.
   *
   * Each function is analogous to an event of the same name triggered from the
   * container element, and is invoked immediately after it.
   *
   * All callback functions receive the current `state` object as their first
   * argument, as well as other more specific arguments described below.
   *
   * @constructor
   * @memberof    mixitup.Config
   * @name        callbacks
   * @namespace
   * @public
   * @since       2.0.0
   */

  _mixitup.ConfigCallbacks = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    /**
     * A callback function invoked immediately after any MixItUp operation is requested
     * and before animations have begun.
     *
     * A second `futureState` argument is passed to the function which represents the final
     * state of the mixer once the requested operation has completed.
     *
     * @example <caption>Example: Adding an `onMixStart` callback function</caption>
     * var mixer = mixitup(containerEl, {
     *     callbacks: {
     *         onMixStart: function(state, futureState) {
     *              console.log('Starting operation...');
     *         }
     *     }
     * });
     *
     * @name        onMixStart
     * @memberof    mixitup.Config.callbacks
     * @instance
     * @type        {function}
     * @default     null
     */

    this.onMixStart = null;
    /**
     * A callback function invoked when a MixItUp operation is requested while another
     * operation is in progress, and the animation queue is full, or queueing
     * is disabled.
     *
     * @example <caption>Example: Adding an `onMixBusy` callback function</caption>
     * var mixer = mixitup(containerEl, {
     *     callbacks: {
     *         onMixBusy: function(state) {
     *              console.log('Mixer busy');
     *         }
     *     }
     * });
     *
     * @name        onMixBusy
     * @memberof    mixitup.Config.callbacks
     * @instance
     * @type        {function}
     * @default     null
     */

    this.onMixBusy = null;
    /**
     * A callback function invoked after any MixItUp operation has completed, and the
     * state has been updated.
     *
     * @example <caption>Example: Adding an `onMixEnd` callback function</caption>
     * var mixer = mixitup(containerEl, {
     *     callbacks: {
     *         onMixEnd: function(state) {
     *              console.log('Operation complete');
     *         }
     *     }
     * });
     *
     * @name        onMixEnd
     * @memberof    mixitup.Config.callbacks
     * @instance
     * @type        {function}
     * @default     null
     */

    this.onMixEnd = null;
    /**
     * A callback function invoked whenever an operation "fails", i.e. no targets
     * could be found matching the requested filter.
     *
     * @example <caption>Example: Adding an `onMixFail` callback function</caption>
     * var mixer = mixitup(containerEl, {
     *     callbacks: {
     *         onMixFail: function(state) {
     *              console.log('No items could be found matching the requested filter');
     *         }
     *     }
     * });
     *
     * @name        onMixFail
     * @memberof    mixitup.Config.callbacks
     * @instance
     * @type        {function}
     * @default     null
     */

    this.onMixFail = null;
    /**
     * A callback function invoked whenever a MixItUp control is clicked, and before its
     * respective operation is requested.
     *
     * The clicked element is assigned to the `this` keyword within the function. The original
     * click event is passed to the function as the second argument, which can be useful if
     * using `<a>` tags as controls where the default behavior needs to be prevented.
     *
     * Returning `false` from the callback will prevent the control click from triggering
     * an operation.
     *
     * @example <caption>Example 1: Adding an `onMixClick` callback function</caption>
     * var mixer = mixitup(containerEl, {
     *     callbacks: {
     *         onMixClick: function(state, originalEvent) {
     *              console.log('The control "' + this.innerText + '" was clicked');
     *         }
     *     }
     * });
     *
     * @example <caption>Example 2: Using `onMixClick` to manipulate the original click event</caption>
     * var mixer = mixitup(containerEl, {
     *     callbacks: {
     *         onMixClick: function(state, originalEvent) {
     *              // Prevent original click event from bubbling up:
     *              originalEvent.stopPropagation();
     *
     *              // Prevent default behavior of clicked element:
     *              originalEvent.preventDefault();
     *         }
     *     }
     * });
     *
     * @example <caption>Example 3: Using `onMixClick` to conditionally cancel operations</caption>
     * var mixer = mixitup(containerEl, {
     *     callbacks: {
     *         onMixClick: function(state, originalEvent) {
     *              // Perform some conditional check:
     *
     *              if (myApp.isLoading) {
     *                  // By returning false, we can prevent the control click from triggering an operation.
     *
     *                  return false;
     *              }
     *         }
     *     }
     * });
     *
     * @name        onMixClick
     * @memberof    mixitup.Config.callbacks
     * @instance
     * @type        {function}
     * @default     null
     */

    this.onMixClick = null;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.ConfigCallbacks);

  _mixitup.ConfigCallbacks.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.ConfigCallbacks.prototype.constructor = _mixitup.ConfigCallbacks;
  /**
   * A group of properties relating to clickable control elements.
   *
   * @constructor
   * @memberof    mixitup.Config
   * @name        controls
   * @namespace
   * @public
   * @since       2.0.0
   */

  _mixitup.ConfigControls = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    /**
     * A boolean dictating whether or not controls should be enabled for the mixer instance.
     *
     * If `true` (default behavior), MixItUp will search the DOM for any clickable elements with
     * `data-filter`, `data-sort` or `data-toggle` attributes, and bind them for click events.
     *
     * If `false`, no click handlers will be bound, and all functionality must therefore be performed
     * via the mixer's API methods.
     *
     * If you do not intend to use the default controls, setting this property to `false` will
     * marginally improve the startup time of your mixer instance, and will also prevent any other active
     * mixer instances in the DOM which are bound to controls from controlling the instance.
     *
     * @example <caption>Example: Disabling controls</caption>
     * var mixer = mixitup(containerEl, {
     *     controls: {
     *         enable: false
     *     }
     * });
     *
     * // With the default controls disabled, we can only control
     * // the mixer via its API methods, e.g.:
     *
     * mixer.filter('.cat-1');
     *
     * @name        enable
     * @memberof    mixitup.Config.controls
     * @instance
     * @type        {boolean}
     * @default     true
     */

    this.enable = true;
    /**
     * A boolean dictating whether or not to use event delegation when binding click events
     * to the default controls.
     *
     * If `false` (default behavior), each control button in the DOM will be found and
     * individually bound when a mixer is instantiated, with their corresponding actions
     * cached for performance.
     *
     * If `true`, a single click handler will be applied to the `window` (or container element - see
     * `config.controls.scope`), and any click events triggered by elements with `data-filter`,
     * `data-sort` or `data-toggle` attributes present will be handled as they propagate upwards.
     *
     * If you require a user interface where control buttons may be added, removed, or changed during the
     * lifetime of a mixer, `controls.live` should be set to `true`. There is a marginal but unavoidable
     * performance deficit when using live controls, as the value of each control button must be read
     * from the DOM in real time once the click event has propagated.
     *
     * @example <caption>Example: Setting live controls</caption>
     * var mixer = mixitup(containerEl, {
     *     controls: {
     *         live: true
     *     }
     * });
     *
     * // Control buttons can now be added, remove and changed without breaking
     * // the mixer's UI
     *
     * @name        live
     * @memberof    mixitup.Config.controls
     * @instance
     * @type        {boolean}
     * @default     true
     */

    this.live = false;
    /**
     * A string dictating the "scope" to use when binding or querying the default controls. The available
     * values are `'global'` or `'local'`.
     *
     * When set to `'global'` (default behavior), MixItUp will query the entire document for control buttons
     * to bind, or delegate click events from (see `config.controls.live`).
     *
     * When set to `'local'`, MixItUp will only query (or bind click events to) its own container element.
     * This may be desireable if you require multiple active mixer instances within the same document, with
     * controls that would otherwise intefere with each other if scoped globally.
     *
     * Conversely, if you wish to control multiple instances with a single UI, you would create one
     * set of controls and keep the controls scope of each mixer set to `global`.
     *
     * @example <caption>Example: Setting 'local' scoped controls</caption>
     * var mixerOne = mixitup(containerOne, {
     *     controls: {
     *         scope: 'local'
     *     }
     * });
     *
     * var mixerTwo = mixitup(containerTwo, {
     *     controls: {
     *         scope: 'local'
     *     }
     * });
     *
     * // Both mixers can now exist within the same document with
     * // isolated controls placed within their container elements.
     *
     * @name        scope
     * @memberof    mixitup.Config.controls
     * @instance
     * @type        {string}
     * @default     'global'
     */

    this.scope = 'global'; // enum: ['local' ,'global']

    /**
     * A string dictating the type of logic to apply when concatenating the filter selectors of
     * active toggle buttons (i.e. any clickable element with a `data-toggle` attribute).
     *
     * If set to `'or'` (default behavior), selectors will be concatenated together as
     * a comma-seperated list. For example:
     *
     * `'.cat-1, .cat-2'` (shows any elements matching `'.cat-1'` OR `'.cat-2'`)
     *
     * If set to `'and'`, selectors will be directly concatenated together. For example:
     *
     * `'.cat-1.cat-2'` (shows any elements which match both `'.cat-1'` AND `'.cat-2'`)
     *
     * @example <caption>Example: Setting "and" toggle logic</caption>
     * var mixer = mixitup(containerEl, {
     *     controls: {
     *         toggleLogic: 'and'
     *     }
     * });
     *
     * @name        toggleLogic
     * @memberof    mixitup.Config.controls
     * @instance
     * @type        {string}
     * @default     'or'
     */

    this.toggleLogic = 'or'; // enum: ['or', 'and']

    /**
     * A string dictating the filter behavior when all toggles are inactive.
     *
     * When set to `'all'` (default behavior), *all* targets will be shown by default
     * when no toggles are active, or at the moment all active toggles are toggled off.
     *
     * When set to `'none'`, no targets will be shown by default when no toggles are
     * active, or at the moment all active toggles are toggled off.
     *
     * @example <caption>Example 1: Setting the default toggle behavior to `'all'`</caption>
     * var mixer = mixitup(containerEl, {
     *     controls: {
     *         toggleDefault: 'all'
     *     }
     * });
     *
     * mixer.toggleOn('.cat-2')
     *     .then(function() {
     *         // Deactivate all active toggles
     *
     *         return mixer.toggleOff('.cat-2')
     *     })
     *     .then(function(state) {
     *          console.log(state.activeFilter.selector); // 'all'
     *          console.log(state.totalShow); // 12
     *     });
     *
     * @example <caption>Example 2: Setting the default toggle behavior to `'none'`</caption>
     * var mixer = mixitup(containerEl, {
     *     controls: {
     *         toggleDefault: 'none'
     *     }
     * });
     *
     * mixer.toggleOn('.cat-2')
     *     .then(function() {
     *         // Deactivate all active toggles
     *
     *         return mixer.toggleOff('.cat-2')
     *     })
     *     .then(function(state) {
     *          console.log(state.activeFilter.selector); // 'none'
     *          console.log(state.totalShow); // 0
     *     });
     *
     * @name        toggleDefault
     * @memberof    mixitup.Config.controls
     * @instance
     * @type        {string}
     * @default     'all'
     */

    this.toggleDefault = 'all'; // enum: ['all', 'none']

    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.ConfigControls);

  _mixitup.ConfigControls.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.ConfigControls.prototype.constructor = _mixitup.ConfigControls;
  /**
   * A group of properties defining the output and structure of class names programmatically
   * added to controls and containers to reflect the state of the mixer.
   *
   * Most commonly, class names are added to controls by MixItUp to indicate that
   * the control is active so that it can be styled accordingly - `'mixitup-control-active'` by default.
   *
   * Using a "BEM" like structure, each classname is broken into the three parts:
   * a block namespace (`'mixitup'`), an element name (e.g. `'control'`), and an optional modifier
   * name (e.g. `'active'`) reflecting the state of the element.
   *
   * By default, each part of the classname is concatenated together using single hyphens as
   * delineators, but this can be easily customised to match the naming convention and style of
   * your project.
   *
   * @constructor
   * @memberof    mixitup.Config
   * @name        classNames
   * @namespace
   * @public
   * @since       3.0.0
   */

  _mixitup.ConfigClassNames = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    /**
     * The "block" portion, or top-level namespace added to the start of any class names created by MixItUp.
     *
     * @example <caption>Example 1: changing the `config.classNames.block` value</caption>
     * var mixer = mixitup(containerEl, {
     *     classNames: {
     *         block: 'portfolio'
     *     }
     * });
     *
     * // Active control output: "portfolio-control-active"
     *
     * @example <caption>Example 2: Removing `config.classNames.block`</caption>
     * var mixer = mixitup(containerEl, {
     *     classNames: {
     *         block: ''
     *     }
     * });
     *
     * // Active control output: "control-active"
     *
     * @name        block
     * @memberof    mixitup.Config.classNames
     * @instance
     * @type        {string}
     * @default     'mixitup'
     */

    this.block = 'mixitup';
    /**
     * The "element" portion of the class name added to container.
     *
     * @name        elementContainer
     * @memberof    mixitup.Config.classNames
     * @instance
     * @type        {string}
     * @default     'container'
     */

    this.elementContainer = 'container';
    /**
     * The "element" portion of the class name added to filter controls.
     *
     * By default, all filter, sort, multimix and toggle controls take the same element value of `'control'`, but
     * each type's element value can be individually overwritten to match the unique classNames of your controls as needed.
     *
     * @example <caption>Example 1: changing the `config.classNames.elementFilter` value</caption>
     * var mixer = mixitup(containerEl, {
     *     classNames: {
     *         elementFilter: 'filter'
     *     }
     * });
     *
     * // Active filter output: "mixitup-filter-active"
     *
     * @example <caption>Example 2: changing the `config.classNames.block` and `config.classNames.elementFilter` values</caption>
     * var mixer = mixitup(containerEl, {
     *     classNames: {
     *         block: 'portfolio',
     *         elementFilter: 'filter'
     *     }
     * });
     *
     * // Active filter output: "portfolio-filter-active"
     *
     * @name        elementFilter
     * @memberof    mixitup.Config.classNames
     * @instance
     * @type        {string}
     * @default     'control'
     */

    this.elementFilter = 'control';
    /**
     * The "element" portion of the class name added to sort controls.
     *
     * By default, all filter, sort, multimix and toggle controls take the same element value of `'control'`, but
     * each type's element value can be individually overwritten to match the unique classNames of your controls as needed.
     *
     * @example <caption>Example 1: changing the `config.classNames.elementSort` value</caption>
     * var mixer = mixitup(containerEl, {
     *     classNames: {
     *         elementSort: 'sort'
     *     }
     * });
     *
     * // Active sort output: "mixitup-sort-active"
     *
     * @example <caption>Example 2: changing the `config.classNames.block` and `config.classNames.elementSort` values</caption>
     * var mixer = mixitup(containerEl, {
     *     classNames: {
     *         block: 'portfolio',
     *         elementSort: 'sort'
     *     }
     * });
     *
     * // Active sort output: "portfolio-sort-active"
     *
     * @name        elementSort
     * @memberof    mixitup.Config.classNames
     * @instance
     * @type        {string}
     * @default     'control'
     */

    this.elementSort = 'control';
    /**
     * The "element" portion of the class name added to multimix controls.
     *
     * By default, all filter, sort, multimix and toggle controls take the same element value of `'control'`, but
     * each type's element value can be individually overwritten to match the unique classNames of your controls as needed.
     *
     * @example <caption>Example 1: changing the `config.classNames.elementMultimix` value</caption>
     * var mixer = mixitup(containerEl, {
     *     classNames: {
     *         elementMultimix: 'multimix'
     *     }
     * });
     *
     * // Active multimix output: "mixitup-multimix-active"
     *
     * @example <caption>Example 2: changing the `config.classNames.block` and `config.classNames.elementMultimix` values</caption>
     * var mixer = mixitup(containerEl, {
     *     classNames: {
     *         block: 'portfolio',
     *         elementSort: 'multimix'
     *     }
     * });
     *
     * // Active multimix output: "portfolio-multimix-active"
     *
     * @name        elementMultimix
     * @memberof    mixitup.Config.classNames
     * @instance
     * @type        {string}
     * @default     'control'
     */

    this.elementMultimix = 'control';
    /**
     * The "element" portion of the class name added to toggle controls.
     *
     * By default, all filter, sort, multimix and toggle controls take the same element value of `'control'`, but
     * each type's element value can be individually overwritten to match the unique classNames of your controls as needed.
     *
     * @example <caption>Example 1: changing the `config.classNames.elementToggle` value</caption>
     * var mixer = mixitup(containerEl, {
     *     classNames: {
     *         elementToggle: 'toggle'
     *     }
     * });
     *
     * // Active toggle output: "mixitup-toggle-active"
     *
     * @example <caption>Example 2: changing the `config.classNames.block` and `config.classNames.elementToggle` values</caption>
     * var mixer = mixitup(containerEl, {
     *     classNames: {
     *         block: 'portfolio',
     *         elementToggle: 'toggle'
     *     }
     * });
     *
     * // Active toggle output: "portfolio-toggle-active"
     *
     * @name        elementToggle
     * @memberof    mixitup.Config.classNames
     * @instance
     * @type        {string}
     * @default     'control'
     */

    this.elementToggle = 'control';
    /**
     * The "modifier" portion of the class name added to active controls.
     * @name        modifierActive
     * @memberof    mixitup.Config.classNames
     * @instance
     * @type        {string}
     * @default     'active'
     */

    this.modifierActive = 'active';
    /**
     * The "modifier" portion of the class name added to disabled controls.
     *
     * @name        modifierDisabled
     * @memberof    mixitup.Config.classNames
     * @instance
     * @type        {string}
     * @default     'disabled'
     */

    this.modifierDisabled = 'disabled';
    /**
     * The "modifier" portion of the class name added to the container when in a "failed" state.
     *
     * @name        modifierFailed
     * @memberof    mixitup.Config.classNames
     * @instance
     * @type        {string}
     * @default     'failed'
     */

    this.modifierFailed = 'failed';
    /**
     * The delineator used between the "block" and "element" portions of any class name added by MixItUp.
     *
     * If the block portion is ommited by setting it to an empty string, no delineator will be added.
     *
     * @example <caption>Example: changing the delineator to match BEM convention</caption>
     * var mixer = mixitup(containerEl, {
     *     classNames: {
     *         delineatorElement: '__'
     *     }
     * });
     *
     * // example active control output: "mixitup__control-active"
     *
     * @name        delineatorElement
     * @memberof    mixitup.Config.classNames
     * @instance
     * @type        {string}
     * @default     '-'
     */

    this.delineatorElement = '-';
    /**
     * The delineator used between the "element" and "modifier" portions of any class name added by MixItUp.
     *
     * If the element portion is ommited by setting it to an empty string, no delineator will be added.
     *
     * @example <caption>Example: changing both delineators to match BEM convention</caption>
     * var mixer = mixitup(containerEl, {
     *     classNames: {
     *         delineatorElement: '__'
     *         delineatorModifier: '--'
     *     }
     * });
     *
     * // Active control output: "mixitup__control--active"
     *
     * @name        delineatorModifier
     * @memberof    mixitup.Config.classNames
     * @instance
     * @type        {string}
     * @default     '-'
     */

    this.delineatorModifier = '-';
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.ConfigClassNames);

  _mixitup.ConfigClassNames.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.ConfigClassNames.prototype.constructor = _mixitup.ConfigClassNames;
  /**
   * A group of properties relating to MixItUp's dataset API.
   *
   * @constructor
   * @memberof    mixitup.Config
   * @name        data
   * @namespace
   * @public
   * @since       3.0.0
   */

  _mixitup.ConfigData = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    /**
     * A string specifying the name of the key containing your data model's unique
     * identifier (UID). To use the dataset API, a UID key must be specified and
     * be present and unique on all objects in the dataset you provide to MixItUp.
     *
     * For example, if your dataset is made up of MongoDB documents, the UID
     * key would be `'id'` or `'_id'`.
     *
     * @example <caption>Example: Setting the UID to `'id'`</caption>
     * var mixer = mixitup(containerEl, {
     *     data: {
     *         uidKey: 'id'
     *     }
     * });
     *
     * @name        uidKey
     * @memberof    mixitup.Config.data
     * @instance
     * @type        {string}
     * @default     ''
     */

    this.uidKey = '';
    /**
     * A boolean dictating whether or not MixItUp should "dirty check" each object in
     * your dataset for changes whenever `.dataset()` is called, and re-render any targets
     * for which a change is found.
     *
     * Depending on the complexity of your data model, dirty checking can be expensive
     * and is therefore disabled by default.
     *
     * NB: For changes to be detected, a new immutable instance of the edited model must be
     * provided to mixitup, rather than manipulating properties on the existing instance.
     * If your changes are a result of a DB write and read, you will most likely be calling
     * `.dataset()` with a clean set of objects each time, so this will not be an issue.
     *
     * @example <caption>Example: Enabling dirty checking</caption>
     *
     * var myDataset = [
     *     {
     *         id: 0,
     *         title: "Blog Post Title 0"
     *         ...
     *     },
     *     {
     *         id: 1,
     *         title: "Blog Post Title 1"
     *         ...
     *     }
     * ];
     *
     * // Instantiate a mixer with a pre-loaded dataset, and a target renderer
     * // function defined
     *
     * var mixer = mixitup(containerEl, {
     *     data: {
     *         uidKey: 'id',
     *         dirtyCheck: true
     *     },
     *     load: {
     *         dataset: myDataset
     *     },
     *     render: {
     *         target: function() { ... }
     *     }
     * });
     *
     * // For illustration, we will clone and edit the second object in the dataset.
     * // NB: this would typically be done server-side in response to a DB update,
     * and then re-queried via an API.
     *
     * myDataset[1] = Object.assign({}, myDataset[1]);
     *
     * myDataset[1].title = 'Blog Post Title 11';
     *
     * mixer.dataset(myDataset)
     *    .then(function() {
     *        // the target with ID "1", will be re-rendered reflecting its new title
     *    });
     *
     * @name        dirtyCheck
     * @memberof    mixitup.Config.data
     * @instance
     * @type        {boolean}
     * @default     false
     */

    this.dirtyCheck = false;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.ConfigData);

  _mixitup.ConfigData.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.ConfigData.prototype.constructor = _mixitup.ConfigData;
  /**
   * A group of properties allowing the toggling of various debug features.
   *
   * @constructor
   * @memberof    mixitup.Config
   * @name        debug
   * @namespace
   * @public
   * @since       3.0.0
   */

  _mixitup.ConfigDebug = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    /**
     * A boolean dictating whether or not the mixer instance returned by the
     * `mixitup()` factory function should expose private properties and methods.
     *
     * By default, mixer instances only expose their public API, but enabling
     * debug mode will give you access to various mixer internals which may aid
     * in debugging, or the authoring of extensions.
     *
     * @example <caption>Example: Enabling debug mode</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     debug: {
     *         enable: true
     *     }
     * });
     *
     * // Private properties and methods will now be visible on the mixer instance:
     *
     * console.log(mixer);
     *
     * @name        enable
     * @memberof    mixitup.Config.debug
     * @instance
     * @type        {boolean}
     * @default     false
     */

    this.enable = false;
    /**
     * A boolean dictating whether or not warnings should be shown when various
     * common gotchas occur.
     *
     * Warnings are intended to provide insights during development when something
     * occurs that is not a fatal, but may indicate an issue with your integration,
     * and are therefore turned on by default. However, you may wish to disable
     * them in production.
     *
     * @example <caption>Example 1: Disabling warnings</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     debug: {
     *         showWarnings: false
     *     }
     * });
     *
     * @example <caption>Example 2: Disabling warnings based on environment</caption>
     *
     * var showWarnings = myAppConfig.environment === 'development' ? true : false;
     *
     * var mixer = mixitup(containerEl, {
     *     debug: {
     *         showWarnings: showWarnings
     *     }
     * });
     *
     * @name        showWarnings
     * @memberof    mixitup.Config.debug
     * @instance
     * @type        {boolean}
     * @default     true
     */

    this.showWarnings = true;
    /**
     * Used for server-side testing only.
     *
     * @private
     * @name        fauxAsync
     * @memberof    mixitup.Config.debug
     * @instance
     * @type        {boolean}
     * @default     false
     */

    this.fauxAsync = false;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.ConfigDebug);

  _mixitup.ConfigDebug.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.ConfigDebug.prototype.constructor = _mixitup.ConfigDebug;
  /**
   * A group of properties relating to the layout of the container.
   *
   * @constructor
   * @memberof    mixitup.Config
   * @name        layout
   * @namespace
   * @public
   * @since       3.0.0
   */

  _mixitup.ConfigLayout = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    /**
     * A boolean dictating whether or not mixitup should query all descendants
     * of the container for targets, or only immediate children.
     *
     * By default, mixitup will query all descendants matching the
     * `selectors.target` selector when indexing targets upon instantiation.
     * This allows for targets to be nested inside a sub-container which is
     * useful when ring-fencing targets from locally scoped controls in your
     * markup (see `controls.scope`).
     *
     * However, if you are building a more complex UI requiring the nesting
     * of mixers within mixers, you will most likely want to limit targets to
     * immediate children of the container by setting this property to `false`.
     *
     * @example <caption>Example: Restricting targets to immediate children</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     layout: {
     *         allowNestedTargets: false
     *     }
     * });
     *
     * @name        allowNestedTargets
     * @memberof    mixitup.Config.layout
     * @instance
     * @type        {boolean}
     * @default     true
     */

    this.allowNestedTargets = true;
    /**
     * A string specifying an optional class name to apply to the container when in
     * its default state.
     *
     * By changing this class name or adding a class name to the container via the
     * `.changeLayout()` API method, the CSS layout of the container can be changed,
     * and MixItUp will attemp to gracefully animate the container and its targets
     * between states.
     *
     * @example <caption>Example 1: Specifying a container class name</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     layout: {
     *         containerClassName: 'grid'
     *     }
     * });
     *
     * @example <caption>Example 2: Changing the default class name with `.changeLayout()`</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     layout: {
     *         containerClassName: 'grid'
     *     }
     * });
     *
     * mixer.changeLayout('list')
     *     .then(function(state) {
     *          console.log(state.activeContainerClass); // "list"
     *     });
     *
     * @name        containerClassName
     * @memberof    mixitup.Config.layout
     * @instance
     * @type        {string}
     * @default     ''
     */

    this.containerClassName = '';
    /**
     * A reference to a non-target sibling element after which to insert targets
     * when there are no targets in the container.
     *
     * @example <caption>Example: Setting a `siblingBefore` reference element</caption>
     *
     * var addButton = containerEl.querySelector('button');
     *
     * var mixer = mixitup(containerEl, {
     *     layout: {
     *         siblingBefore: addButton
     *     }
     * });
     *
     * @name        siblingBefore
     * @memberof    mixitup.Config.layout
     * @instance
     * @type        {HTMLElement}
     * @default     null
     */

    this.siblingBefore = null;
    /**
     * A reference to a non-target sibling element before which to insert targets
     * when there are no targets in the container.
     *
     * @example <caption>Example: Setting an `siblingAfter` reference element</caption>
     *
     * var gap = containerEl.querySelector('.gap');
     *
     * var mixer = mixitup(containerEl, {
     *     layout: {
     *         siblingAfter: gap
     *     }
     * });
     *
     * @name        siblingAfter
     * @memberof    mixitup.Config.layout
     * @instance
     * @type        {HTMLElement}
     * @default     null
     */

    this.siblingAfter = null;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.ConfigLayout);

  _mixitup.ConfigLayout.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.ConfigLayout.prototype.constructor = _mixitup.ConfigLayout;
  /**
   * A group of properties defining the initial state of the mixer on load (instantiation).
   *
   * @constructor
   * @memberof    mixitup.Config
   * @name        load
   * @namespace
   * @public
   * @since       2.0.0
   */

  _mixitup.ConfigLoad = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    /**
     * A string defining any filtering to be statically applied to the mixer on load.
     * As per the `.filter()` API, this can be any valid selector string, or the
     * values `'all'` or `'none'`.
     *
     * @example <caption>Example 1: Defining an initial filter selector to be applied on load</caption>
     *
     * // The mixer will show only those targets matching '.category-a' on load.
     *
     * var mixer = mixitup(containerEl, {
     *     load: {
     *         filter: '.category-a'
     *     }
     * });
     *
     * @example <caption>Example 2: Hiding all targets on load</caption>
     *
     * // The mixer will show hide all targets on load.
     *
     * var mixer = mixitup(containerEl, {
     *     load: {
     *         filter: 'none'
     *     }
     * });
     *
     * @name        filter
     * @memberof    mixitup.Config.load
     * @instance
     * @type        {string}
     * @default     'all'
     */

    this.filter = 'all';
    /**
     * A string defining any sorting to be statically applied to the mixer on load.
     * As per the `.sort()` API, this should be a valid "sort string" made up of
     * an attribute to sort by (or `'default'`) followed by an optional sorting
     * order, or the value `'random'`;
     *
     * @example <caption>Example: Defining sorting to be applied on load</caption>
     *
     * // The mixer will sort the container by the value of the `data-published-date`
     * // attribute, in descending order.
     *
     * var mixer = mixitup(containerEl, {
     *     load: {
     *         sort: 'published-date:desc'
     *     }
     * });
     *
     * @name        sort
     * @memberof    mixitup.Config.load
     * @instance
     * @type        {string}
     * @default     'default:asc'
     */

    this.sort = 'default:asc';
    /**
     * An array of objects representing the underlying data of any pre-rendered targets,
     * when using the `.dataset()` API.
     *
     * NB: If targets are pre-rendered when the mixer is instantiated, this must be set.
     *
     * @example <caption>Example: Defining the initial underyling dataset</caption>
     *
     * var myDataset = [
     *     {
     *         id: 0,
     *         title: "Blog Post Title 0",
     *         ...
     *     },
     *     {
     *         id: 1,
     *         title: "Blog Post Title 1",
     *         ...
     *     }
     * ];
     *
     * var mixer = mixitup(containerEl, {
     *     data: {
     *         uidKey: 'id'
     *     },
     *     load: {
     *         dataset: myDataset
     *     }
     * });
     *
     * @name        dataset
     * @memberof    mixitup.Config.load
     * @instance
     * @type        {Array.<object>}
     * @default     null
     */

    this.dataset = null;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.ConfigLoad);

  _mixitup.ConfigLoad.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.ConfigLoad.prototype.constructor = _mixitup.ConfigLoad;
  /**
   * A group of properties defining the selectors used to query elements within a mixitup container.
   *
   * @constructor
   * @memberof    mixitup.Config
   * @name        selectors
   * @namespace
   * @public
   * @since       3.0.0
   */

  _mixitup.ConfigSelectors = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    /**
     * A selector string used to query and index target elements within the container.
     *
     * By default, the class selector `'.mix'` is used, but this can be changed to an
     * attribute or element selector to match the style of your project.
     *
     * @example <caption>Example 1: Changing the target selector</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     selectors: {
     *         target: '.portfolio-item'
     *     }
     * });
     *
     * @example <caption>Example 2: Using an attribute selector as a target selector</caption>
     *
     * // The mixer will search for any children with the attribute `data-ref="mix"`
     *
     * var mixer = mixitup(containerEl, {
     *     selectors: {
     *         target: '[data-ref="mix"]'
     *     }
     * });
     *
     * @name        target
     * @memberof    mixitup.Config.selectors
     * @instance
     * @type        {string}
     * @default     '.mix'
     */

    this.target = '.mix';
    /**
     * A optional selector string used to add further specificity to the querying of control elements,
     * in addition to their mandatory data attribute (e.g. `data-filter`, `data-toggle`, `data-sort`).
     *
     * This can be used if other elements in your document must contain the above attributes
     * (e.g. for use in third-party scripts), and would otherwise interfere with MixItUp. Adding
     * an additional `control` selector of your choice allows MixItUp to restrict event handling
     * to only those elements matching the defined selector.
     *
     * @name        control
     * @memberof    mixitup.Config.selectors
     * @instance
     * @type        {string}
     * @default     ''
     *
     * @example <caption>Example 1: Adding a `selectors.control` selector</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     selectors: {
     *         control: '.mixitup-control'
     *     }
     * });
     *
     * // Will not be handled:
     * // <button data-filter=".category-a"></button>
     *
     * // Will be handled:
     * // <button class="mixitup-control" data-filter=".category-a"></button>
     */

    this.control = '';
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.ConfigSelectors);

  _mixitup.ConfigSelectors.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.ConfigSelectors.prototype.constructor = _mixitup.ConfigSelectors;
  /**
   * A group of optional render functions for creating and updating elements.
   *
   * All render functions receive a data object, and should return a valid HTML string.
   *
   * @constructor
   * @memberof    mixitup.Config
   * @name        render
   * @namespace
   * @public
   * @since       3.0.0
   */

  _mixitup.ConfigRender = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    /**
     * A function returning an HTML string representing a target element, or a reference to a
     * single DOM element.
     *
     * The function is invoked as part of the `.dataset()` API, whenever a new item is added
     * to the dataset, or an item in the dataset changes (if `dataset.dirtyCheck` is enabled).
     *
     * The function receives the relevant dataset item as its first parameter.
     *
     * @example <caption>Example 1: Using string concatenation</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     render: {
     *         target: function(item) {
     *             return (
     *                 '&lt;div class="mix"&gt;' +
     *                     '&lt;h2&gt;' + item.title + '&lt;/h2&gt;' +
     *                 '&lt;/div&gt;'
     *             );
     *         }
     *     }
     * });
     *
     * @example <caption>Example 2: Using an ES2015 template literal</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     render: {
     *         target: function(item) {
     *             return (
     *                 `&lt;div class="mix"&gt;
     *                     &lt;h2&gt;${item.title}&lt;/h2&gt;
     *                  &lt;/div&gt;`
     *             );
     *         }
     *     }
     * });
     *
     * @example <caption>Example 3: Using a Handlebars template</caption>
     *
     * var targetTemplate = Handlebars.compile('&lt;div class="mix"&gt;&lt;h2&gt;{{title}}&lt;/h2&gt;&lt;/div&gt;');
     *
     * var mixer = mixitup(containerEl, {
     *     render: {
     *         target: targetTemplate
     *     }
     * });
     *
     * @example <caption>Example 4: Returning a DOM element</caption>
     *
     * var mixer = mixitup(containerEl, {
     *     render: {
     *         target: function(item) {
     *              // Create a single element using your framework's built-in renderer
     *
     *              var el = ...
     *
     *              return el;
     *         }
     *     }
     * });
     *
     * @name        target
     * @memberof    mixitup.Config.render
     * @instance
     * @type        {function}
     * @default     'null'
     */

    this.target = null;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.ConfigRender);

  _mixitup.ConfigRender.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.ConfigRender.prototype.constructor = _mixitup.ConfigRender;
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.ConfigTemplates = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.ConfigTemplates);

  _mixitup.ConfigTemplates.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.ConfigTemplates.prototype.constructor = _mixitup.ConfigTemplates;
  /**
   * `mixitup.Config` is an interface used for customising the functionality of a
   * mixer instance. It is organised into several semantically distinct sub-objects,
   * each one pertaining to a particular aspect of MixItUp functionality.
   *
   * An object literal containing any or all of the available properies,
   * known as the "configuration object", can be passed as the second parameter to
   * the `mixitup` factory function when creating a mixer instance to customise its
   * functionality as needed.
   *
   * If no configuration object is passed, the mixer instance will take on the default
   * configuration values detailed below.
   *
   * @example <caption>Example 1: Creating and passing the configuration object</caption>
   * // Create a configuration object with desired values
   *
   * var config = {
   *     animation: {
   *         enable: false
   *     },
   *     selectors: {
   *         target: '.item'
   *     }
   * };
   *
   * // Pass the configuration object to the mixitup factory function
   *
   * var mixer = mixitup(containerEl, config);
   *
   * @example <caption>Example 2: Passing the configuration object inline</caption>
   * // Typically, the configuration object is passed inline for brevity.
   *
   * var mixer = mixitup(containerEl, {
   *     controls: {
   *         live: true,
   *         toggleLogic: 'and'
   *     }
   * });
   *
   *
   * @constructor
   * @memberof    mixitup
   * @namespace
   * @public
   * @since       2.0.0
   */

  _mixitup.Config = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.animation = new _mixitup.ConfigAnimation();
    this.behavior = new _mixitup.ConfigBehavior();
    this.callbacks = new _mixitup.ConfigCallbacks();
    this.controls = new _mixitup.ConfigControls();
    this.classNames = new _mixitup.ConfigClassNames();
    this.data = new _mixitup.ConfigData();
    this.debug = new _mixitup.ConfigDebug();
    this.layout = new _mixitup.ConfigLayout();
    this.load = new _mixitup.ConfigLoad();
    this.selectors = new _mixitup.ConfigSelectors();
    this.render = new _mixitup.ConfigRender();
    this.templates = new _mixitup.ConfigTemplates();
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.Config);

  _mixitup.Config.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.Config.prototype.constructor = _mixitup.Config;
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.MixerDom = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.document = null;
    this.body = null;
    this.container = null;
    this.parent = null;
    this.targets = [];
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.MixerDom);

  _mixitup.MixerDom.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.MixerDom.prototype.constructor = _mixitup.MixerDom;
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.UiClassNames = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.base = '';
    this.active = '';
    this.disabled = '';
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.UiClassNames);

  _mixitup.UiClassNames.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.UiClassNames.prototype.constructor = _mixitup.UiClassNames;
  /**
   * An object into which all arbitrary arguments sent to '.dataset()' are mapped.
   *
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.CommandDataset = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.dataset = null;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.CommandDataset);

  _mixitup.CommandDataset.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.CommandDataset.prototype.constructor = _mixitup.CommandDataset;
  /**
   * An object into which all arbitrary arguments sent to '.multimix()' are mapped.
   *
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.CommandMultimix = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.filter = null;
    this.sort = null;
    this.insert = null;
    this.remove = null;
    this.changeLayout = null;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.CommandMultimix);

  _mixitup.CommandMultimix.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.CommandMultimix.prototype.constructor = _mixitup.CommandMultimix;
  /**
   * An object into which all arbitrary arguments sent to '.filter()' are mapped.
   *
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.CommandFilter = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.selector = '';
    this.collection = null;
    this.action = 'show'; // enum: ['show', 'hide']

    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.CommandFilter);

  _mixitup.CommandFilter.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.CommandFilter.prototype.constructor = _mixitup.CommandFilter;
  /**
   * An object into which all arbitrary arguments sent to '.sort()' are mapped.
   *
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.CommandSort = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.sortString = '';
    this.attribute = '';
    this.order = 'asc';
    this.collection = null;
    this.next = null;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.CommandSort);

  _mixitup.CommandSort.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.CommandSort.prototype.constructor = _mixitup.CommandSort;
  /**
   * An object into which all arbitrary arguments sent to '.insert()' are mapped.
   *
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.CommandInsert = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.index = 0;
    this.collection = [];
    this.position = 'before'; // enum: ['before', 'after']

    this.sibling = null;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.CommandInsert);

  _mixitup.CommandInsert.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.CommandInsert.prototype.constructor = _mixitup.CommandInsert;
  /**
   * An object into which all arbitrary arguments sent to '.remove()' are mapped.
   *
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.CommandRemove = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.targets = [];
    this.collection = [];
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.CommandRemove);

  _mixitup.CommandRemove.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.CommandRemove.prototype.constructor = _mixitup.CommandRemove;
  /**
   * An object into which all arbitrary arguments sent to '.changeLayout()' are mapped.
   *
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.CommandChangeLayout = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.containerClassName = '';
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.CommandChangeLayout);

  _mixitup.CommandChangeLayout.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.CommandChangeLayout.prototype.constructor = _mixitup.CommandChangeLayout;
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   * @param       {string}        type
   * @param       {string}        selector
   * @param       {boolean}       [live]
   * @param       {string}        [parent]
   *     An optional string representing the name of the mixer.dom property containing a reference to a parent element.
   */

  _mixitup.ControlDefinition = function (type, selector, live, parent) {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.type = type;
    this.selector = selector;
    this.live = live || false;
    this.parent = parent || '';
    this.callActions('afterConstruct');
    h.freeze(this);
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.ControlDefinition);

  _mixitup.ControlDefinition.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.ControlDefinition.prototype.constructor = _mixitup.ControlDefinition;
  _mixitup.controlDefinitions = [];

  _mixitup.controlDefinitions.push(new _mixitup.ControlDefinition('multimix', '[data-filter][data-sort]'));

  _mixitup.controlDefinitions.push(new _mixitup.ControlDefinition('filter', '[data-filter]'));

  _mixitup.controlDefinitions.push(new _mixitup.ControlDefinition('sort', '[data-sort]'));

  _mixitup.controlDefinitions.push(new _mixitup.ControlDefinition('toggle', '[data-toggle]'));
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */


  _mixitup.Control = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.el = null;
    this.selector = '';
    this.bound = [];
    this.pending = -1;
    this.type = '';
    this.status = 'inactive'; // enum: ['inactive', 'active', 'disabled', 'live']

    this.filter = '';
    this.sort = '';
    this.canDisable = false;
    this.handler = null;
    this.classNames = new _mixitup.UiClassNames();
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.Control);

  _mixitup.Control.prototype = Object.create(_mixitup.Base.prototype);
  h.extend(_mixitup.Control.prototype,
  /** @lends mixitup.Control */
  {
    constructor: _mixitup.Control,

    /**
     * @private
     * @param {HTMLElement} el
     * @param {string}      type
     * @param {string}      selector
     */
    init: function init(el, type, selector) {
      var self = this;
      this.callActions('beforeInit', arguments);
      self.el = el;
      self.type = type;
      self.selector = selector;

      if (self.selector) {
        self.status = 'live';
      } else {
        self.canDisable = typeof self.el.disable === 'boolean';

        switch (self.type) {
          case 'filter':
            self.filter = self.el.getAttribute('data-filter');
            break;

          case 'toggle':
            self.filter = self.el.getAttribute('data-toggle');
            break;

          case 'sort':
            self.sort = self.el.getAttribute('data-sort');
            break;

          case 'multimix':
            self.filter = self.el.getAttribute('data-filter');
            self.sort = self.el.getAttribute('data-sort');
            break;
        }
      }

      self.bindClick();

      _mixitup.controls.push(self);

      this.callActions('afterInit', arguments);
    },

    /**
     * @private
     * @param  {mixitup.Mixer} mixer
     * @return {boolean}
     */
    isBound: function isBound(mixer) {
      var self = this,
          isBound = false;
      this.callActions('beforeIsBound', arguments);
      isBound = self.bound.indexOf(mixer) > -1;
      return self.callFilters('afterIsBound', isBound, arguments);
    },

    /**
     * @private
     * @param  {mixitup.Mixer} mixer
     * @return {void}
     */
    addBinding: function addBinding(mixer) {
      var self = this;
      this.callActions('beforeAddBinding', arguments);

      if (!self.isBound()) {
        self.bound.push(mixer);
      }

      this.callActions('afterAddBinding', arguments);
    },

    /**
     * @private
     * @param  {mixitup.Mixer} mixer
     * @return {void}
     */
    removeBinding: function removeBinding(mixer) {
      var self = this,
          removeIndex = -1;
      this.callActions('beforeRemoveBinding', arguments);

      if ((removeIndex = self.bound.indexOf(mixer)) > -1) {
        self.bound.splice(removeIndex, 1);
      }

      if (self.bound.length < 1) {
        // No bindings exist, unbind event click handlers
        self.unbindClick(); // Remove from `mixitup.controls` list

        removeIndex = _mixitup.controls.indexOf(self);

        _mixitup.controls.splice(removeIndex, 1);

        if (self.status === 'active') {
          self.renderStatus(self.el, 'inactive');
        }
      }

      this.callActions('afterRemoveBinding', arguments);
    },

    /**
     * @private
     * @return {void}
     */
    bindClick: function bindClick() {
      var self = this;
      this.callActions('beforeBindClick', arguments);

      self.handler = function (e) {
        self.handleClick(e);
      };

      h.on(self.el, 'click', self.handler);
      this.callActions('afterBindClick', arguments);
    },

    /**
     * @private
     * @return {void}
     */
    unbindClick: function unbindClick() {
      var self = this;
      this.callActions('beforeUnbindClick', arguments);
      h.off(self.el, 'click', self.handler);
      self.handler = null;
      this.callActions('afterUnbindClick', arguments);
    },

    /**
     * @private
     * @param   {MouseEvent} e
     * @return  {void}
     */
    handleClick: function handleClick(e) {
      var self = this,
          button = null,
          mixer = null,
          isActive = false,
          returnValue = void 0,
          command = {},
          clone = null,
          commands = [],
          i = -1;
      this.callActions('beforeHandleClick', arguments);
      this.pending = 0;
      mixer = self.bound[0];

      if (!self.selector) {
        button = self.el;
      } else {
        button = h.closestParent(e.target, mixer.config.selectors.control + self.selector, true, mixer.dom.document);
      }

      if (!button) {
        self.callActions('afterHandleClick', arguments);
        return;
      }

      switch (self.type) {
        case 'filter':
          command.filter = self.filter || button.getAttribute('data-filter');
          break;

        case 'sort':
          command.sort = self.sort || button.getAttribute('data-sort');
          break;

        case 'multimix':
          command.filter = self.filter || button.getAttribute('data-filter');
          command.sort = self.sort || button.getAttribute('data-sort');
          break;

        case 'toggle':
          command.filter = self.filter || button.getAttribute('data-toggle');

          if (self.status === 'live') {
            isActive = h.hasClass(button, self.classNames.active);
          } else {
            isActive = self.status === 'active';
          }

          break;
      }

      for (i = 0; i < self.bound.length; i++) {
        // Create a clone of the command for each bound mixer instance
        clone = new _mixitup.CommandMultimix();
        h.extend(clone, command);
        commands.push(clone);
      }

      commands = self.callFilters('commandsHandleClick', commands, arguments);
      self.pending = self.bound.length;

      for (i = 0; mixer = self.bound[i]; i++) {
        command = commands[i];

        if (!command) {
          // An extension may set a command null to indicate that the click should not be handled
          continue;
        }

        if (!mixer.lastClicked) {
          mixer.lastClicked = button;
        }

        _mixitup.events.fire('mixClick', mixer.dom.container, {
          state: mixer.state,
          instance: mixer,
          originalEvent: e,
          control: mixer.lastClicked
        }, mixer.dom.document);

        if (typeof mixer.config.callbacks.onMixClick === 'function') {
          returnValue = mixer.config.callbacks.onMixClick.call(mixer.lastClicked, mixer.state, e, mixer);

          if (returnValue === false) {
            // User has returned `false` from the callback, so do not handle click
            continue;
          }
        }

        if (self.type === 'toggle') {
          isActive ? mixer.toggleOff(command.filter) : mixer.toggleOn(command.filter);
        } else {
          mixer.multimix(command);
        }
      }

      this.callActions('afterHandleClick', arguments);
    },

    /**
     * @param   {object}          command
     * @param   {Array<string>}   toggleArray
     * @return  {void}
     */
    update: function update(command, toggleArray) {
      var self = this,
          actions = new _mixitup.CommandMultimix();
      self.callActions('beforeUpdate', arguments);
      self.pending--;
      self.pending = Math.max(0, self.pending);
      if (self.pending > 0) return;

      if (self.status === 'live') {
        // Live control (status unknown)
        self.updateLive(command, toggleArray);
      } else {
        // Static control
        actions.sort = self.sort;
        actions.filter = self.filter;
        self.callFilters('actionsUpdate', actions, arguments);
        self.parseStatusChange(self.el, command, actions, toggleArray);
      }

      self.callActions('afterUpdate', arguments);
    },

    /**
     * @param   {mixitup.CommandMultimix} command
     * @param   {Array<string>}           toggleArray
     * @return  {void}
     */
    updateLive: function updateLive(command, toggleArray) {
      var self = this,
          controlButtons = null,
          actions = null,
          button = null,
          i = -1;
      self.callActions('beforeUpdateLive', arguments);
      if (!self.el) return;
      controlButtons = self.el.querySelectorAll(self.selector);

      for (i = 0; button = controlButtons[i]; i++) {
        actions = new _mixitup.CommandMultimix();

        switch (self.type) {
          case 'filter':
            actions.filter = button.getAttribute('data-filter');
            break;

          case 'sort':
            actions.sort = button.getAttribute('data-sort');
            break;

          case 'multimix':
            actions.filter = button.getAttribute('data-filter');
            actions.sort = button.getAttribute('data-sort');
            break;

          case 'toggle':
            actions.filter = button.getAttribute('data-toggle');
            break;
        }

        actions = self.callFilters('actionsUpdateLive', actions, arguments);
        self.parseStatusChange(button, command, actions, toggleArray);
      }

      self.callActions('afterUpdateLive', arguments);
    },

    /**
     * @param   {HTMLElement}             button
     * @param   {mixitup.CommandMultimix} command
     * @param   {mixitup.CommandMultimix} actions
     * @param   {Array<string>}           toggleArray
     * @return  {void}
     */
    parseStatusChange: function parseStatusChange(button, command, actions, toggleArray) {
      var self = this,
          alias = '',
          toggle = '',
          i = -1;
      self.callActions('beforeParseStatusChange', arguments);

      switch (self.type) {
        case 'filter':
          if (command.filter === actions.filter) {
            self.renderStatus(button, 'active');
          } else {
            self.renderStatus(button, 'inactive');
          }

          break;

        case 'multimix':
          if (command.sort === actions.sort && command.filter === actions.filter) {
            self.renderStatus(button, 'active');
          } else {
            self.renderStatus(button, 'inactive');
          }

          break;

        case 'sort':
          if (command.sort.match(/:asc/g)) {
            alias = command.sort.replace(/:asc/g, '');
          }

          if (command.sort === actions.sort || alias === actions.sort) {
            self.renderStatus(button, 'active');
          } else {
            self.renderStatus(button, 'inactive');
          }

          break;

        case 'toggle':
          if (toggleArray.length < 1) self.renderStatus(button, 'inactive');

          if (command.filter === actions.filter) {
            self.renderStatus(button, 'active');
          }

          for (i = 0; i < toggleArray.length; i++) {
            toggle = toggleArray[i];

            if (toggle === actions.filter) {
              // Button matches one active toggle
              self.renderStatus(button, 'active');
              break;
            }

            self.renderStatus(button, 'inactive');
          }

          break;
      }

      self.callActions('afterParseStatusChange', arguments);
    },

    /**
     * @param   {HTMLElement}   button
     * @param   {string}        status
     * @return  {void}
     */
    renderStatus: function renderStatus(button, status) {
      var self = this;
      self.callActions('beforeRenderStatus', arguments);

      switch (status) {
        case 'active':
          h.addClass(button, self.classNames.active);
          h.removeClass(button, self.classNames.disabled);
          if (self.canDisable) self.el.disabled = false;
          break;

        case 'inactive':
          h.removeClass(button, self.classNames.active);
          h.removeClass(button, self.classNames.disabled);
          if (self.canDisable) self.el.disabled = false;
          break;

        case 'disabled':
          if (self.canDisable) self.el.disabled = true;
          h.addClass(button, self.classNames.disabled);
          h.removeClass(button, self.classNames.active);
          break;
      }

      if (self.status !== 'live') {
        // Update the control's status propery if not live
        self.status = status;
      }

      self.callActions('afterRenderStatus', arguments);
    }
  });
  _mixitup.controls = [];
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.StyleData = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.x = 0;
    this.y = 0;
    this.top = 0;
    this.right = 0;
    this.bottom = 0;
    this.left = 0;
    this.width = 0;
    this.height = 0;
    this.marginRight = 0;
    this.marginBottom = 0;
    this.opacity = 0;
    this.scale = new _mixitup.TransformData();
    this.translateX = new _mixitup.TransformData();
    this.translateY = new _mixitup.TransformData();
    this.translateZ = new _mixitup.TransformData();
    this.rotateX = new _mixitup.TransformData();
    this.rotateY = new _mixitup.TransformData();
    this.rotateZ = new _mixitup.TransformData();
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.StyleData);

  _mixitup.StyleData.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.StyleData.prototype.constructor = _mixitup.StyleData;
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.TransformData = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.value = 0;
    this.unit = '';
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.TransformData);

  _mixitup.TransformData.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.TransformData.prototype.constructor = _mixitup.TransformData;
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.TransformDefaults = function () {
    _mixitup.StyleData.apply(this);

    this.callActions('beforeConstruct');
    this.scale.value = 0.01;
    this.scale.unit = '';
    this.translateX.value = 20;
    this.translateX.unit = 'px';
    this.translateY.value = 20;
    this.translateY.unit = 'px';
    this.translateZ.value = 20;
    this.translateZ.unit = 'px';
    this.rotateX.value = 90;
    this.rotateX.unit = 'deg';
    this.rotateY.value = 90;
    this.rotateY.unit = 'deg';
    this.rotateX.value = 90;
    this.rotateX.unit = 'deg';
    this.rotateZ.value = 180;
    this.rotateZ.unit = 'deg';
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.TransformDefaults);

  _mixitup.TransformDefaults.prototype = Object.create(_mixitup.StyleData.prototype);
  _mixitup.TransformDefaults.prototype.constructor = _mixitup.TransformDefaults;
  /**
   * @private
   * @static
   * @since   3.0.0
   * @type    {mixitup.TransformDefaults}
   */

  _mixitup.transformDefaults = new _mixitup.TransformDefaults();
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.EventDetail = function () {
    this.state = null;
    this.futureState = null;
    this.instance = null;
    this.originalEvent = null;
  };
  /**
   * The `mixitup.Events` class contains all custom events dispatched by MixItUp at various
   * points within the lifecycle of a mixer operation.
   *
   * Each event is analogous to the callback function of the same name defined in
   * the `callbacks` configuration object, and is triggered immediately before it.
   *
   * Events are always triggered from the container element on which MixItUp is instantiated
   * upon.
   *
   * As with any event, registered event handlers receive the event object as a parameter
   * which includes a `detail` property containting references to the current `state`,
   * the `mixer` instance, and other event-specific properties described below.
   *
   * @constructor
   * @namespace
   * @memberof    mixitup
   * @public
   * @since       3.0.0
   */


  _mixitup.Events = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    /**
     * A custom event triggered immediately after any MixItUp operation is requested
     * and before animations have begun.
     *
     * The `mixStart` event also exposes a `futureState` property via the
     * `event.detail` object, which represents the final state of the mixer once
     * the requested operation has completed.
     *
     * @name        mixStart
     * @memberof    mixitup.Events
     * @static
     * @type        {CustomEvent}
     */

    this.mixStart = null;
    /**
     * A custom event triggered when a MixItUp operation is requested while another
     * operation is in progress, and the animation queue is full, or queueing
     * is disabled.
     *
     * @name        mixBusy
     * @memberof    mixitup.Events
     * @static
     * @type        {CustomEvent}
     */

    this.mixBusy = null;
    /**
     * A custom event triggered after any MixItUp operation has completed, and the
     * state has been updated.
     *
     * @name        mixEnd
     * @memberof    mixitup.Events
     * @static
     * @type        {CustomEvent}
     */

    this.mixEnd = null;
    /**
     * A custom event triggered whenever a filter operation "fails", i.e. no targets
     * could be found matching the requested filter.
     *
     * @name        mixFail
     * @memberof    mixitup.Events
     * @static
     * @type        {CustomEvent}
     */

    this.mixFail = null;
    /**
     * A custom event triggered whenever a MixItUp control is clicked, and before its
     * respective operation is requested.
     *
     * This event also exposes an `originalEvent` property via the `event.detail`
     * object, which holds a reference to the original click event.
     *
     * @name        mixClick
     * @memberof    mixitup.Events
     * @static
     * @type        {CustomEvent}
     */

    this.mixClick = null;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.Events);

  _mixitup.Events.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.Events.prototype.constructor = _mixitup.Events;
  /**
   * @private
   * @param   {string}      eventType
   * @param   {Element}     el
   * @param   {object}      detail
   * @param   {Document}    [doc]
   */

  _mixitup.Events.prototype.fire = function (eventType, el, detail, doc) {
    var self = this,
        event = null,
        eventDetail = new _mixitup.EventDetail();
    self.callActions('beforeFire', arguments);

    if (typeof self[eventType] === 'undefined') {
      throw new Error('Event type "' + eventType + '" not found.');
    }

    eventDetail.state = new _mixitup.State();
    h.extend(eventDetail.state, detail.state);

    if (detail.futureState) {
      eventDetail.futureState = new _mixitup.State();
      h.extend(eventDetail.futureState, detail.futureState);
    }

    eventDetail.instance = detail.instance;

    if (detail.originalEvent) {
      eventDetail.originalEvent = detail.originalEvent;
    }

    event = h.getCustomEvent(eventType, eventDetail, doc);
    self.callFilters('eventFire', event, arguments);
    el.dispatchEvent(event);
  }; // Asign a singleton instance to `mixitup.events`:


  _mixitup.events = new _mixitup.Events();
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.QueueItem = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.args = [];
    this.instruction = null;
    this.triggerElement = null;
    this.deferred = null;
    this.isToggling = false;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.QueueItem);

  _mixitup.QueueItem.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.QueueItem.prototype.constructor = _mixitup.QueueItem;
  /**
   * The `mixitup.Mixer` class is used to hold discreet, user-configured
   * instances of MixItUp on a provided container element.
   *
   * Mixer instances are returned whenever the `mixitup()` factory function is called,
   * which expose a range of methods enabling API-based filtering, sorting,
   * insertion, removal and more.
   *
   * @constructor
   * @namespace
   * @memberof    mixitup
   * @public
   * @since       3.0.0
   */

  _mixitup.Mixer = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.config = new _mixitup.Config();
    this.id = '';
    this.isBusy = false;
    this.isToggling = false;
    this.incPadding = true;
    this.controls = [];
    this.targets = [];
    this.origOrder = [];
    this.cache = {};
    this.toggleArray = [];
    this.targetsMoved = 0;
    this.targetsImmovable = 0;
    this.targetsBound = 0;
    this.targetsDone = 0;
    this.staggerDuration = 0;
    this.effectsIn = null;
    this.effectsOut = null;
    this.transformIn = [];
    this.transformOut = [];
    this.queue = [];
    this.state = null;
    this.lastOperation = null;
    this.lastClicked = null;
    this.userCallback = null;
    this.userDeferred = null;
    this.dom = new _mixitup.MixerDom();
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.Mixer);

  _mixitup.Mixer.prototype = Object.create(_mixitup.Base.prototype);
  h.extend(_mixitup.Mixer.prototype,
  /** @lends mixitup.Mixer */
  {
    constructor: _mixitup.Mixer,

    /**
     * @private
     * @instance
     * @since 3.0.0
     * @param {HTMLElement} container
     * @param {HTMLElement} document
     * @param {string}      id
     * @param {object}      [config]
     */
    attach: function attach(container, document, id, config) {
      var self = this,
          target = null,
          i = -1;
      self.callActions('beforeAttach', arguments);
      self.id = id;

      if (config) {
        h.extend(self.config, config, true, true);
      }

      self.sanitizeConfig();
      self.cacheDom(container, document);

      if (self.config.layout.containerClassName) {
        h.addClass(self.dom.container, self.config.layout.containerClassName);
      }

      if (!_mixitup.features.has.transitions) {
        self.config.animation.enable = false;
      }

      if (typeof window.console === 'undefined') {
        self.config.debug.showWarnings = false;
      }

      if (self.config.data.uidKey) {
        // If the dataset API is in use, force disable controls
        self.config.controls.enable = false;
      }

      self.indexTargets();
      self.state = self.getInitialState();

      for (i = 0; target = self.lastOperation.toHide[i]; i++) {
        target.hide();
      }

      if (self.config.controls.enable) {
        self.initControls();
        self.buildToggleArray(null, self.state);
        self.updateControls({
          filter: self.state.activeFilter,
          sort: self.state.activeSort
        });
      }

      self.parseEffects();
      self.callActions('afterAttach', arguments);
    },

    /**
     * @private
     * @instance
     * @since 3.0.0
     * @return {void}
     */
    sanitizeConfig: function sanitizeConfig() {
      var self = this;
      self.callActions('beforeSanitizeConfig', arguments); // Sanitize enum/string config options

      self.config.controls.scope = self.config.controls.scope.toLowerCase().trim();
      self.config.controls.toggleLogic = self.config.controls.toggleLogic.toLowerCase().trim();
      self.config.controls.toggleDefault = self.config.controls.toggleDefault.toLowerCase().trim();
      self.config.animation.effects = self.config.animation.effects.trim();
      self.callActions('afterSanitizeConfig', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @return  {mixitup.State}
     */
    getInitialState: function getInitialState() {
      var self = this,
          state = new _mixitup.State(),
          operation = new _mixitup.Operation();
      self.callActions('beforeGetInitialState', arguments); // Map initial values into a mock state object in order to construct an operation

      state.activeContainerClassName = self.config.layout.containerClassName;

      if (self.config.load.dataset) {
        // Dataset API
        if (!self.config.data.uidKey || typeof self.config.data.uidKey !== 'string') {
          throw new TypeError(_mixitup.messages.errorConfigDataUidKeyNotSet());
        }

        operation.startDataset = operation.newDataset = state.activeDataset = self.config.load.dataset.slice();
        operation.startContainerClassName = operation.newContainerClassName = state.activeContainerClassName;
        operation.show = self.targets.slice();
        state = self.callFilters('stateGetInitialState', state, arguments);
      } else {
        // DOM API
        state.activeFilter = self.parseFilterArgs([self.config.load.filter]).command;
        state.activeSort = self.parseSortArgs([self.config.load.sort]).command;
        state.totalTargets = self.targets.length;
        state = self.callFilters('stateGetInitialState', state, arguments);

        if (state.activeSort.collection || state.activeSort.attribute || state.activeSort.order === 'random' || state.activeSort.order === 'desc') {
          // Sorting on load
          operation.newSort = state.activeSort;
          self.sortOperation(operation);
          self.printSort(false, operation);
          self.targets = operation.newOrder;
        } else {
          operation.startOrder = operation.newOrder = self.targets;
        }

        operation.startFilter = operation.newFilter = state.activeFilter;
        operation.startSort = operation.newSort = state.activeSort;
        operation.startContainerClassName = operation.newContainerClassName = state.activeContainerClassName;

        if (operation.newFilter.selector === 'all') {
          operation.newFilter.selector = self.config.selectors.target;
        } else if (operation.newFilter.selector === 'none') {
          operation.newFilter.selector = '';
        }
      }

      operation = self.callFilters('operationGetInitialState', operation, [state]);
      self.lastOperation = operation;

      if (operation.newFilter) {
        self.filterOperation(operation);
      }

      state = self.buildState(operation);
      return state;
    },

    /**
     * Caches references of DOM elements neccessary for the mixer's functionality.
     *
     * @private
     * @instance
     * @since   3.0.0
     * @param   {HTMLElement}       el
     * @param   {HTMLHtmlElement}   document
     * @return  {void}
     */
    cacheDom: function cacheDom(el, document) {
      var self = this;
      self.callActions('beforeCacheDom', arguments);
      self.dom.document = document;
      self.dom.body = self.dom.document.querySelector('body');
      self.dom.container = el;
      self.dom.parent = el;
      self.callActions('afterCacheDom', arguments);
    },

    /**
     * Indexes all child elements of the mixer matching the `selectors.target`
     * selector, instantiating a mixitup.Target for each one.
     *
     * @private
     * @instance
     * @since   3.0.0
     * @return  {void}
     */
    indexTargets: function indexTargets() {
      var self = this,
          target = null,
          el = null,
          dataset = null,
          i = -1;
      self.callActions('beforeIndexTargets', arguments);
      self.dom.targets = self.config.layout.allowNestedTargets ? self.dom.container.querySelectorAll(self.config.selectors.target) : h.children(self.dom.container, self.config.selectors.target, self.dom.document);
      self.dom.targets = h.arrayFromList(self.dom.targets);
      self.targets = [];

      if ((dataset = self.config.load.dataset) && dataset.length !== self.dom.targets.length) {
        throw new Error(_mixitup.messages.errorDatasetPrerenderedMismatch());
      }

      if (self.dom.targets.length) {
        for (i = 0; el = self.dom.targets[i]; i++) {
          target = new _mixitup.Target();
          target.init(el, self, dataset ? dataset[i] : void 0);
          target.isInDom = true;
          self.targets.push(target);
        }

        self.dom.parent = self.dom.targets[0].parentElement === self.dom.container ? self.dom.container : self.dom.targets[0].parentElement;
      }

      self.origOrder = self.targets;
      self.callActions('afterIndexTargets', arguments);
    },
    initControls: function initControls() {
      var self = this,
          definition = '',
          controlElements = null,
          el = null,
          parent = null,
          delagators = null,
          control = null,
          i = -1,
          j = -1;
      self.callActions('beforeInitControls', arguments);

      switch (self.config.controls.scope) {
        case 'local':
          parent = self.dom.container;
          break;

        case 'global':
          parent = self.dom.document;
          break;

        default:
          throw new Error(_mixitup.messages.errorConfigInvalidControlsScope());
      }

      for (i = 0; definition = _mixitup.controlDefinitions[i]; i++) {
        if (self.config.controls.live || definition.live) {
          if (definition.parent) {
            delagators = self.dom[definition.parent];
            if (!delagators || delagators.length < 0) continue;

            if (typeof delagators.length !== 'number') {
              delagators = [delagators];
            }
          } else {
            delagators = [parent];
          }

          for (j = 0; el = delagators[j]; j++) {
            control = self.getControl(el, definition.type, definition.selector);
            self.controls.push(control);
          }
        } else {
          controlElements = parent.querySelectorAll(self.config.selectors.control + definition.selector);

          for (j = 0; el = controlElements[j]; j++) {
            control = self.getControl(el, definition.type, '');
            if (!control) continue;
            self.controls.push(control);
          }
        }
      }

      self.callActions('afterInitControls', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {HTMLElement} el
     * @param   {string}      type
     * @param   {string}      selector
     * @return  {mixitup.Control|null}
     */
    getControl: function getControl(el, type, selector) {
      var self = this,
          control = null,
          i = -1;
      self.callActions('beforeGetControl', arguments);

      if (!selector) {
        // Static controls only
        for (i = 0; control = _mixitup.controls[i]; i++) {
          if (control.el === el && control.isBound(self)) {
            // Control already bound to this mixer (as another type).
            // NB: This prevents duplicate controls from being registered where a selector
            // might collide, eg: "[data-filter]" and "[data-filter][data-sort]"
            return self.callFilters('controlGetControl', null, arguments);
          } else if (control.el === el && control.type === type && control.selector === selector) {
            // Another mixer is already using this control, add this mixer as a binding
            control.addBinding(self);
            return self.callFilters('controlGetControl', control, arguments);
          }
        }
      } // Create new control


      control = new _mixitup.Control();
      control.init(el, type, selector);
      control.classNames.base = h.getClassname(self.config.classNames, type);
      control.classNames.active = h.getClassname(self.config.classNames, type, self.config.classNames.modifierActive);
      control.classNames.disabled = h.getClassname(self.config.classNames, type, self.config.classNames.modifierDisabled); // Add a reference to this mixer as a binding

      control.addBinding(self);
      return self.callFilters('controlGetControl', control, arguments);
    },

    /**
     * Creates a compound selector by joining the `toggleArray` value as per the
     * defined toggle logic.
     *
     * @private
     * @instance
     * @since   3.0.0
     * @return  {string}
     */
    getToggleSelector: function getToggleSelector() {
      var self = this,
          delineator = self.config.controls.toggleLogic === 'or' ? ', ' : '',
          toggleSelector = '';
      self.callActions('beforeGetToggleSelector', arguments);
      self.toggleArray = h.clean(self.toggleArray);
      toggleSelector = self.toggleArray.join(delineator);

      if (toggleSelector === '') {
        toggleSelector = self.config.controls.toggleDefault;
      }

      return self.callFilters('selectorGetToggleSelector', toggleSelector, arguments);
    },

    /**
     * Breaks compound selector strings in an array of discreet selectors,
     * as per the active `controls.toggleLogic` configuration option. Accepts
     * either a dynamic command object, or a state object.
     *
     * @private
     * @instance
     * @since   2.0.0
     * @param   {object}        [command]
     * @param   {mixitup.State} [state]
     * @return  {void}
     */
    buildToggleArray: function buildToggleArray(command, state) {
      var self = this,
          activeFilterSelector = '';
      self.callActions('beforeBuildToggleArray', arguments);

      if (command && command.filter) {
        activeFilterSelector = command.filter.selector.replace(/\s/g, '');
      } else if (state) {
        activeFilterSelector = state.activeFilter.selector.replace(/\s/g, '');
      } else {
        return;
      }

      if (activeFilterSelector === self.config.selectors.target || activeFilterSelector === 'all') {
        activeFilterSelector = '';
      }

      if (self.config.controls.toggleLogic === 'or') {
        self.toggleArray = activeFilterSelector.split(',');
      } else {
        self.toggleArray = self.splitCompoundSelector(activeFilterSelector);
      }

      self.toggleArray = h.clean(self.toggleArray);
      self.callActions('afterBuildToggleArray', arguments);
    },

    /**
     * Takes a compound selector (e.g. `.cat-1.cat-2`, `[data-cat="1"][data-cat="2"]`)
     * and breaks into its individual selectors.
     *
     * @private
     * @instance
     * @since   3.0.0
     * @param   {string} compoundSelector
     * @return  {string[]}
     */
    splitCompoundSelector: function splitCompoundSelector(compoundSelector) {
      // Break at a `.` or `[`, capturing the delineator
      var partials = compoundSelector.split(/([\.\[])/g),
          toggleArray = [],
          selector = '',
          i = -1;

      if (partials[0] === '') {
        partials.shift();
      }

      for (i = 0; i < partials.length; i++) {
        if (i % 2 === 0) {
          selector = '';
        }

        selector += partials[i];

        if (i % 2 !== 0) {
          toggleArray.push(selector);
        }
      }

      return toggleArray;
    },

    /**
     * Updates controls to their active/inactive state based on the command or
     * current state of the mixer.
     *
     * @private
     * @instance
     * @since   2.0.0
     * @param   {object} command
     * @return  {void}
     */
    updateControls: function updateControls(command) {
      var self = this,
          control = null,
          output = new _mixitup.CommandMultimix(),
          i = -1;
      self.callActions('beforeUpdateControls', arguments); // Sanitise to defaults

      if (command.filter) {
        output.filter = command.filter.selector;
      } else {
        output.filter = self.state.activeFilter.selector;
      }

      if (command.sort) {
        output.sort = self.buildSortString(command.sort);
      } else {
        output.sort = self.buildSortString(self.state.activeSort);
      }

      if (output.filter === self.config.selectors.target) {
        output.filter = 'all';
      }

      if (output.filter === '') {
        output.filter = 'none';
      }

      h.freeze(output);

      for (i = 0; control = self.controls[i]; i++) {
        control.update(output, self.toggleArray);
      }

      self.callActions('afterUpdateControls', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {mixitup.CommandSort}   command
     * @return  {string}
     */
    buildSortString: function buildSortString(command) {
      var self = this;
      var output = '';
      output += command.sortString;

      if (command.next) {
        output += ' ' + self.buildSortString(command.next);
      }

      return output;
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {object}        command
     * @param   {Operation}     operation
     * @return  {Promise.<mixitup.State>}
     */
    insertTargets: function insertTargets(command, operation) {
      var self = this,
          nextSibling = null,
          insertionIndex = -1,
          frag = null,
          target = null,
          el = null,
          i = -1;
      self.callActions('beforeInsertTargets', arguments);
      if (typeof command.index === 'undefined') command.index = 0;
      nextSibling = self.getNextSibling(command.index, command.sibling, command.position);
      frag = self.dom.document.createDocumentFragment();

      if (nextSibling) {
        insertionIndex = h.index(nextSibling, self.config.selectors.target);
      } else {
        insertionIndex = self.targets.length;
      }

      if (command.collection) {
        for (i = 0; el = command.collection[i]; i++) {
          if (self.dom.targets.indexOf(el) > -1) {
            throw new Error(_mixitup.messages.errorInsertPreexistingElement());
          } // Ensure elements are hidden when they are added to the DOM, so they can
          // be animated in gracefully


          el.style.display = 'none';
          frag.appendChild(el);
          frag.appendChild(self.dom.document.createTextNode(' '));
          if (!h.isElement(el, self.dom.document) || !el.matches(self.config.selectors.target)) continue;
          target = new _mixitup.Target();
          target.init(el, self);
          target.isInDom = true;
          self.targets.splice(insertionIndex, 0, target);
          insertionIndex++;
        }

        self.dom.parent.insertBefore(frag, nextSibling);
      } // Since targets have been added, the original order must be updated


      operation.startOrder = self.origOrder = self.targets;
      self.callActions('afterInsertTargets', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {Number}      [index]
     * @param   {Element}     [sibling]
     * @param   {string}      [position]
     * @return  {Element}
     */
    getNextSibling: function getNextSibling(index, sibling, position) {
      var self = this,
          element = null;
      index = Math.max(index, 0);

      if (sibling && position === 'before') {
        // Explicit sibling
        element = sibling;
      } else if (sibling && position === 'after') {
        // Explicit sibling
        element = sibling.nextElementSibling || null;
      } else if (self.targets.length > 0 && typeof index !== 'undefined') {
        // Index and targets exist
        element = index < self.targets.length || !self.targets.length ? self.targets[index].dom.el : self.targets[self.targets.length - 1].dom.el.nextElementSibling;
      } else if (self.targets.length === 0 && self.dom.parent.children.length > 0) {
        // No targets but other siblings
        if (self.config.layout.siblingAfter) {
          element = self.config.layout.siblingAfter;
        } else if (self.config.layout.siblingBefore) {
          element = self.config.layout.siblingBefore.nextElementSibling;
        } else {
          self.dom.parent.children[0];
        }
      } else {
        element === null;
      }

      return self.callFilters('elementGetNextSibling', element, arguments);
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {Operation}     operation
     * @return  {void}
     */
    filterOperation: function filterOperation(operation) {
      var self = this,
          testResult = false,
          index = -1,
          action = '',
          target = null,
          i = -1;
      self.callActions('beforeFilterOperation', arguments);
      action = operation.newFilter.action;

      for (i = 0; target = operation.newOrder[i]; i++) {
        if (operation.newFilter.collection) {
          // show via collection
          testResult = operation.newFilter.collection.indexOf(target.dom.el) > -1;
        } else {
          // show via selector
          if (operation.newFilter.selector === '') {
            testResult = false;
          } else {
            testResult = target.dom.el.matches(operation.newFilter.selector);
          }
        }

        self.evaluateHideShow(testResult, target, action, operation);
      }

      if (operation.toRemove.length) {
        for (i = 0; target = operation.show[i]; i++) {
          if (operation.toRemove.indexOf(target) > -1) {
            // If any shown targets should be removed, move them into the toHide array
            operation.show.splice(i, 1);

            if ((index = operation.toShow.indexOf(target)) > -1) {
              operation.toShow.splice(index, 1);
            }

            operation.toHide.push(target);
            operation.hide.push(target);
            i--;
          }
        }
      }

      operation.matching = operation.show.slice();

      if (operation.show.length === 0 && operation.newFilter.selector !== '' && self.targets.length !== 0) {
        operation.hasFailed = true;
      }

      self.callActions('afterFilterOperation', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {boolean}   testResult
     * @param   {Element}   target
     * @param   {string}    action
     * @param   {Operation} operation
     * @return  {void}
     */
    evaluateHideShow: function evaluateHideShow(testResult, target, action, operation) {
      var self = this,
          filteredTestResult = false,
          args = Array.prototype.slice.call(arguments, 1);
      filteredTestResult = self.callFilters('testResultEvaluateHideShow', testResult, args);
      self.callActions('beforeEvaluateHideShow', arguments);

      if (filteredTestResult === true && action === 'show' || filteredTestResult === false && action === 'hide') {
        operation.show.push(target);
        !target.isShown && operation.toShow.push(target);
      } else {
        operation.hide.push(target);
        target.isShown && operation.toHide.push(target);
      }

      self.callActions('afterEvaluateHideShow', arguments);
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {Operation}     operation
     * @return  {void}
     */
    sortOperation: function sortOperation(operation) {
      var self = this,
          newOrder = [],
          target = null,
          el = null,
          i = -1;
      self.callActions('beforeSortOperation', arguments);
      operation.startOrder = self.targets;

      if (operation.newSort.collection) {
        // Sort by collection
        newOrder = [];

        for (i = 0; el = operation.newSort.collection[i]; i++) {
          if (self.dom.targets.indexOf(el) < 0) {
            throw new Error(_mixitup.messages.errorSortNonExistentElement());
          }

          target = new _mixitup.Target();
          target.init(el, self);
          target.isInDom = true;
          newOrder.push(target);
        }

        operation.newOrder = newOrder;
      } else if (operation.newSort.order === 'random') {
        // Sort random
        operation.newOrder = h.arrayShuffle(operation.startOrder);
      } else if (operation.newSort.attribute === '') {
        // Sort by default
        operation.newOrder = self.origOrder.slice();

        if (operation.newSort.order === 'desc') {
          operation.newOrder.reverse();
        }
      } else {
        // Sort by attribute
        operation.newOrder = operation.startOrder.slice();
        operation.newOrder.sort(function (a, b) {
          return self.compare(a, b, operation.newSort);
        });
      }

      if (h.isEqualArray(operation.newOrder, operation.startOrder)) {
        operation.willSort = false;
      }

      self.callActions('afterSortOperation', arguments);
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {mixitup.Target}        a
     * @param   {mixitup.Target}        b
     * @param   {mixitup.CommandSort}   command
     * @return  {Number}
     */
    compare: function compare(a, b, command) {
      var self = this,
          order = command.order,
          attrA = self.getAttributeValue(a, command.attribute),
          attrB = self.getAttributeValue(b, command.attribute);

      if (isNaN(attrA * 1) || isNaN(attrB * 1)) {
        attrA = attrA.toLowerCase();
        attrB = attrB.toLowerCase();
      } else {
        attrA = attrA * 1;
        attrB = attrB * 1;
      }

      if (attrA < attrB) {
        return order === 'asc' ? -1 : 1;
      }

      if (attrA > attrB) {
        return order === 'asc' ? 1 : -1;
      }

      if (attrA === attrB && command.next) {
        return self.compare(a, b, command.next);
      }

      return 0;
    },

    /**
     * Reads the values of any data attributes present the provided target element
     * which match the current sort command.
     *
     * @private
     * @instance
     * @since   3.0.0
     * @param   {mixitup.Target}    target
     * @param   {string}            [attribute]
     * @return  {(String|Number)}
     */
    getAttributeValue: function getAttributeValue(target, attribute) {
      var self = this,
          value = '';
      value = target.dom.el.getAttribute('data-' + attribute);

      if (value === null) {
        if (self.config.debug.showWarnings) {
          // Encourage users to assign values to all targets to avoid erroneous sorting
          // when types are mixed
          console.warn(_mixitup.messages.warningInconsistentSortingAttributes({
            attribute: 'data-' + attribute
          }));
        }
      } // If an attribute is not present, return 0 as a safety value


      return self.callFilters('valueGetAttributeValue', value || 0, arguments);
    },

    /**
     * Inserts elements into the DOM in the appropriate
     * order using a document fragment for minimal
     * DOM thrashing
     *
     * @private
     * @instance
     * @since   2.0.0
     * @param   {boolean}   isResetting
     * @param   {Operation} operation
     * @return  {void}
     */
    printSort: function printSort(isResetting, operation) {
      var self = this,
          startOrder = isResetting ? operation.newOrder : operation.startOrder,
          newOrder = isResetting ? operation.startOrder : operation.newOrder,
          nextSibling = startOrder.length ? startOrder[startOrder.length - 1].dom.el.nextElementSibling : null,
          frag = window.document.createDocumentFragment(),
          whitespace = null,
          target = null,
          el = null,
          i = -1;
      self.callActions('beforePrintSort', arguments); // Empty the container

      for (i = 0; target = startOrder[i]; i++) {
        el = target.dom.el;
        if (el.style.position === 'absolute') continue;
        h.removeWhitespace(el.previousSibling);
        el.parentElement.removeChild(el);
      }

      whitespace = nextSibling ? nextSibling.previousSibling : self.dom.parent.lastChild;

      if (whitespace && whitespace.nodeName === '#text') {
        h.removeWhitespace(whitespace);
      }

      for (i = 0; target = newOrder[i]; i++) {
        // Add targets into a document fragment
        el = target.dom.el;

        if (h.isElement(frag.lastChild)) {
          frag.appendChild(window.document.createTextNode(' '));
        }

        frag.appendChild(el);
      } // Insert the document fragment into the container
      // before any other non-target elements


      if (self.dom.parent.firstChild && self.dom.parent.firstChild !== nextSibling) {
        frag.insertBefore(window.document.createTextNode(' '), frag.childNodes[0]);
      }

      if (nextSibling) {
        frag.appendChild(window.document.createTextNode(' '));
        self.dom.parent.insertBefore(frag, nextSibling);
      } else {
        self.dom.parent.appendChild(frag);
      }

      self.callActions('afterPrintSort', arguments);
    },

    /**
     * Parses user-defined sort strings (i.e. `default:asc`) into sort commands objects.
     *
     * @private
     * @instance
     * @since   3.0.0
     * @param   {string}                sortString
     * @param   {mixitup.CommandSort}   command
     * @return  {mixitup.CommandSort}
     */
    parseSortString: function parseSortString(sortString, command) {
      var self = this,
          rules = sortString.split(' '),
          current = command,
          rule = [],
          i = -1; // command.sortString = sortString;

      for (i = 0; i < rules.length; i++) {
        rule = rules[i].split(':');
        current.sortString = rules[i];
        current.attribute = h.dashCase(rule[0]);
        current.order = rule[1] || 'asc';

        switch (current.attribute) {
          case 'default':
            // treat "default" as sorting by no attribute
            current.attribute = '';
            break;

          case 'random':
            // treat "random" as an order not an attribute
            current.attribute = '';
            current.order = 'random';
            break;
        }

        if (!current.attribute || current.order === 'random') break;

        if (i < rules.length - 1) {
          // Embed reference to the next command
          current.next = new _mixitup.CommandSort();
          h.freeze(current);
          current = current.next;
        }
      }

      return self.callFilters('commandsParseSort', command, arguments);
    },

    /**
     * Parses all effects out of the user-defined `animation.effects` string into
     * their respective properties and units.
     *
     * @private
     * @instance
     * @since   2.0.0
     * @return  {void}
     */
    parseEffects: function parseEffects() {
      var self = this,
          transformName = '',
          effectsIn = self.config.animation.effectsIn || self.config.animation.effects,
          effectsOut = self.config.animation.effectsOut || self.config.animation.effects;
      self.callActions('beforeParseEffects', arguments);
      self.effectsIn = new _mixitup.StyleData();
      self.effectsOut = new _mixitup.StyleData();
      self.transformIn = [];
      self.transformOut = [];
      self.effectsIn.opacity = self.effectsOut.opacity = 1;
      self.parseEffect('fade', effectsIn, self.effectsIn, self.transformIn);
      self.parseEffect('fade', effectsOut, self.effectsOut, self.transformOut, true);

      for (transformName in _mixitup.transformDefaults) {
        if (!(_mixitup.transformDefaults[transformName] instanceof _mixitup.TransformData)) {
          continue;
        }

        self.parseEffect(transformName, effectsIn, self.effectsIn, self.transformIn);
        self.parseEffect(transformName, effectsOut, self.effectsOut, self.transformOut, true);
      }

      self.parseEffect('stagger', effectsIn, self.effectsIn, self.transformIn);
      self.parseEffect('stagger', effectsOut, self.effectsOut, self.transformOut, true);
      self.callActions('afterParseEffects', arguments);
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {string}    effectName
     * @param   {string}    effectString
     * @param   {StyleData} effects
     * @param   {String[]}  transform
     * @param   {boolean}   [isOut]
     */
    parseEffect: function parseEffect(effectName, effectString, effects, transform, isOut) {
      var self = this,
          re = /\(([^)]+)\)/,
          propIndex = -1,
          str = '',
          match = [],
          val = '',
          units = ['%', 'px', 'em', 'rem', 'vh', 'vw', 'deg'],
          unit = '',
          i = -1;
      self.callActions('beforeParseEffect', arguments);

      if (typeof effectString !== 'string') {
        throw new TypeError(_mixitup.messages.errorConfigInvalidAnimationEffects());
      }

      if (effectString.indexOf(effectName) < 0) {
        // The effect is not present in the effects string
        if (effectName === 'stagger') {
          // Reset stagger to 0
          self.staggerDuration = 0;
        }

        return;
      } // The effect is present


      propIndex = effectString.indexOf(effectName + '(');

      if (propIndex > -1) {
        // The effect has a user defined value in parentheses
        // Extract from the first parenthesis to the end of string
        str = effectString.substring(propIndex); // Match any number of characters between "(" and ")"

        match = re.exec(str);
        val = match[1];
      }

      switch (effectName) {
        case 'fade':
          effects.opacity = val ? parseFloat(val) : 0;
          break;

        case 'stagger':
          self.staggerDuration = val ? parseFloat(val) : 100; // TODO: Currently stagger must be applied globally, but
          // if seperate values are specified for in/out, this should
          // be respected

          break;

        default:
          // All other effects are transforms following the same structure
          if (isOut && self.config.animation.reverseOut && effectName !== 'scale') {
            effects[effectName].value = (val ? parseFloat(val) : _mixitup.transformDefaults[effectName].value) * -1;
          } else {
            effects[effectName].value = val ? parseFloat(val) : _mixitup.transformDefaults[effectName].value;
          }

          if (val) {
            for (i = 0; unit = units[i]; i++) {
              if (val.indexOf(unit) > -1) {
                effects[effectName].unit = unit;
                break;
              }
            }
          } else {
            effects[effectName].unit = _mixitup.transformDefaults[effectName].unit;
          }

          transform.push(effectName + '(' + effects[effectName].value + effects[effectName].unit + ')');
      }

      self.callActions('afterParseEffect', arguments);
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {Operation}     operation
     * @return  {State}
     */
    buildState: function buildState(operation) {
      var self = this,
          state = new _mixitup.State(),
          target = null,
          i = -1;
      self.callActions('beforeBuildState', arguments); // Map target elements into state arrays.
      // the real target objects should never be exposed

      for (i = 0; target = self.targets[i]; i++) {
        if (!operation.toRemove.length || operation.toRemove.indexOf(target) < 0) {
          state.targets.push(target.dom.el);
        }
      }

      for (i = 0; target = operation.matching[i]; i++) {
        state.matching.push(target.dom.el);
      }

      for (i = 0; target = operation.show[i]; i++) {
        state.show.push(target.dom.el);
      }

      for (i = 0; target = operation.hide[i]; i++) {
        if (!operation.toRemove.length || operation.toRemove.indexOf(target) < 0) {
          state.hide.push(target.dom.el);
        }
      }

      state.id = self.id;
      state.container = self.dom.container;
      state.activeFilter = operation.newFilter;
      state.activeSort = operation.newSort;
      state.activeDataset = operation.newDataset;
      state.activeContainerClassName = operation.newContainerClassName;
      state.hasFailed = operation.hasFailed;
      state.totalTargets = self.targets.length;
      state.totalShow = operation.show.length;
      state.totalHide = operation.hide.length;
      state.totalMatching = operation.matching.length;
      state.triggerElement = operation.triggerElement;
      return self.callFilters('stateBuildState', state, arguments);
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {boolean}   shouldAnimate
     * @param   {Operation} operation
     * @return  {void}
     */
    goMix: function goMix(shouldAnimate, operation) {
      var self = this,
          deferred = null;
      self.callActions('beforeGoMix', arguments); // If the animation duration is set to 0ms,
      // or no effects specified,
      // or the container is hidden
      // then abort animation

      if (!self.config.animation.duration || !self.config.animation.effects || !h.isVisible(self.dom.container)) {
        shouldAnimate = false;
      }

      if (!operation.toShow.length && !operation.toHide.length && !operation.willSort && !operation.willChangeLayout) {
        // If nothing to show or hide, and not sorting or
        // changing layout
        shouldAnimate = false;
      }

      if (!operation.startState.show.length && !operation.show.length) {
        // If nothing currently shown, nothing to show
        shouldAnimate = false;
      }

      _mixitup.events.fire('mixStart', self.dom.container, {
        state: operation.startState,
        futureState: operation.newState,
        instance: self
      }, self.dom.document);

      if (typeof self.config.callbacks.onMixStart === 'function') {
        self.config.callbacks.onMixStart.call(self.dom.container, operation.startState, operation.newState, self);
      }

      h.removeClass(self.dom.container, h.getClassname(self.config.classNames, 'container', self.config.classNames.modifierFailed));

      if (!self.userDeferred) {
        // Queue empty, no pending operations
        deferred = self.userDeferred = h.defer(_mixitup.libraries);
      } else {
        // Use existing deferred
        deferred = self.userDeferred;
      }

      self.isBusy = true;

      if (!shouldAnimate || !_mixitup.features.has.transitions) {
        // Abort
        if (self.config.debug.fauxAsync) {
          setTimeout(function () {
            self.cleanUp(operation);
          }, self.config.animation.duration);
        } else {
          self.cleanUp(operation);
        }

        return self.callFilters('promiseGoMix', deferred.promise, arguments);
      } // If we should animate and the platform supports transitions, go for it


      if (window.pageYOffset !== operation.docState.scrollTop) {
        window.scrollTo(operation.docState.scrollLeft, operation.docState.scrollTop);
      }

      if (self.config.animation.applyPerspective) {
        self.dom.parent.style[_mixitup.features.perspectiveProp] = self.config.animation.perspectiveDistance;
        self.dom.parent.style[_mixitup.features.perspectiveOriginProp] = self.config.animation.perspectiveOrigin;
      }

      if (self.config.animation.animateResizeContainer && operation.startHeight !== operation.newHeight && operation.viewportDeltaY !== operation.startHeight - operation.newHeight) {
        self.dom.parent.style.height = operation.startHeight + 'px';
      }

      if (self.config.animation.animateResizeContainer && operation.startWidth !== operation.newWidth && operation.viewportDeltaX !== operation.startWidth - operation.newWidth) {
        self.dom.parent.style.width = operation.startWidth + 'px';
      }

      if (operation.startHeight === operation.newHeight) {
        self.dom.parent.style.height = operation.startHeight + 'px';
      }

      if (operation.startWidth === operation.newWidth) {
        self.dom.parent.style.width = operation.startWidth + 'px';
      }

      if (operation.startHeight === operation.newHeight && operation.startWidth === operation.newWidth) {
        self.dom.parent.style.overflow = 'hidden';
      }

      requestAnimationFrame(function () {
        self.moveTargets(operation);
      });
      return self.callFilters('promiseGoMix', deferred.promise, arguments);
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {Operation}     operation
     * @return  {void}
     */
    getStartMixData: function getStartMixData(operation) {
      var self = this,
          parentStyle = window.getComputedStyle(self.dom.parent),
          parentRect = self.dom.parent.getBoundingClientRect(),
          target = null,
          data = {},
          i = -1,
          boxSizing = parentStyle[_mixitup.features.boxSizingProp];
      self.incPadding = boxSizing === 'border-box';
      self.callActions('beforeGetStartMixData', arguments);

      for (i = 0; target = operation.show[i]; i++) {
        data = target.getPosData();
        operation.showPosData[i] = {
          startPosData: data
        };
      }

      for (i = 0; target = operation.toHide[i]; i++) {
        data = target.getPosData();
        operation.toHidePosData[i] = {
          startPosData: data
        };
      }

      operation.startX = parentRect.left;
      operation.startY = parentRect.top;
      operation.startHeight = self.incPadding ? parentRect.height : parentRect.height - parseFloat(parentStyle.paddingTop) - parseFloat(parentStyle.paddingBottom) - parseFloat(parentStyle.borderTop) - parseFloat(parentStyle.borderBottom);
      operation.startWidth = self.incPadding ? parentRect.width : parentRect.width - parseFloat(parentStyle.paddingLeft) - parseFloat(parentStyle.paddingRight) - parseFloat(parentStyle.borderLeft) - parseFloat(parentStyle.borderRight);
      self.callActions('afterGetStartMixData', arguments);
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {Operation}     operation
     * @return  {void}
     */
    setInter: function setInter(operation) {
      var self = this,
          target = null,
          i = -1;
      self.callActions('beforeSetInter', arguments); // Prevent scrollbar flicker on non-inertial scroll platforms by clamping height/width

      if (self.config.animation.clampHeight) {
        self.dom.parent.style.height = operation.startHeight + 'px';
        self.dom.parent.style.overflow = 'hidden';
      }

      if (self.config.animation.clampWidth) {
        self.dom.parent.style.width = operation.startWidth + 'px';
        self.dom.parent.style.overflow = 'hidden';
      }

      for (i = 0; target = operation.toShow[i]; i++) {
        target.show();
      }

      if (operation.willChangeLayout) {
        h.removeClass(self.dom.container, operation.startContainerClassName);
        h.addClass(self.dom.container, operation.newContainerClassName);
      }

      self.callActions('afterSetInter', arguments);
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {Operation}     operation
     * @return  {void}
     */
    getInterMixData: function getInterMixData(operation) {
      var self = this,
          target = null,
          i = -1;
      self.callActions('beforeGetInterMixData', arguments);

      for (i = 0; target = operation.show[i]; i++) {
        operation.showPosData[i].interPosData = target.getPosData();
      }

      for (i = 0; target = operation.toHide[i]; i++) {
        operation.toHidePosData[i].interPosData = target.getPosData();
      }

      self.callActions('afterGetInterMixData', arguments);
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {Operation}     operation
     * @return  {void}
     */
    setFinal: function setFinal(operation) {
      var self = this,
          target = null,
          i = -1;
      self.callActions('beforeSetFinal', arguments);
      operation.willSort && self.printSort(false, operation);

      for (i = 0; target = operation.toHide[i]; i++) {
        target.hide();
      }

      self.callActions('afterSetFinal', arguments);
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {Operation}     operation
     * @return  {void}
     */
    getFinalMixData: function getFinalMixData(operation) {
      var self = this,
          parentStyle = null,
          parentRect = null,
          target = null,
          i = -1;
      self.callActions('beforeGetFinalMixData', arguments);

      for (i = 0; target = operation.show[i]; i++) {
        operation.showPosData[i].finalPosData = target.getPosData();
      }

      for (i = 0; target = operation.toHide[i]; i++) {
        operation.toHidePosData[i].finalPosData = target.getPosData();
      } // Remove clamping


      if (self.config.animation.clampHeight || self.config.animation.clampWidth) {
        self.dom.parent.style.height = self.dom.parent.style.width = self.dom.parent.style.overflow = '';
      }

      if (!self.incPadding) {
        parentStyle = window.getComputedStyle(self.dom.parent);
      }

      parentRect = self.dom.parent.getBoundingClientRect();
      operation.newX = parentRect.left;
      operation.newY = parentRect.top;
      operation.newHeight = self.incPadding ? parentRect.height : parentRect.height - parseFloat(parentStyle.paddingTop) - parseFloat(parentStyle.paddingBottom) - parseFloat(parentStyle.borderTop) - parseFloat(parentStyle.borderBottom);
      operation.newWidth = self.incPadding ? parentRect.width : parentRect.width - parseFloat(parentStyle.paddingLeft) - parseFloat(parentStyle.paddingRight) - parseFloat(parentStyle.borderLeft) - parseFloat(parentStyle.borderRight);
      operation.viewportDeltaX = operation.docState.viewportWidth - this.dom.document.documentElement.clientWidth;
      operation.viewportDeltaY = operation.docState.viewportHeight - this.dom.document.documentElement.clientHeight;

      if (operation.willSort) {
        self.printSort(true, operation);
      }

      for (i = 0; target = operation.toShow[i]; i++) {
        target.hide();
      }

      for (i = 0; target = operation.toHide[i]; i++) {
        target.show();
      }

      if (operation.willChangeLayout) {
        h.removeClass(self.dom.container, operation.newContainerClassName);
        h.addClass(self.dom.container, self.config.layout.containerClassName);
      }

      self.callActions('afterGetFinalMixData', arguments);
    },

    /**
     * @private
     * @instance
     * @since    3.0.0
     * @param    {Operation}     operation
     */
    getTweenData: function getTweenData(operation) {
      var self = this,
          target = null,
          posData = null,
          effectNames = Object.getOwnPropertyNames(self.effectsIn),
          effectName = '',
          effect = null,
          widthChange = -1,
          heightChange = -1,
          i = -1,
          j = -1;
      self.callActions('beforeGetTweenData', arguments);

      for (i = 0; target = operation.show[i]; i++) {
        posData = operation.showPosData[i];
        posData.posIn = new _mixitup.StyleData();
        posData.posOut = new _mixitup.StyleData();
        posData.tweenData = new _mixitup.StyleData(); // Process x and y

        if (target.isShown) {
          posData.posIn.x = posData.startPosData.x - posData.interPosData.x;
          posData.posIn.y = posData.startPosData.y - posData.interPosData.y;
        } else {
          posData.posIn.x = posData.posIn.y = 0;
        }

        posData.posOut.x = posData.finalPosData.x - posData.interPosData.x;
        posData.posOut.y = posData.finalPosData.y - posData.interPosData.y; // Process opacity

        posData.posIn.opacity = target.isShown ? 1 : self.effectsIn.opacity;
        posData.posOut.opacity = 1;
        posData.tweenData.opacity = posData.posOut.opacity - posData.posIn.opacity; // Adjust x and y if not nudging

        if (!target.isShown && !self.config.animation.nudge) {
          posData.posIn.x = posData.posOut.x;
          posData.posIn.y = posData.posOut.y;
        }

        posData.tweenData.x = posData.posOut.x - posData.posIn.x;
        posData.tweenData.y = posData.posOut.y - posData.posIn.y; // Process width, height, and margins

        if (self.config.animation.animateResizeTargets) {
          posData.posIn.width = posData.startPosData.width;
          posData.posIn.height = posData.startPosData.height; // "||" Prevents width/height change from including 0 width/height if hiding or showing

          widthChange = (posData.startPosData.width || posData.finalPosData.width) - posData.interPosData.width;
          posData.posIn.marginRight = posData.startPosData.marginRight - widthChange;
          heightChange = (posData.startPosData.height || posData.finalPosData.height) - posData.interPosData.height;
          posData.posIn.marginBottom = posData.startPosData.marginBottom - heightChange;
          posData.posOut.width = posData.finalPosData.width;
          posData.posOut.height = posData.finalPosData.height;
          widthChange = (posData.finalPosData.width || posData.startPosData.width) - posData.interPosData.width;
          posData.posOut.marginRight = posData.finalPosData.marginRight - widthChange;
          heightChange = (posData.finalPosData.height || posData.startPosData.height) - posData.interPosData.height;
          posData.posOut.marginBottom = posData.finalPosData.marginBottom - heightChange;
          posData.tweenData.width = posData.posOut.width - posData.posIn.width;
          posData.tweenData.height = posData.posOut.height - posData.posIn.height;
          posData.tweenData.marginRight = posData.posOut.marginRight - posData.posIn.marginRight;
          posData.tweenData.marginBottom = posData.posOut.marginBottom - posData.posIn.marginBottom;
        } // Process transforms


        for (j = 0; effectName = effectNames[j]; j++) {
          effect = self.effectsIn[effectName];
          if (!(effect instanceof _mixitup.TransformData) || !effect.value) continue;
          posData.posIn[effectName].value = effect.value;
          posData.posOut[effectName].value = 0;
          posData.tweenData[effectName].value = posData.posOut[effectName].value - posData.posIn[effectName].value;
          posData.posIn[effectName].unit = posData.posOut[effectName].unit = posData.tweenData[effectName].unit = effect.unit;
        }
      }

      for (i = 0; target = operation.toHide[i]; i++) {
        posData = operation.toHidePosData[i];
        posData.posIn = new _mixitup.StyleData();
        posData.posOut = new _mixitup.StyleData();
        posData.tweenData = new _mixitup.StyleData(); // Process x and y

        posData.posIn.x = target.isShown ? posData.startPosData.x - posData.interPosData.x : 0;
        posData.posIn.y = target.isShown ? posData.startPosData.y - posData.interPosData.y : 0;
        posData.posOut.x = self.config.animation.nudge ? 0 : posData.posIn.x;
        posData.posOut.y = self.config.animation.nudge ? 0 : posData.posIn.y;
        posData.tweenData.x = posData.posOut.x - posData.posIn.x;
        posData.tweenData.y = posData.posOut.y - posData.posIn.y; // Process width, height, and margins

        if (self.config.animation.animateResizeTargets) {
          posData.posIn.width = posData.startPosData.width;
          posData.posIn.height = posData.startPosData.height;
          widthChange = posData.startPosData.width - posData.interPosData.width;
          posData.posIn.marginRight = posData.startPosData.marginRight - widthChange;
          heightChange = posData.startPosData.height - posData.interPosData.height;
          posData.posIn.marginBottom = posData.startPosData.marginBottom - heightChange;
        } // Process opacity


        posData.posIn.opacity = 1;
        posData.posOut.opacity = self.effectsOut.opacity;
        posData.tweenData.opacity = posData.posOut.opacity - posData.posIn.opacity; // Process transforms

        for (j = 0; effectName = effectNames[j]; j++) {
          effect = self.effectsOut[effectName];
          if (!(effect instanceof _mixitup.TransformData) || !effect.value) continue;
          posData.posIn[effectName].value = 0;
          posData.posOut[effectName].value = effect.value;
          posData.tweenData[effectName].value = posData.posOut[effectName].value - posData.posIn[effectName].value;
          posData.posIn[effectName].unit = posData.posOut[effectName].unit = posData.tweenData[effectName].unit = effect.unit;
        }
      }

      self.callActions('afterGetTweenData', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {Operation}     operation
     * @return  {void}
     */
    moveTargets: function moveTargets(operation) {
      var self = this,
          target = null,
          moveData = null,
          posData = null,
          statusChange = '',
          willTransition = false,
          staggerIndex = -1,
          i = -1,
          checkProgress = self.checkProgress.bind(self);
      self.callActions('beforeMoveTargets', arguments); // TODO: this is an extra loop in addition to the calcs
      // done in getOperation, could some of this be done there?

      for (i = 0; target = operation.show[i]; i++) {
        moveData = new _mixitup.IMoveData();
        posData = operation.showPosData[i];
        statusChange = target.isShown ? 'none' : 'show';
        willTransition = self.willTransition(statusChange, operation.hasEffect, posData.posIn, posData.posOut);

        if (willTransition) {
          // Prevent non-transitioning targets from incrementing the staggerIndex
          staggerIndex++;
        }

        target.show();
        moveData.posIn = posData.posIn;
        moveData.posOut = posData.posOut;
        moveData.statusChange = statusChange;
        moveData.staggerIndex = staggerIndex;
        moveData.operation = operation;
        moveData.callback = willTransition ? checkProgress : null;
        target.move(moveData);
      }

      for (i = 0; target = operation.toHide[i]; i++) {
        posData = operation.toHidePosData[i];
        moveData = new _mixitup.IMoveData();
        statusChange = 'hide';
        willTransition = self.willTransition(statusChange, posData.posIn, posData.posOut);
        moveData.posIn = posData.posIn;
        moveData.posOut = posData.posOut;
        moveData.statusChange = statusChange;
        moveData.staggerIndex = i;
        moveData.operation = operation;
        moveData.callback = willTransition ? checkProgress : null;
        target.move(moveData);
      }

      if (self.config.animation.animateResizeContainer) {
        self.dom.parent.style[_mixitup.features.transitionProp] = 'height ' + self.config.animation.duration + 'ms ease, ' + 'width ' + self.config.animation.duration + 'ms ease ';
        requestAnimationFrame(function () {
          if (operation.startHeight !== operation.newHeight && operation.viewportDeltaY !== operation.startHeight - operation.newHeight) {
            self.dom.parent.style.height = operation.newHeight + 'px';
          }

          if (operation.startWidth !== operation.newWidth && operation.viewportDeltaX !== operation.startWidth - operation.newWidth) {
            self.dom.parent.style.width = operation.newWidth + 'px';
          }
        });
      }

      if (operation.willChangeLayout) {
        h.removeClass(self.dom.container, self.config.layout.ContainerClassName);
        h.addClass(self.dom.container, operation.newContainerClassName);
      }

      self.callActions('afterMoveTargets', arguments);
    },

    /**
     * @private
     * @instance
     * @return  {boolean}
     */
    hasEffect: function hasEffect() {
      var self = this,
          EFFECTABLES = ['scale', 'translateX', 'translateY', 'translateZ', 'rotateX', 'rotateY', 'rotateZ'],
          effectName = '',
          effect = null,
          result = false,
          value = -1,
          i = -1;

      if (self.effectsIn.opacity !== 1) {
        return self.callFilters('resultHasEffect', true, arguments);
      }

      for (i = 0; effectName = EFFECTABLES[i]; i++) {
        effect = self.effectsIn[effectName];
        value = _typeof(effect) && effect.value !== 'undefined' ? effect.value : effect;

        if (value !== 0) {
          result = true;
          break;
        }
      }

      return self.callFilters('resultHasEffect', result, arguments);
    },

    /**
     * Determines if a target element will transition in
     * some fasion and therefore requires binding of
     * transitionEnd
     *
     * @private
     * @instance
     * @since   3.0.0
     * @param   {string}        statusChange
     * @param   {boolean}       hasEffect
     * @param   {StyleData}     posIn
     * @param   {StyleData}     posOut
     * @return  {boolean}
     */
    willTransition: function willTransition(statusChange, hasEffect, posIn, posOut) {
      var self = this,
          result = false;

      if (!h.isVisible(self.dom.container)) {
        // If the container is not visible, the transitionEnd
        // event will not occur and MixItUp will hang
        result = false;
      } else if (statusChange !== 'none' && hasEffect || posIn.x !== posOut.x || posIn.y !== posOut.y) {
        // If opacity and/or translate will change
        result = true;
      } else if (self.config.animation.animateResizeTargets) {
        // Check if width, height or margins will change
        result = posIn.width !== posOut.width || posIn.height !== posOut.height || posIn.marginRight !== posOut.marginRight || posIn.marginTop !== posOut.marginTop;
      } else {
        result = false;
      }

      return self.callFilters('resultWillTransition', result, arguments);
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {Operation}     operation
     * @return  {void}
     */
    checkProgress: function checkProgress(operation) {
      var self = this;
      self.targetsDone++;

      if (self.targetsBound === self.targetsDone) {
        self.cleanUp(operation);
      }
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {Operation}     operation
     * @return  {void}
     */
    cleanUp: function cleanUp(operation) {
      var self = this,
          target = null,
          whitespaceBefore = null,
          whitespaceAfter = null,
          nextInQueue = null,
          i = -1;
      self.callActions('beforeCleanUp', arguments);
      self.targetsMoved = self.targetsImmovable = self.targetsBound = self.targetsDone = 0;

      for (i = 0; target = operation.show[i]; i++) {
        target.cleanUp();
        target.show();
      }

      for (i = 0; target = operation.toHide[i]; i++) {
        target.cleanUp();
        target.hide();
      }

      if (operation.willSort) {
        self.printSort(false, operation);
      } // Remove any styles applied to the parent container


      self.dom.parent.style[_mixitup.features.transitionProp] = self.dom.parent.style.height = self.dom.parent.style.width = self.dom.parent.style.overflow = self.dom.parent.style[_mixitup.features.perspectiveProp] = self.dom.parent.style[_mixitup.features.perspectiveOriginProp] = '';

      if (operation.willChangeLayout) {
        h.removeClass(self.dom.container, operation.startContainerClassName);
        h.addClass(self.dom.container, operation.newContainerClassName);
      }

      if (operation.toRemove.length) {
        for (i = 0; target = self.targets[i]; i++) {
          if (operation.toRemove.indexOf(target) > -1) {
            if ((whitespaceBefore = target.dom.el.previousSibling) && whitespaceBefore.nodeName === '#text' && (whitespaceAfter = target.dom.el.nextSibling) && whitespaceAfter.nodeName === '#text') {
              h.removeWhitespace(whitespaceBefore);
            }

            if (!operation.willSort) {
              // NB: Sorting will remove targets as a bi-product of `printSort()`
              self.dom.parent.removeChild(target.dom.el);
            }

            self.targets.splice(i, 1);
            target.isInDom = false;
            i--;
          }
        } // Since targets have been removed, the original order must be updated


        self.origOrder = self.targets;
      }

      if (operation.willSort) {
        self.targets = operation.newOrder;
      }

      self.state = operation.newState;
      self.lastOperation = operation;
      self.dom.targets = self.state.targets; // mixEnd

      _mixitup.events.fire('mixEnd', self.dom.container, {
        state: self.state,
        instance: self
      }, self.dom.document);

      if (typeof self.config.callbacks.onMixEnd === 'function') {
        self.config.callbacks.onMixEnd.call(self.dom.container, self.state, self);
      }

      if (operation.hasFailed) {
        // mixFail
        _mixitup.events.fire('mixFail', self.dom.container, {
          state: self.state,
          instance: self
        }, self.dom.document);

        if (typeof self.config.callbacks.onMixFail === 'function') {
          self.config.callbacks.onMixFail.call(self.dom.container, self.state, self);
        }

        h.addClass(self.dom.container, h.getClassname(self.config.classNames, 'container', self.config.classNames.modifierFailed));
      } // User-defined callback function


      if (typeof self.userCallback === 'function') {
        self.userCallback.call(self.dom.container, self.state, self);
      }

      if (typeof self.userDeferred.resolve === 'function') {
        self.userDeferred.resolve(self.state);
      }

      self.userCallback = null;
      self.userDeferred = null;
      self.lastClicked = null;
      self.isToggling = false;
      self.isBusy = false;

      if (self.queue.length) {
        self.callActions('beforeReadQueueCleanUp', arguments);
        nextInQueue = self.queue.shift(); // Update non-public API properties stored in queue

        self.userDeferred = nextInQueue.deferred;
        self.isToggling = nextInQueue.isToggling;
        self.lastClicked = nextInQueue.triggerElement;

        if (nextInQueue.instruction.command instanceof _mixitup.CommandMultimix) {
          self.multimix.apply(self, nextInQueue.args);
        } else {
          self.dataset.apply(self, nextInQueue.args);
        }
      }

      self.callActions('afterCleanUp', arguments);
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {Array<*>}  args
     * @return  {mixitup.UserInstruction}
     */
    parseMultimixArgs: function parseMultimixArgs(args) {
      var self = this,
          instruction = new _mixitup.UserInstruction(),
          arg = null,
          i = -1;
      instruction.animate = self.config.animation.enable;
      instruction.command = new _mixitup.CommandMultimix();

      for (i = 0; i < args.length; i++) {
        arg = args[i];
        if (arg === null) continue;

        if (_typeof(arg) === 'object') {
          h.extend(instruction.command, arg);
        } else if (typeof arg === 'boolean') {
          instruction.animate = arg;
        } else if (typeof arg === 'function') {
          instruction.callback = arg;
        }
      } // Coerce arbitrary command arguments into typed command objects


      if (instruction.command.insert && !(instruction.command.insert instanceof _mixitup.CommandInsert)) {
        instruction.command.insert = self.parseInsertArgs([instruction.command.insert]).command;
      }

      if (instruction.command.remove && !(instruction.command.remove instanceof _mixitup.CommandRemove)) {
        instruction.command.remove = self.parseRemoveArgs([instruction.command.remove]).command;
      }

      if (instruction.command.filter && !(instruction.command.filter instanceof _mixitup.CommandFilter)) {
        instruction.command.filter = self.parseFilterArgs([instruction.command.filter]).command;
      }

      if (instruction.command.sort && !(instruction.command.sort instanceof _mixitup.CommandSort)) {
        instruction.command.sort = self.parseSortArgs([instruction.command.sort]).command;
      }

      if (instruction.command.changeLayout && !(instruction.command.changeLayout instanceof _mixitup.CommandChangeLayout)) {
        instruction.command.changeLayout = self.parseChangeLayoutArgs([instruction.command.changeLayout]).command;
      }

      instruction = self.callFilters('instructionParseMultimixArgs', instruction, arguments);
      h.freeze(instruction);
      return instruction;
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {Array<*>}  args
     * @return  {mixitup.UserInstruction}
     */
    parseFilterArgs: function parseFilterArgs(args) {
      var self = this,
          instruction = new _mixitup.UserInstruction(),
          arg = null,
          i = -1;
      instruction.animate = self.config.animation.enable;
      instruction.command = new _mixitup.CommandFilter();

      for (i = 0; i < args.length; i++) {
        arg = args[i];

        if (typeof arg === 'string') {
          // Selector
          instruction.command.selector = arg;
        } else if (arg === null) {
          instruction.command.collection = [];
        } else if (_typeof(arg) === 'object' && h.isElement(arg, self.dom.document)) {
          // Single element
          instruction.command.collection = [arg];
        } else if (_typeof(arg) === 'object' && typeof arg.length !== 'undefined') {
          // Multiple elements in array, NodeList or jQuery collection
          instruction.command.collection = h.arrayFromList(arg);
        } else if (_typeof(arg) === 'object') {
          // Filter command
          h.extend(instruction.command, arg);
        } else if (typeof arg === 'boolean') {
          instruction.animate = arg;
        } else if (typeof arg === 'function') {
          instruction.callback = arg;
        }
      }

      if (instruction.command.selector && instruction.command.collection) {
        throw new Error(_mixitup.messages.errorFilterInvalidArguments());
      }

      instruction = self.callFilters('instructionParseFilterArgs', instruction, arguments);
      h.freeze(instruction);
      return instruction;
    },
    parseSortArgs: function parseSortArgs(args) {
      var self = this,
          instruction = new _mixitup.UserInstruction(),
          arg = null,
          sortString = '',
          i = -1;
      instruction.animate = self.config.animation.enable;
      instruction.command = new _mixitup.CommandSort();

      for (i = 0; i < args.length; i++) {
        arg = args[i];
        if (arg === null) continue;

        switch (_typeof(arg)) {
          case 'string':
            // Sort string
            sortString = arg;
            break;

          case 'object':
            // Array of element references
            if (arg.length) {
              instruction.command.collection = h.arrayFromList(arg);
            }

            break;

          case 'boolean':
            instruction.animate = arg;
            break;

          case 'function':
            instruction.callback = arg;
            break;
        }
      }

      if (sortString) {
        instruction.command = self.parseSortString(sortString, instruction.command);
      }

      instruction = self.callFilters('instructionParseSortArgs', instruction, arguments);
      h.freeze(instruction);
      return instruction;
    },

    /**
     * @private
     * @instance
     * @since   2.0.0
     * @param   {Array<*>}  args
     * @return  {mixitup.UserInstruction}
     */
    parseInsertArgs: function parseInsertArgs(args) {
      var self = this,
          instruction = new _mixitup.UserInstruction(),
          arg = null,
          i = -1;
      instruction.animate = self.config.animation.enable;
      instruction.command = new _mixitup.CommandInsert();

      for (i = 0; i < args.length; i++) {
        arg = args[i];
        if (arg === null) continue;

        if (typeof arg === 'number') {
          // Insert index
          instruction.command.index = arg;
        } else if (typeof arg === 'string' && ['before', 'after'].indexOf(arg) > -1) {
          // 'before'/'after'
          instruction.command.position = arg;
        } else if (typeof arg === 'string') {
          // Markup
          instruction.command.collection = h.arrayFromList(h.createElement(arg).childNodes);
        } else if (_typeof(arg) === 'object' && h.isElement(arg, self.dom.document)) {
          // Single element
          !instruction.command.collection.length ? instruction.command.collection = [arg] : instruction.command.sibling = arg;
        } else if (_typeof(arg) === 'object' && arg.length) {
          // Multiple elements in array or jQuery collection
          !instruction.command.collection.length ? instruction.command.collection = arg : instruction.command.sibling = arg[0];
        } else if (_typeof(arg) === 'object' && arg.childNodes && arg.childNodes.length) {
          // Document fragment
          !instruction.command.collection.length ? instruction.command.collection = h.arrayFromList(arg.childNodes) : instruction.command.sibling = arg.childNodes[0];
        } else if (_typeof(arg) === 'object') {
          // Insert command
          h.extend(instruction.command, arg);
        } else if (typeof arg === 'boolean') {
          instruction.animate = arg;
        } else if (typeof arg === 'function') {
          instruction.callback = arg;
        }
      }

      if (instruction.command.index && instruction.command.sibling) {
        throw new Error(_mixitup.messages.errorInsertInvalidArguments());
      }

      if (!instruction.command.collection.length && self.config.debug.showWarnings) {
        console.warn(_mixitup.messages.warningInsertNoElements());
      }

      instruction = self.callFilters('instructionParseInsertArgs', instruction, arguments);
      h.freeze(instruction);
      return instruction;
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {Array<*>}  args
     * @return  {mixitup.UserInstruction}
     */
    parseRemoveArgs: function parseRemoveArgs(args) {
      var self = this,
          instruction = new _mixitup.UserInstruction(),
          target = null,
          arg = null,
          i = -1;
      instruction.animate = self.config.animation.enable;
      instruction.command = new _mixitup.CommandRemove();

      for (i = 0; i < args.length; i++) {
        arg = args[i];
        if (arg === null) continue;

        switch (_typeof(arg)) {
          case 'number':
            if (self.targets[arg]) {
              instruction.command.targets[0] = self.targets[arg];
            }

            break;

          case 'string':
            instruction.command.collection = h.arrayFromList(self.dom.parent.querySelectorAll(arg));
            break;

          case 'object':
            if (arg && arg.length) {
              instruction.command.collection = arg;
            } else if (h.isElement(arg, self.dom.document)) {
              instruction.command.collection = [arg];
            } else {
              // Remove command
              h.extend(instruction.command, arg);
            }

            break;

          case 'boolean':
            instruction.animate = arg;
            break;

          case 'function':
            instruction.callback = arg;
            break;
        }
      }

      if (instruction.command.collection.length) {
        for (i = 0; target = self.targets[i]; i++) {
          if (instruction.command.collection.indexOf(target.dom.el) > -1) {
            instruction.command.targets.push(target);
          }
        }
      }

      if (!instruction.command.targets.length && self.config.debug.showWarnings) {
        console.warn(_mixitup.messages.warningRemoveNoElements());
      }

      h.freeze(instruction);
      return instruction;
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {Array<*>}  args
     * @return  {mixitup.UserInstruction}
     */
    parseDatasetArgs: function parseDatasetArgs(args) {
      var self = this,
          instruction = new _mixitup.UserInstruction(),
          arg = null,
          i = -1;
      instruction.animate = self.config.animation.enable;
      instruction.command = new _mixitup.CommandDataset();

      for (i = 0; i < args.length; i++) {
        arg = args[i];
        if (arg === null) continue;

        switch (_typeof(arg)) {
          case 'object':
            if (Array.isArray(arg) || typeof arg.length === 'number') {
              instruction.command.dataset = arg;
            } else {
              // Change layout command
              h.extend(instruction.command, arg);
            }

            break;

          case 'boolean':
            instruction.animate = arg;
            break;

          case 'function':
            instruction.callback = arg;
            break;
        }
      }

      h.freeze(instruction);
      return instruction;
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {Array<*>}  args
     * @return  {mixitup.UserInstruction}
     */
    parseChangeLayoutArgs: function parseChangeLayoutArgs(args) {
      var self = this,
          instruction = new _mixitup.UserInstruction(),
          arg = null,
          i = -1;
      instruction.animate = self.config.animation.enable;
      instruction.command = new _mixitup.CommandChangeLayout();

      for (i = 0; i < args.length; i++) {
        arg = args[i];
        if (arg === null) continue;

        switch (_typeof(arg)) {
          case 'string':
            instruction.command.containerClassName = arg;
            break;

          case 'object':
            // Change layout command
            h.extend(instruction.command, arg);
            break;

          case 'boolean':
            instruction.animate = arg;
            break;

          case 'function':
            instruction.callback = arg;
            break;
        }
      }

      h.freeze(instruction);
      return instruction;
    },

    /**
     * @private
     * @instance
     * @since       3.0.0
     * @param       {mixitup.QueueItem}         queueItem
     * @return      {Promise.<mixitup.State>}
     */
    queueMix: function queueMix(queueItem) {
      var self = this,
          deferred = null,
          toggleSelector = '';
      self.callActions('beforeQueueMix', arguments);
      deferred = h.defer(_mixitup.libraries);

      if (self.config.animation.queue && self.queue.length < self.config.animation.queueLimit) {
        queueItem.deferred = deferred;
        self.queue.push(queueItem); // Keep controls in sync with user interactions. Mixer will catch up as it drains the queue.

        if (self.config.controls.enable) {
          if (self.isToggling) {
            self.buildToggleArray(queueItem.instruction.command);
            toggleSelector = self.getToggleSelector();
            self.updateControls({
              filter: {
                selector: toggleSelector
              }
            });
          } else {
            self.updateControls(queueItem.instruction.command);
          }
        }
      } else {
        if (self.config.debug.showWarnings) {
          console.warn(_mixitup.messages.warningMultimixInstanceQueueFull());
        }

        deferred.resolve(self.state);

        _mixitup.events.fire('mixBusy', self.dom.container, {
          state: self.state,
          instance: self
        }, self.dom.document);

        if (typeof self.config.callbacks.onMixBusy === 'function') {
          self.config.callbacks.onMixBusy.call(self.dom.container, self.state, self);
        }
      }

      return self.callFilters('promiseQueueMix', deferred.promise, arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {Array.<object>}    newDataset
     * @return  {Operation}
     */
    getDataOperation: function getDataOperation(newDataset) {
      var self = this,
          operation = new _mixitup.Operation(),
          startDataset = [];
      operation = self.callFilters('operationUnmappedGetDataOperation', operation, arguments);

      if (self.dom.targets.length && !(startDataset = self.state.activeDataset || []).length) {
        throw new Error(_mixitup.messages.errorDatasetNotSet());
      }

      operation.id = h.randomHex();
      operation.startState = self.state;
      operation.startDataset = startDataset;
      operation.newDataset = newDataset.slice();
      self.diffDatasets(operation);
      operation.startOrder = self.targets;
      operation.newOrder = operation.show;

      if (self.config.animation.enable) {
        self.getStartMixData(operation);
        self.setInter(operation);
        operation.docState = h.getDocumentState(self.dom.document);
        self.getInterMixData(operation);
        self.setFinal(operation);
        self.getFinalMixData(operation);
        self.parseEffects();
        operation.hasEffect = self.hasEffect();
        self.getTweenData(operation);
      }

      self.targets = operation.show.slice();
      operation.newState = self.buildState(operation); // NB: Targets to be removed must be included in `self.targets` for removal during clean up,
      // but are added after state is built so that state is accurate

      Array.prototype.push.apply(self.targets, operation.toRemove);
      operation = self.callFilters('operationMappedGetDataOperation', operation, arguments);
      return operation;
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {mixitup.Operation} operation
     * @return  {void}
     */
    diffDatasets: function diffDatasets(operation) {
      var self = this,
          persistantStartIds = [],
          persistantNewIds = [],
          insertedTargets = [],
          data = null,
          target = null,
          el = null,
          frag = null,
          nextEl = null,
          uids = {},
          id = '',
          i = -1;
      self.callActions('beforeDiffDatasets', arguments);

      for (i = 0; data = operation.newDataset[i]; i++) {
        if (typeof (id = data[self.config.data.uidKey]) === 'undefined' || id.toString().length < 1) {
          throw new TypeError(_mixitup.messages.errorDatasetInvalidUidKey({
            uidKey: self.config.data.uidKey
          }));
        }

        if (!uids[id]) {
          uids[id] = true;
        } else {
          throw new Error(_mixitup.messages.errorDatasetDuplicateUid({
            uid: id
          }));
        }

        if ((target = self.cache[id]) instanceof _mixitup.Target) {
          // Already in cache
          if (self.config.data.dirtyCheck && !h.deepEquals(data, target.data)) {
            // change detected
            el = target.render(data);
            target.data = data;

            if (el !== target.dom.el) {
              // Update target element reference
              if (target.isInDom) {
                target.unbindEvents();
                self.dom.parent.replaceChild(el, target.dom.el);
              }

              if (!target.isShown) {
                el.style.display = 'none';
              }

              target.dom.el = el;

              if (target.isInDom) {
                target.bindEvents();
              }
            }
          }

          el = target.dom.el;
        } else {
          // New target
          target = new _mixitup.Target();
          target.init(null, self, data);
          target.hide();
        }

        if (!target.isInDom) {
          // Adding to DOM
          if (!frag) {
            // Open frag
            frag = self.dom.document.createDocumentFragment();
          }

          if (frag.lastElementChild) {
            frag.appendChild(self.dom.document.createTextNode(' '));
          }

          frag.appendChild(target.dom.el);
          target.isInDom = true;
          target.unbindEvents();
          target.bindEvents();
          target.hide();
          operation.toShow.push(target);
          insertedTargets.push(target);
        } else {
          // Already in DOM
          nextEl = target.dom.el.nextElementSibling;
          persistantNewIds.push(id);

          if (frag) {
            // Close and insert previously opened frag
            if (frag.lastElementChild) {
              frag.appendChild(self.dom.document.createTextNode(' '));
            }

            self.insertDatasetFrag(frag, target.dom.el, insertedTargets);
            frag = null;
          }
        }

        operation.show.push(target);
      }

      if (frag) {
        // Unclosed frag remaining
        nextEl = nextEl || self.config.layout.siblingAfter;

        if (nextEl) {
          frag.appendChild(self.dom.document.createTextNode(' '));
        }

        self.insertDatasetFrag(frag, nextEl, insertedTargets);
      }

      for (i = 0; data = operation.startDataset[i]; i++) {
        id = data[self.config.data.uidKey];
        target = self.cache[id];

        if (operation.show.indexOf(target) < 0) {
          // Previously shown but now absent
          operation.hide.push(target);
          operation.toHide.push(target);
          operation.toRemove.push(target);
        } else {
          persistantStartIds.push(id);
        }
      }

      if (!h.isEqualArray(persistantStartIds, persistantNewIds)) {
        operation.willSort = true;
      }

      self.callActions('afterDiffDatasets', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.1.5
     * @param   {DocumentFragment}          frag
     * @param   {(HTMLElement|null)}        nextEl
     * @param   {Array.<mixitup.Target>}    targets
     * @return  {void}
     */
    insertDatasetFrag: function insertDatasetFrag(frag, nextEl, targets) {
      var self = this;
      var insertAt = nextEl ? h.arrayFromList(self.dom.parent.children).indexOf(nextEl) : self.targets.length;
      self.dom.parent.insertBefore(frag, nextEl);

      while (targets.length) {
        self.targets.splice(insertAt, 0, targets.shift());
        insertAt++;
      }
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {mixitup.CommandSort} sortCommandA
     * @param   {mixitup.CommandSort} sortCommandB
     * @return  {boolean}
     */
    willSort: function willSort(sortCommandA, sortCommandB) {
      var self = this,
          result = false;

      if (self.config.behavior.liveSort || sortCommandA.order === 'random' || sortCommandA.attribute !== sortCommandB.attribute || sortCommandA.order !== sortCommandB.order || sortCommandA.collection !== sortCommandB.collection || sortCommandA.next === null && sortCommandB.next || sortCommandA.next && sortCommandB.next === null) {
        result = true;
      } else if (sortCommandA.next && sortCommandB.next) {
        result = self.willSort(sortCommandA.next, sortCommandB.next);
      } else {
        result = false;
      }

      return self.callFilters('resultWillSort', result, arguments);
    },

    /**
     * A shorthand method for `.filter('all')`. Shows all targets in the container.
     *
     * @example
     *
     * .show()
     *
     * @example <caption>Example: Showing all targets</caption>
     *
     * mixer.show()
     *     .then(function(state) {
     *         console.log(state.totalShow === state.totalTargets); // true
     *     });
     *
     * @public
     * @instance
     * @since       3.0.0
     * @return      {Promise.<mixitup.State>}
     */
    show: function show() {
      var self = this;
      return self.filter('all');
    },

    /**
     * A shorthand method for `.filter('none')`. Hides all targets in the container.
     *
     * @example
     *
     * .hide()
     *
     * @example <caption>Example: Hiding all targets</caption>
     *
     * mixer.hide()
     *     .then(function(state) {
     *         console.log(state.totalShow === 0); // true
     *         console.log(state.totalHide === state.totalTargets); // true
     *     });
     *
     * @public
     * @instance
     * @since       3.0.0
     * @return      {Promise.<mixitup.State>}
     */
    hide: function hide() {
      var self = this;
      return self.filter('none');
    },

    /**
     * Returns a boolean indicating whether or not a MixItUp operation is
     * currently in progress.
     *
     * @example
     *
     * .isMixing()
     *
     * @example <caption>Example: Checking the status of a mixer</caption>
     *
     * mixer.sort('random', function() {
     *     console.log(mixer.isMixing()) // false
     * });
     *
     * console.log(mixer.isMixing()) // true
     *
     * @public
     * @instance
     * @since   2.0.0
     * @return  {boolean}
     */
    isMixing: function isMixing() {
      var self = this;
      return self.isBusy;
    },

    /**
     * Filters all targets in the container by a provided selector string, or the values `'all'`
     * or `'none'`. Only targets matching the selector will be shown.
     *
     * @example
     *
     * .filter(selector [, animate] [, callback])
     *
     * @example <caption>Example 1: Filtering targets by a class selector</caption>
     *
     * mixer.filter('.category-a')
     *     .then(function(state) {
     *         console.log(state.totalShow === containerEl.querySelectorAll('.category-a').length); // true
     *     });
     *
     * @example <caption>Example 2: Filtering targets by an attribute selector</caption>
     *
     * mixer.filter('[data-category~="a"]')
     *     .then(function(state) {
     *         console.log(state.totalShow === containerEl.querySelectorAll('[data-category~="a"]').length); // true
     *     });
     *
     * @example <caption>Example 3: Filtering targets by a compound selector</caption>
     *
     * // Show only those targets with the classes 'category-a' AND 'category-b'
     *
     * mixer.filter('.category-a.category-c')
     *     .then(function(state) {
     *         console.log(state.totalShow === containerEl.querySelectorAll('.category-a.category-c').length); // true
     *     });
     *
     * @example <caption>Example 4: Filtering via an element collection</caption>
     *
     * var collection = Array.from(container.querySelectorAll('.mix'));
     *
     * console.log(collection.length); // 34
     *
     * // Filter the collection manually using Array.prototype.filter
     *
     * var filtered = collection.filter(function(target) {
     *    return parseInt(target.getAttribute('data-price')) > 10;
     * });
     *
     * console.log(filtered.length); // 22
     *
     * // Pass the filtered collection to MixItUp
     *
     * mixer.filter(filtered)
     *    .then(function(state) {
     *        console.log(state.activeFilter.collection.length === 22); // true
     *    });
     *
     * @public
     * @instance
     * @since       2.0.0
     * @param       {(string|HTMLElement|Array.<HTMLElement>)} selector
     *      Any valid CSS selector (i.e. `'.category-a'`), or the values `'all'` or `'none'`. The filter method also accepts a reference to single target element or a collection of target elements to show.
     * @param       {boolean}   [animate=true]
     *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.
     * @param       {function}  [callback=null]
     *      An optional callback function to be invoked after the operation has completed.
     * @return      {Promise.<mixitup.State>}
     *      A promise resolving with the current state object.
     */
    filter: function filter() {
      var self = this,
          instruction = self.parseFilterArgs(arguments);
      return self.multimix({
        filter: instruction.command
      }, instruction.animate, instruction.callback);
    },

    /**
     * Adds an additional selector to the currently active filter selector, concatenating
     * as per the logic defined in `controls.toggleLogic`.
     *
     * @example
     *
     * .toggleOn(selector [, animate] [, callback])
     *
     * @example <caption>Example: Toggling on a filter selector</caption>
     *
     * console.log(mixer.getState().activeFilter.selector); // '.category-a'
     *
     * mixer.toggleOn('.category-b')
     *     .then(function(state) {
     *         console.log(state.activeFilter.selector); // '.category-a, .category-b'
     *     });
     *
     * @public
     * @instance
     * @since       3.0.0
     * @param       {string}    selector
     *      Any valid CSS selector (i.e. `'.category-a'`)
     * @param       {boolean}   [animate=true]
     *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.
     * @param       {function}  [callback=null]
     *      An optional callback function to be invoked after the operation has completed.
     * @return      {Promise.<mixitup.State>}
     *      A promise resolving with the current state object.
     */
    toggleOn: function toggleOn() {
      var self = this,
          instruction = self.parseFilterArgs(arguments),
          selector = instruction.command.selector,
          toggleSelector = '';
      self.isToggling = true;

      if (self.toggleArray.indexOf(selector) < 0) {
        self.toggleArray.push(selector);
      }

      toggleSelector = self.getToggleSelector();
      return self.multimix({
        filter: toggleSelector
      }, instruction.animate, instruction.callback);
    },

    /**
     * Removes a selector from the active filter selector.
     *
     * @example
     *
     * .toggleOff(selector [, animate] [, callback])
     *
     * @example <caption>Example: Toggling off a filter selector</caption>
     *
     * console.log(mixer.getState().activeFilter.selector); // '.category-a, .category-b'
     *
     * mixer.toggleOff('.category-b')
     *     .then(function(state) {
     *         console.log(state.activeFilter.selector); // '.category-a'
     *     });
     *
     * @public
     * @instance
     * @since       3.0.0
     * @param       {string}    selector
     *      Any valid CSS selector (i.e. `'.category-a'`)
     * @param       {boolean}   [animate=true]
     *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.
     * @param       {function}  [callback=null]
     *      An optional callback function to be invoked after the operation has completed.
     * @return      {Promise.<mixitup.State>}
     *      A promise resolving with the current state object.
     */
    toggleOff: function toggleOff() {
      var self = this,
          instruction = self.parseFilterArgs(arguments),
          selector = instruction.command.selector,
          selectorIndex = self.toggleArray.indexOf(selector),
          toggleSelector = '';
      self.isToggling = true;

      if (selectorIndex > -1) {
        self.toggleArray.splice(selectorIndex, 1);
      }

      toggleSelector = self.getToggleSelector();
      return self.multimix({
        filter: toggleSelector
      }, instruction.animate, instruction.callback);
    },

    /**
     * Sorts all targets in the container according to a provided sort string.
     *
     * @example
     *
     * .sort(sortString [, animate] [, callback])
     *
     * @example <caption>Example 1: Sorting by the default DOM order</caption>
     *
     * // Reverse the default order of the targets
     *
     * mixer.sort('default:desc')
     *     .then(function(state) {
     *         console.log(state.activeSort.attribute === 'default'); // true
     *         console.log(state.activeSort.order === 'desc'); // true
     *     });
     *
     * @example <caption>Example 2: Sorting by a custom data-attribute</caption>
     *
     * // Sort the targets by the value of a `data-published-date` attribute
     *
     * mixer.sort('published-date:asc')
     *     .then(function(state) {
     *         console.log(state.activeSort.attribute === 'published-date'); // true
     *         console.log(state.activeSort.order === 'asc'); // true
     *     });
     *
     * @example <caption>Example 3: Sorting by multiple attributes</caption>
     *
     * // Sort the targets by the value of a `data-published-date` attribute, then by `data-title`
     *
     * mixer.sort('published-date:desc data-title:asc')
     *     .then(function(state) {
     *         console.log(state.activeSort.attribute === 'published-date'); // true
     *         console.log(state.activeSort.order === 'desc'); // true
     *
     *         console.log(state.activeSort.next.attribute === 'title'); // true
     *         console.log(state.activeSort.next.order === 'asc'); // true
     *     });
     *
     * @example <caption>Example 4: Sorting by random</caption>
     *
     * mixer.sort('random')
     *     .then(function(state) {
     *         console.log(state.activeSort.order === 'random') // true
     *     });
     *
     * @example <caption>Example 5: Sorting via an element collection</caption>
     *
     * var collection = Array.from(container.querySelectorAll('.mix'));
     *
     * // Swap the position of two elements in the collection:
     *
     * var temp = collection[1];
     *
     * collection[1] = collection[0];
     * collection[0] = temp;
     *
     * // Pass the sorted collection to MixItUp
     *
     * mixer.sort(collection)
     *     .then(function(state) {
     *         console.log(state.targets[0] === collection[0]); // true
     *     });
     *
     * @public
     * @instance
     * @since       2.0.0
     * @param       {(string|Array.<HTMLElement>)}    sortString
     *      A valid sort string (e.g. `'default'`, `'published-date:asc'`, or `'random'`). The sort method also accepts an array of all target elements in a user-defined order.
     * @param       {boolean}   [animate=true]
     *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.
     * @param       {function}  [callback=null]
     *      An optional callback function to be invoked after the operation has completed.
     * @return      {Promise.<mixitup.State>}
     *      A promise resolving with the current state object.
     */
    sort: function sort() {
      var self = this,
          instruction = self.parseSortArgs(arguments);
      return self.multimix({
        sort: instruction.command
      }, instruction.animate, instruction.callback);
    },

    /**
     * Changes the layout of the container by adding, removing or updating a
     * layout-specific class name. If `animation.animateResizetargets` is
     * enabled, MixItUp will attempt to gracefully animate the width, height,
     * and position of targets between layout states.
     *
     * @example
     *
     * .changeLayout(containerClassName [, animate] [, callback])
     *
     * @example <caption>Example 1: Adding a new class name to the container</caption>
     *
     * mixer.changeLayout('container-list')
     *      .then(function(state) {
     *          console.log(state.activeContainerClass === 'container-list'); // true
     *      });
     *
     * @example <caption>Example 2: Removing a previously added class name from the container</caption>
     *
     * mixer.changeLayout('')
     *      .then(function(state) {
     *          console.log(state.activeContainerClass === ''); // true
     *      });
     *
     * @public
     * @instance
     * @since       2.0.0
     * @param       {string}    containerClassName
     *      A layout-specific class name to add to the container.
     * @param       {boolean}   [animate=true]
     *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.
     * @param       {function}  [callback=null]
     *      An optional callback function to be invoked after the operation has completed.
     * @return      {Promise.<mixitup.State>}
     *      A promise resolving with the current state object.
     */
    changeLayout: function changeLayout() {
      var self = this,
          instruction = self.parseChangeLayoutArgs(arguments);
      return self.multimix({
        changeLayout: instruction.command
      }, instruction.animate, instruction.callback);
    },

    /**
     * Updates the contents and order of the container to reflect the provided dataset,
     * if the dataset API is in use.
     *
     * The dataset API is designed for use in API-driven JavaScript applications, and
     * can be used instead of DOM-based methods such as `.filter()`, `.sort()`,
     * `.insert()`, etc. When used, insertion, removal, sorting and pagination can be
     * achieved purely via changes to your data model, without the uglyness of having
     * to interact with or query the DOM directly.
     *
     * @example
     *
     * .dataset(dataset [, animate] [, callback])
     *
     * @example <caption>Example 1: Rendering a dataset</caption>
     *
     * var myDataset = [
     *     {id: 1, ...},
     *     {id: 2, ...},
     *     {id: 3, ...}
     * ];
     *
     * mixer.dataset(myDataset)
     *     .then(function(state) {
     *         console.log(state.totalShow === 3); // true
     *     });
     *
     * @example <caption>Example 2: Sorting a dataset</caption>
     *
     * // Create a new dataset in reverse order
     *
     * var newDataset = myDataset.slice().reverse();
     *
     * mixer.dataset(newDataset)
     *     .then(function(state) {
     *         console.log(state.activeDataset[0] === myDataset[2]); // true
     *     });
     *
     * @example <caption>Example 3: Removing an item from the dataset</caption>
     *
     * console.log(myDataset.length); // 3
     *
     * // Create a new dataset with the last item removed.
     *
     * var newDataset = myDataset.slice().pop();
     *
     * mixer.dataset(newDataset)
     *     .then(function(state) {
     *         console.log(state.totalShow === 2); // true
     *     });
     *
     * @public
     * @instance
     * @since       3.0.0
     * @param       {Array.<object>}    dataset
     *      An array of objects, each one representing the underlying data model of a target to be rendered.
     * @param       {boolean}           [animate=true]
     *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.
     * @param       {function}          [callback=null]
     *      An optional callback function to be invoked after the operation has completed.
     * @return      {Promise.<mixitup.State>}
     *      A promise resolving with the current state object.
     */
    dataset: function dataset() {
      var self = this,
          instruction = self.parseDatasetArgs(arguments),
          operation = null,
          queueItem = null,
          animate = false;
      self.callActions('beforeDataset', arguments);

      if (!self.isBusy) {
        if (instruction.callback) self.userCallback = instruction.callback;
        animate = instruction.animate ^ self.config.animation.enable ? instruction.animate : self.config.animation.enable;
        operation = self.getDataOperation(instruction.command.dataset);
        return self.goMix(animate, operation);
      } else {
        queueItem = new _mixitup.QueueItem();
        queueItem.args = arguments;
        queueItem.instruction = instruction;
        return self.queueMix(queueItem);
      }
    },

    /**
     * Performs simultaneous `filter`, `sort`, `insert`, `remove` and `changeLayout`
     * operations as requested.
     *
     * @example
     *
     * .multimix(multimixCommand [, animate] [, callback])
     *
     * @example <caption>Example 1: Performing simultaneous filtering and sorting</caption>
     *
     * mixer.multimix({
     *     filter: '.category-b',
     *     sort: 'published-date:desc'
     * })
     *     .then(function(state) {
     *         console.log(state.activeFilter.selector === '.category-b'); // true
     *         console.log(state.activeSort.attribute === 'published-date'); // true
     *     });
     *
     * @example <caption>Example 2: Performing simultaneous sorting, insertion, and removal</caption>
     *
     * console.log(mixer.getState().totalShow); // 6
     *
     * // NB: When inserting via `multimix()`, an object should be provided as the value
     * // for the `insert` portion of the command, allowing for a collection of elements
     * // and an insertion index to be specified.
     *
     * mixer.multimix({
     *     sort: 'published-date:desc', // Sort the container, including any new elements
     *     insert: {
     *         collection: [newElementReferenceA, newElementReferenceB], // Add 2 new elements at index 5
     *         index: 5
     *     },
     *     remove: existingElementReference // Remove 1 existing element
     * })
     *     .then(function(state) {
     *         console.log(state.activeSort.attribute === 'published-date'); // true
     *         console.log(state.totalShow === 7); // true
     *     });
     *
     * @public
     * @instance
     * @since       2.0.0
     * @param       {object}    multimixCommand
     *      An object containing one or more things to do
     * @param       {boolean}   [animate=true]
     *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.
     * @param       {function}  [callback=null]
     *      An optional callback function to be invoked after the operation has completed.
     * @return      {Promise.<mixitup.State>}
     *      A promise resolving with the current state object.
     */
    multimix: function multimix() {
      var self = this,
          operation = null,
          animate = false,
          queueItem = null,
          instruction = self.parseMultimixArgs(arguments);
      self.callActions('beforeMultimix', arguments);

      if (!self.isBusy) {
        operation = self.getOperation(instruction.command);

        if (self.config.controls.enable) {
          // Update controls for API calls
          if (instruction.command.filter && !self.isToggling) {
            // As we are not toggling, reset the toggle array
            // so new filter overrides existing toggles
            self.toggleArray.length = 0;
            self.buildToggleArray(operation.command);
          }

          if (self.queue.length < 1) {
            self.updateControls(operation.command);
          }
        }

        if (instruction.callback) self.userCallback = instruction.callback; // Always allow the instruction to override the instance setting

        animate = instruction.animate ^ self.config.animation.enable ? instruction.animate : self.config.animation.enable;
        self.callFilters('operationMultimix', operation, arguments);
        return self.goMix(animate, operation);
      } else {
        queueItem = new _mixitup.QueueItem();
        queueItem.args = arguments;
        queueItem.instruction = instruction;
        queueItem.triggerElement = self.lastClicked;
        queueItem.isToggling = self.isToggling;
        return self.queueMix(queueItem);
      }
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {object}            multimixCommand
     * @param   {boolean}           [isPreFetch]
     *      An optional boolean indicating that the operation is being pre-fetched for execution at a later time.
     * @return  {Operation|null}
     */
    getOperation: function getOperation(multimixCommand) {
      var self = this,
          sortCommand = multimixCommand.sort,
          filterCommand = multimixCommand.filter,
          changeLayoutCommand = multimixCommand.changeLayout,
          removeCommand = multimixCommand.remove,
          insertCommand = multimixCommand.insert,
          operation = new _mixitup.Operation();
      operation = self.callFilters('operationUnmappedGetOperation', operation, arguments);
      operation.id = h.randomHex();
      operation.command = multimixCommand;
      operation.startState = self.state;
      operation.triggerElement = self.lastClicked;

      if (self.isBusy) {
        if (self.config.debug.showWarnings) {
          console.warn(_mixitup.messages.warningGetOperationInstanceBusy());
        }

        return null;
      }

      if (insertCommand) {
        self.insertTargets(insertCommand, operation);
      }

      if (removeCommand) {
        operation.toRemove = removeCommand.targets;
      }

      operation.startSort = operation.newSort = operation.startState.activeSort;
      operation.startOrder = operation.newOrder = self.targets;

      if (sortCommand) {
        operation.startSort = operation.startState.activeSort;
        operation.newSort = sortCommand;
        operation.willSort = self.willSort(sortCommand, operation.startState.activeSort);

        if (operation.willSort) {
          self.sortOperation(operation);
        }
      }

      operation.startFilter = operation.startState.activeFilter;

      if (filterCommand) {
        operation.newFilter = filterCommand;
      } else {
        operation.newFilter = h.extend(new _mixitup.CommandFilter(), operation.startFilter);
      }

      if (operation.newFilter.selector === 'all') {
        operation.newFilter.selector = self.config.selectors.target;
      } else if (operation.newFilter.selector === 'none') {
        operation.newFilter.selector = '';
      }

      self.filterOperation(operation);
      operation.startContainerClassName = operation.startState.activeContainerClassName;

      if (changeLayoutCommand) {
        operation.newContainerClassName = changeLayoutCommand.containerClassName;

        if (operation.newContainerClassName !== operation.startContainerClassName) {
          operation.willChangeLayout = true;
        }
      } else {
        operation.newContainerClassName = operation.startContainerClassName;
      }

      if (self.config.animation.enable) {
        // Populate the operation's position data
        self.getStartMixData(operation);
        self.setInter(operation);
        operation.docState = h.getDocumentState(self.dom.document);
        self.getInterMixData(operation);
        self.setFinal(operation);
        self.getFinalMixData(operation);
        self.parseEffects();
        operation.hasEffect = self.hasEffect();
        self.getTweenData(operation);
      }

      if (operation.willSort) {
        self.targets = operation.newOrder;
      }

      operation.newState = self.buildState(operation);
      return self.callFilters('operationMappedGetOperation', operation, arguments);
    },

    /**
     * Renders a previously created operation at a specific point in its path, as
     * determined by a multiplier between 0 and 1.
     *
     * @example
     * .tween(operation, multiplier)
     *
     * @private
     * @instance
     * @since   3.0.0
     * @param   {mixitup.Operation}     operation
     *      An operation object created via the `getOperation` method
     *
     * @param   {Float}                 multiplier
     *      Any number between 0 and 1 representing the percentage complete of the operation
     * @return  {void}
     */
    tween: function tween(operation, multiplier) {
      var target = null,
          posData = null,
          toHideIndex = -1,
          i = -1;
      multiplier = Math.min(multiplier, 1);
      multiplier = Math.max(multiplier, 0);

      for (i = 0; target = operation.show[i]; i++) {
        posData = operation.showPosData[i];
        target.applyTween(posData, multiplier);
      }

      for (i = 0; target = operation.hide[i]; i++) {
        if (target.isShown) {
          target.hide();
        }

        if ((toHideIndex = operation.toHide.indexOf(target)) > -1) {
          posData = operation.toHidePosData[toHideIndex];

          if (!target.isShown) {
            target.show();
          }

          target.applyTween(posData, multiplier);
        }
      }
    },

    /**
     * Inserts one or more new target elements into the container at a specified
     * index.
     *
     * To be indexed as targets, new elements must match the `selectors.target`
     * selector (`'.mix'` by default).
     *
     * @example
     *
     * .insert(newElements [, index] [, animate], [, callback])
     *
     * @example <caption>Example 1: Inserting a single element via reference</caption>
     *
     * console.log(mixer.getState().totalShow); // 0
     *
     * // Create a new element
     *
     * var newElement = document.createElement('div');
     * newElement.classList.add('mix');
     *
     * mixer.insert(newElement)
     *     .then(function(state) {
     *         console.log(state.totalShow === 1); // true
     *     });
     *
     * @example <caption>Example 2: Inserting a single element via HTML string</caption>
     *
     * console.log(mixer.getState().totalShow); // 1
     *
     * // Create a new element via reference
     *
     * var newElementHtml = '&lt;div class="mix"&gt;&lt;/div&gt;';
     *
     * // Create and insert the new element at index 1
     *
     * mixer.insert(newElementHtml, 1)
     *     .then(function(state) {
     *         console.log(state.totalShow === 2); // true
     *         console.log(state.show[1].outerHTML === newElementHtml); // true
     *     });
     *
     * @example <caption>Example 3: Inserting multiple elements via reference</caption>
     *
     * console.log(mixer.getState().totalShow); // 2
     *
     * // Create an array of new elements to insert.
     *
     * var newElement1 = document.createElement('div');
     * var newElement2 = document.createElement('div');
     *
     * newElement1.classList.add('mix');
     * newElement2.classList.add('mix');
     *
     * var newElementsCollection = [newElement1, newElement2];
     *
     * // Insert the new elements starting at index 1
     *
     * mixer.insert(newElementsCollection, 1)
     *     .then(function(state) {
     *         console.log(state.totalShow === 4); // true
     *         console.log(state.show[1] === newElement1); // true
     *         console.log(state.show[2] === newElement2); // true
     *     });
     *
     * @example <caption>Example 4: Inserting a jQuery collection object containing one or more elements</caption>
     *
     * console.log(mixer.getState().totalShow); // 4
     *
     * var $newElement = $('&lt;div class="mix"&gt;&lt;/div&gt;');
     *
     * // Insert the new elements starting at index 3
     *
     * mixer.insert($newElement, 3)
     *     .then(function(state) {
     *         console.log(state.totalShow === 5); // true
     *         console.log(state.show[3] === $newElement[0]); // true
     *     });
     *
     * @public
     * @instance
     * @since       2.0.0
     * @param       {(HTMLElement|Array.<HTMLElement>|string)}    newElements
     *      A reference to a single element to insert, an array-like collection of elements, or an HTML string representing a single element.
     * @param       {number}    index=0
     *      The index at which to insert the new element(s). `0` by default.
     * @param       {boolean}   [animate=true]
     *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.
     * @param       {function}  [callback=null]
     *      An optional callback function to be invoked after the operation has completed.
     * @return      {Promise.<mixitup.State>}
     *      A promise resolving with the current state object.
     */
    insert: function insert() {
      var self = this,
          args = self.parseInsertArgs(arguments);
      return self.multimix({
        insert: args.command
      }, args.animate, args.callback);
    },

    /**
     * Inserts one or more new elements before a provided reference element.
     *
     * @example
     *
     * .insertBefore(newElements, referenceElement [, animate] [, callback])
     *
     * @example <caption>Example: Inserting a new element before a reference element</caption>
     *
     * // An existing reference element is chosen at index 2
     *
     * var referenceElement = mixer.getState().show[2];
     *
     * // Create a new element
     *
     * var newElement = document.createElement('div');
     * newElement.classList.add('mix');
     *
     * mixer.insertBefore(newElement, referenceElement)
     *     .then(function(state) {
     *         // The new element is inserted into the container at index 2, before the reference element
     *
     *         console.log(state.show[2] === newElement); // true
     *
     *         // The reference element is now at index 3
     *
     *         console.log(state.show[3] === referenceElement); // true
     *     });
     *
     * @public
     * @instance
     * @since       3.0.0
     * @param       {(HTMLElement|Array.<HTMLElement>|string)}    newElements
     *      A reference to a single element to insert, an array-like collection of elements, or an HTML string representing a single element.
     * @param       {HTMLElement}    referenceElement
     *      A reference to an existing element in the container to insert new elements before.
     *@param       {boolean}   [animate=true]
     *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.
     * @param       {function}  [callback=null]
     *      An optional callback function to be invoked after the operation has completed.
     * @return      {Promise.<mixitup.State>}
     *      A promise resolving with the current state object.
     */
    insertBefore: function insertBefore() {
      var self = this,
          args = self.parseInsertArgs(arguments);
      return self.insert(args.command.collection, 'before', args.command.sibling, args.animate, args.callback);
    },

    /**
     * Inserts one or more new elements after a provided reference element.
     *
     * @example
     *
     * .insertAfter(newElements, referenceElement [, animate] [, callback])
     *
     * @example <caption>Example: Inserting a new element after a reference element</caption>
     *
     * // An existing reference element is chosen at index 2
     *
     * var referenceElement = mixer.getState().show[2];
     *
     * // Create a new element
     *
     * var newElement = document.createElement('div');
     * newElement.classList.add('mix');
     *
     * mixer.insertAfter(newElement, referenceElement)
     *     .then(function(state) {
     *         // The new element is inserted into the container at index 3, after the reference element
     *
     *         console.log(state.show[3] === newElement); // true
     *     });
     *
     * @public
     * @instance
     * @since       3.0.0
     * @param       {(HTMLElement|Array.<HTMLElement>|string)}    newElements
     *      A reference to a single element to insert, an array-like collection of elements, or an HTML string representing a single element.
     * @param       {HTMLElement}    referenceElement
     *      A reference to an existing element in the container to insert new elements after.
     * @param       {boolean}   [animate=true]
     *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.
     * @param       {function}  [callback=null]
     *      An optional callback function to be invoked after the operation has completed.
     * @return      {Promise.<mixitup.State>}
     *      A promise resolving with the current state object.
     */
    insertAfter: function insertAfter() {
      var self = this,
          args = self.parseInsertArgs(arguments);
      return self.insert(args.command.collection, 'after', args.command.sibling, args.animate, args.callback);
    },

    /**
     * Inserts one or more new elements into the container before all existing targets.
     *
     * @example
     *
     * .prepend(newElements [,animate] [,callback])
     *
     * @example <caption>Example: Prepending a new element</caption>
     *
     * // Create a new element
     *
     * var newElement = document.createElement('div');
     * newElement.classList.add('mix');
     *
     * // Insert the element into the container
     *
     * mixer.prepend(newElement)
     *     .then(function(state) {
     *         console.log(state.show[0] === newElement); // true
     *     });
     *
     * @public
     * @instance
     * @since       3.0.0
     * @param       {(HTMLElement|Array.<HTMLElement>|string)}    newElements
     *      A reference to a single element to insert, an array-like collection of elements, or an HTML string representing a single element.
     * @param       {boolean}   [animate=true]
     *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.
     * @param       {function}  [callback=null]
     *      An optional callback function to be invoked after the operation has completed.
     * @return      {Promise.<mixitup.State>}
     *      A promise resolving with the current state object.
     */
    prepend: function prepend() {
      var self = this,
          args = self.parseInsertArgs(arguments);
      return self.insert(0, args.command.collection, args.animate, args.callback);
    },

    /**
     * Inserts one or more new elements into the container after all existing targets.
     *
     * @example
     *
     * .append(newElements [,animate] [,callback])
     *
     * @example <caption>Example: Appending a new element</caption>
     *
     * // Create a new element
     *
     * var newElement = document.createElement('div');
     * newElement.classList.add('mix');
     *
     * // Insert the element into the container
     *
     * mixer.append(newElement)
     *     .then(function(state) {
     *         console.log(state.show[state.show.length - 1] === newElement); // true
     *     });
     *
     * @public
     * @instance
     * @since       3.0.0
     * @param       {(HTMLElement|Array.<HTMLElement>|string)}    newElements
     *      A reference to a single element to insert, an array-like collection of elements, or an HTML string representing a single element.
     * @param       {boolean}   [animate=true]
     *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.
     * @param       {function}  [callback=null]
     *      An optional callback function to be invoked after the operation has completed.
     * @return      {Promise.<mixitup.State>}
     *      A promise resolving with the current state object.
     */
    append: function append() {
      var self = this,
          args = self.parseInsertArgs(arguments);
      return self.insert(self.state.totalTargets, args.command.collection, args.animate, args.callback);
    },

    /**
     * Removes one or more existing target elements from the container.
     *
     * @example
     *
     * .remove(elements [, animate] [, callback])
     *
     * @example <caption>Example 1: Removing an element by reference</caption>
     *
     * var elementToRemove = containerEl.firstElementChild;
     *
     * mixer.remove(elementToRemove)
     *      .then(function(state) {
     *          console.log(state.targets.indexOf(elementToRemove) === -1); // true
     *      });
     *
     * @example <caption>Example 2: Removing a collection of elements by reference</caption>
     *
     * var elementsToRemove = containerEl.querySelectorAll('.category-a');
     *
     * console.log(elementsToRemove.length) // 3
     *
     * mixer.remove(elementsToRemove)
     *      .then(function() {
     *          console.log(containerEl.querySelectorAll('.category-a').length); // 0
     *      });
     *
     * @example <caption>Example 3: Removing one or more elements by selector</caption>
     *
     * mixer.remove('.category-a')
     *      .then(function() {
     *          console.log(containerEl.querySelectorAll('.category-a').length); // 0
     *      });
     *
     * @example <caption>Example 4: Removing an element by index</caption>
     *
     * console.log(mixer.getState.totalShow); // 4
     *
     * // Remove the element at index 3
     *
     * mixer.remove(3)
     *      .then(function(state) {
     *          console.log(state.totalShow); // 3
     *          console.log(state.show[3]); // undefined
     *      });
     *
     *
     * @public
     * @instance
     * @since       3.0.0
     * @param       {(HTMLElement|Array.<HTMLElement>|string|number)}    elements
     *      A reference to a single element to remove, an array-like collection of elements, a selector string, or the index of an element to remove.
     * @param       {boolean}   [animate=true]
     *      An optional boolean dictating whether the operation should animate, or occur syncronously with no animation. `true` by default.
     * @param       {function}  [callback=null]
     *      An optional callback function to be invoked after the operation has completed.
     * @return      {Promise.<mixitup.State>}
     *      A promise resolving with the current state object.
     */
    remove: function remove() {
      var self = this,
          args = self.parseRemoveArgs(arguments);
      return self.multimix({
        remove: args.command
      }, args.animate, args.callback);
    },

    /**
     * Retrieves the the value of any property or sub-object within the current
     * mixitup configuration, or the whole configuration object.
     *
     * @example
     *
     * .getConfig([stringKey])
     *
     * @example <caption>Example 1: retrieve the entire configuration object</caption>
     *
     * var config = mixer.getConfig(); // Config { ... }
     *
     * @example <caption>Example 2: retrieve a named sub-object of configuration object</caption>
     *
     * var animation = mixer.getConfig('animation'); // ConfigAnimation { ... }
     *
     * @example <caption>Example 3: retrieve a value of configuration object via a dot-notation string key</caption>
     *
     * var effects = mixer.getConfig('animation.effects'); // 'fade scale'
     *
     * @public
     * @instance
     * @since       2.0.0
     * @param       {string}    [stringKey]    A "dot-notation" string key
     * @return      {*}
     */
    getConfig: function getConfig(stringKey) {
      var self = this,
          value = null;

      if (!stringKey) {
        value = self.config;
      } else {
        value = h.getProperty(self.config, stringKey);
      }

      return self.callFilters('valueGetConfig', value, arguments);
    },

    /**
     * Updates the configuration of the mixer, after it has been instantiated.
     *
     * See the Configuration Object documentation for a full list of avilable
     * configuration options.
     *
     * @example
     *
     * .configure(config)
     *
     * @example <caption>Example 1: Updating animation options</caption>
     *
     * mixer.configure({
     *     animation: {
     *         effects: 'fade translateX(-100%)',
     *         duration: 300
     *     }
     * });
     *
     * @example <caption>Example 2: Removing a callback after it has been set</caption>
     *
     * var mixer;
     *
     * function handleMixEndOnce() {
     *     // Do something ..
     *
     *     // Then nullify the callback
     *
     *     mixer.configure({
     *         callbacks: {
     *             onMixEnd: null
     *         }
     *     });
     * };
     *
     * // Instantiate a mixer with a callback defined
     *
     * mixer = mixitup(containerEl, {
     *     callbacks: {
     *         onMixEnd: handleMixEndOnce
     *     }
     * });
     *
     * @public
     * @instance
     * @since       3.0.0
     * @param       {object}    config
     *      An object containing one of more configuration options.
     * @return      {void}
     */
    configure: function configure(config) {
      var self = this;
      self.callActions('beforeConfigure', arguments);
      h.extend(self.config, config, true, true);
      self.callActions('afterConfigure', arguments);
    },

    /**
     * Returns an object containing information about the current state of the
     * mixer. See the State Object documentation for more information.
     *
     * NB: State objects are immutable and should therefore be regenerated
     * after any operation.
     *
     * @example
     *
     * .getState();
     *
     * @example <caption>Example: Retrieving a state object</caption>
     *
     * var state = mixer.getState();
     *
     * console.log(state.totalShow + 'targets are currently shown');
     *
     * @public
     * @instance
     * @since       2.0.0
     * @return      {mixitup.State} An object reflecting the current state of the mixer.
     */
    getState: function getState() {
      var self = this,
          state = null;
      state = new _mixitup.State();
      h.extend(state, self.state);
      h.freeze(state);
      return self.callFilters('stateGetState', state, arguments);
    },

    /**
     * Forces the re-indexing all targets within the container.
     *
     * This should only be used if some other piece of code in your application
     * has manipulated the contents of your container, which should be avoided.
     *
     * If you need to add or remove target elements from the container, use
     * the built-in `.insert()` or `.remove()` methods, and MixItUp will keep
     * itself up to date.
     *
     * @example
     *
     * .forceRefresh()
     *
     * @example <caption>Example: Force refreshing the mixer after external DOM manipulation</caption>
     *
     * console.log(mixer.getState().totalShow); // 3
     *
     * // An element is removed from the container via some external DOM manipulation code:
     *
     * containerEl.removeChild(containerEl.firstElementChild);
     *
     * // The mixer does not know that the number of targets has changed:
     *
     * console.log(mixer.getState().totalShow); // 3
     *
     * mixer.forceRefresh();
     *
     * // After forceRefresh, the mixer is in sync again:
     *
     * console.log(mixer.getState().totalShow); // 2
     *
     * @public
     * @instance
     * @since 2.1.2
     * @return {void}
     */
    forceRefresh: function forceRefresh() {
      var self = this;
      self.indexTargets();
    },

    /**
     * Forces the re-rendering of all targets when using the Dataset API.
     *
     * By default, targets are only re-rendered when `data.dirtyCheck` is
     * enabled, and an item's data has changed when `dataset()` is called.
     *
     * The `forceRender()` method allows for the re-rendering of all targets
     * in response to some arbitrary event, such as the changing of the target
     * render function.
     *
     * Targets are rendered against their existing data.
     *
     * @example
     *
     * .forceRender()
     *
     * @example <caption>Example: Force render targets after changing the target render function</caption>
     *
     * console.log(container.innerHTML); // ... &lt;span class="mix"&gt;Foo&lt;/span&gt; ...
     *
     * mixer.configure({
     *     render: {
     *         target: (item) => `&lt;a href="/${item.slug}/" class="mix"&gt;${item.title}&lt;/a&gt;`
     *     }
     * });
     *
     * mixer.forceRender();
     *
     * console.log(container.innerHTML); // ... &lt;a href="/foo/" class="mix"&gt;Foo&lt;/a&gt; ...
     *
     * @public
     * @instance
     * @since 3.2.1
     * @return {void}
     */
    forceRender: function forceRender() {
      var self = this,
          target = null,
          el = null,
          id = '';

      for (id in self.cache) {
        target = self.cache[id];
        el = target.render(target.data);

        if (el !== target.dom.el) {
          // Update target element reference
          if (target.isInDom) {
            target.unbindEvents();
            self.dom.parent.replaceChild(el, target.dom.el);
          }

          if (!target.isShown) {
            el.style.display = 'none';
          }

          target.dom.el = el;

          if (target.isInDom) {
            target.bindEvents();
          }
        }
      }

      self.state = self.buildState(self.lastOperation);
    },

    /**
     * Removes mixitup functionality from the container, unbinds all control
     * event handlers, and deletes the mixer instance from MixItUp's internal
     * cache.
     *
     * This should be performed whenever a mixer's container is removed from
     * the DOM, such as during a page change in a single page application,
     * or React's `componentWillUnmount()`.
     *
     * @example
     *
     * .destroy([cleanUp])
     *
     * @example <caption>Example: Destroying the mixer before removing its container element</caption>
     *
     * mixer.destroy();
     *
     * containerEl.parentElement.removeChild(containerEl);
     *
     * @public
     * @instance
     * @since   2.0.0
     * @param   {boolean}   [cleanUp=false]
     *     An optional boolean dictating whether or not to clean up any inline `display: none;` styling applied to hidden targets.
     * @return  {void}
     */
    destroy: function destroy(cleanUp) {
      var self = this,
          control = null,
          target = null,
          i = 0;
      self.callActions('beforeDestroy', arguments);

      for (i = 0; control = self.controls[i]; i++) {
        control.removeBinding(self);
      }

      for (i = 0; target = self.targets[i]; i++) {
        if (cleanUp) {
          target.show();
        }

        target.unbindEvents();
      }

      if (self.dom.container.id.match(/^MixItUp/)) {
        self.dom.container.removeAttribute('id');
      }

      delete _mixitup.instances[self.id];
      self.callActions('afterDestroy', arguments);
    }
  });
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.IMoveData = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.posIn = null;
    this.posOut = null;
    this.operation = null;
    this.callback = null;
    this.statusChange = '';
    this.duration = -1;
    this.staggerIndex = -1;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.IMoveData);

  _mixitup.IMoveData.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.IMoveData.prototype.constructor = _mixitup.IMoveData;
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.TargetDom = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.el = null;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.TargetDom);

  _mixitup.TargetDom.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.TargetDom.prototype.constructor = _mixitup.TargetDom;
  /**
   * @constructor
   * @namespace
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.Target = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.id = '';
    this.sortString = '';
    this.mixer = null;
    this.callback = null;
    this.isShown = false;
    this.isBound = false;
    this.isExcluded = false;
    this.isInDom = false;
    this.handler = null;
    this.operation = null;
    this.data = null;
    this.dom = new _mixitup.TargetDom();
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.Target);

  _mixitup.Target.prototype = Object.create(_mixitup.Base.prototype);
  h.extend(_mixitup.Target.prototype, {
    constructor: _mixitup.Target,

    /**
     * Initialises a newly instantiated Target.
     *
     * @private
     * @instance
     * @since   3.0.0
     * @param   {(Element|null)}    el
     * @param   {object}            mixer
     * @param   {object}            [data]
     * @return  {void}
     */
    init: function init(el, mixer, data) {
      var self = this,
          id = '';
      self.callActions('beforeInit', arguments);
      self.mixer = mixer;

      if (!el) {
        // If no element is provided, render it
        el = self.render(data);
      }

      self.cacheDom(el);
      self.bindEvents();

      if (self.dom.el.style.display !== 'none') {
        self.isShown = true;
      }

      if (data && mixer.config.data.uidKey) {
        if (typeof (id = data[mixer.config.data.uidKey]) === 'undefined' || id.toString().length < 1) {
          throw new TypeError(_mixitup.messages.errorDatasetInvalidUidKey({
            uidKey: mixer.config.data.uidKey
          }));
        }

        self.id = id;
        self.data = data;
        mixer.cache[id] = self;
      }

      self.callActions('afterInit', arguments);
    },

    /**
     * Renders the target element using a user-defined renderer function.
     *
     * @private
     * @instance
     * @since   3.1.4
     * @param   {object} data
     * @return  {void}
     */
    render: function render(data) {
      var self = this,
          render = null,
          el = null,
          temp = null,
          output = '';
      self.callActions('beforeRender', arguments);
      render = self.callFilters('renderRender', self.mixer.config.render.target, arguments);

      if (typeof render !== 'function') {
        throw new TypeError(_mixitup.messages.errorDatasetRendererNotSet());
      }

      output = render(data);

      if (output && _typeof(output) === 'object' && h.isElement(output)) {
        el = output;
      } else if (typeof output === 'string') {
        temp = document.createElement('div');
        temp.innerHTML = output;
        el = temp.firstElementChild;
      }

      return self.callFilters('elRender', el, arguments);
    },

    /**
     * Caches references of DOM elements neccessary for the target's functionality.
     *
     * @private
     * @instance
     * @since   3.0.0
     * @param   {Element} el
     * @return  {void}
     */
    cacheDom: function cacheDom(el) {
      var self = this;
      self.callActions('beforeCacheDom', arguments);
      self.dom.el = el;
      self.callActions('afterCacheDom', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {string}    attributeName
     * @return  {void}
     */
    getSortString: function getSortString(attributeName) {
      var self = this,
          value = self.dom.el.getAttribute('data-' + attributeName) || '';
      self.callActions('beforeGetSortString', arguments);
      value = isNaN(value * 1) ? value.toLowerCase() : value * 1;
      self.sortString = value;
      self.callActions('afterGetSortString', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @return  {void}
     */
    show: function show() {
      var self = this;
      self.callActions('beforeShow', arguments);

      if (!self.isShown) {
        self.dom.el.style.display = '';
        self.isShown = true;
      }

      self.callActions('afterShow', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @return  {void}
     */
    hide: function hide() {
      var self = this;
      self.callActions('beforeHide', arguments);

      if (self.isShown) {
        self.dom.el.style.display = 'none';
        self.isShown = false;
      }

      self.callActions('afterHide', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {mixitup.IMoveData} moveData
     * @return  {void}
     */
    move: function move(moveData) {
      var self = this;
      self.callActions('beforeMove', arguments);

      if (!self.isExcluded) {
        self.mixer.targetsMoved++;
      }

      self.applyStylesIn(moveData);
      requestAnimationFrame(function () {
        self.applyStylesOut(moveData);
      });
      self.callActions('afterMove', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {object}    posData
     * @param   {number}    multiplier
     * @return  {void}
     */
    applyTween: function applyTween(posData, multiplier) {
      var self = this,
          propertyName = '',
          tweenData = null,
          posIn = posData.posIn,
          currentTransformValues = [],
          currentValues = new _mixitup.StyleData(),
          i = -1;
      self.callActions('beforeApplyTween', arguments);
      currentValues.x = posIn.x;
      currentValues.y = posIn.y;

      if (multiplier === 0) {
        self.hide();
      } else if (!self.isShown) {
        self.show();
      }

      for (i = 0; propertyName = _mixitup.features.TWEENABLE[i]; i++) {
        tweenData = posData.tweenData[propertyName];

        if (propertyName === 'x') {
          if (!tweenData) continue;
          currentValues.x = posIn.x + tweenData * multiplier;
        } else if (propertyName === 'y') {
          if (!tweenData) continue;
          currentValues.y = posIn.y + tweenData * multiplier;
        } else if (tweenData instanceof _mixitup.TransformData) {
          if (!tweenData.value) continue;
          currentValues[propertyName].value = posIn[propertyName].value + tweenData.value * multiplier;
          currentValues[propertyName].unit = tweenData.unit;
          currentTransformValues.push(propertyName + '(' + currentValues[propertyName].value + tweenData.unit + ')');
        } else {
          if (!tweenData) continue;
          currentValues[propertyName] = posIn[propertyName] + tweenData * multiplier;
          self.dom.el.style[propertyName] = currentValues[propertyName];
        }
      }

      if (currentValues.x || currentValues.y) {
        currentTransformValues.unshift('translate(' + currentValues.x + 'px, ' + currentValues.y + 'px)');
      }

      if (currentTransformValues.length) {
        self.dom.el.style[_mixitup.features.transformProp] = currentTransformValues.join(' ');
      }

      self.callActions('afterApplyTween', arguments);
    },

    /**
     * Applies the initial styling to a target element before any transition
     * is applied.
     *
     * @private
     * @instance
     * @param   {mixitup.IMoveData} moveData
     * @return  {void}
     */
    applyStylesIn: function applyStylesIn(moveData) {
      var self = this,
          posIn = moveData.posIn,
          isFading = self.mixer.effectsIn.opacity !== 1,
          transformValues = [];
      self.callActions('beforeApplyStylesIn', arguments);
      transformValues.push('translate(' + posIn.x + 'px, ' + posIn.y + 'px)');

      if (self.mixer.config.animation.animateResizeTargets) {
        if (moveData.statusChange !== 'show') {
          // Don't apply posIn width or height or showing, as will be 0
          self.dom.el.style.width = posIn.width + 'px';
          self.dom.el.style.height = posIn.height + 'px';
        }

        self.dom.el.style.marginRight = posIn.marginRight + 'px';
        self.dom.el.style.marginBottom = posIn.marginBottom + 'px';
      }

      isFading && (self.dom.el.style.opacity = posIn.opacity);

      if (moveData.statusChange === 'show') {
        transformValues = transformValues.concat(self.mixer.transformIn);
      }

      self.dom.el.style[_mixitup.features.transformProp] = transformValues.join(' ');
      self.callActions('afterApplyStylesIn', arguments);
    },

    /**
     * Applies a transition followed by the final styles for the element to
     * transition towards.
     *
     * @private
     * @instance
     * @param   {mixitup.IMoveData} moveData
     * @return  {void}
     */
    applyStylesOut: function applyStylesOut(moveData) {
      var self = this,
          transitionRules = [],
          transformValues = [],
          isResizing = self.mixer.config.animation.animateResizeTargets,
          isFading = typeof self.mixer.effectsIn.opacity !== 'undefined';
      self.callActions('beforeApplyStylesOut', arguments); // Build the transition rules

      transitionRules.push(self.writeTransitionRule(_mixitup.features.transformRule, moveData.staggerIndex));

      if (moveData.statusChange !== 'none') {
        transitionRules.push(self.writeTransitionRule('opacity', moveData.staggerIndex, moveData.duration));
      }

      if (isResizing) {
        transitionRules.push(self.writeTransitionRule('width', moveData.staggerIndex, moveData.duration));
        transitionRules.push(self.writeTransitionRule('height', moveData.staggerIndex, moveData.duration));
        transitionRules.push(self.writeTransitionRule('margin', moveData.staggerIndex, moveData.duration));
      } // If no callback was provided, the element will
      // not transition in any way so tag it as "immovable"


      if (!moveData.callback) {
        self.mixer.targetsImmovable++;

        if (self.mixer.targetsMoved === self.mixer.targetsImmovable) {
          // If the total targets moved is equal to the
          // number of immovable targets, the operation
          // should be considered finished
          self.mixer.cleanUp(moveData.operation);
        }

        return;
      } // If the target will transition in some fasion,
      // assign a callback function


      self.operation = moveData.operation;
      self.callback = moveData.callback; // As long as the target is not excluded, increment
      // the total number of targets bound

      !self.isExcluded && self.mixer.targetsBound++; // Tag the target as bound to differentiate from transitionEnd
      // events that may come from stylesheet driven effects

      self.isBound = true; // Apply the transition

      self.applyTransition(transitionRules); // Apply width, height and margin negation

      if (isResizing && moveData.posOut.width > 0 && moveData.posOut.height > 0) {
        self.dom.el.style.width = moveData.posOut.width + 'px';
        self.dom.el.style.height = moveData.posOut.height + 'px';
        self.dom.el.style.marginRight = moveData.posOut.marginRight + 'px';
        self.dom.el.style.marginBottom = moveData.posOut.marginBottom + 'px';
      }

      if (!self.mixer.config.animation.nudge && moveData.statusChange === 'hide') {
        // If we're not nudging, the translation should be
        // applied before any other transforms to prevent
        // lateral movement
        transformValues.push('translate(' + moveData.posOut.x + 'px, ' + moveData.posOut.y + 'px)');
      } // Apply fade


      switch (moveData.statusChange) {
        case 'hide':
          isFading && (self.dom.el.style.opacity = self.mixer.effectsOut.opacity);
          transformValues = transformValues.concat(self.mixer.transformOut);
          break;

        case 'show':
          isFading && (self.dom.el.style.opacity = 1);
      }

      if (self.mixer.config.animation.nudge || !self.mixer.config.animation.nudge && moveData.statusChange !== 'hide') {
        // Opposite of above - apply translate after
        // other transform
        transformValues.push('translate(' + moveData.posOut.x + 'px, ' + moveData.posOut.y + 'px)');
      } // Apply transforms


      self.dom.el.style[_mixitup.features.transformProp] = transformValues.join(' ');
      self.callActions('afterApplyStylesOut', arguments);
    },

    /**
     * Combines the name of a CSS property with the appropriate duration and delay
     * values to created a valid transition rule.
     *
     * @private
     * @instance
     * @since   3.0.0
     * @param   {string}    property
     * @param   {number}    staggerIndex
     * @param   {number}    duration
     * @return  {string}
     */
    writeTransitionRule: function writeTransitionRule(property, staggerIndex, duration) {
      var self = this,
          delay = self.getDelay(staggerIndex),
          rule = '';
      rule = property + ' ' + (duration > 0 ? duration : self.mixer.config.animation.duration) + 'ms ' + delay + 'ms ' + (property === 'opacity' ? 'linear' : self.mixer.config.animation.easing);
      return self.callFilters('ruleWriteTransitionRule', rule, arguments);
    },

    /**
     * Calculates the transition delay for each target element based on its index, if
     * staggering is applied. If defined, A custom `animation.staggerSeqeuence`
     * function can be used to manipulate the order of indices to produce custom
     * stagger effects (e.g. for use in a grid with irregular row lengths).
     *
     * @private
     * @instance
     * @since   2.0.0
     * @param   {number}    index
     * @return  {number}
     */
    getDelay: function getDelay(index) {
      var self = this,
          delay = -1;

      if (typeof self.mixer.config.animation.staggerSequence === 'function') {
        index = self.mixer.config.animation.staggerSequence.call(self, index, self.state);
      }

      delay = !!self.mixer.staggerDuration ? index * self.mixer.staggerDuration : 0;
      return self.callFilters('delayGetDelay', delay, arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {string[]}  rules
     * @return  {void}
     */
    applyTransition: function applyTransition(rules) {
      var self = this,
          transitionString = rules.join(', ');
      self.callActions('beforeApplyTransition', arguments);
      self.dom.el.style[_mixitup.features.transitionProp] = transitionString;
      self.callActions('afterApplyTransition', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {Event} e
     * @return  {void}
     */
    handleTransitionEnd: function handleTransitionEnd(e) {
      var self = this,
          propName = e.propertyName,
          canResize = self.mixer.config.animation.animateResizeTargets;
      self.callActions('beforeHandleTransitionEnd', arguments);

      if (self.isBound && e.target.matches(self.mixer.config.selectors.target) && (propName.indexOf('transform') > -1 || propName.indexOf('opacity') > -1 || canResize && propName.indexOf('height') > -1 || canResize && propName.indexOf('width') > -1 || canResize && propName.indexOf('margin') > -1)) {
        self.callback.call(self, self.operation);
        self.isBound = false;
        self.callback = null;
        self.operation = null;
      }

      self.callActions('afterHandleTransitionEnd', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {Event}     e
     * @return  {void}
     */
    eventBus: function eventBus(e) {
      var self = this;
      self.callActions('beforeEventBus', arguments);

      switch (e.type) {
        case 'webkitTransitionEnd':
        case 'transitionend':
          self.handleTransitionEnd(e);
      }

      self.callActions('afterEventBus', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @return  {void}
     */
    unbindEvents: function unbindEvents() {
      var self = this;
      self.callActions('beforeUnbindEvents', arguments);
      h.off(self.dom.el, 'webkitTransitionEnd', self.handler);
      h.off(self.dom.el, 'transitionend', self.handler);
      self.callActions('afterUnbindEvents', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @return  {void}
     */
    bindEvents: function bindEvents() {
      var self = this,
          transitionEndEvent = '';
      self.callActions('beforeBindEvents', arguments);
      transitionEndEvent = _mixitup.features.transitionPrefix === 'webkit' ? 'webkitTransitionEnd' : 'transitionend';

      self.handler = function (e) {
        return self.eventBus(e);
      };

      h.on(self.dom.el, transitionEndEvent, self.handler);
      self.callActions('afterBindEvents', arguments);
    },

    /**
     * @private
     * @instance
     * @since   3.0.0
     * @param   {boolean}   [getBox]
     * @return  {PosData}
     */
    getPosData: function getPosData(getBox) {
      var self = this,
          styles = {},
          rect = null,
          posData = new _mixitup.StyleData();
      self.callActions('beforeGetPosData', arguments);
      posData.x = self.dom.el.offsetLeft;
      posData.y = self.dom.el.offsetTop;

      if (self.mixer.config.animation.animateResizeTargets || getBox) {
        rect = self.dom.el.getBoundingClientRect();
        posData.top = rect.top;
        posData.right = rect.right;
        posData.bottom = rect.bottom;
        posData.left = rect.left;
        posData.width = rect.width;
        posData.height = rect.height;
      }

      if (self.mixer.config.animation.animateResizeTargets) {
        styles = window.getComputedStyle(self.dom.el);
        posData.marginBottom = parseFloat(styles.marginBottom);
        posData.marginRight = parseFloat(styles.marginRight);
      }

      return self.callFilters('posDataGetPosData', posData, arguments);
    },

    /**
     * @private
     * @instance
     * @since       3.0.0
     * @return      {void}
     */
    cleanUp: function cleanUp() {
      var self = this;
      self.callActions('beforeCleanUp', arguments);
      self.dom.el.style[_mixitup.features.transformProp] = '';
      self.dom.el.style[_mixitup.features.transitionProp] = '';
      self.dom.el.style.opacity = '';

      if (self.mixer.config.animation.animateResizeTargets) {
        self.dom.el.style.width = '';
        self.dom.el.style.height = '';
        self.dom.el.style.marginRight = '';
        self.dom.el.style.marginBottom = '';
      }

      self.callActions('afterCleanUp', arguments);
    }
  });
  /**
   * A jQuery-collection-like wrapper around one or more `mixitup.Mixer` instances
   * allowing simultaneous control of said instances similar to the MixItUp 2 API.
   *
   * @example
   * new mixitup.Collection(instances)
   *
   * @constructor
   * @namespace
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   * @param       {mixitup.Mixer[]}   instances
   */

  _mixitup.Collection = function (instances) {
    var instance = null,
        i = -1;
    this.callActions('beforeConstruct');

    for (i = 0; instance = instances[i]; i++) {
      this[i] = instance;
    }

    this.length = instances.length;
    this.callActions('afterConstruct');
    h.freeze(this);
  };

  _mixitup.BaseStatic.call(_mixitup.Collection);

  _mixitup.Collection.prototype = Object.create(_mixitup.Base.prototype);
  h.extend(_mixitup.Collection.prototype,
  /** @lends mixitup.Collection */
  {
    constructor: _mixitup.Collection,

    /**
     * Calls a method on all instances in the collection by passing the method
     * name as a string followed by any applicable parameters to be curried into
     * to the method.
     *
     * @example
     * .mixitup(methodName[,arg1][,arg2..]);
     *
     * @example
     * var collection = new Collection([mixer1, mixer2]);
     *
     * return collection.mixitup('filter', '.category-a')
     *     .then(function(states) {
     *         state.forEach(function(state) {
     *             console.log(state.activeFilter.selector); // .category-a
     *         });
     *     });
     *
     * @public
     * @instance
     * @since       3.0.0
     * @param       {string}  methodName
     * @return      {Promise<Array<mixitup.State>>}
     */
    mixitup: function mixitup(methodName) {
      var self = this,
          instance = null,
          args = Array.prototype.slice.call(arguments),
          tasks = [],
          i = -1;
      this.callActions('beforeMixitup');
      args.shift();

      for (i = 0; instance = self[i]; i++) {
        tasks.push(instance[methodName].apply(instance, args));
      }

      return self.callFilters('promiseMixitup', h.all(tasks, _mixitup.libraries), arguments);
    }
  });
  /**
   * `mixitup.Operation` objects contain all data neccessary to describe the full
   * lifecycle of any MixItUp operation. They can be used to compute and store an
   * operation for use at a later time (e.g. programmatic tweening).
   *
   * @constructor
   * @namespace
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.Operation = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.id = '';
    this.args = [];
    this.command = null;
    this.showPosData = [];
    this.toHidePosData = [];
    this.startState = null;
    this.newState = null;
    this.docState = null;
    this.willSort = false;
    this.willChangeLayout = false;
    this.hasEffect = false;
    this.hasFailed = false;
    this.triggerElement = null;
    this.show = [];
    this.hide = [];
    this.matching = [];
    this.toShow = [];
    this.toHide = [];
    this.toMove = [];
    this.toRemove = [];
    this.startOrder = [];
    this.newOrder = [];
    this.startSort = null;
    this.newSort = null;
    this.startFilter = null;
    this.newFilter = null;
    this.startDataset = null;
    this.newDataset = null;
    this.viewportDeltaX = 0;
    this.viewportDeltaY = 0;
    this.startX = 0;
    this.startY = 0;
    this.startHeight = 0;
    this.startWidth = 0;
    this.newX = 0;
    this.newY = 0;
    this.newHeight = 0;
    this.newWidth = 0;
    this.startContainerClassName = '';
    this.startDisplay = '';
    this.newContainerClassName = '';
    this.newDisplay = '';
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.Operation);

  _mixitup.Operation.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.Operation.prototype.constructor = _mixitup.Operation;
  /**
   * `mixitup.State` objects expose various pieces of data detailing the state of
   * a MixItUp instance. They are provided at the start and end of any operation via
   * callbacks and events, with the most recent state stored between operations
   * for retrieval at any time via the API.
   *
   * @constructor
   * @namespace
   * @memberof    mixitup
   * @public
   * @since       3.0.0
   */

  _mixitup.State = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    /**
     * The ID of the mixer instance.
     *
     * @name        id
     * @memberof    mixitup.State
     * @instance
     * @type        {string}
     * @default     ''
     */

    this.id = '';
    /**
     * The currently active filter command as set by a control click or API call.
     *
     * @name        activeFilter
     * @memberof    mixitup.State
     * @instance
     * @type        {mixitup.CommandFilter}
     * @default     null
     */

    this.activeFilter = null;
    /**
     * The currently active sort command as set by a control click or API call.
     *
     * @name        activeSort
     * @memberof    mixitup.State
     * @instance
     * @type        {mixitup.CommandSort}
     * @default     null
     */

    this.activeSort = null;
    /**
     * The current layout-specific container class name, if applied.
     *
     * @name        activeContainerClassName
     * @memberof    mixitup.State
     * @instance
     * @type        {string}
     * @default     ''
     */

    this.activeContainerClassName = '';
    /**
     * A reference to the container element that the mixer is instantiated on.
     *
     * @name        container
     * @memberof    mixitup.State
     * @instance
     * @type        {Element}
     * @default     null
     */

    this.container = null;
    /**
     * An array of all target elements indexed by the mixer.
     *
     * @name        targets
     * @memberof    mixitup.State
     * @instance
     * @type        {Array.<Element>}
     * @default     []
     */

    this.targets = [];
    /**
     * An array of all target elements not matching the current filter.
     *
     * @name        hide
     * @memberof    mixitup.State
     * @instance
     * @type        {Array.<Element>}
     * @default     []
     */

    this.hide = [];
    /**
     * An array of all target elements matching the current filter and any additional
     * limits applied such as pagination.
     *
     * @name        show
     * @memberof    mixitup.State
     * @instance
     * @type        {Array.<Element>}
     * @default     []
     */

    this.show = [];
    /**
     * An array of all target elements matching the current filter irrespective of
     * any additional limits applied such as pagination.
     *
     * @name        matching
     * @memberof    mixitup.State
     * @instance
     * @type        {Array.<Element>}
     * @default     []
     */

    this.matching = [];
    /**
     * An integer representing the total number of target elements indexed by the
     * mixer. Equivalent to `state.targets.length`.
     *
     * @name        totalTargets
     * @memberof    mixitup.State
     * @instance
     * @type        {number}
     * @default     -1
     */

    this.totalTargets = -1;
    /**
     * An integer representing the total number of target elements matching the
     * current filter and any additional limits applied such as pagination.
     * Equivalent to `state.show.length`.
     *
     * @name        totalShow
     * @memberof    mixitup.State
     * @instance
     * @type        {number}
     * @default     -1
     */

    this.totalShow = -1;
    /**
     * An integer representing the total number of target elements not matching
     * the current filter. Equivalent to `state.hide.length`.
     *
     * @name        totalHide
     * @memberof    mixitup.State
     * @instance
     * @type        {number}
     * @default     -1
     */

    this.totalHide = -1;
    /**
     * An integer representing the total number of target elements matching the
     * current filter irrespective of any other limits applied such as pagination.
     * Equivalent to `state.matching.length`.
     *
     * @name        totalMatching
     * @memberof    mixitup.State
     * @instance
     * @type        {number}
     * @default     -1
     */

    this.totalMatching = -1;
    /**
     * A boolean indicating whether the last operation "failed", i.e. no targets
     * could be found matching the filter.
     *
     * @name        hasFailed
     * @memberof    mixitup.State
     * @instance
     * @type        {boolean}
     * @default     false
     */

    this.hasFailed = false;
    /**
     * The DOM element that was clicked if the last operation was triggered by the
     * clicking of a control and not an API call.
     *
     * @name        triggerElement
     * @memberof    mixitup.State
     * @instance
     * @type        {Element|null}
     * @default     null
     */

    this.triggerElement = null;
    /**
     * The currently active dataset underlying the rendered targets, if the
     * dataset API is in use.
     *
     * @name        activeDataset
     * @memberof    mixitup.State
     * @instance
     * @type        {Array.<object>}
     * @default     null
     */

    this.activeDataset = null;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.State);

  _mixitup.State.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.State.prototype.constructor = _mixitup.State;
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.UserInstruction = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    this.command = {};
    this.animate = false;
    this.callback = null;
    this.callActions('afterConstruct');
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.UserInstruction);

  _mixitup.UserInstruction.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.UserInstruction.prototype.constructor = _mixitup.UserInstruction;
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   */

  _mixitup.Messages = function () {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct');
    /* Errors
    ----------------------------------------------------------------------------- */

    this.ERROR_FACTORY_INVALID_CONTAINER = '[MixItUp] An invalid selector or element reference was passed to the mixitup factory function';
    this.ERROR_FACTORY_CONTAINER_NOT_FOUND = '[MixItUp] The provided selector yielded no container element';
    this.ERROR_CONFIG_INVALID_ANIMATION_EFFECTS = '[MixItUp] Invalid value for `animation.effects`';
    this.ERROR_CONFIG_INVALID_CONTROLS_SCOPE = '[MixItUp] Invalid value for `controls.scope`';
    this.ERROR_CONFIG_INVALID_PROPERTY = '[MixitUp] Invalid configuration object property "${erroneous}"${suggestion}';
    this.ERROR_CONFIG_INVALID_PROPERTY_SUGGESTION = '. Did you mean "${probableMatch}"?';
    this.ERROR_CONFIG_DATA_UID_KEY_NOT_SET = '[MixItUp] To use the dataset API, a UID key must be specified using `data.uidKey`';
    this.ERROR_DATASET_INVALID_UID_KEY = '[MixItUp] The specified UID key "${uidKey}" is not present on one or more dataset items';
    this.ERROR_DATASET_DUPLICATE_UID = '[MixItUp] The UID "${uid}" was found on two or more dataset items. UIDs must be unique.';
    this.ERROR_INSERT_INVALID_ARGUMENTS = '[MixItUp] Please provider either an index or a sibling and position to insert, not both';
    this.ERROR_INSERT_PREEXISTING_ELEMENT = '[MixItUp] An element to be inserted already exists in the container';
    this.ERROR_FILTER_INVALID_ARGUMENTS = '[MixItUp] Please provide either a selector or collection `.filter()`, not both';
    this.ERROR_DATASET_NOT_SET = '[MixItUp] To use the dataset API with pre-rendered targets, a starting dataset must be set using `load.dataset`';
    this.ERROR_DATASET_PRERENDERED_MISMATCH = '[MixItUp] `load.dataset` does not match pre-rendered targets';
    this.ERROR_DATASET_RENDERER_NOT_SET = '[MixItUp] To insert an element via the dataset API, a target renderer function must be provided to `render.target`';
    this.ERROR_SORT_NON_EXISTENT_ELEMENT = '[MixItUp] An element to be sorted does not already exist in the container';
    /* Warnings
    ----------------------------------------------------------------------------- */

    this.WARNING_FACTORY_PREEXISTING_INSTANCE = '[MixItUp] WARNING: This element already has an active MixItUp instance. The provided configuration object will be ignored.' + ' If you wish to perform additional methods on this instance, please create a reference.';
    this.WARNING_INSERT_NO_ELEMENTS = '[MixItUp] WARNING: No valid elements were passed to `.insert()`';
    this.WARNING_REMOVE_NO_ELEMENTS = '[MixItUp] WARNING: No valid elements were passed to `.remove()`';
    this.WARNING_MULTIMIX_INSTANCE_QUEUE_FULL = '[MixItUp] WARNING: An operation was requested but the MixItUp instance was busy. The operation was rejected because the ' + 'queue is full or queuing is disabled.';
    this.WARNING_GET_OPERATION_INSTANCE_BUSY = '[MixItUp] WARNING: Operations can be be created while the MixItUp instance is busy.';
    this.WARNING_NO_PROMISE_IMPLEMENTATION = '[MixItUp] WARNING: No Promise implementations could be found. If you wish to use promises with MixItUp please install' + ' an ES6 Promise polyfill.';
    this.WARNING_INCONSISTENT_SORTING_ATTRIBUTES = '[MixItUp] WARNING: The requested sorting data attribute "${attribute}" was not present on one or more target elements' + ' which may product unexpected sort output';
    this.callActions('afterConstruct');
    this.compileTemplates();
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.Messages);

  _mixitup.Messages.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.Messages.prototype.constructor = _mixitup.Messages;
  /**
   * @return {void}
   */

  _mixitup.Messages.prototype.compileTemplates = function () {
    var errorKey = '';
    var errorMessage = '';

    for (errorKey in this) {
      if (typeof (errorMessage = this[errorKey]) !== 'string') continue;
      this[h.camelCase(errorKey)] = h.template(errorMessage);
    }
  };

  _mixitup.messages = new _mixitup.Messages();
  /**
   * @constructor
   * @memberof    mixitup
   * @private
   * @since       3.0.0
   * @param       {mixitup.Mixer} mixer
   */

  _mixitup.Facade = function Mixer(mixer) {
    _mixitup.Base.call(this);

    this.callActions('beforeConstruct', arguments);
    this.configure = mixer.configure.bind(mixer);
    this.show = mixer.show.bind(mixer);
    this.hide = mixer.hide.bind(mixer);
    this.filter = mixer.filter.bind(mixer);
    this.toggleOn = mixer.toggleOn.bind(mixer);
    this.toggleOff = mixer.toggleOff.bind(mixer);
    this.sort = mixer.sort.bind(mixer);
    this.changeLayout = mixer.changeLayout.bind(mixer);
    this.multimix = mixer.multimix.bind(mixer);
    this.dataset = mixer.dataset.bind(mixer);
    this.tween = mixer.tween.bind(mixer);
    this.insert = mixer.insert.bind(mixer);
    this.insertBefore = mixer.insertBefore.bind(mixer);
    this.insertAfter = mixer.insertAfter.bind(mixer);
    this.prepend = mixer.prepend.bind(mixer);
    this.append = mixer.append.bind(mixer);
    this.remove = mixer.remove.bind(mixer);
    this.destroy = mixer.destroy.bind(mixer);
    this.forceRefresh = mixer.forceRefresh.bind(mixer);
    this.forceRender = mixer.forceRender.bind(mixer);
    this.isMixing = mixer.isMixing.bind(mixer);
    this.getOperation = mixer.getOperation.bind(mixer);
    this.getConfig = mixer.getConfig.bind(mixer);
    this.getState = mixer.getState.bind(mixer);
    this.callActions('afterConstruct', arguments);
    h.freeze(this);
    h.seal(this);
  };

  _mixitup.BaseStatic.call(_mixitup.Facade);

  _mixitup.Facade.prototype = Object.create(_mixitup.Base.prototype);
  _mixitup.Facade.prototype.constructor = _mixitup.Facade;

  if (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') {
    module.exports = _mixitup;
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return _mixitup;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

  _mixitup.BaseStatic.call(_mixitup.constructor);

  _mixitup.NAME = 'mixitup';
  _mixitup.CORE_VERSION = '3.3.1';
})(window);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),

/***/ "./src/assets/scripts/app.js":
/*!***********************************!*\
  !*** ./src/assets/scripts/app.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var mixitup_dist_mixitup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mixitup/dist/mixitup */ "./node_modules/mixitup/dist/mixitup.js");
/* harmony import */ var mixitup_dist_mixitup__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mixitup_dist_mixitup__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glidejs_glide_dist_glide__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @glidejs/glide/dist/glide */ "./node_modules/@glidejs/glide/dist/glide.js");
/* harmony import */ var _glidejs_glide_dist_glide__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_glidejs_glide_dist_glide__WEBPACK_IMPORTED_MODULE_1__);


var mixerContainer = document.querySelector('.portfolioMix');
var mixer = mixitup_dist_mixitup__WEBPACK_IMPORTED_MODULE_0___default()(mixerContainer, {
  selectors: {
    target: '.mix'
  },
  animation: {
    duration: 300
  }
});
var glide = new _glidejs_glide_dist_glide__WEBPACK_IMPORTED_MODULE_1___default.a('.glide', {
  type: 'carousel',
  perView: 1,
  focusAt: 'center',
  autoplay: "2500"
});
glide.mount();
var mq = window.matchMedia("(max-width: 992px)");
var sr = new ScrollReveal();
console.log(mq);
var slideUp = {
  distance: '150%',
  origin: 'bottom',
  opacity: .1,
  duration: 700,
  interval: 50,
  delay: 200
};
var slideLeft = {
  distance: '150%',
  origin: 'left',
  duration: 750,
  delay: 100,
  mobile: false
};
var slideTop = {
  distance: '300%',
  origin: 'top',
  duration: 850,
  delay: 300
};
var slideRight = {
  distance: '150%',
  origin: 'right',
  duration: 250,
  opacity: 0
};

if (!mq.matches) {
  sr.reveal('.stats-counter', slideUp);
  sr.reveal('.about-us__img', slideLeft);
  sr.reveal('.about-us', slideTop);
  sr.reveal('.carousel', slideLeft);
  sr.reveal('.case-study__img', slideRight);
}

var nav = document.getElementById('nav');
var arrowTop = document.getElementById('arrowTop');
var sliderPanel = document.querySelectorAll('.slider__trigger');
var parallax = document.querySelector('.parallax');
var statistics = document.querySelector('.statistics');
var statsDIVs = document.querySelectorAll('.stats-counter__num');
var xScrollPosition;
var yScrollPosition;
var lastScrollPos = 0;
var distance = 0;
var counted = false;
var parallaxPos = document.querySelector('.statistics');
var data = parallaxPos.getBoundingClientRect();
var menuItems = document.querySelectorAll('.nav__item');
var menuBtn = document.querySelector('.nav__button'); // const breakpoints = {
//     sm: 3,
//     md:
// };
/// closing mobile menu

menuItems.forEach(function (item) {
  item.addEventListener('click', function (e) {
    console.log(e.currentTarget.parentElement.parentElement);
    e.currentTarget.children[0].click();
    e.currentTarget.parentElement.parentElement.classList.remove('open');
    menuBtn.classList.remove('active');
  });
});

function getDocHeight() {
  var D = document;
  return Math.max(D.body.scrollHeight, D.documentElement.scrollHeight, D.body.offsetHeight, D.documentElement.offsetHeight, D.body.clientHeight, D.documentElement.clientHeight);
}

var docheight = getDocHeight();

window.onscroll = function () {
  shrinkNav();
  showArrow(); /////// start counting up in service section

  if (isElementInViewport(statistics) && counted === false) {
    statsDIVs.forEach(function (e) {
      var cat = e.id;
      var time = 3;
      var countTo = completeStats["".concat(cat)];
      countValue(e, countTo, time);
      counted = true;
    });
  }
};

function isElementInViewport(el) {
  var rect = el.getBoundingClientRect();
  return rect.bottom > 0 && rect.right > 0 && rect.left < (window.innerWidth || document.documentElement.clientWidth)
  /* or $(window).width() */
  && rect.top < (window.innerHeight || document.documentElement.clientHeight)
  /* or $(window).height() */
  ;
}

function scrollLoop() {
  xScrollPosition = window.scrollX;
  yScrollPosition = window.scrollY;
  setTranslate(0, yScrollPosition * 0.1, parallax);
  requestAnimationFrame(scrollLoop); //console.log(xScrollPosition,yScrollPosition,parallaxPos.offsetTop);
}

function setTranslate(xPos, yPos, el) {
  el.style.transform = "translate3d(".concat(xPos, "px, ").concat(yPos, "px, 0)");
}

function setBgPosY(yPos, el) {
  el.style.backgroundPositionY = yPos + "px";
} // Smooth scroll


document.querySelectorAll('a[href^="#"]').forEach(function (anchor) {
  anchor.addEventListener('click', function (e) {
    e.preventDefault();
    document.querySelector(this.getAttribute('href')).scrollIntoView({
      behavior: 'smooth'
    });
  });
});
document.addEventListener('DOMContentLoaded', function () {
  addDataAttributes(); //scrollLoop();
}, false);

var shrinkNav = function shrinkNav(width) {
  if (document.body.scrollTop > 80 || document.documentElement.scrollTop > 80) {
    nav.style.backgroundColor = 'rgba(0,0,0,.55)';
    nav.style.padding = '1rem';
    nav.style.position = 'fixed';
    nav.style.height = '80px';
  } else {
    nav.style.backgroundColor = 'transparent';
    nav.style.padding = '3rem 2.5rem';
    nav.style.position = 'absolute';
  }
};

var showArrow = function showArrow() {
  if (document.body.scrollTop > 400 || document.documentElement.scrollTop > 400) {
    arrowTop.style.opacity = '1';
  } else {
    arrowTop.style.opacity = '0';
  }
}; // SLIDER


var sliderBtns = document.querySelectorAll('.slider__trigger');
var sliderImgs = document.querySelectorAll('.slider__img');

function addDataAttributes() {
  sliderImgs.forEach(function (img) {
    var name = img.getAttribute('src').split('/')[3].split('.')[0]; // adding data-name to img

    img.setAttribute('data-name', name);
  });
} // global - timeout event for slide


var slideInProgress;
sliderBtns.forEach(function (e) {
  e.addEventListener('click', function (event) {
    if (e.classList.contains('active')) {
      console.log('aktivno dugmo');
      return false;
    } else {
      document.querySelector('.slider__trigger.active').classList.remove('active');
      e.classList.add('active');
    }

    var slide = e.id;
    var img = document.querySelectorAll("[data-name='".concat(slide, "']")); // removing active image

    if (document.querySelector('.slider__img.active')) {
      document.querySelector('.slider__img.active').classList.remove('active');
    } // if sliding in progress


    var elems = document.querySelector(".sliding");

    if (elems !== null) {
      elems.classList.remove('sliding');
      clearTimeout(slideInProgress);
    }

    if (!img[0].classList.contains('active') && !img[0].classList.contains('sliding')) {
      img[0].classList.add('sliding'); // Getting animation duration from CSS //

      var currentAnimationDuration = window.getComputedStyle(img[0], null).getPropertyValue("animation-duration"); // in ms

      currentAnimationDuration = parseFloat(currentAnimationDuration.replace('s', '')) * 1000; // setting timeout event

      slideInProgress = setTimeout(function () {
        img[0].classList.remove('sliding');
        img[0].classList.add('active');
      }, currentAnimationDuration);
    }
  });
});
adjustServicesSection(); // Adjust services section

function adjustServicesSection() {
  var rowLeft = document.querySelector('.row').getBoundingClientRect().x;
  var servicesLeft = document.querySelector('.services').getBoundingClientRect().x;
  var mq = window.matchMedia("(max-width: 1200px)");
  sliderPanel.forEach(function (el) {
    if (!mq.matches) {
      el.style.paddingLeft = rowLeft + servicesLeft + 'px';
    }
  });
} // make sub titles in a slider


var slides = document.querySelectorAll('.mix');
slides.forEach(function (slide) {
  buildDescDiv(slide);
});

function buildDescDiv(div) {
  // list of cats
  var categories = div.classList.value.replace('mix', '').trim().split(' '); // img name

  var imgName = div.lastElementChild.getAttribute('src').split('/')[1].split('.')[0];
  var container = document.createElement("div");
  var title = document.createElement('h5');
  container.className = 'mix__title';
  title.textContent = imgName.split('-').join(' ');
  container.appendChild(title);
  var categoriesSub = document.createElement('p');
  categoriesSub.className = 'mix__category';

  for (var i = 0; i < categories.length; i++) {
    var categoryHolder = document.createElement('span');
    categoryHolder.textContent = categories[i];
    categoriesSub.appendChild(categoryHolder);
  }

  container.appendChild(categoriesSub);
  div.appendChild(container);
} // Stats counter


var completeStats = {
  favorites: 3891,
  posts24h: 233,
  totalPosts: 643,
  campaigns: 564,
  amazingFeatures: 154
};

function countValue(el, value, time) {
  var interval = value / time / 7;
  var init = 0;
  var counting = setInterval(function () {
    init += interval;

    if (el.id === "posts24h") {
      el.textContent = Math.floor(init) + "K";
    } else {
      el.textContent = Math.floor(init);
    }

    if (init >= value) {
      init = value;
      clearInterval(counting);

      if (el.id === "posts24h") {
        el.textContent = Math.floor(init) + "K";
      } else {
        el.textContent = Math.floor(init);
      }

      return Math.floor(init);
    }
  }, 120);
} // Blog hover function


var readMoreBlog = document.querySelectorAll('.blog__readmore');
readMoreBlog.forEach(function (elem) {
  elem.addEventListener('mouseenter', function (e) {
    var overlay = e.target.parentElement.parentElement.children[0].children[0];
    overlay.classList.add('active');
  });
  elem.addEventListener('mouseout', function (e) {
    var overlay = e.target.parentElement.parentElement.children[0].children[0];
    overlay.classList.remove('active');
  });
}); // hamburger menu

menuBtn.addEventListener('click', function (e) {
  e.currentTarget.classList.toggle('active');
  console.log(e.currentTarget.parentNode.children[1].classList.toggle('open'));
});

/***/ }),

/***/ "./src/assets/scripts/main.js":
/*!************************************!*\
  !*** ./src/assets/scripts/main.js ***!
  \************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _app_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app.js */ "./src/assets/scripts/app.js");


/***/ }),

/***/ 0:
/*!******************************************!*\
  !*** multi ./src/assets/scripts/main.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! F:\Coding-practice\Bino\src\assets\scripts\main.js */"./src/assets/scripts/main.js");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWpzL2dsaWRlL2Rpc3QvZ2xpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21peGl0dXAvZGlzdC9taXhpdHVwLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9zY3JpcHRzL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL3NjcmlwdHMvbWFpbi5qcyJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImRlZmF1bHRzIiwidHlwZSIsInN0YXJ0QXQiLCJwZXJWaWV3IiwiZm9jdXNBdCIsImdhcCIsImF1dG9wbGF5IiwiaG92ZXJwYXVzZSIsImtleWJvYXJkIiwiYm91bmQiLCJzd2lwZVRocmVzaG9sZCIsImRyYWdUaHJlc2hvbGQiLCJwZXJUb3VjaCIsInRvdWNoUmF0aW8iLCJ0b3VjaEFuZ2xlIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJyZXdpbmQiLCJyZXdpbmREdXJhdGlvbiIsImFuaW1hdGlvblRpbWluZ0Z1bmMiLCJ0aHJvdHRsZSIsImRpcmVjdGlvbiIsInBlZWsiLCJicmVha3BvaW50cyIsImNsYXNzZXMiLCJsdHIiLCJydGwiLCJzbGlkZXIiLCJjYXJvdXNlbCIsInN3aXBlYWJsZSIsImRyYWdnaW5nIiwiY2xvbmVTbGlkZSIsImFjdGl2ZU5hdiIsImFjdGl2ZVNsaWRlIiwiZGlzYWJsZWRBcnJvdyIsIndhcm4iLCJtc2ciLCJjb25zb2xlIiwiZXJyb3IiLCJfdHlwZW9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJvYmoiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImNsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsImNyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9leHRlbmRzIiwiYXNzaWduIiwiYXJndW1lbnRzIiwic291cmNlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZ2V0Iiwib2JqZWN0IiwicHJvcGVydHkiLCJyZWNlaXZlciIsIkZ1bmN0aW9uIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInVuZGVmaW5lZCIsInBhcmVudCIsImdldFByb3RvdHlwZU9mIiwidmFsdWUiLCJnZXR0ZXIiLCJpbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwicG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsInRvSW50IiwicGFyc2VJbnQiLCJ0b0Zsb2F0IiwicGFyc2VGbG9hdCIsImlzU3RyaW5nIiwiaXNPYmplY3QiLCJpc051bWJlciIsImlzRnVuY3Rpb24iLCJpc1VuZGVmaW5lZCIsImlzQXJyYXkiLCJBcnJheSIsIm1vdW50IiwiZ2xpZGUiLCJleHRlbnNpb25zIiwiZXZlbnRzIiwiY29tcG9uZW50cyIsIm5hbWUiLCJfbmFtZSIsInByb3AiLCJkZWZpbml0aW9uIiwic29ydEtleXMiLCJrZXlzIiwic29ydCIsInJlZHVjZSIsInIiLCJrIiwibWVyZ2VPcHRpb25zIiwic2V0dGluZ3MiLCJvcHRpb25zIiwiRXZlbnRzQnVzIiwiaG9wIiwib24iLCJldmVudCIsImhhbmRsZXIiLCJpbmRleCIsInB1c2giLCJyZW1vdmUiLCJlbWl0IiwiY29udGV4dCIsImZvckVhY2giLCJpdGVtIiwiR2xpZGUiLCJzZWxlY3RvciIsIl9jIiwiX3QiLCJfZSIsImRpc2FibGVkIiwibW91bnQkJDEiLCJtdXRhdGUiLCJ0cmFuc2Zvcm1lcnMiLCJ1cGRhdGUiLCJnbyIsInBhdHRlcm4iLCJSdW4iLCJtYWtlIiwibW92ZSIsImRpc3RhbmNlIiwiVHJhbnNpdGlvbiIsImRpc2FibGUiLCJNb3ZlIiwiZGVzdHJveSIsInBsYXkiLCJpbnRlcnZhbCIsInBhdXNlIiwiZW5hYmxlIiwiaXNUeXBlIiwiZ2V0JCQxIiwiX28iLCJzZXQiLCJzZXQkJDEiLCJvIiwiX2kiLCJfZCIsInN0YXR1cyIsIkNvbXBvbmVudHMiLCJFdmVudHMiLCJfdGhpcyIsImNhbGN1bGF0ZSIsImFmdGVyIiwiaXNTdGFydCIsImlzRW5kIiwiaXNPZmZzZXQiLCJzdGVwcyIsImNvdW50YWJsZVN0ZXBzIiwiTWF0aCIsIm1pbiIsIl9tIiwic3RlcCIsInN1YnN0ciIsIkh0bWwiLCJzbGlkZXMiLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsImZ1bmMiLCJ3YWl0IiwidGltZW91dCIsImFyZ3MiLCJyZXN1bHQiLCJwcmV2aW91cyIsImxhdGVyIiwibGVhZGluZyIsImFwcGx5IiwidGhyb3R0bGVkIiwiYXQiLCJyZW1haW5pbmciLCJjbGVhclRpbWVvdXQiLCJ0cmFpbGluZyIsInNldFRpbWVvdXQiLCJjYW5jZWwiLCJNQVJHSU5fVFlQRSIsIkdhcHMiLCJsZW4iLCJzdHlsZSIsIkRpcmVjdGlvbiIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsIlNpemVzIiwid3JhcHBlciIsImNoaWxkcmVuIiwic2libGluZ3MiLCJub2RlIiwicGFyZW50Tm9kZSIsIm4iLCJmaXJzdENoaWxkIiwibWF0Y2hlZCIsIm5leHRTaWJsaW5nIiwibm9kZVR5cGUiLCJleGlzdCIsIndpbmRvdyIsIkhUTUxFbGVtZW50IiwiVFJBQ0tfU0VMRUNUT1IiLCJyb290IiwidHJhY2siLCJxdWVyeVNlbGVjdG9yIiwic2xpY2UiLCJmaWx0ZXIiLCJzbGlkZSIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwiX3IiLCJkb2N1bWVudCIsInQiLCJQZWVrIiwiX3YiLCJiZWZvcmUiLCJvZmZzZXQiLCJtb3ZlbWVudCIsInNsaWRlV2lkdGgiLCJ0cmFuc2xhdGUiLCJpcyIsInNldHVwU2xpZGVzIiwid2lkdGgiLCJzZXR1cFdyYXBwZXIiLCJkaW1lbnRpb24iLCJ3cmFwcGVyU2l6ZSIsIm9mZnNldFdpZHRoIiwiZ3JvdyIsIkNsb25lcyIsInJlZHVjdG9yIiwiQnVpbGQiLCJ0eXBlQ2xhc3MiLCJhY3RpdmVDbGFzcyIsImFkZCIsInNpYmxpbmciLCJyZW1vdmVDbGFzc2VzIiwiaXRlbXMiLCJjb2xsZWN0IiwiX0dsaWRlJHNldHRpbmdzIiwicGVla0luY3JlbWVudGVyIiwicGFydCIsInN0YXJ0IiwiZW5kIiwibWF4IiwiZmxvb3IiLCJjbG9uZSIsImNsb25lTm9kZSIsIl9jbG9uZSIsInVuc2hpZnQiLCJhcHBlbmQiLCJfQ29tcG9uZW50cyRIdG1sIiwiaGFsZiIsInByZXBlbmQiLCJyZXZlcnNlIiwiYXBwZW5kQ2hpbGQiLCJfaTIiLCJpbnNlcnRCZWZvcmUiLCJfaTMiLCJyZW1vdmVDaGlsZCIsIkV2ZW50c0JpbmRlciIsImxpc3RlbmVycyIsImVsIiwiY2xvc3VyZSIsImNhcHR1cmUiLCJhZGRFdmVudExpc3RlbmVyIiwib2ZmIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIlJlc2l6ZSIsIkJpbmRlciIsImJpbmQiLCJ1bmJpbmQiLCJWQUxJRF9ESVJFQ1RJT05TIiwiRkxJUEVEX01PVkVNRU5UUyIsInJlc29sdmUiLCJ0b2tlbiIsInNwbGl0Iiwiam9pbiIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJpbmRleE9mIiwiUnRsIiwibW9kaWZ5IiwiR2FwIiwiR3JvdyIsIlBlZWtpbmciLCJGb2N1c2luZyIsIm11dGF0b3IiLCJUUkFOU0ZPUk1FUlMiLCJjb25jYXQiLCJ0cmFuc2Zvcm1lciIsIlRyYW5zbGF0ZSIsInRyYW5zZm9ybSIsImNvbXBvc2UiLCJkdXJhdGlvbiIsInRyYW5zaXRpb24iLCJjYWxsYmFjayIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJlIiwic3VwcG9ydHNQYXNzaXZlJDEiLCJTVEFSVF9FVkVOVFMiLCJNT1ZFX0VWRU5UUyIsIkVORF9FVkVOVFMiLCJNT1VTRV9FVkVOVFMiLCJTd2lwZSIsInN3aXBlU2luIiwic3dpcGVTdGFydFgiLCJzd2lwZVN0YXJ0WSIsInBhc3NpdmUiLCJiaW5kU3dpcGVTdGFydCIsInN3aXBlIiwidG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJiaW5kU3dpcGVNb3ZlIiwiYmluZFN3aXBlRW5kIiwic3ViRXhTeCIsInN1YkV5U3kiLCJwb3dFWCIsImFicyIsInBvd0VZIiwic3dpcGVIeXBvdGVudXNlIiwic3FydCIsInN3aXBlQ2F0aGV0dXMiLCJhc2luIiwiUEkiLCJzdG9wUHJvcGFnYXRpb24iLCJ0aHJlc2hvbGQiLCJzd2lwZURpc3RhbmNlIiwic3dpcGVEZWciLCJyb3VuZCIsInVuYmluZFN3aXBlTW92ZSIsInVuYmluZFN3aXBlRW5kIiwidW5iaW5kU3dpcGVTdGFydCIsIl90aGlzMiIsIl90aGlzMyIsImNoYW5nZWRUb3VjaGVzIiwiSW1hZ2VzIiwiZHJhZ3N0YXJ0IiwicHJldmVudERlZmF1bHQiLCJBbmNob3JzIiwiZGV0YWNoZWQiLCJwcmV2ZW50ZWQiLCJfYSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjbGljayIsImRldGFjaCIsImRyYWdnYWJsZSIsInNldEF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImF0dGFjaCIsIk5BVl9TRUxFQ1RPUiIsIkNPTlRST0xTX1NFTEVDVE9SIiwiQ29udHJvbHMiLCJfbiIsImFkZEJpbmRpbmdzIiwic2V0QWN0aXZlIiwicmVtb3ZlQWN0aXZlIiwiY29udHJvbHMiLCJyZW1vdmVCaW5kaW5ncyIsImVsZW1lbnRzIiwiY3VycmVudFRhcmdldCIsIktleWJvYXJkIiwicHJlc3MiLCJrZXlDb2RlIiwiQXV0b3BsYXkiLCJzZXRJbnRlcnZhbCIsInN0b3AiLCJ0aW1lIiwiY2xlYXJJbnRlcnZhbCIsInNvcnRCcmVha3BvaW50cyIsInBvaW50cyIsIkJyZWFrcG9pbnRzIiwibWF0Y2giLCJtYXRjaE1lZGlhIiwicG9pbnQiLCJtYXRjaGVzIiwiQ09NUE9ORU5UUyIsIkdsaWRlJDEiLCJfQ29yZSIsIkdsaWRlJCQxIiwibWl4aXR1cCIsImgiLCJWRU5ET1JTIiwiY2FuYXJ5IiwiY3JlYXRlRWxlbWVudCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRFbGVtZW50U2libGluZyIsIkVsZW1lbnQiLCJFbGVtZW50UHJvdG90eXBlIiwibWFjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJwYXJlbnRFbGVtZW50IiwiaGFzRG9udEVudW1CdWciLCJkb250RW51bXMiLCJkb250RW51bXNMZW5ndGgiLCJ0b1N0cmluZyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiYXJnIiwiVGVtcCIsInByb3BlcnRpZXNPYmplY3QiLCJTdHJpbmciLCJ0cmltIiwicmVwbGFjZSIsInNlYXJjaEVsZW1lbnQiLCJOdW1iZXIiLCJJbmZpbml0eSIsIm9UaGlzIiwiYUFyZ3MiLCJGTk9QIiwiZkJvdW5kIiwiZGlzcGF0Y2hFdmVudCIsImZpcmVFdmVudCIsImVyciIsImNvbnRhaW5lciIsImNvbmZpZyIsImZvcmVpZ25Eb2MiLCJyZXR1cm5Db2xsZWN0aW9uIiwiZmFjYWRlIiwiZG9jIiwib3V0cHV0IiwiaW5zdGFuY2VzIiwiaWQiLCJpc0VsZW1lbnQiLCJFcnJvciIsIm1lc3NhZ2VzIiwiZXJyb3JGYWN0b3J5SW52YWxpZENvbnRhaW5lciIsImVycm9yRmFjdG9yeUNvbnRhaW5lck5vdEZvdW5kIiwicmFuZG9tSGV4IiwiTWl4ZXIiLCJkZWJ1ZyIsInNob3dXYXJuaW5ncyIsIndhcm5pbmdGYWN0b3J5UHJlZXhpc3RpbmdJbnN0YW5jZSIsIkZhY2FkZSIsIkNvbGxlY3Rpb24iLCJ1c2UiLCJleHRlbnNpb24iLCJCYXNlIiwiY2FsbEFjdGlvbnMiLCJUWVBFIiwiTkFNRSIsImZuIiwianF1ZXJ5IiwibGlicmFyaWVzIiwiJCIsImhhc0NsYXNzIiwiY2xzIiwiY2xhc3NOYW1lIiwiUmVnRXhwIiwicmVnIiwiZXh0ZW5kIiwiZGVzdGluYXRpb24iLCJkZWVwIiwiaGFuZGxlRXJyb3JzIiwic291cmNlS2V5cyIsImhhbmRsZUV4dGVuZEVycm9yIiwicmUiLCJlcnJvbmVvdXMiLCJtZXNzYWdlIiwic3VnZ2VzdGlvbiIsInByb2JhYmxlTWF0Y2giLCJtb3N0TWF0Y2hpbmdDaGFycyIsImV4ZWMiLCJjaGFyQXQiLCJlcnJvckNvbmZpZ0ludmFsaWRQcm9wZXJ0eVN1Z2dlc3Rpb24iLCJlcnJvckNvbmZpZ0ludmFsaWRQcm9wZXJ0eSIsInRlbXBsYXRlIiwic3RyIiwiZHluYW1pY3MiLCJkYXRhIiwidXNlQ2FwdHVyZSIsImF0dGFjaEV2ZW50IiwiZGV0YWNoRXZlbnQiLCJnZXRDdXN0b21FdmVudCIsImV2ZW50VHlwZSIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsImNyZWF0ZUV2ZW50T2JqZWN0IiwicmV0dXJuVmFsdWUiLCJjYW5jZWxCdWJibGUiLCJnZXRPcmlnaW5hbEV2ZW50IiwicHJldmlvdXNFbGVtZW50U2libGluZyIsImNhbWVsQ2FzZSIsInRvTG93ZXJDYXNlIiwiJDEiLCJ0b1VwcGVyQ2FzZSIsInBhc2NhbENhc2UiLCJkYXNoQ2FzZSIsImRlZmF1bHRWaWV3Iiwibm9kZU5hbWUiLCJodG1sU3RyaW5nIiwiZnJhZyIsInRlbXAiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiaW5uZXJIVE1MIiwicmVtb3ZlV2hpdGVzcGFjZSIsImRlbGV0aW5nIiwicHJldmlvdXNTaWJsaW5nIiwiaXNFcXVhbEFycmF5IiwiYSIsImIiLCJkZWVwRXF1YWxzIiwiYXJyYXlTaHVmZmxlIiwib2xkQXJyYXkiLCJuZXdBcnJheSIsInAiLCJyYW5kb20iLCJhcnJheUZyb21MaXN0IiwibGlzdCIsImRlYm91bmNlIiwiaW1tZWRpYXRlIiwiY2FsbE5vdyIsInBvc2l0aW9uIiwiZWxlbWVudCIsInhQb3NpdGlvbiIsInlQb3NpdGlvbiIsIm9mZnNldFBhcmVudCIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwieCIsInkiLCJnZXRIeXBvdGVudXNlIiwibm9kZTEiLCJub2RlMiIsImRpc3RhbmNlWCIsImRpc3RhbmNlWSIsInBvdyIsImdldEludGVyc2VjdGlvblJhdGlvIiwiYm94MSIsImJveDIiLCJjb250cm9sQXJlYSIsImhlaWdodCIsImludGVyc2VjdGlvblgiLCJpbnRlcnNlY3Rpb25ZIiwiaW50ZXJzZWN0aW9uQXJlYSIsInJhdGlvIiwibGVmdCIsInRvcCIsImNsb3Nlc3RQYXJlbnQiLCJpbmNsdWRlU2VsZiIsImJvZHkiLCJ0ZW1wSWQiLCJyYW5kb21IZXhLZXkiLCJjbGVhbiIsIm9yaWdpbmFsQXJyYXkiLCJjbGVhbkFycmF5IiwiZGVmZXIiLCJkZWZlcnJlZCIsInByb21pc2VXcmFwcGVyIiwiRGVmZXJyZWQiLCJmZWF0dXJlcyIsImhhcyIsInByb21pc2VzIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZWplY3QiLCJqUXVlcnkiLCJ3YXJuaW5nTm9Qcm9taXNlSW1wbGVtZW50YXRpb24iLCJhbGwiLCJ0YXNrcyIsIndoZW4iLCJkb25lIiwiZ2V0UHJlZml4IiwidmVuZG9ycyIsInByZWZpeCIsImdldERvY3VtZW50U3RhdGUiLCJwYWdlWU9mZnNldCIsInBhZ2VYT2Zmc2V0IiwiZG9jSGVpZ2h0IiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsSGVpZ2h0IiwiZG9jV2lkdGgiLCJzY3JvbGxXaWR0aCIsInZpZXdwb3J0SGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwidmlld3BvcnRXaWR0aCIsImNsaWVudFdpZHRoIiwiaXNWaXNpYmxlIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInZpc2liaWxpdHkiLCJvcGFjaXR5Iiwic2VhbCIsImZyZWV6ZSIsImNvbXBhcmVWZXJzaW9ucyIsImNvbnRyb2wiLCJzcGVjaW1lbiIsImNvbnRyb2xQYXJ0cyIsInNwZWNpbWVuUGFydHMiLCJjb250cm9sUGFydCIsInNwZWNpbWVuUGFydCIsImlzRW1wdHlPYmplY3QiLCJnZXRDbGFzc25hbWUiLCJjbGFzc05hbWVzIiwiZWxlbWVudE5hbWUiLCJtb2RpZmllciIsImNsYXNzbmFtZSIsImJsb2NrIiwiZGVsaW5lYXRvckVsZW1lbnQiLCJkZWxpbmVhdG9yTW9kaWZpZXIiLCJnZXRQcm9wZXJ0eSIsInN0cmluZ0tleSIsInBhcnRzIiwicmV0dXJuQ3VycmVudCIsImN1cnJlbnQiLCJhY3Rpb25OYW1lIiwiaG9va3MiLCJhY3Rpb25zIiwiZXh0ZW5zaW9uTmFtZSIsImNhbGxGaWx0ZXJzIiwiZmlsdGVyTmFtZSIsImlucHV0IiwiZmlsdGVycyIsIkJhc2VTdGF0aWMiLCJyZWdpc3RlckFjdGlvbiIsImhvb2tOYW1lIiwicmVnaXN0ZXJGaWx0ZXIiLCJGZWF0dXJlcyIsImJveFNpemluZ1ByZWZpeCIsInRyYW5zZm9ybVByZWZpeCIsInRyYW5zaXRpb25QcmVmaXgiLCJ0cmFuc2Zvcm1Qcm9wIiwidHJhbnNmb3JtUnVsZSIsInRyYW5zaXRpb25Qcm9wIiwicGVyc3BlY3RpdmVQcm9wIiwicGVyc3BlY3RpdmVPcmlnaW5Qcm9wIiwiSGFzIiwiQk9YX1NJWklOR19QUk9QIiwiVFJBTlNJVElPTl9QUk9QIiwiVFJBTlNGT1JNX1BST1AiLCJQRVJTUEVDVElWRV9QUk9QIiwiUEVSU1BFQ1RJVkVfT1JJR0lOX1BST1AiLCJUV0VFTkFCTEUiLCJpbml0Iiwic2V0UHJlZml4ZXMiLCJydW5UZXN0cyIsInRyYW5zaXRpb25zIiwiYm94U2l6aW5nUHJvcCIsIkNvbmZpZ0FuaW1hdGlvbiIsImVmZmVjdHMiLCJlZmZlY3RzSW4iLCJlZmZlY3RzT3V0IiwiZWFzaW5nIiwiYXBwbHlQZXJzcGVjdGl2ZSIsInBlcnNwZWN0aXZlRGlzdGFuY2UiLCJwZXJzcGVjdGl2ZU9yaWdpbiIsInF1ZXVlIiwicXVldWVMaW1pdCIsImFuaW1hdGVSZXNpemVDb250YWluZXIiLCJhbmltYXRlUmVzaXplVGFyZ2V0cyIsInN0YWdnZXJTZXF1ZW5jZSIsInJldmVyc2VPdXQiLCJudWRnZSIsImNsYW1wSGVpZ2h0IiwiY2xhbXBXaWR0aCIsIkNvbmZpZ0JlaGF2aW9yIiwibGl2ZVNvcnQiLCJDb25maWdDYWxsYmFja3MiLCJvbk1peFN0YXJ0Iiwib25NaXhCdXN5Iiwib25NaXhFbmQiLCJvbk1peEZhaWwiLCJvbk1peENsaWNrIiwiQ29uZmlnQ29udHJvbHMiLCJsaXZlIiwic2NvcGUiLCJ0b2dnbGVMb2dpYyIsInRvZ2dsZURlZmF1bHQiLCJDb25maWdDbGFzc05hbWVzIiwiZWxlbWVudENvbnRhaW5lciIsImVsZW1lbnRGaWx0ZXIiLCJlbGVtZW50U29ydCIsImVsZW1lbnRNdWx0aW1peCIsImVsZW1lbnRUb2dnbGUiLCJtb2RpZmllckFjdGl2ZSIsIm1vZGlmaWVyRGlzYWJsZWQiLCJtb2RpZmllckZhaWxlZCIsIkNvbmZpZ0RhdGEiLCJ1aWRLZXkiLCJkaXJ0eUNoZWNrIiwiQ29uZmlnRGVidWciLCJmYXV4QXN5bmMiLCJDb25maWdMYXlvdXQiLCJhbGxvd05lc3RlZFRhcmdldHMiLCJjb250YWluZXJDbGFzc05hbWUiLCJzaWJsaW5nQmVmb3JlIiwic2libGluZ0FmdGVyIiwiQ29uZmlnTG9hZCIsImRhdGFzZXQiLCJDb25maWdTZWxlY3RvcnMiLCJDb25maWdSZW5kZXIiLCJDb25maWdUZW1wbGF0ZXMiLCJDb25maWciLCJhbmltYXRpb24iLCJiZWhhdmlvciIsImNhbGxiYWNrcyIsImxheW91dCIsImxvYWQiLCJzZWxlY3RvcnMiLCJyZW5kZXIiLCJ0ZW1wbGF0ZXMiLCJNaXhlckRvbSIsInRhcmdldHMiLCJVaUNsYXNzTmFtZXMiLCJiYXNlIiwiYWN0aXZlIiwiQ29tbWFuZERhdGFzZXQiLCJDb21tYW5kTXVsdGltaXgiLCJpbnNlcnQiLCJjaGFuZ2VMYXlvdXQiLCJDb21tYW5kRmlsdGVyIiwiY29sbGVjdGlvbiIsImFjdGlvbiIsIkNvbW1hbmRTb3J0Iiwic29ydFN0cmluZyIsImF0dHJpYnV0ZSIsIm9yZGVyIiwibmV4dCIsIkNvbW1hbmRJbnNlcnQiLCJDb21tYW5kUmVtb3ZlIiwiQ29tbWFuZENoYW5nZUxheW91dCIsIkNvbnRyb2xEZWZpbml0aW9uIiwiY29udHJvbERlZmluaXRpb25zIiwiQ29udHJvbCIsInBlbmRpbmciLCJjYW5EaXNhYmxlIiwiYmluZENsaWNrIiwiaXNCb3VuZCIsIm1peGVyIiwiYWRkQmluZGluZyIsInJlbW92ZUJpbmRpbmciLCJyZW1vdmVJbmRleCIsInNwbGljZSIsInVuYmluZENsaWNrIiwicmVuZGVyU3RhdHVzIiwiaGFuZGxlQ2xpY2siLCJidXR0b24iLCJpc0FjdGl2ZSIsImNvbW1hbmQiLCJjb21tYW5kcyIsImRvbSIsImxhc3RDbGlja2VkIiwiZmlyZSIsInN0YXRlIiwib3JpZ2luYWxFdmVudCIsInRvZ2dsZU9mZiIsInRvZ2dsZU9uIiwibXVsdGltaXgiLCJ0b2dnbGVBcnJheSIsInVwZGF0ZUxpdmUiLCJwYXJzZVN0YXR1c0NoYW5nZSIsImNvbnRyb2xCdXR0b25zIiwiYWxpYXMiLCJ0b2dnbGUiLCJTdHlsZURhdGEiLCJyaWdodCIsImJvdHRvbSIsIm1hcmdpbkJvdHRvbSIsInNjYWxlIiwiVHJhbnNmb3JtRGF0YSIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwidHJhbnNsYXRlWiIsInJvdGF0ZVgiLCJyb3RhdGVZIiwicm90YXRlWiIsInVuaXQiLCJUcmFuc2Zvcm1EZWZhdWx0cyIsInRyYW5zZm9ybURlZmF1bHRzIiwiRXZlbnREZXRhaWwiLCJmdXR1cmVTdGF0ZSIsIm1peFN0YXJ0IiwibWl4QnVzeSIsIm1peEVuZCIsIm1peEZhaWwiLCJtaXhDbGljayIsImV2ZW50RGV0YWlsIiwiU3RhdGUiLCJRdWV1ZUl0ZW0iLCJpbnN0cnVjdGlvbiIsInRyaWdnZXJFbGVtZW50IiwiaXNUb2dnbGluZyIsImlzQnVzeSIsImluY1BhZGRpbmciLCJvcmlnT3JkZXIiLCJjYWNoZSIsInRhcmdldHNNb3ZlZCIsInRhcmdldHNJbW1vdmFibGUiLCJ0YXJnZXRzQm91bmQiLCJ0YXJnZXRzRG9uZSIsInN0YWdnZXJEdXJhdGlvbiIsInRyYW5zZm9ybUluIiwidHJhbnNmb3JtT3V0IiwibGFzdE9wZXJhdGlvbiIsInVzZXJDYWxsYmFjayIsInVzZXJEZWZlcnJlZCIsInNhbml0aXplQ29uZmlnIiwiY2FjaGVEb20iLCJpbmRleFRhcmdldHMiLCJnZXRJbml0aWFsU3RhdGUiLCJ0b0hpZGUiLCJoaWRlIiwiaW5pdENvbnRyb2xzIiwiYnVpbGRUb2dnbGVBcnJheSIsInVwZGF0ZUNvbnRyb2xzIiwiYWN0aXZlRmlsdGVyIiwiYWN0aXZlU29ydCIsInBhcnNlRWZmZWN0cyIsIm9wZXJhdGlvbiIsIk9wZXJhdGlvbiIsImFjdGl2ZUNvbnRhaW5lckNsYXNzTmFtZSIsImVycm9yQ29uZmlnRGF0YVVpZEtleU5vdFNldCIsInN0YXJ0RGF0YXNldCIsIm5ld0RhdGFzZXQiLCJhY3RpdmVEYXRhc2V0Iiwic3RhcnRDb250YWluZXJDbGFzc05hbWUiLCJuZXdDb250YWluZXJDbGFzc05hbWUiLCJzaG93IiwicGFyc2VGaWx0ZXJBcmdzIiwicGFyc2VTb3J0QXJncyIsInRvdGFsVGFyZ2V0cyIsIm5ld1NvcnQiLCJzb3J0T3BlcmF0aW9uIiwicHJpbnRTb3J0IiwibmV3T3JkZXIiLCJzdGFydE9yZGVyIiwic3RhcnRGaWx0ZXIiLCJuZXdGaWx0ZXIiLCJzdGFydFNvcnQiLCJmaWx0ZXJPcGVyYXRpb24iLCJidWlsZFN0YXRlIiwiZXJyb3JEYXRhc2V0UHJlcmVuZGVyZWRNaXNtYXRjaCIsIlRhcmdldCIsImlzSW5Eb20iLCJjb250cm9sRWxlbWVudHMiLCJkZWxhZ2F0b3JzIiwiaiIsImVycm9yQ29uZmlnSW52YWxpZENvbnRyb2xzU2NvcGUiLCJnZXRDb250cm9sIiwiZ2V0VG9nZ2xlU2VsZWN0b3IiLCJkZWxpbmVhdG9yIiwidG9nZ2xlU2VsZWN0b3IiLCJhY3RpdmVGaWx0ZXJTZWxlY3RvciIsInNwbGl0Q29tcG91bmRTZWxlY3RvciIsImNvbXBvdW5kU2VsZWN0b3IiLCJwYXJ0aWFscyIsInNoaWZ0IiwiYnVpbGRTb3J0U3RyaW5nIiwiaW5zZXJ0VGFyZ2V0cyIsImluc2VydGlvbkluZGV4IiwiZ2V0TmV4dFNpYmxpbmciLCJlcnJvckluc2VydFByZWV4aXN0aW5nRWxlbWVudCIsImRpc3BsYXkiLCJjcmVhdGVUZXh0Tm9kZSIsInRlc3RSZXN1bHQiLCJldmFsdWF0ZUhpZGVTaG93IiwidG9SZW1vdmUiLCJ0b1Nob3ciLCJtYXRjaGluZyIsImhhc0ZhaWxlZCIsImZpbHRlcmVkVGVzdFJlc3VsdCIsImlzU2hvd24iLCJlcnJvclNvcnROb25FeGlzdGVudEVsZW1lbnQiLCJjb21wYXJlIiwid2lsbFNvcnQiLCJhdHRyQSIsImdldEF0dHJpYnV0ZVZhbHVlIiwiYXR0ckIiLCJpc05hTiIsIndhcm5pbmdJbmNvbnNpc3RlbnRTb3J0aW5nQXR0cmlidXRlcyIsImlzUmVzZXR0aW5nIiwid2hpdGVzcGFjZSIsImxhc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJwYXJzZVNvcnRTdHJpbmciLCJydWxlcyIsInJ1bGUiLCJ0cmFuc2Zvcm1OYW1lIiwicGFyc2VFZmZlY3QiLCJlZmZlY3ROYW1lIiwiZWZmZWN0U3RyaW5nIiwiaXNPdXQiLCJwcm9wSW5kZXgiLCJ2YWwiLCJ1bml0cyIsImVycm9yQ29uZmlnSW52YWxpZEFuaW1hdGlvbkVmZmVjdHMiLCJzdWJzdHJpbmciLCJ0b3RhbFNob3ciLCJ0b3RhbEhpZGUiLCJ0b3RhbE1hdGNoaW5nIiwiZ29NaXgiLCJzaG91bGRBbmltYXRlIiwid2lsbENoYW5nZUxheW91dCIsInN0YXJ0U3RhdGUiLCJuZXdTdGF0ZSIsImNsZWFuVXAiLCJkb2NTdGF0ZSIsInNjcm9sbFRvIiwic3RhcnRIZWlnaHQiLCJuZXdIZWlnaHQiLCJ2aWV3cG9ydERlbHRhWSIsInN0YXJ0V2lkdGgiLCJuZXdXaWR0aCIsInZpZXdwb3J0RGVsdGFYIiwib3ZlcmZsb3ciLCJtb3ZlVGFyZ2V0cyIsImdldFN0YXJ0TWl4RGF0YSIsInBhcmVudFN0eWxlIiwicGFyZW50UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJveFNpemluZyIsImdldFBvc0RhdGEiLCJzaG93UG9zRGF0YSIsInN0YXJ0UG9zRGF0YSIsInRvSGlkZVBvc0RhdGEiLCJzdGFydFgiLCJzdGFydFkiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsImJvcmRlclRvcCIsImJvcmRlckJvdHRvbSIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiYm9yZGVyTGVmdCIsImJvcmRlclJpZ2h0Iiwic2V0SW50ZXIiLCJnZXRJbnRlck1peERhdGEiLCJpbnRlclBvc0RhdGEiLCJzZXRGaW5hbCIsImdldEZpbmFsTWl4RGF0YSIsImZpbmFsUG9zRGF0YSIsIm5ld1giLCJuZXdZIiwiZ2V0VHdlZW5EYXRhIiwicG9zRGF0YSIsImVmZmVjdE5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImVmZmVjdCIsIndpZHRoQ2hhbmdlIiwiaGVpZ2h0Q2hhbmdlIiwicG9zSW4iLCJwb3NPdXQiLCJ0d2VlbkRhdGEiLCJtb3ZlRGF0YSIsInN0YXR1c0NoYW5nZSIsIndpbGxUcmFuc2l0aW9uIiwic3RhZ2dlckluZGV4IiwiY2hlY2tQcm9ncmVzcyIsIklNb3ZlRGF0YSIsImhhc0VmZmVjdCIsIkNvbnRhaW5lckNsYXNzTmFtZSIsIkVGRkVDVEFCTEVTIiwibWFyZ2luVG9wIiwid2hpdGVzcGFjZUJlZm9yZSIsIndoaXRlc3BhY2VBZnRlciIsIm5leHRJblF1ZXVlIiwicGFyc2VNdWx0aW1peEFyZ3MiLCJVc2VySW5zdHJ1Y3Rpb24iLCJhbmltYXRlIiwicGFyc2VJbnNlcnRBcmdzIiwicGFyc2VSZW1vdmVBcmdzIiwicGFyc2VDaGFuZ2VMYXlvdXRBcmdzIiwiZXJyb3JGaWx0ZXJJbnZhbGlkQXJndW1lbnRzIiwiZXJyb3JJbnNlcnRJbnZhbGlkQXJndW1lbnRzIiwid2FybmluZ0luc2VydE5vRWxlbWVudHMiLCJ3YXJuaW5nUmVtb3ZlTm9FbGVtZW50cyIsInBhcnNlRGF0YXNldEFyZ3MiLCJxdWV1ZU1peCIsInF1ZXVlSXRlbSIsIndhcm5pbmdNdWx0aW1peEluc3RhbmNlUXVldWVGdWxsIiwiZ2V0RGF0YU9wZXJhdGlvbiIsImVycm9yRGF0YXNldE5vdFNldCIsImRpZmZEYXRhc2V0cyIsInBlcnNpc3RhbnRTdGFydElkcyIsInBlcnNpc3RhbnROZXdJZHMiLCJpbnNlcnRlZFRhcmdldHMiLCJuZXh0RWwiLCJ1aWRzIiwiZXJyb3JEYXRhc2V0SW52YWxpZFVpZEtleSIsImVycm9yRGF0YXNldER1cGxpY2F0ZVVpZCIsInVpZCIsInVuYmluZEV2ZW50cyIsInJlcGxhY2VDaGlsZCIsImJpbmRFdmVudHMiLCJsYXN0RWxlbWVudENoaWxkIiwiaW5zZXJ0RGF0YXNldEZyYWciLCJpbnNlcnRBdCIsInNvcnRDb21tYW5kQSIsInNvcnRDb21tYW5kQiIsImlzTWl4aW5nIiwic2VsZWN0b3JJbmRleCIsImdldE9wZXJhdGlvbiIsIm11bHRpbWl4Q29tbWFuZCIsInNvcnRDb21tYW5kIiwiZmlsdGVyQ29tbWFuZCIsImNoYW5nZUxheW91dENvbW1hbmQiLCJyZW1vdmVDb21tYW5kIiwiaW5zZXJ0Q29tbWFuZCIsIndhcm5pbmdHZXRPcGVyYXRpb25JbnN0YW5jZUJ1c3kiLCJ0d2VlbiIsIm11bHRpcGxpZXIiLCJ0b0hpZGVJbmRleCIsImFwcGx5VHdlZW4iLCJpbnNlcnRBZnRlciIsImdldENvbmZpZyIsImNvbmZpZ3VyZSIsImdldFN0YXRlIiwiZm9yY2VSZWZyZXNoIiwiZm9yY2VSZW5kZXIiLCJUYXJnZXREb20iLCJpc0V4Y2x1ZGVkIiwiZXJyb3JEYXRhc2V0UmVuZGVyZXJOb3RTZXQiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImdldFNvcnRTdHJpbmciLCJhdHRyaWJ1dGVOYW1lIiwiYXBwbHlTdHlsZXNJbiIsImFwcGx5U3R5bGVzT3V0IiwicHJvcGVydHlOYW1lIiwiY3VycmVudFRyYW5zZm9ybVZhbHVlcyIsImN1cnJlbnRWYWx1ZXMiLCJpc0ZhZGluZyIsInRyYW5zZm9ybVZhbHVlcyIsInRyYW5zaXRpb25SdWxlcyIsImlzUmVzaXppbmciLCJ3cml0ZVRyYW5zaXRpb25SdWxlIiwiYXBwbHlUcmFuc2l0aW9uIiwiZGVsYXkiLCJnZXREZWxheSIsInRyYW5zaXRpb25TdHJpbmciLCJoYW5kbGVUcmFuc2l0aW9uRW5kIiwicHJvcE5hbWUiLCJjYW5SZXNpemUiLCJldmVudEJ1cyIsInRyYW5zaXRpb25FbmRFdmVudCIsImdldEJveCIsInJlY3QiLCJtZXRob2ROYW1lIiwidG9Nb3ZlIiwic3RhcnREaXNwbGF5IiwibmV3RGlzcGxheSIsIk1lc3NhZ2VzIiwiRVJST1JfRkFDVE9SWV9JTlZBTElEX0NPTlRBSU5FUiIsIkVSUk9SX0ZBQ1RPUllfQ09OVEFJTkVSX05PVF9GT1VORCIsIkVSUk9SX0NPTkZJR19JTlZBTElEX0FOSU1BVElPTl9FRkZFQ1RTIiwiRVJST1JfQ09ORklHX0lOVkFMSURfQ09OVFJPTFNfU0NPUEUiLCJFUlJPUl9DT05GSUdfSU5WQUxJRF9QUk9QRVJUWSIsIkVSUk9SX0NPTkZJR19JTlZBTElEX1BST1BFUlRZX1NVR0dFU1RJT04iLCJFUlJPUl9DT05GSUdfREFUQV9VSURfS0VZX05PVF9TRVQiLCJFUlJPUl9EQVRBU0VUX0lOVkFMSURfVUlEX0tFWSIsIkVSUk9SX0RBVEFTRVRfRFVQTElDQVRFX1VJRCIsIkVSUk9SX0lOU0VSVF9JTlZBTElEX0FSR1VNRU5UUyIsIkVSUk9SX0lOU0VSVF9QUkVFWElTVElOR19FTEVNRU5UIiwiRVJST1JfRklMVEVSX0lOVkFMSURfQVJHVU1FTlRTIiwiRVJST1JfREFUQVNFVF9OT1RfU0VUIiwiRVJST1JfREFUQVNFVF9QUkVSRU5ERVJFRF9NSVNNQVRDSCIsIkVSUk9SX0RBVEFTRVRfUkVOREVSRVJfTk9UX1NFVCIsIkVSUk9SX1NPUlRfTk9OX0VYSVNURU5UX0VMRU1FTlQiLCJXQVJOSU5HX0ZBQ1RPUllfUFJFRVhJU1RJTkdfSU5TVEFOQ0UiLCJXQVJOSU5HX0lOU0VSVF9OT19FTEVNRU5UUyIsIldBUk5JTkdfUkVNT1ZFX05PX0VMRU1FTlRTIiwiV0FSTklOR19NVUxUSU1JWF9JTlNUQU5DRV9RVUVVRV9GVUxMIiwiV0FSTklOR19HRVRfT1BFUkFUSU9OX0lOU1RBTkNFX0JVU1kiLCJXQVJOSU5HX05PX1BST01JU0VfSU1QTEVNRU5UQVRJT04iLCJXQVJOSU5HX0lOQ09OU0lTVEVOVF9TT1JUSU5HX0FUVFJJQlVURVMiLCJjb21waWxlVGVtcGxhdGVzIiwiZXJyb3JLZXkiLCJlcnJvck1lc3NhZ2UiLCJDT1JFX1ZFUlNJT04iLCJ3ZWJwYWNrUG9seWZpbGwiLCJkZXByZWNhdGUiLCJwYXRocyIsImwiLCJtaXhlckNvbnRhaW5lciIsIm1xIiwic3IiLCJTY3JvbGxSZXZlYWwiLCJsb2ciLCJzbGlkZVVwIiwib3JpZ2luIiwic2xpZGVMZWZ0IiwibW9iaWxlIiwic2xpZGVUb3AiLCJzbGlkZVJpZ2h0IiwicmV2ZWFsIiwibmF2IiwiZ2V0RWxlbWVudEJ5SWQiLCJhcnJvd1RvcCIsInNsaWRlclBhbmVsIiwicGFyYWxsYXgiLCJzdGF0aXN0aWNzIiwic3RhdHNESVZzIiwieFNjcm9sbFBvc2l0aW9uIiwieVNjcm9sbFBvc2l0aW9uIiwibGFzdFNjcm9sbFBvcyIsImNvdW50ZWQiLCJwYXJhbGxheFBvcyIsIm1lbnVJdGVtcyIsIm1lbnVCdG4iLCJnZXREb2NIZWlnaHQiLCJEIiwib2Zmc2V0SGVpZ2h0IiwiZG9jaGVpZ2h0Iiwib25zY3JvbGwiLCJzaHJpbmtOYXYiLCJzaG93QXJyb3ciLCJpc0VsZW1lbnRJblZpZXdwb3J0IiwiY2F0IiwiY291bnRUbyIsImNvbXBsZXRlU3RhdHMiLCJjb3VudFZhbHVlIiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0Iiwic2Nyb2xsTG9vcCIsInNjcm9sbFgiLCJzY3JvbGxZIiwic2V0VHJhbnNsYXRlIiwieFBvcyIsInlQb3MiLCJzZXRCZ1Bvc1kiLCJiYWNrZ3JvdW5kUG9zaXRpb25ZIiwiYW5jaG9yIiwic2Nyb2xsSW50b1ZpZXciLCJhZGREYXRhQXR0cmlidXRlcyIsImJhY2tncm91bmRDb2xvciIsInBhZGRpbmciLCJzbGlkZXJCdG5zIiwic2xpZGVySW1ncyIsImltZyIsInNsaWRlSW5Qcm9ncmVzcyIsImVsZW1zIiwiY3VycmVudEFuaW1hdGlvbkR1cmF0aW9uIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImFkanVzdFNlcnZpY2VzU2VjdGlvbiIsInJvd0xlZnQiLCJzZXJ2aWNlc0xlZnQiLCJidWlsZERlc2NEaXYiLCJkaXYiLCJjYXRlZ29yaWVzIiwiaW1nTmFtZSIsInRpdGxlIiwidGV4dENvbnRlbnQiLCJjYXRlZ29yaWVzU3ViIiwiY2F0ZWdvcnlIb2xkZXIiLCJmYXZvcml0ZXMiLCJwb3N0czI0aCIsInRvdGFsUG9zdHMiLCJjYW1wYWlnbnMiLCJhbWF6aW5nRmVhdHVyZXMiLCJjb3VudGluZyIsInJlYWRNb3JlQmxvZyIsImVsZW0iLCJvdmVybGF5Il0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7OztBQ2xGQTs7Ozs7QUFNQyxXQUFVQSxNQUFWLEVBQWtCQyxPQUFsQixFQUEyQjtBQUMxQixpQ0FBT0MsT0FBUCxPQUFtQixRQUFuQixJQUErQixPQUFPQyxNQUFQLEtBQWtCLFdBQWpELEdBQStEQSxNQUFNLENBQUNELE9BQVAsR0FBaUJELE9BQU8sRUFBdkYsR0FDQSxRQUE2Q0csb0NBQU9ILE9BQUQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxvR0FBbkQsR0FDQ0QsU0FGRDtBQUdELENBSkEsRUFJQyxJQUpELEVBSVEsWUFBWTtBQUFFOztBQUVyQixNQUFJSyxRQUFRLEdBQUc7QUFDYjs7Ozs7Ozs7O0FBU0FDLFFBQUksRUFBRSxRQVZPOztBQVliOzs7OztBQUtBQyxXQUFPLEVBQUUsQ0FqQkk7O0FBbUJiOzs7OztBQUtBQyxXQUFPLEVBQUUsQ0F4Qkk7O0FBMEJiOzs7Ozs7Ozs7QUFTQUMsV0FBTyxFQUFFLENBbkNJOztBQXFDYjs7Ozs7QUFLQUMsT0FBRyxFQUFFLEVBMUNROztBQTRDYjs7Ozs7QUFLQUMsWUFBUSxFQUFFLEtBakRHOztBQW1EYjs7Ozs7QUFLQUMsY0FBVSxFQUFFLElBeERDOztBQTBEYjs7Ozs7QUFLQUMsWUFBUSxFQUFFLElBL0RHOztBQWlFYjs7Ozs7Ozs7QUFRQUMsU0FBSyxFQUFFLEtBekVNOztBQTJFYjs7Ozs7QUFLQUMsa0JBQWMsRUFBRSxFQWhGSDs7QUFrRmI7Ozs7O0FBS0FDLGlCQUFhLEVBQUUsR0F2RkY7O0FBeUZiOzs7OztBQUtBQyxZQUFRLEVBQUUsS0E5Rkc7O0FBZ0diOzs7OztBQUtBQyxjQUFVLEVBQUUsR0FyR0M7O0FBdUdiOzs7OztBQUtBQyxjQUFVLEVBQUUsRUE1R0M7O0FBOEdiOzs7OztBQUtBQyxxQkFBaUIsRUFBRSxHQW5ITjs7QUFxSGI7Ozs7O0FBS0FDLFVBQU0sRUFBRSxJQTFISzs7QUE0SGI7Ozs7O0FBS0FDLGtCQUFjLEVBQUUsR0FqSUg7O0FBbUliOzs7OztBQUtBQyx1QkFBbUIsRUFBRSxtQ0F4SVI7O0FBMEliOzs7OztBQUtBQyxZQUFRLEVBQUUsRUEvSUc7O0FBaUpiOzs7Ozs7Ozs7QUFTQUMsYUFBUyxFQUFFLEtBMUpFOztBQTRKYjs7Ozs7Ozs7Ozs7O0FBWUFDLFFBQUksRUFBRSxDQXhLTzs7QUEwS2I7Ozs7Ozs7OztBQVNBQyxlQUFXLEVBQUUsRUFuTEE7O0FBcUxiOzs7Ozs7QUFNQUMsV0FBTyxFQUFFO0FBQ1BILGVBQVMsRUFBRTtBQUNUSSxXQUFHLEVBQUUsWUFESTtBQUVUQyxXQUFHLEVBQUU7QUFGSSxPQURKO0FBS1BDLFlBQU0sRUFBRSxlQUxEO0FBTVBDLGNBQVEsRUFBRSxpQkFOSDtBQU9QQyxlQUFTLEVBQUUsa0JBUEo7QUFRUEMsY0FBUSxFQUFFLGlCQVJIO0FBU1BDLGdCQUFVLEVBQUUscUJBVEw7QUFVUEMsZUFBUyxFQUFFLHVCQVZKO0FBV1BDLGlCQUFXLEVBQUUsc0JBWE47QUFZUEMsbUJBQWEsRUFBRTtBQVpSO0FBM0xJLEdBQWY7QUEyTUE7Ozs7Ozs7QUFNQSxXQUFTQyxJQUFULENBQWNDLEdBQWQsRUFBbUI7QUFDakJDLFdBQU8sQ0FBQ0MsS0FBUixDQUFjLG1CQUFtQkYsR0FBakM7QUFDRDs7QUFFRCxNQUFJRyxPQUFPLEdBQUcsT0FBT0MsTUFBUCxLQUFrQixVQUFsQixJQUFnQyxTQUFPQSxNQUFNLENBQUNDLFFBQWQsTUFBMkIsUUFBM0QsR0FBc0UsVUFBVUMsR0FBVixFQUFlO0FBQ2pHLG9CQUFjQSxHQUFkO0FBQ0QsR0FGYSxHQUVWLFVBQVVBLEdBQVYsRUFBZTtBQUNqQixXQUFPQSxHQUFHLElBQUksT0FBT0YsTUFBUCxLQUFrQixVQUF6QixJQUF1Q0UsR0FBRyxDQUFDQyxXQUFKLEtBQW9CSCxNQUEzRCxJQUFxRUUsR0FBRyxLQUFLRixNQUFNLENBQUNJLFNBQXBGLEdBQWdHLFFBQWhHLFlBQWtIRixHQUFsSCxDQUFQO0FBQ0QsR0FKRDs7QUFNQSxNQUFJRyxjQUFjLEdBQUcsU0FBakJBLGNBQWlCLENBQVVDLFFBQVYsRUFBb0JDLFdBQXBCLEVBQWlDO0FBQ3BELFFBQUksRUFBRUQsUUFBUSxZQUFZQyxXQUF0QixDQUFKLEVBQXdDO0FBQ3RDLFlBQU0sSUFBSUMsU0FBSixDQUFjLG1DQUFkLENBQU47QUFDRDtBQUNGLEdBSkQ7O0FBTUEsTUFBSUMsV0FBVyxHQUFHLFlBQVk7QUFDNUIsYUFBU0MsZ0JBQVQsQ0FBMEJDLE1BQTFCLEVBQWtDQyxLQUFsQyxFQUF5QztBQUN2QyxXQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdELEtBQUssQ0FBQ0UsTUFBMUIsRUFBa0NELENBQUMsRUFBbkMsRUFBdUM7QUFDckMsWUFBSUUsVUFBVSxHQUFHSCxLQUFLLENBQUNDLENBQUQsQ0FBdEI7QUFDQUUsa0JBQVUsQ0FBQ0MsVUFBWCxHQUF3QkQsVUFBVSxDQUFDQyxVQUFYLElBQXlCLEtBQWpEO0FBQ0FELGtCQUFVLENBQUNFLFlBQVgsR0FBMEIsSUFBMUI7QUFDQSxZQUFJLFdBQVdGLFVBQWYsRUFBMkJBLFVBQVUsQ0FBQ0csUUFBWCxHQUFzQixJQUF0QjtBQUMzQkMsY0FBTSxDQUFDQyxjQUFQLENBQXNCVCxNQUF0QixFQUE4QkksVUFBVSxDQUFDTSxHQUF6QyxFQUE4Q04sVUFBOUM7QUFDRDtBQUNGOztBQUVELFdBQU8sVUFBVVIsV0FBVixFQUF1QmUsVUFBdkIsRUFBbUNDLFdBQW5DLEVBQWdEO0FBQ3JELFVBQUlELFVBQUosRUFBZ0JaLGdCQUFnQixDQUFDSCxXQUFXLENBQUNILFNBQWIsRUFBd0JrQixVQUF4QixDQUFoQjtBQUNoQixVQUFJQyxXQUFKLEVBQWlCYixnQkFBZ0IsQ0FBQ0gsV0FBRCxFQUFjZ0IsV0FBZCxDQUFoQjtBQUNqQixhQUFPaEIsV0FBUDtBQUNELEtBSkQ7QUFLRCxHQWhCaUIsRUFBbEI7O0FBa0JBLE1BQUlpQixRQUFRLEdBQUdMLE1BQU0sQ0FBQ00sTUFBUCxJQUFpQixVQUFVZCxNQUFWLEVBQWtCO0FBQ2hELFNBQUssSUFBSUUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2EsU0FBUyxDQUFDWixNQUE5QixFQUFzQ0QsQ0FBQyxFQUF2QyxFQUEyQztBQUN6QyxVQUFJYyxNQUFNLEdBQUdELFNBQVMsQ0FBQ2IsQ0FBRCxDQUF0Qjs7QUFFQSxXQUFLLElBQUlRLEdBQVQsSUFBZ0JNLE1BQWhCLEVBQXdCO0FBQ3RCLFlBQUlSLE1BQU0sQ0FBQ2YsU0FBUCxDQUFpQndCLGNBQWpCLENBQWdDQyxJQUFoQyxDQUFxQ0YsTUFBckMsRUFBNkNOLEdBQTdDLENBQUosRUFBdUQ7QUFDckRWLGdCQUFNLENBQUNVLEdBQUQsQ0FBTixHQUFjTSxNQUFNLENBQUNOLEdBQUQsQ0FBcEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsV0FBT1YsTUFBUDtBQUNELEdBWkQ7O0FBY0EsTUFBSW1CLEdBQUcsR0FBRyxTQUFTQSxHQUFULENBQWFDLE1BQWIsRUFBcUJDLFFBQXJCLEVBQStCQyxRQUEvQixFQUF5QztBQUNqRCxRQUFJRixNQUFNLEtBQUssSUFBZixFQUFxQkEsTUFBTSxHQUFHRyxRQUFRLENBQUM5QixTQUFsQjtBQUNyQixRQUFJK0IsSUFBSSxHQUFHaEIsTUFBTSxDQUFDaUIsd0JBQVAsQ0FBZ0NMLE1BQWhDLEVBQXdDQyxRQUF4QyxDQUFYOztBQUVBLFFBQUlHLElBQUksS0FBS0UsU0FBYixFQUF3QjtBQUN0QixVQUFJQyxNQUFNLEdBQUduQixNQUFNLENBQUNvQixjQUFQLENBQXNCUixNQUF0QixDQUFiOztBQUVBLFVBQUlPLE1BQU0sS0FBSyxJQUFmLEVBQXFCO0FBQ25CLGVBQU9ELFNBQVA7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPUCxHQUFHLENBQUNRLE1BQUQsRUFBU04sUUFBVCxFQUFtQkMsUUFBbkIsQ0FBVjtBQUNEO0FBQ0YsS0FSRCxNQVFPLElBQUksV0FBV0UsSUFBZixFQUFxQjtBQUMxQixhQUFPQSxJQUFJLENBQUNLLEtBQVo7QUFDRCxLQUZNLE1BRUE7QUFDTCxVQUFJQyxNQUFNLEdBQUdOLElBQUksQ0FBQ0wsR0FBbEI7O0FBRUEsVUFBSVcsTUFBTSxLQUFLSixTQUFmLEVBQTBCO0FBQ3hCLGVBQU9BLFNBQVA7QUFDRDs7QUFFRCxhQUFPSSxNQUFNLENBQUNaLElBQVAsQ0FBWUksUUFBWixDQUFQO0FBQ0Q7QUFDRixHQXZCRDs7QUF5QkEsTUFBSVMsUUFBUSxHQUFHLFNBQVhBLFFBQVcsQ0FBVUMsUUFBVixFQUFvQkMsVUFBcEIsRUFBZ0M7QUFDN0MsUUFBSSxPQUFPQSxVQUFQLEtBQXNCLFVBQXRCLElBQW9DQSxVQUFVLEtBQUssSUFBdkQsRUFBNkQ7QUFDM0QsWUFBTSxJQUFJcEMsU0FBSixDQUFjLHNFQUFvRW9DLFVBQXBFLENBQWQsQ0FBTjtBQUNEOztBQUVERCxZQUFRLENBQUN2QyxTQUFULEdBQXFCZSxNQUFNLENBQUMwQixNQUFQLENBQWNELFVBQVUsSUFBSUEsVUFBVSxDQUFDeEMsU0FBdkMsRUFBa0Q7QUFDckVELGlCQUFXLEVBQUU7QUFDWHFDLGFBQUssRUFBRUcsUUFESTtBQUVYM0Isa0JBQVUsRUFBRSxLQUZEO0FBR1hFLGdCQUFRLEVBQUUsSUFIQztBQUlYRCxvQkFBWSxFQUFFO0FBSkg7QUFEd0QsS0FBbEQsQ0FBckI7QUFRQSxRQUFJMkIsVUFBSixFQUFnQnpCLE1BQU0sQ0FBQzJCLGNBQVAsR0FBd0IzQixNQUFNLENBQUMyQixjQUFQLENBQXNCSCxRQUF0QixFQUFnQ0MsVUFBaEMsQ0FBeEIsR0FBc0VELFFBQVEsQ0FBQ0ksU0FBVCxHQUFxQkgsVUFBM0Y7QUFDakIsR0FkRDs7QUFnQkEsTUFBSUkseUJBQXlCLEdBQUcsU0FBNUJBLHlCQUE0QixDQUFVQyxJQUFWLEVBQWdCcEIsSUFBaEIsRUFBc0I7QUFDcEQsUUFBSSxDQUFDb0IsSUFBTCxFQUFXO0FBQ1QsWUFBTSxJQUFJQyxjQUFKLENBQW1CLDJEQUFuQixDQUFOO0FBQ0Q7O0FBRUQsV0FBT3JCLElBQUksS0FBSyxTQUFPQSxJQUFQLE1BQWdCLFFBQWhCLElBQTRCLE9BQU9BLElBQVAsS0FBZ0IsVUFBakQsQ0FBSixHQUFtRUEsSUFBbkUsR0FBMEVvQixJQUFqRjtBQUNELEdBTkQ7QUFRQTs7Ozs7Ozs7O0FBT0EsV0FBU0UsS0FBVCxDQUFlWCxLQUFmLEVBQXNCO0FBQ3BCLFdBQU9ZLFFBQVEsQ0FBQ1osS0FBRCxDQUFmO0FBQ0Q7QUFFRDs7Ozs7Ozs7O0FBT0EsV0FBU2EsT0FBVCxDQUFpQmIsS0FBakIsRUFBd0I7QUFDdEIsV0FBT2MsVUFBVSxDQUFDZCxLQUFELENBQWpCO0FBQ0Q7QUFFRDs7Ozs7Ozs7QUFNQSxXQUFTZSxRQUFULENBQWtCZixLQUFsQixFQUF5QjtBQUN2QixXQUFPLE9BQU9BLEtBQVAsS0FBaUIsUUFBeEI7QUFDRDtBQUVEOzs7Ozs7Ozs7O0FBUUEsV0FBU2dCLFFBQVQsQ0FBa0JoQixLQUFsQixFQUF5QjtBQUN2QixRQUFJOUUsSUFBSSxHQUFHLE9BQU84RSxLQUFQLEtBQWlCLFdBQWpCLEdBQStCLFdBQS9CLEdBQTZDekMsT0FBTyxDQUFDeUMsS0FBRCxDQUEvRDtBQUVBLFdBQU85RSxJQUFJLEtBQUssVUFBVCxJQUF1QkEsSUFBSSxLQUFLLFFBQVQsSUFBcUIsQ0FBQyxDQUFDOEUsS0FBckQsQ0FIdUIsQ0FHcUM7QUFDN0Q7QUFFRDs7Ozs7Ozs7QUFNQSxXQUFTaUIsUUFBVCxDQUFrQmpCLEtBQWxCLEVBQXlCO0FBQ3ZCLFdBQU8sT0FBT0EsS0FBUCxLQUFpQixRQUF4QjtBQUNEO0FBRUQ7Ozs7Ozs7O0FBTUEsV0FBU2tCLFVBQVQsQ0FBb0JsQixLQUFwQixFQUEyQjtBQUN6QixXQUFPLE9BQU9BLEtBQVAsS0FBaUIsVUFBeEI7QUFDRDtBQUVEOzs7Ozs7OztBQU1BLFdBQVNtQixXQUFULENBQXFCbkIsS0FBckIsRUFBNEI7QUFDMUIsV0FBTyxPQUFPQSxLQUFQLEtBQWlCLFdBQXhCO0FBQ0Q7QUFFRDs7Ozs7Ozs7QUFNQSxXQUFTb0IsT0FBVCxDQUFpQnBCLEtBQWpCLEVBQXdCO0FBQ3RCLFdBQU9BLEtBQUssQ0FBQ3JDLFdBQU4sS0FBc0IwRCxLQUE3QjtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7O0FBU0EsV0FBU0MsS0FBVCxDQUFlQyxLQUFmLEVBQXNCQyxVQUF0QixFQUFrQ0MsTUFBbEMsRUFBMEM7QUFDeEMsUUFBSUMsVUFBVSxHQUFHLEVBQWpCOztBQUVBLFNBQUssSUFBSUMsSUFBVCxJQUFpQkgsVUFBakIsRUFBNkI7QUFDM0IsVUFBSU4sVUFBVSxDQUFDTSxVQUFVLENBQUNHLElBQUQsQ0FBWCxDQUFkLEVBQWtDO0FBQ2hDRCxrQkFBVSxDQUFDQyxJQUFELENBQVYsR0FBbUJILFVBQVUsQ0FBQ0csSUFBRCxDQUFWLENBQWlCSixLQUFqQixFQUF3QkcsVUFBeEIsRUFBb0NELE1BQXBDLENBQW5CO0FBQ0QsT0FGRCxNQUVPO0FBQ0x0RSxZQUFJLENBQUMsOEJBQUQsQ0FBSjtBQUNEO0FBQ0Y7O0FBRUQsU0FBSyxJQUFJeUUsS0FBVCxJQUFrQkYsVUFBbEIsRUFBOEI7QUFDNUIsVUFBSVIsVUFBVSxDQUFDUSxVQUFVLENBQUNFLEtBQUQsQ0FBVixDQUFrQk4sS0FBbkIsQ0FBZCxFQUF5QztBQUN2Q0ksa0JBQVUsQ0FBQ0UsS0FBRCxDQUFWLENBQWtCTixLQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBT0ksVUFBUDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7QUFRQSxXQUFTMUcsTUFBVCxDQUFnQjBDLEdBQWhCLEVBQXFCbUUsSUFBckIsRUFBMkJDLFVBQTNCLEVBQXVDO0FBQ3JDbkQsVUFBTSxDQUFDQyxjQUFQLENBQXNCbEIsR0FBdEIsRUFBMkJtRSxJQUEzQixFQUFpQ0MsVUFBakM7QUFDRDtBQUVEOzs7Ozs7OztBQU1BLFdBQVNDLFFBQVQsQ0FBa0JyRSxHQUFsQixFQUF1QjtBQUNyQixXQUFPaUIsTUFBTSxDQUFDcUQsSUFBUCxDQUFZdEUsR0FBWixFQUFpQnVFLElBQWpCLEdBQXdCQyxNQUF4QixDQUErQixVQUFVQyxDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFDcERELE9BQUMsQ0FBQ0MsQ0FBRCxDQUFELEdBQU8xRSxHQUFHLENBQUMwRSxDQUFELENBQVY7QUFFQSxhQUFPRCxDQUFDLENBQUNDLENBQUQsQ0FBRCxFQUFNRCxDQUFiO0FBQ0QsS0FKTSxFQUlKLEVBSkksQ0FBUDtBQUtEO0FBRUQ7Ozs7Ozs7OztBQU9BLFdBQVNFLFlBQVQsQ0FBc0JwSCxRQUF0QixFQUFnQ3FILFFBQWhDLEVBQTBDO0FBQ3hDLFFBQUlDLE9BQU8sR0FBR3ZELFFBQVEsQ0FBQyxFQUFELEVBQUsvRCxRQUFMLEVBQWVxSCxRQUFmLENBQXRCLENBRHdDLENBR3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFFBQUlBLFFBQVEsQ0FBQ2xELGNBQVQsQ0FBd0IsU0FBeEIsQ0FBSixFQUF3QztBQUN0Q21ELGFBQU8sQ0FBQy9GLE9BQVIsR0FBa0J3QyxRQUFRLENBQUMsRUFBRCxFQUFLL0QsUUFBUSxDQUFDdUIsT0FBZCxFQUF1QjhGLFFBQVEsQ0FBQzlGLE9BQWhDLENBQTFCOztBQUVBLFVBQUk4RixRQUFRLENBQUM5RixPQUFULENBQWlCNEMsY0FBakIsQ0FBZ0MsV0FBaEMsQ0FBSixFQUFrRDtBQUNoRG1ELGVBQU8sQ0FBQy9GLE9BQVIsQ0FBZ0JILFNBQWhCLEdBQTRCMkMsUUFBUSxDQUFDLEVBQUQsRUFBSy9ELFFBQVEsQ0FBQ3VCLE9BQVQsQ0FBaUJILFNBQXRCLEVBQWlDaUcsUUFBUSxDQUFDOUYsT0FBVCxDQUFpQkgsU0FBbEQsQ0FBcEM7QUFDRDtBQUNGOztBQUVELFFBQUlpRyxRQUFRLENBQUNsRCxjQUFULENBQXdCLGFBQXhCLENBQUosRUFBNEM7QUFDMUNtRCxhQUFPLENBQUNoRyxXQUFSLEdBQXNCeUMsUUFBUSxDQUFDLEVBQUQsRUFBSy9ELFFBQVEsQ0FBQ3NCLFdBQWQsRUFBMkIrRixRQUFRLENBQUMvRixXQUFwQyxDQUE5QjtBQUNEOztBQUVELFdBQU9nRyxPQUFQO0FBQ0Q7O0FBRUQsTUFBSUMsU0FBUyxHQUFHLFlBQVk7QUFDMUI7Ozs7O0FBS0EsYUFBU0EsU0FBVCxHQUFxQjtBQUNuQixVQUFJZixNQUFNLEdBQUd2QyxTQUFTLENBQUNaLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JZLFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUJXLFNBQXpDLEdBQXFEWCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxFQUFqRjtBQUNBckIsb0JBQWMsQ0FBQyxJQUFELEVBQU8yRSxTQUFQLENBQWQ7QUFFQSxXQUFLZixNQUFMLEdBQWNBLE1BQWQ7QUFDQSxXQUFLZ0IsR0FBTCxHQUFXaEIsTUFBTSxDQUFDckMsY0FBbEI7QUFDRDtBQUVEOzs7Ozs7OztBQVFBbkIsZUFBVyxDQUFDdUUsU0FBRCxFQUFZLENBQUM7QUFDdEIzRCxTQUFHLEVBQUUsSUFEaUI7QUFFdEJtQixXQUFLLEVBQUUsU0FBUzBDLEVBQVQsQ0FBWUMsS0FBWixFQUFtQkMsT0FBbkIsRUFBNEI7QUFDakMsWUFBSXhCLE9BQU8sQ0FBQ3VCLEtBQUQsQ0FBWCxFQUFvQjtBQUNsQixlQUFLLElBQUl0RSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHc0UsS0FBSyxDQUFDckUsTUFBMUIsRUFBa0NELENBQUMsRUFBbkMsRUFBdUM7QUFDckMsaUJBQUtxRSxFQUFMLENBQVFDLEtBQUssQ0FBQ3RFLENBQUQsQ0FBYixFQUFrQnVFLE9BQWxCO0FBQ0Q7QUFDRixTQUxnQyxDQU9qQzs7O0FBQ0EsWUFBSSxDQUFDLEtBQUtILEdBQUwsQ0FBU3BELElBQVQsQ0FBYyxLQUFLb0MsTUFBbkIsRUFBMkJrQixLQUEzQixDQUFMLEVBQXdDO0FBQ3RDLGVBQUtsQixNQUFMLENBQVlrQixLQUFaLElBQXFCLEVBQXJCO0FBQ0QsU0FWZ0MsQ0FZakM7OztBQUNBLFlBQUlFLEtBQUssR0FBRyxLQUFLcEIsTUFBTCxDQUFZa0IsS0FBWixFQUFtQkcsSUFBbkIsQ0FBd0JGLE9BQXhCLElBQW1DLENBQS9DLENBYmlDLENBZWpDOztBQUNBLGVBQU87QUFDTEcsZ0JBQU0sRUFBRSxTQUFTQSxNQUFULEdBQWtCO0FBQ3hCLG1CQUFPLEtBQUt0QixNQUFMLENBQVlrQixLQUFaLEVBQW1CRSxLQUFuQixDQUFQO0FBQ0Q7QUFISSxTQUFQO0FBS0Q7QUFFRDs7Ozs7OztBQXpCc0IsS0FBRCxFQWdDcEI7QUFDRGhFLFNBQUcsRUFBRSxNQURKO0FBRURtQixXQUFLLEVBQUUsU0FBU2dELElBQVQsQ0FBY0wsS0FBZCxFQUFxQk0sT0FBckIsRUFBOEI7QUFDbkMsWUFBSTdCLE9BQU8sQ0FBQ3VCLEtBQUQsQ0FBWCxFQUFvQjtBQUNsQixlQUFLLElBQUl0RSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHc0UsS0FBSyxDQUFDckUsTUFBMUIsRUFBa0NELENBQUMsRUFBbkMsRUFBdUM7QUFDckMsaUJBQUsyRSxJQUFMLENBQVVMLEtBQUssQ0FBQ3RFLENBQUQsQ0FBZixFQUFvQjRFLE9BQXBCO0FBQ0Q7QUFDRixTQUxrQyxDQU9uQzs7O0FBQ0EsWUFBSSxDQUFDLEtBQUtSLEdBQUwsQ0FBU3BELElBQVQsQ0FBYyxLQUFLb0MsTUFBbkIsRUFBMkJrQixLQUEzQixDQUFMLEVBQXdDO0FBQ3RDO0FBQ0QsU0FWa0MsQ0FZbkM7OztBQUNBLGFBQUtsQixNQUFMLENBQVlrQixLQUFaLEVBQW1CTyxPQUFuQixDQUEyQixVQUFVQyxJQUFWLEVBQWdCO0FBQ3pDQSxjQUFJLENBQUNGLE9BQU8sSUFBSSxFQUFaLENBQUo7QUFDRCxTQUZEO0FBR0Q7QUFsQkEsS0FoQ29CLENBQVosQ0FBWDtBQW9EQSxXQUFPVCxTQUFQO0FBQ0QsR0EzRWUsRUFBaEI7O0FBNkVBLE1BQUlZLEtBQUssR0FBRyxZQUFZO0FBQ3RCOzs7Ozs7QUFNQSxhQUFTQSxLQUFULENBQWVDLFFBQWYsRUFBeUI7QUFDdkIsVUFBSWQsT0FBTyxHQUFHckQsU0FBUyxDQUFDWixNQUFWLEdBQW1CLENBQW5CLElBQXdCWSxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCVyxTQUF6QyxHQUFxRFgsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsRUFBbEY7QUFDQXJCLG9CQUFjLENBQUMsSUFBRCxFQUFPdUYsS0FBUCxDQUFkO0FBRUEsV0FBS0UsRUFBTCxHQUFVLEVBQVY7QUFDQSxXQUFLQyxFQUFMLEdBQVUsRUFBVjtBQUNBLFdBQUtDLEVBQUwsR0FBVSxJQUFJaEIsU0FBSixFQUFWO0FBRUEsV0FBS2lCLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSxXQUFLSixRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFdBQUtmLFFBQUwsR0FBZ0JELFlBQVksQ0FBQ3BILFFBQUQsRUFBV3NILE9BQVgsQ0FBNUI7QUFDQSxXQUFLTSxLQUFMLEdBQWEsS0FBS1AsUUFBTCxDQUFjbkgsT0FBM0I7QUFDRDtBQUVEOzs7Ozs7OztBQVFBOEMsZUFBVyxDQUFDbUYsS0FBRCxFQUFRLENBQUM7QUFDbEJ2RSxTQUFHLEVBQUUsT0FEYTtBQUVsQm1CLFdBQUssRUFBRSxTQUFTMEQsUUFBVCxHQUFvQjtBQUN6QixZQUFJbEMsVUFBVSxHQUFHdEMsU0FBUyxDQUFDWixNQUFWLEdBQW1CLENBQW5CLElBQXdCWSxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCVyxTQUF6QyxHQUFxRFgsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsRUFBckY7O0FBRUEsYUFBS3NFLEVBQUwsQ0FBUVIsSUFBUixDQUFhLGNBQWI7O0FBRUEsWUFBSWhDLFFBQVEsQ0FBQ1EsVUFBRCxDQUFaLEVBQTBCO0FBQ3hCLGVBQUs4QixFQUFMLEdBQVVoQyxLQUFLLENBQUMsSUFBRCxFQUFPRSxVQUFQLEVBQW1CLEtBQUtnQyxFQUF4QixDQUFmO0FBQ0QsU0FGRCxNQUVPO0FBQ0xyRyxjQUFJLENBQUMsMkNBQUQsQ0FBSjtBQUNEOztBQUVELGFBQUtxRyxFQUFMLENBQVFSLElBQVIsQ0FBYSxhQUFiOztBQUVBLGVBQU8sSUFBUDtBQUNEO0FBRUQ7Ozs7Ozs7QUFsQmtCLEtBQUQsRUF5QmhCO0FBQ0RuRSxTQUFHLEVBQUUsUUFESjtBQUVEbUIsV0FBSyxFQUFFLFNBQVMyRCxNQUFULEdBQWtCO0FBQ3ZCLFlBQUlDLFlBQVksR0FBRzFFLFNBQVMsQ0FBQ1osTUFBVixHQUFtQixDQUFuQixJQUF3QlksU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQlcsU0FBekMsR0FBcURYLFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEVBQXZGOztBQUVBLFlBQUlrQyxPQUFPLENBQUN3QyxZQUFELENBQVgsRUFBMkI7QUFDekIsZUFBS0wsRUFBTCxHQUFVSyxZQUFWO0FBQ0QsU0FGRCxNQUVPO0FBQ0x6RyxjQUFJLENBQUMsMkNBQUQsQ0FBSjtBQUNEOztBQUVELGVBQU8sSUFBUDtBQUNEO0FBRUQ7Ozs7Ozs7QUFkQyxLQXpCZ0IsRUE4Q2hCO0FBQ0QwQixTQUFHLEVBQUUsUUFESjtBQUVEbUIsV0FBSyxFQUFFLFNBQVM2RCxNQUFULEdBQWtCO0FBQ3ZCLFlBQUl2QixRQUFRLEdBQUdwRCxTQUFTLENBQUNaLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JZLFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUJXLFNBQXpDLEdBQXFEWCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxFQUFuRjtBQUVBLGFBQUtvRCxRQUFMLEdBQWdCRCxZQUFZLENBQUMsS0FBS0MsUUFBTixFQUFnQkEsUUFBaEIsQ0FBNUI7O0FBRUEsWUFBSUEsUUFBUSxDQUFDbEQsY0FBVCxDQUF3QixTQUF4QixDQUFKLEVBQXdDO0FBQ3RDLGVBQUt5RCxLQUFMLEdBQWFQLFFBQVEsQ0FBQ25ILE9BQXRCO0FBQ0Q7O0FBRUQsYUFBS3FJLEVBQUwsQ0FBUVIsSUFBUixDQUFhLFFBQWI7O0FBRUEsZUFBTyxJQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7O0FBaEJDLEtBOUNnQixFQTBFaEI7QUFDRG5FLFNBQUcsRUFBRSxJQURKO0FBRURtQixXQUFLLEVBQUUsU0FBUzhELEVBQVQsQ0FBWUMsT0FBWixFQUFxQjtBQUMxQixhQUFLVCxFQUFMLENBQVFVLEdBQVIsQ0FBWUMsSUFBWixDQUFpQkYsT0FBakI7O0FBRUEsZUFBTyxJQUFQO0FBQ0Q7QUFFRDs7Ozs7OztBQVJDLEtBMUVnQixFQXlGaEI7QUFDRGxGLFNBQUcsRUFBRSxNQURKO0FBRURtQixXQUFLLEVBQUUsU0FBU2tFLElBQVQsQ0FBY0MsUUFBZCxFQUF3QjtBQUM3QixhQUFLYixFQUFMLENBQVFjLFVBQVIsQ0FBbUJDLE9BQW5COztBQUNBLGFBQUtmLEVBQUwsQ0FBUWdCLElBQVIsQ0FBYUwsSUFBYixDQUFrQkUsUUFBbEI7O0FBRUEsZUFBTyxJQUFQO0FBQ0Q7QUFFRDs7Ozs7O0FBVEMsS0F6RmdCLEVBd0doQjtBQUNEdEYsU0FBRyxFQUFFLFNBREo7QUFFRG1CLFdBQUssRUFBRSxTQUFTdUUsT0FBVCxHQUFtQjtBQUN4QixhQUFLZixFQUFMLENBQVFSLElBQVIsQ0FBYSxTQUFiOztBQUVBLGVBQU8sSUFBUDtBQUNEO0FBRUQ7Ozs7Ozs7QUFSQyxLQXhHZ0IsRUF1SGhCO0FBQ0RuRSxTQUFHLEVBQUUsTUFESjtBQUVEbUIsV0FBSyxFQUFFLFNBQVN3RSxJQUFULEdBQWdCO0FBQ3JCLFlBQUlDLFFBQVEsR0FBR3ZGLFNBQVMsQ0FBQ1osTUFBVixHQUFtQixDQUFuQixJQUF3QlksU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQlcsU0FBekMsR0FBcURYLFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEtBQW5GOztBQUVBLFlBQUl1RixRQUFKLEVBQWM7QUFDWixlQUFLbkMsUUFBTCxDQUFjL0csUUFBZCxHQUF5QmtKLFFBQXpCO0FBQ0Q7O0FBRUQsYUFBS2pCLEVBQUwsQ0FBUVIsSUFBUixDQUFhLE1BQWI7O0FBRUEsZUFBTyxJQUFQO0FBQ0Q7QUFFRDs7Ozs7O0FBZEMsS0F2SGdCLEVBMkloQjtBQUNEbkUsU0FBRyxFQUFFLE9BREo7QUFFRG1CLFdBQUssRUFBRSxTQUFTMEUsS0FBVCxHQUFpQjtBQUN0QixhQUFLbEIsRUFBTCxDQUFRUixJQUFSLENBQWEsT0FBYjs7QUFFQSxlQUFPLElBQVA7QUFDRDtBQUVEOzs7Ozs7QUFSQyxLQTNJZ0IsRUF5SmhCO0FBQ0RuRSxTQUFHLEVBQUUsU0FESjtBQUVEbUIsV0FBSyxFQUFFLFNBQVNxRSxPQUFULEdBQW1CO0FBQ3hCLGFBQUtaLFFBQUwsR0FBZ0IsSUFBaEI7QUFFQSxlQUFPLElBQVA7QUFDRDtBQUVEOzs7Ozs7QUFSQyxLQXpKZ0IsRUF1S2hCO0FBQ0Q1RSxTQUFHLEVBQUUsUUFESjtBQUVEbUIsV0FBSyxFQUFFLFNBQVMyRSxNQUFULEdBQWtCO0FBQ3ZCLGFBQUtsQixRQUFMLEdBQWdCLEtBQWhCO0FBRUEsZUFBTyxJQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7QUFSQyxLQXZLZ0IsRUF1TGhCO0FBQ0Q1RSxTQUFHLEVBQUUsSUFESjtBQUVEbUIsV0FBSyxFQUFFLFNBQVMwQyxFQUFULENBQVlDLEtBQVosRUFBbUJDLE9BQW5CLEVBQTRCO0FBQ2pDLGFBQUtZLEVBQUwsQ0FBUWQsRUFBUixDQUFXQyxLQUFYLEVBQWtCQyxPQUFsQjs7QUFFQSxlQUFPLElBQVA7QUFDRDtBQUVEOzs7Ozs7O0FBUkMsS0F2TGdCLEVBc01oQjtBQUNEL0QsU0FBRyxFQUFFLFFBREo7QUFFRG1CLFdBQUssRUFBRSxTQUFTNEUsTUFBVCxDQUFnQmpELElBQWhCLEVBQXNCO0FBQzNCLGVBQU8sS0FBS1csUUFBTCxDQUFjcEgsSUFBZCxLQUF1QnlHLElBQTlCO0FBQ0Q7QUFFRDs7Ozs7O0FBTkMsS0F0TWdCLEVBa05oQjtBQUNEOUMsU0FBRyxFQUFFLFVBREo7QUFFRFMsU0FBRyxFQUFFLFNBQVN1RixNQUFULEdBQWtCO0FBQ3JCLGVBQU8sS0FBS0MsRUFBWjtBQUNEO0FBRUQ7Ozs7OztBQU5DO0FBYURDLFNBQUcsRUFBRSxTQUFTQyxNQUFULENBQWdCQyxDQUFoQixFQUFtQjtBQUN0QixZQUFJakUsUUFBUSxDQUFDaUUsQ0FBRCxDQUFaLEVBQWlCO0FBQ2YsZUFBS0gsRUFBTCxHQUFVRyxDQUFWO0FBQ0QsU0FGRCxNQUVPO0FBQ0w5SCxjQUFJLENBQUMsdUNBQUQsQ0FBSjtBQUNEO0FBQ0Y7QUFFRDs7Ozs7O0FBckJDLEtBbE5nQixFQTZPaEI7QUFDRDBCLFNBQUcsRUFBRSxPQURKO0FBRURTLFNBQUcsRUFBRSxTQUFTdUYsTUFBVCxHQUFrQjtBQUNyQixlQUFPLEtBQUtLLEVBQVo7QUFDRDtBQUVEOzs7OztBQU5DO0FBWURILFNBQUcsRUFBRSxTQUFTQyxNQUFULENBQWdCM0csQ0FBaEIsRUFBbUI7QUFDdEIsYUFBSzZHLEVBQUwsR0FBVXZFLEtBQUssQ0FBQ3RDLENBQUQsQ0FBZjtBQUNEO0FBRUQ7Ozs7OztBQWhCQyxLQTdPZ0IsRUFtUWhCO0FBQ0RRLFNBQUcsRUFBRSxNQURKO0FBRURTLFNBQUcsRUFBRSxTQUFTdUYsTUFBVCxHQUFrQjtBQUNyQixlQUFPLEtBQUt2QyxRQUFMLENBQWNwSCxJQUFyQjtBQUNEO0FBRUQ7Ozs7OztBQU5DLEtBblFnQixFQStRaEI7QUFDRDJELFNBQUcsRUFBRSxVQURKO0FBRURTLFNBQUcsRUFBRSxTQUFTdUYsTUFBVCxHQUFrQjtBQUNyQixlQUFPLEtBQUtNLEVBQVo7QUFDRDtBQUVEOzs7OztBQU5DO0FBWURKLFNBQUcsRUFBRSxTQUFTQyxNQUFULENBQWdCSSxNQUFoQixFQUF3QjtBQUMzQixhQUFLRCxFQUFMLEdBQVUsQ0FBQyxDQUFDQyxNQUFaO0FBQ0Q7QUFkQSxLQS9RZ0IsQ0FBUixDQUFYO0FBK1JBLFdBQU9oQyxLQUFQO0FBQ0QsR0E3VFcsRUFBWjs7QUErVEEsV0FBU1ksR0FBVCxDQUFjWixLQUFkLEVBQXFCaUMsVUFBckIsRUFBaUNDLE1BQWpDLEVBQXlDO0FBQ3ZDLFFBQUl0QixHQUFHLEdBQUc7QUFDUjs7Ozs7QUFLQTFDLFdBQUssRUFBRSxTQUFTQSxLQUFULEdBQWlCO0FBQ3RCLGFBQUt3RCxFQUFMLEdBQVUsS0FBVjtBQUNELE9BUk87O0FBV1I7Ozs7O0FBS0FiLFVBQUksRUFBRSxTQUFTQSxJQUFULENBQWNDLElBQWQsRUFBb0I7QUFDeEIsWUFBSXFCLEtBQUssR0FBRyxJQUFaOztBQUVBLFlBQUksQ0FBQ25DLEtBQUssQ0FBQ0ssUUFBWCxFQUFxQjtBQUNuQkwsZUFBSyxDQUFDaUIsT0FBTjtBQUVBLGVBQUtILElBQUwsR0FBWUEsSUFBWjtBQUVBb0IsZ0JBQU0sQ0FBQ3RDLElBQVAsQ0FBWSxZQUFaLEVBQTBCLEtBQUtrQixJQUEvQjtBQUVBLGVBQUtzQixTQUFMO0FBRUFGLGdCQUFNLENBQUN0QyxJQUFQLENBQVksS0FBWixFQUFtQixLQUFLa0IsSUFBeEI7QUFFQW1CLG9CQUFVLENBQUNqQixVQUFYLENBQXNCcUIsS0FBdEIsQ0FBNEIsWUFBWTtBQUN0QyxnQkFBSUYsS0FBSyxDQUFDRyxPQUFOLEVBQUosRUFBcUI7QUFDbkJKLG9CQUFNLENBQUN0QyxJQUFQLENBQVksV0FBWixFQUF5QnVDLEtBQUssQ0FBQ3JCLElBQS9CO0FBQ0Q7O0FBRUQsZ0JBQUlxQixLQUFLLENBQUNJLEtBQU4sRUFBSixFQUFtQjtBQUNqQkwsb0JBQU0sQ0FBQ3RDLElBQVAsQ0FBWSxTQUFaLEVBQXVCdUMsS0FBSyxDQUFDckIsSUFBN0I7QUFDRDs7QUFFRCxnQkFBSXFCLEtBQUssQ0FBQ0ssUUFBTixDQUFlLEdBQWYsS0FBdUJMLEtBQUssQ0FBQ0ssUUFBTixDQUFlLEdBQWYsQ0FBM0IsRUFBZ0Q7QUFDOUNMLG1CQUFLLENBQUNULEVBQU4sR0FBVyxLQUFYO0FBRUFRLG9CQUFNLENBQUN0QyxJQUFQLENBQVksWUFBWixFQUEwQnVDLEtBQUssQ0FBQ3JCLElBQWhDO0FBQ0Q7O0FBRURvQixrQkFBTSxDQUFDdEMsSUFBUCxDQUFZLFdBQVosRUFBeUJ1QyxLQUFLLENBQUNyQixJQUEvQjtBQUVBZCxpQkFBSyxDQUFDdUIsTUFBTjtBQUNELFdBbEJEO0FBbUJEO0FBQ0YsT0FsRE87O0FBcURSOzs7OztBQUtBYSxlQUFTLEVBQUUsU0FBU0EsU0FBVCxHQUFxQjtBQUM5QixZQUFJdEIsSUFBSSxHQUFHLEtBQUtBLElBQWhCO0FBQUEsWUFDSTVGLE1BQU0sR0FBRyxLQUFLQSxNQURsQjtBQUVBLFlBQUl1SCxLQUFLLEdBQUczQixJQUFJLENBQUMyQixLQUFqQjtBQUFBLFlBQ0l4SixTQUFTLEdBQUc2SCxJQUFJLENBQUM3SCxTQURyQjtBQUlBLFlBQUl5SixjQUFjLEdBQUc3RSxRQUFRLENBQUNOLEtBQUssQ0FBQ2tGLEtBQUQsQ0FBTixDQUFSLElBQTBCbEYsS0FBSyxDQUFDa0YsS0FBRCxDQUFMLEtBQWlCLENBQWhFOztBQUVBLGdCQUFReEosU0FBUjtBQUNFLGVBQUssR0FBTDtBQUNFLGdCQUFJd0osS0FBSyxLQUFLLEdBQWQsRUFBbUI7QUFDakJ6QyxtQkFBSyxDQUFDUCxLQUFOLEdBQWN2RSxNQUFkO0FBQ0QsYUFGRCxNQUVPLElBQUksS0FBS3FILEtBQUwsRUFBSixFQUFrQjtBQUN2QixrQkFBSSxFQUFFdkMsS0FBSyxDQUFDd0IsTUFBTixDQUFhLFFBQWIsS0FBMEIsQ0FBQ3hCLEtBQUssQ0FBQ2QsUUFBTixDQUFlckcsTUFBNUMsQ0FBSixFQUF5RDtBQUN2RCxxQkFBSzZJLEVBQUwsR0FBVSxJQUFWO0FBRUExQixxQkFBSyxDQUFDUCxLQUFOLEdBQWMsQ0FBZDtBQUNEO0FBQ0YsYUFOTSxNQU1BLElBQUlpRCxjQUFKLEVBQW9CO0FBQ3pCMUMsbUJBQUssQ0FBQ1AsS0FBTixJQUFla0QsSUFBSSxDQUFDQyxHQUFMLENBQVMxSCxNQUFNLEdBQUc4RSxLQUFLLENBQUNQLEtBQXhCLEVBQStCLENBQUNsQyxLQUFLLENBQUNrRixLQUFELENBQXJDLENBQWY7QUFDRCxhQUZNLE1BRUE7QUFDTHpDLG1CQUFLLENBQUNQLEtBQU47QUFDRDs7QUFDRDs7QUFFRixlQUFLLEdBQUw7QUFDRSxnQkFBSWdELEtBQUssS0FBSyxHQUFkLEVBQW1CO0FBQ2pCekMsbUJBQUssQ0FBQ1AsS0FBTixHQUFjLENBQWQ7QUFDRCxhQUZELE1BRU8sSUFBSSxLQUFLNkMsT0FBTCxFQUFKLEVBQW9CO0FBQ3pCLGtCQUFJLEVBQUV0QyxLQUFLLENBQUN3QixNQUFOLENBQWEsUUFBYixLQUEwQixDQUFDeEIsS0FBSyxDQUFDZCxRQUFOLENBQWVyRyxNQUE1QyxDQUFKLEVBQXlEO0FBQ3ZELHFCQUFLNkksRUFBTCxHQUFVLElBQVY7QUFFQTFCLHFCQUFLLENBQUNQLEtBQU4sR0FBY3ZFLE1BQWQ7QUFDRDtBQUNGLGFBTk0sTUFNQSxJQUFJd0gsY0FBSixFQUFvQjtBQUN6QjFDLG1CQUFLLENBQUNQLEtBQU4sSUFBZWtELElBQUksQ0FBQ0MsR0FBTCxDQUFTNUMsS0FBSyxDQUFDUCxLQUFmLEVBQXNCbEMsS0FBSyxDQUFDa0YsS0FBRCxDQUEzQixDQUFmO0FBQ0QsYUFGTSxNQUVBO0FBQ0x6QyxtQkFBSyxDQUFDUCxLQUFOO0FBQ0Q7O0FBQ0Q7O0FBRUYsZUFBSyxHQUFMO0FBQ0VPLGlCQUFLLENBQUNQLEtBQU4sR0FBY2dELEtBQWQ7QUFDQTs7QUFFRjtBQUNFMUksZ0JBQUksQ0FBQyxnQ0FBZ0NkLFNBQWhDLEdBQTRDd0osS0FBNUMsR0FBb0QsaUJBQXJELENBQUo7QUFDQTtBQXZDSjtBQXlDRCxPQTVHTzs7QUErR1I7Ozs7O0FBS0FILGFBQU8sRUFBRSxTQUFTQSxPQUFULEdBQW1CO0FBQzFCLGVBQU90QyxLQUFLLENBQUNQLEtBQU4sS0FBZ0IsQ0FBdkI7QUFDRCxPQXRITzs7QUF5SFI7Ozs7O0FBS0E4QyxXQUFLLEVBQUUsU0FBU0EsS0FBVCxHQUFpQjtBQUN0QixlQUFPdkMsS0FBSyxDQUFDUCxLQUFOLEtBQWdCLEtBQUt2RSxNQUE1QjtBQUNELE9BaElPOztBQW1JUjs7Ozs7O0FBTUFzSCxjQUFRLEVBQUUsU0FBU0EsUUFBVCxDQUFrQnZKLFNBQWxCLEVBQTZCO0FBQ3JDLGVBQU8sS0FBS3lJLEVBQUwsSUFBVyxLQUFLWixJQUFMLENBQVU3SCxTQUFWLEtBQXdCQSxTQUExQztBQUNEO0FBM0lPLEtBQVY7QUE4SUFyQixVQUFNLENBQUNnSixHQUFELEVBQU0sTUFBTixFQUFjO0FBQ2xCOzs7OztBQUtBMUUsU0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixlQUFPLEtBQUsyRyxFQUFaO0FBQ0QsT0FSaUI7O0FBV2xCOzs7OztBQUtBbEIsU0FBRyxFQUFFLFNBQVNBLEdBQVQsQ0FBYS9FLEtBQWIsRUFBb0I7QUFDdkIsWUFBSWtHLElBQUksR0FBR2xHLEtBQUssQ0FBQ21HLE1BQU4sQ0FBYSxDQUFiLENBQVg7QUFFQSxhQUFLRixFQUFMLEdBQVU7QUFDUjVKLG1CQUFTLEVBQUUyRCxLQUFLLENBQUNtRyxNQUFOLENBQWEsQ0FBYixFQUFnQixDQUFoQixDQURIO0FBRVJOLGVBQUssRUFBRUssSUFBSSxHQUFHdkYsS0FBSyxDQUFDdUYsSUFBRCxDQUFMLEdBQWN2RixLQUFLLENBQUN1RixJQUFELENBQW5CLEdBQTRCQSxJQUEvQixHQUFzQztBQUZ6QyxTQUFWO0FBSUQ7QUF2QmlCLEtBQWQsQ0FBTjtBQTBCQWxMLFVBQU0sQ0FBQ2dKLEdBQUQsRUFBTSxRQUFOLEVBQWdCO0FBQ3BCOzs7Ozs7QUFNQTFFLFNBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsWUFBSWdELFFBQVEsR0FBR2MsS0FBSyxDQUFDZCxRQUFyQjtBQUNBLFlBQUloRSxNQUFNLEdBQUcrRyxVQUFVLENBQUNlLElBQVgsQ0FBZ0JDLE1BQWhCLENBQXVCL0gsTUFBcEMsQ0FGa0IsQ0FJbEI7QUFDQTtBQUNBOztBQUVBLFlBQUk4RSxLQUFLLENBQUN3QixNQUFOLENBQWEsUUFBYixLQUEwQnRDLFFBQVEsQ0FBQ2pILE9BQVQsS0FBcUIsUUFBL0MsSUFBMkRpSCxRQUFRLENBQUM1RyxLQUF4RSxFQUErRTtBQUM3RSxpQkFBTzRDLE1BQU0sR0FBRyxDQUFULElBQWNxQyxLQUFLLENBQUMyQixRQUFRLENBQUNsSCxPQUFWLENBQUwsR0FBMEIsQ0FBeEMsSUFBNkN1RixLQUFLLENBQUMyQixRQUFRLENBQUNqSCxPQUFWLENBQXpEO0FBQ0Q7O0FBRUQsZUFBT2lELE1BQU0sR0FBRyxDQUFoQjtBQUNEO0FBcEJtQixLQUFoQixDQUFOO0FBdUJBdEQsVUFBTSxDQUFDZ0osR0FBRCxFQUFNLFFBQU4sRUFBZ0I7QUFDcEI7Ozs7O0FBS0ExRSxTQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGVBQU8sS0FBS3dGLEVBQVo7QUFDRDtBQVJtQixLQUFoQixDQUFOO0FBV0EsV0FBT2QsR0FBUDtBQUNEO0FBRUQ7Ozs7Ozs7QUFLQSxXQUFTc0MsR0FBVCxHQUFlO0FBQ2IsV0FBTyxJQUFJQyxJQUFKLEdBQVdDLE9BQVgsRUFBUDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFXQSxXQUFTcEssUUFBVCxDQUFrQnFLLElBQWxCLEVBQXdCQyxJQUF4QixFQUE4Qm5FLE9BQTlCLEVBQXVDO0FBQ3JDLFFBQUlvRSxPQUFPLEdBQUcsS0FBSyxDQUFuQjtBQUFBLFFBQ0kxRCxPQUFPLEdBQUcsS0FBSyxDQURuQjtBQUFBLFFBRUkyRCxJQUFJLEdBQUcsS0FBSyxDQUZoQjtBQUFBLFFBR0lDLE1BQU0sR0FBRyxLQUFLLENBSGxCO0FBSUEsUUFBSUMsUUFBUSxHQUFHLENBQWY7QUFDQSxRQUFJLENBQUN2RSxPQUFMLEVBQWNBLE9BQU8sR0FBRyxFQUFWOztBQUVkLFFBQUl3RSxLQUFLLEdBQUcsU0FBU0EsS0FBVCxHQUFpQjtBQUMzQkQsY0FBUSxHQUFHdkUsT0FBTyxDQUFDeUUsT0FBUixLQUFvQixLQUFwQixHQUE0QixDQUE1QixHQUFnQ1YsR0FBRyxFQUE5QztBQUNBSyxhQUFPLEdBQUcsSUFBVjtBQUNBRSxZQUFNLEdBQUdKLElBQUksQ0FBQ1EsS0FBTCxDQUFXaEUsT0FBWCxFQUFvQjJELElBQXBCLENBQVQ7QUFDQSxVQUFJLENBQUNELE9BQUwsRUFBYzFELE9BQU8sR0FBRzJELElBQUksR0FBRyxJQUFqQjtBQUNmLEtBTEQ7O0FBT0EsUUFBSU0sU0FBUyxHQUFHLFNBQVNBLFNBQVQsR0FBcUI7QUFDbkMsVUFBSUMsRUFBRSxHQUFHYixHQUFHLEVBQVo7QUFDQSxVQUFJLENBQUNRLFFBQUQsSUFBYXZFLE9BQU8sQ0FBQ3lFLE9BQVIsS0FBb0IsS0FBckMsRUFBNENGLFFBQVEsR0FBR0ssRUFBWDtBQUM1QyxVQUFJQyxTQUFTLEdBQUdWLElBQUksSUFBSVMsRUFBRSxHQUFHTCxRQUFULENBQXBCO0FBQ0E3RCxhQUFPLEdBQUcsSUFBVjtBQUNBMkQsVUFBSSxHQUFHMUgsU0FBUDs7QUFDQSxVQUFJa0ksU0FBUyxJQUFJLENBQWIsSUFBa0JBLFNBQVMsR0FBR1YsSUFBbEMsRUFBd0M7QUFDdEMsWUFBSUMsT0FBSixFQUFhO0FBQ1hVLHNCQUFZLENBQUNWLE9BQUQsQ0FBWjtBQUNBQSxpQkFBTyxHQUFHLElBQVY7QUFDRDs7QUFDREcsZ0JBQVEsR0FBR0ssRUFBWDtBQUNBTixjQUFNLEdBQUdKLElBQUksQ0FBQ1EsS0FBTCxDQUFXaEUsT0FBWCxFQUFvQjJELElBQXBCLENBQVQ7QUFDQSxZQUFJLENBQUNELE9BQUwsRUFBYzFELE9BQU8sR0FBRzJELElBQUksR0FBRyxJQUFqQjtBQUNmLE9BUkQsTUFRTyxJQUFJLENBQUNELE9BQUQsSUFBWXBFLE9BQU8sQ0FBQytFLFFBQVIsS0FBcUIsS0FBckMsRUFBNEM7QUFDakRYLGVBQU8sR0FBR1ksVUFBVSxDQUFDUixLQUFELEVBQVFLLFNBQVIsQ0FBcEI7QUFDRDs7QUFDRCxhQUFPUCxNQUFQO0FBQ0QsS0FsQkQ7O0FBb0JBSyxhQUFTLENBQUNNLE1BQVYsR0FBbUIsWUFBWTtBQUM3Qkgsa0JBQVksQ0FBQ1YsT0FBRCxDQUFaO0FBQ0FHLGNBQVEsR0FBRyxDQUFYO0FBQ0FILGFBQU8sR0FBRzFELE9BQU8sR0FBRzJELElBQUksR0FBRyxJQUEzQjtBQUNELEtBSkQ7O0FBTUEsV0FBT00sU0FBUDtBQUNEOztBQUVELE1BQUlPLFdBQVcsR0FBRztBQUNoQmhMLE9BQUcsRUFBRSxDQUFDLFlBQUQsRUFBZSxhQUFmLENBRFc7QUFFaEJDLE9BQUcsRUFBRSxDQUFDLGFBQUQsRUFBZ0IsWUFBaEI7QUFGVyxHQUFsQjs7QUFLQSxXQUFTZ0wsSUFBVCxDQUFldEUsS0FBZixFQUFzQmlDLFVBQXRCLEVBQWtDQyxNQUFsQyxFQUEwQztBQUN4QyxRQUFJb0MsSUFBSSxHQUFHO0FBQ1Q7Ozs7Ozs7QUFPQVQsV0FBSyxFQUFFLFNBQVNBLEtBQVQsQ0FBZVosTUFBZixFQUF1QjtBQUM1QixhQUFLLElBQUloSSxDQUFDLEdBQUcsQ0FBUixFQUFXc0osR0FBRyxHQUFHdEIsTUFBTSxDQUFDL0gsTUFBN0IsRUFBcUNELENBQUMsR0FBR3NKLEdBQXpDLEVBQThDdEosQ0FBQyxFQUEvQyxFQUFtRDtBQUNqRCxjQUFJdUosS0FBSyxHQUFHdkIsTUFBTSxDQUFDaEksQ0FBRCxDQUFOLENBQVV1SixLQUF0QjtBQUNBLGNBQUl2TCxTQUFTLEdBQUdnSixVQUFVLENBQUN3QyxTQUFYLENBQXFCN0gsS0FBckM7O0FBRUEsY0FBSTNCLENBQUMsS0FBSyxDQUFWLEVBQWE7QUFDWHVKLGlCQUFLLENBQUNILFdBQVcsQ0FBQ3BMLFNBQUQsQ0FBWCxDQUF1QixDQUF2QixDQUFELENBQUwsR0FBbUMsS0FBSzJELEtBQUwsR0FBYSxDQUFiLEdBQWlCLElBQXBEO0FBQ0QsV0FGRCxNQUVPO0FBQ0w0SCxpQkFBSyxDQUFDSCxXQUFXLENBQUNwTCxTQUFELENBQVgsQ0FBdUIsQ0FBdkIsQ0FBRCxDQUFMLEdBQW1DLEVBQW5DO0FBQ0Q7O0FBRUQsY0FBSWdDLENBQUMsS0FBS2dJLE1BQU0sQ0FBQy9ILE1BQVAsR0FBZ0IsQ0FBMUIsRUFBNkI7QUFDM0JzSixpQkFBSyxDQUFDSCxXQUFXLENBQUNwTCxTQUFELENBQVgsQ0FBdUIsQ0FBdkIsQ0FBRCxDQUFMLEdBQW1DLEtBQUsyRCxLQUFMLEdBQWEsQ0FBYixHQUFpQixJQUFwRDtBQUNELFdBRkQsTUFFTztBQUNMNEgsaUJBQUssQ0FBQ0gsV0FBVyxDQUFDcEwsU0FBRCxDQUFYLENBQXVCLENBQXZCLENBQUQsQ0FBTCxHQUFtQyxFQUFuQztBQUNEO0FBQ0Y7QUFDRixPQXpCUTs7QUE0QlQ7Ozs7OztBQU1BMEcsWUFBTSxFQUFFLFNBQVNBLE1BQVQsQ0FBZ0JzRCxNQUFoQixFQUF3QjtBQUM5QixhQUFLLElBQUloSSxDQUFDLEdBQUcsQ0FBUixFQUFXc0osR0FBRyxHQUFHdEIsTUFBTSxDQUFDL0gsTUFBN0IsRUFBcUNELENBQUMsR0FBR3NKLEdBQXpDLEVBQThDdEosQ0FBQyxFQUEvQyxFQUFtRDtBQUNqRCxjQUFJdUosS0FBSyxHQUFHdkIsTUFBTSxDQUFDaEksQ0FBRCxDQUFOLENBQVV1SixLQUF0QjtBQUVBQSxlQUFLLENBQUNFLFVBQU4sR0FBbUIsRUFBbkI7QUFDQUYsZUFBSyxDQUFDRyxXQUFOLEdBQW9CLEVBQXBCO0FBQ0Q7QUFDRjtBQXpDUSxLQUFYO0FBNENBL00sVUFBTSxDQUFDME0sSUFBRCxFQUFPLE9BQVAsRUFBZ0I7QUFDcEI7Ozs7O0FBS0FwSSxTQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGVBQU9xQixLQUFLLENBQUN5QyxLQUFLLENBQUNkLFFBQU4sQ0FBZWhILEdBQWhCLENBQVo7QUFDRDtBQVJtQixLQUFoQixDQUFOO0FBV0FOLFVBQU0sQ0FBQzBNLElBQUQsRUFBTyxNQUFQLEVBQWU7QUFDbkI7Ozs7OztBQU1BcEksU0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixlQUFPb0ksSUFBSSxDQUFDMUgsS0FBTCxJQUFjcUYsVUFBVSxDQUFDMkMsS0FBWCxDQUFpQjFKLE1BQWpCLEdBQTBCLENBQXhDLENBQVA7QUFDRDtBQVRrQixLQUFmLENBQU47QUFZQXRELFVBQU0sQ0FBQzBNLElBQUQsRUFBTyxVQUFQLEVBQW1CO0FBQ3ZCOzs7Ozs7QUFNQXBJLFNBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsWUFBSWxFLE9BQU8sR0FBR2dJLEtBQUssQ0FBQ2QsUUFBTixDQUFlbEgsT0FBN0I7QUFFQSxlQUFPc00sSUFBSSxDQUFDMUgsS0FBTCxJQUFjNUUsT0FBTyxHQUFHLENBQXhCLElBQTZCQSxPQUFwQztBQUNEO0FBWHNCLEtBQW5CLENBQU47QUFjQTs7Ozs7O0FBS0FrSyxVQUFNLENBQUM1QyxFQUFQLENBQVUsQ0FBQyxhQUFELEVBQWdCLFFBQWhCLENBQVYsRUFBcUN0RyxRQUFRLENBQUMsWUFBWTtBQUN4RHNMLFVBQUksQ0FBQ1QsS0FBTCxDQUFXNUIsVUFBVSxDQUFDZSxJQUFYLENBQWdCNkIsT0FBaEIsQ0FBd0JDLFFBQW5DO0FBQ0QsS0FGNEMsRUFFMUMsRUFGMEMsQ0FBN0M7QUFJQTs7Ozs7QUFJQTVDLFVBQU0sQ0FBQzVDLEVBQVAsQ0FBVSxTQUFWLEVBQXFCLFlBQVk7QUFDL0JnRixVQUFJLENBQUMzRSxNQUFMLENBQVlzQyxVQUFVLENBQUNlLElBQVgsQ0FBZ0I2QixPQUFoQixDQUF3QkMsUUFBcEM7QUFDRCxLQUZEO0FBSUEsV0FBT1IsSUFBUDtBQUNEO0FBRUQ7Ozs7Ozs7O0FBTUEsV0FBU1MsUUFBVCxDQUFrQkMsSUFBbEIsRUFBd0I7QUFDdEIsUUFBSUEsSUFBSSxJQUFJQSxJQUFJLENBQUNDLFVBQWpCLEVBQTZCO0FBQzNCLFVBQUlDLENBQUMsR0FBR0YsSUFBSSxDQUFDQyxVQUFMLENBQWdCRSxVQUF4QjtBQUNBLFVBQUlDLE9BQU8sR0FBRyxFQUFkOztBQUVBLGFBQU9GLENBQVAsRUFBVUEsQ0FBQyxHQUFHQSxDQUFDLENBQUNHLFdBQWhCLEVBQTZCO0FBQzNCLFlBQUlILENBQUMsQ0FBQ0ksUUFBRixLQUFlLENBQWYsSUFBb0JKLENBQUMsS0FBS0YsSUFBOUIsRUFBb0M7QUFDbENJLGlCQUFPLENBQUMxRixJQUFSLENBQWF3RixDQUFiO0FBQ0Q7QUFDRjs7QUFFRCxhQUFPRSxPQUFQO0FBQ0Q7O0FBRUQsV0FBTyxFQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7QUFNQSxXQUFTRyxLQUFULENBQWVQLElBQWYsRUFBcUI7QUFDbkIsUUFBSUEsSUFBSSxJQUFJQSxJQUFJLFlBQVlRLE1BQU0sQ0FBQ0MsV0FBbkMsRUFBZ0Q7QUFDOUMsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsTUFBSUMsY0FBYyxHQUFHLHlCQUFyQjs7QUFFQSxXQUFTMUMsSUFBVCxDQUFlaEQsS0FBZixFQUFzQmlDLFVBQXRCLEVBQWtDO0FBQ2hDLFFBQUllLElBQUksR0FBRztBQUNUOzs7OztBQUtBOUUsV0FBSyxFQUFFLFNBQVNBLEtBQVQsR0FBaUI7QUFDdEIsYUFBS3lILElBQUwsR0FBWTNGLEtBQUssQ0FBQ0MsUUFBbEI7QUFDQSxhQUFLMkYsS0FBTCxHQUFhLEtBQUtELElBQUwsQ0FBVUUsYUFBVixDQUF3QkgsY0FBeEIsQ0FBYjtBQUNBLGFBQUt6QyxNQUFMLEdBQWNoRixLQUFLLENBQUN6RCxTQUFOLENBQWdCc0wsS0FBaEIsQ0FBc0I3SixJQUF0QixDQUEyQixLQUFLNEksT0FBTCxDQUFhQyxRQUF4QyxFQUFrRGlCLE1BQWxELENBQXlELFVBQVVDLEtBQVYsRUFBaUI7QUFDdEYsaUJBQU8sQ0FBQ0EsS0FBSyxDQUFDQyxTQUFOLENBQWdCQyxRQUFoQixDQUF5QmxHLEtBQUssQ0FBQ2QsUUFBTixDQUFlOUYsT0FBZixDQUF1Qk8sVUFBaEQsQ0FBUjtBQUNELFNBRmEsQ0FBZDtBQUdEO0FBWlEsS0FBWDtBQWVBL0IsVUFBTSxDQUFDb0wsSUFBRCxFQUFPLE1BQVAsRUFBZTtBQUNuQjs7Ozs7QUFLQTlHLFNBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsZUFBTzhHLElBQUksQ0FBQ21ELEVBQVo7QUFDRCxPQVJrQjs7QUFXbkI7Ozs7O0FBS0F4RSxTQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhNUMsQ0FBYixFQUFnQjtBQUNuQixZQUFJcEIsUUFBUSxDQUFDb0IsQ0FBRCxDQUFaLEVBQWlCO0FBQ2ZBLFdBQUMsR0FBR3FILFFBQVEsQ0FBQ1AsYUFBVCxDQUF1QjlHLENBQXZCLENBQUo7QUFDRDs7QUFFRCxZQUFJd0csS0FBSyxDQUFDeEcsQ0FBRCxDQUFULEVBQWM7QUFDWmlFLGNBQUksQ0FBQ21ELEVBQUwsR0FBVXBILENBQVY7QUFDRCxTQUZELE1BRU87QUFDTGhGLGNBQUksQ0FBQywyQ0FBRCxDQUFKO0FBQ0Q7QUFDRjtBQTFCa0IsS0FBZixDQUFOO0FBNkJBbkMsVUFBTSxDQUFDb0wsSUFBRCxFQUFPLE9BQVAsRUFBZ0I7QUFDcEI7Ozs7O0FBS0E5RyxTQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGVBQU84RyxJQUFJLENBQUM3QyxFQUFaO0FBQ0QsT0FSbUI7O0FBV3BCOzs7OztBQUtBd0IsU0FBRyxFQUFFLFNBQVNBLEdBQVQsQ0FBYTBFLENBQWIsRUFBZ0I7QUFDbkIsWUFBSWQsS0FBSyxDQUFDYyxDQUFELENBQVQsRUFBYztBQUNackQsY0FBSSxDQUFDN0MsRUFBTCxHQUFVa0csQ0FBVjtBQUNELFNBRkQsTUFFTztBQUNMdE0sY0FBSSxDQUFDLDhDQUE4QzJMLGNBQTlDLEdBQStELGFBQWhFLENBQUo7QUFDRDtBQUNGO0FBdEJtQixLQUFoQixDQUFOO0FBeUJBOU4sVUFBTSxDQUFDb0wsSUFBRCxFQUFPLFNBQVAsRUFBa0I7QUFDdEI7Ozs7O0FBS0E5RyxTQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGVBQU84RyxJQUFJLENBQUM0QyxLQUFMLENBQVdkLFFBQVgsQ0FBb0IsQ0FBcEIsQ0FBUDtBQUNEO0FBUnFCLEtBQWxCLENBQU47QUFXQSxXQUFPOUIsSUFBUDtBQUNEOztBQUVELFdBQVNzRCxJQUFULENBQWV0RyxLQUFmLEVBQXNCaUMsVUFBdEIsRUFBa0NDLE1BQWxDLEVBQTBDO0FBQ3hDLFFBQUlvRSxJQUFJLEdBQUc7QUFDVDs7Ozs7QUFLQXBJLFdBQUssRUFBRSxTQUFTQSxLQUFULEdBQWlCO0FBQ3RCLGFBQUt0QixLQUFMLEdBQWFvRCxLQUFLLENBQUNkLFFBQU4sQ0FBZWhHLElBQTVCO0FBQ0Q7QUFSUSxLQUFYO0FBV0F0QixVQUFNLENBQUMwTyxJQUFELEVBQU8sT0FBUCxFQUFnQjtBQUNwQjs7Ozs7QUFLQXBLLFNBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsZUFBT29LLElBQUksQ0FBQ0MsRUFBWjtBQUNELE9BUm1COztBQVdwQjs7Ozs7O0FBTUE1RSxTQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhL0UsS0FBYixFQUFvQjtBQUN2QixZQUFJZ0IsUUFBUSxDQUFDaEIsS0FBRCxDQUFaLEVBQXFCO0FBQ25CQSxlQUFLLENBQUM0SixNQUFOLEdBQWVqSixLQUFLLENBQUNYLEtBQUssQ0FBQzRKLE1BQVAsQ0FBcEI7QUFDQTVKLGVBQUssQ0FBQ3lGLEtBQU4sR0FBYzlFLEtBQUssQ0FBQ1gsS0FBSyxDQUFDeUYsS0FBUCxDQUFuQjtBQUNELFNBSEQsTUFHTztBQUNMekYsZUFBSyxHQUFHVyxLQUFLLENBQUNYLEtBQUQsQ0FBYjtBQUNEOztBQUVEMEosWUFBSSxDQUFDQyxFQUFMLEdBQVUzSixLQUFWO0FBQ0Q7QUExQm1CLEtBQWhCLENBQU47QUE2QkFoRixVQUFNLENBQUMwTyxJQUFELEVBQU8sVUFBUCxFQUFtQjtBQUN2Qjs7Ozs7QUFLQXBLLFNBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsWUFBSVUsS0FBSyxHQUFHMEosSUFBSSxDQUFDMUosS0FBakI7QUFDQSxZQUFJNUUsT0FBTyxHQUFHZ0ksS0FBSyxDQUFDZCxRQUFOLENBQWVsSCxPQUE3Qjs7QUFFQSxZQUFJNEYsUUFBUSxDQUFDaEIsS0FBRCxDQUFaLEVBQXFCO0FBQ25CLGlCQUFPQSxLQUFLLENBQUM0SixNQUFOLEdBQWV4TyxPQUFmLEdBQXlCNEUsS0FBSyxDQUFDeUYsS0FBTixHQUFjckssT0FBOUM7QUFDRDs7QUFFRCxlQUFPNEUsS0FBSyxHQUFHLENBQVIsR0FBWTVFLE9BQW5CO0FBQ0Q7QUFmc0IsS0FBbkIsQ0FBTjtBQWtCQTs7Ozs7QUFJQWtLLFVBQU0sQ0FBQzVDLEVBQVAsQ0FBVSxDQUFDLFFBQUQsRUFBVyxRQUFYLENBQVYsRUFBZ0MsWUFBWTtBQUMxQ2dILFVBQUksQ0FBQ3BJLEtBQUw7QUFDRCxLQUZEO0FBSUEsV0FBT29JLElBQVA7QUFDRDs7QUFFRCxXQUFTcEYsSUFBVCxDQUFlbEIsS0FBZixFQUFzQmlDLFVBQXRCLEVBQWtDQyxNQUFsQyxFQUEwQztBQUN4QyxRQUFJaEIsSUFBSSxHQUFHO0FBQ1Q7Ozs7O0FBS0FoRCxXQUFLLEVBQUUsU0FBU0EsS0FBVCxHQUFpQjtBQUN0QixhQUFLd0QsRUFBTCxHQUFVLENBQVY7QUFDRCxPQVJROztBQVdUOzs7Ozs7QUFNQWIsVUFBSSxFQUFFLFNBQVNBLElBQVQsR0FBZ0I7QUFDcEIsWUFBSXNCLEtBQUssR0FBRyxJQUFaOztBQUVBLFlBQUlzRSxNQUFNLEdBQUczSyxTQUFTLENBQUNaLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JZLFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUJXLFNBQXpDLEdBQXFEWCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxDQUFqRjtBQUVBLGFBQUsySyxNQUFMLEdBQWNBLE1BQWQ7QUFFQXZFLGNBQU0sQ0FBQ3RDLElBQVAsQ0FBWSxNQUFaLEVBQW9CO0FBQ2xCOEcsa0JBQVEsRUFBRSxLQUFLOUo7QUFERyxTQUFwQjtBQUlBcUYsa0JBQVUsQ0FBQ2pCLFVBQVgsQ0FBc0JxQixLQUF0QixDQUE0QixZQUFZO0FBQ3RDSCxnQkFBTSxDQUFDdEMsSUFBUCxDQUFZLFlBQVosRUFBMEI7QUFDeEI4RyxvQkFBUSxFQUFFdkUsS0FBSyxDQUFDdkY7QUFEUSxXQUExQjtBQUdELFNBSkQ7QUFLRDtBQWpDUSxLQUFYO0FBb0NBaEYsVUFBTSxDQUFDc0osSUFBRCxFQUFPLFFBQVAsRUFBaUI7QUFDckI7Ozs7O0FBS0FoRixTQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGVBQU9nRixJQUFJLENBQUNRLEVBQVo7QUFDRCxPQVJvQjs7QUFXckI7Ozs7O0FBS0FDLFNBQUcsRUFBRSxTQUFTQSxHQUFULENBQWEvRSxLQUFiLEVBQW9CO0FBQ3ZCc0UsWUFBSSxDQUFDUSxFQUFMLEdBQVUsQ0FBQzNELFdBQVcsQ0FBQ25CLEtBQUQsQ0FBWixHQUFzQlcsS0FBSyxDQUFDWCxLQUFELENBQTNCLEdBQXFDLENBQS9DO0FBQ0Q7QUFsQm9CLEtBQWpCLENBQU47QUFxQkFoRixVQUFNLENBQUNzSixJQUFELEVBQU8sV0FBUCxFQUFvQjtBQUN4Qjs7Ozs7QUFLQWhGLFNBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsZUFBTytGLFVBQVUsQ0FBQzJDLEtBQVgsQ0FBaUIrQixVQUFqQixHQUE4QjNHLEtBQUssQ0FBQ1AsS0FBM0M7QUFDRDtBQVJ1QixLQUFwQixDQUFOO0FBV0E3SCxVQUFNLENBQUNzSixJQUFELEVBQU8sT0FBUCxFQUFnQjtBQUNwQjs7Ozs7QUFLQWhGLFNBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsWUFBSXVLLE1BQU0sR0FBRyxLQUFLQSxNQUFsQjtBQUNBLFlBQUlHLFNBQVMsR0FBRyxLQUFLQSxTQUFyQjs7QUFFQSxZQUFJM0UsVUFBVSxDQUFDd0MsU0FBWCxDQUFxQm9DLEVBQXJCLENBQXdCLEtBQXhCLENBQUosRUFBb0M7QUFDbEMsaUJBQU9ELFNBQVMsR0FBR0gsTUFBbkI7QUFDRDs7QUFFRCxlQUFPRyxTQUFTLEdBQUdILE1BQW5CO0FBQ0Q7QUFmbUIsS0FBaEIsQ0FBTjtBQWtCQTs7Ozs7O0FBS0F2RSxVQUFNLENBQUM1QyxFQUFQLENBQVUsQ0FBQyxjQUFELEVBQWlCLEtBQWpCLENBQVYsRUFBbUMsWUFBWTtBQUM3QzRCLFVBQUksQ0FBQ0wsSUFBTDtBQUNELEtBRkQ7QUFJQSxXQUFPSyxJQUFQO0FBQ0Q7O0FBRUQsV0FBUzBELEtBQVQsQ0FBZ0I1RSxLQUFoQixFQUF1QmlDLFVBQXZCLEVBQW1DQyxNQUFuQyxFQUEyQztBQUN6QyxRQUFJMEMsS0FBSyxHQUFHO0FBQ1Y7Ozs7O0FBS0FrQyxpQkFBVyxFQUFFLFNBQVNBLFdBQVQsR0FBdUI7QUFDbEMsWUFBSUMsS0FBSyxHQUFHLEtBQUtKLFVBQUwsR0FBa0IsSUFBOUI7QUFDQSxZQUFJMUQsTUFBTSxHQUFHaEIsVUFBVSxDQUFDZSxJQUFYLENBQWdCQyxNQUE3Qjs7QUFFQSxhQUFLLElBQUloSSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHZ0ksTUFBTSxDQUFDL0gsTUFBM0IsRUFBbUNELENBQUMsRUFBcEMsRUFBd0M7QUFDdENnSSxnQkFBTSxDQUFDaEksQ0FBRCxDQUFOLENBQVV1SixLQUFWLENBQWdCdUMsS0FBaEIsR0FBd0JBLEtBQXhCO0FBQ0Q7QUFDRixPQWJTOztBQWdCVjs7Ozs7QUFLQUMsa0JBQVksRUFBRSxTQUFTQSxZQUFULENBQXNCQyxTQUF0QixFQUFpQztBQUM3Q2hGLGtCQUFVLENBQUNlLElBQVgsQ0FBZ0I2QixPQUFoQixDQUF3QkwsS0FBeEIsQ0FBOEJ1QyxLQUE5QixHQUFzQyxLQUFLRyxXQUFMLEdBQW1CLElBQXpEO0FBQ0QsT0F2QlM7O0FBMEJWOzs7OztBQUtBdkgsWUFBTSxFQUFFLFNBQVNBLE1BQVQsR0FBa0I7QUFDeEIsWUFBSXNELE1BQU0sR0FBR2hCLFVBQVUsQ0FBQ2UsSUFBWCxDQUFnQkMsTUFBN0I7O0FBRUEsYUFBSyxJQUFJaEksQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2dJLE1BQU0sQ0FBQy9ILE1BQTNCLEVBQW1DRCxDQUFDLEVBQXBDLEVBQXdDO0FBQ3RDZ0ksZ0JBQU0sQ0FBQ2hJLENBQUQsQ0FBTixDQUFVdUosS0FBVixDQUFnQnVDLEtBQWhCLEdBQXdCLEVBQXhCO0FBQ0Q7O0FBRUQ5RSxrQkFBVSxDQUFDZSxJQUFYLENBQWdCNkIsT0FBaEIsQ0FBd0JMLEtBQXhCLENBQThCdUMsS0FBOUIsR0FBc0MsRUFBdEM7QUFDRDtBQXZDUyxLQUFaO0FBMENBblAsVUFBTSxDQUFDZ04sS0FBRCxFQUFRLFFBQVIsRUFBa0I7QUFDdEI7Ozs7O0FBS0ExSSxTQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGVBQU8rRixVQUFVLENBQUNlLElBQVgsQ0FBZ0JDLE1BQWhCLENBQXVCL0gsTUFBOUI7QUFDRDtBQVJxQixLQUFsQixDQUFOO0FBV0F0RCxVQUFNLENBQUNnTixLQUFELEVBQVEsT0FBUixFQUFpQjtBQUNyQjs7Ozs7QUFLQTFJLFNBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsZUFBTytGLFVBQVUsQ0FBQ2UsSUFBWCxDQUFnQjJDLElBQWhCLENBQXFCd0IsV0FBNUI7QUFDRDtBQVJvQixLQUFqQixDQUFOO0FBV0F2UCxVQUFNLENBQUNnTixLQUFELEVBQVEsYUFBUixFQUF1QjtBQUMzQjs7Ozs7QUFLQTFJLFNBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsZUFBTzBJLEtBQUssQ0FBQytCLFVBQU4sR0FBbUIvQixLQUFLLENBQUMxSixNQUF6QixHQUFrQytHLFVBQVUsQ0FBQ3FDLElBQVgsQ0FBZ0I4QyxJQUFsRCxHQUF5RG5GLFVBQVUsQ0FBQ29GLE1BQVgsQ0FBa0JELElBQWxGO0FBQ0Q7QUFSMEIsS0FBdkIsQ0FBTjtBQVdBeFAsVUFBTSxDQUFDZ04sS0FBRCxFQUFRLFlBQVIsRUFBc0I7QUFDMUI7Ozs7O0FBS0ExSSxTQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGVBQU8wSSxLQUFLLENBQUNtQyxLQUFOLEdBQWMvRyxLQUFLLENBQUNkLFFBQU4sQ0FBZWxILE9BQTdCLEdBQXVDaUssVUFBVSxDQUFDcUUsSUFBWCxDQUFnQmdCLFFBQXZELEdBQWtFckYsVUFBVSxDQUFDcUMsSUFBWCxDQUFnQmdELFFBQXpGO0FBQ0Q7QUFSeUIsS0FBdEIsQ0FBTjtBQVdBOzs7Ozs7O0FBTUFwRixVQUFNLENBQUM1QyxFQUFQLENBQVUsQ0FBQyxjQUFELEVBQWlCLFFBQWpCLEVBQTJCLFFBQTNCLENBQVYsRUFBZ0QsWUFBWTtBQUMxRHNGLFdBQUssQ0FBQ2tDLFdBQU47QUFDQWxDLFdBQUssQ0FBQ29DLFlBQU47QUFDRCxLQUhEO0FBS0E7Ozs7O0FBSUE5RSxVQUFNLENBQUM1QyxFQUFQLENBQVUsU0FBVixFQUFxQixZQUFZO0FBQy9Cc0YsV0FBSyxDQUFDakYsTUFBTjtBQUNELEtBRkQ7QUFJQSxXQUFPaUYsS0FBUDtBQUNEOztBQUVELFdBQVMyQyxLQUFULENBQWdCdkgsS0FBaEIsRUFBdUJpQyxVQUF2QixFQUFtQ0MsTUFBbkMsRUFBMkM7QUFDekMsUUFBSXFGLEtBQUssR0FBRztBQUNWOzs7Ozs7QUFNQXJKLFdBQUssRUFBRSxTQUFTQSxLQUFULEdBQWlCO0FBQ3RCZ0UsY0FBTSxDQUFDdEMsSUFBUCxDQUFZLGNBQVo7QUFFQSxhQUFLNEgsU0FBTDtBQUNBLGFBQUtDLFdBQUw7QUFFQXZGLGNBQU0sQ0FBQ3RDLElBQVAsQ0FBWSxhQUFaO0FBQ0QsT0FkUzs7QUFpQlY7Ozs7O0FBS0E0SCxlQUFTLEVBQUUsU0FBU0EsU0FBVCxHQUFxQjtBQUM5QnZGLGtCQUFVLENBQUNlLElBQVgsQ0FBZ0IyQyxJQUFoQixDQUFxQk0sU0FBckIsQ0FBK0J5QixHQUEvQixDQUFtQzFILEtBQUssQ0FBQ2QsUUFBTixDQUFlOUYsT0FBZixDQUF1QjRHLEtBQUssQ0FBQ2QsUUFBTixDQUFlcEgsSUFBdEMsQ0FBbkM7QUFDRCxPQXhCUzs7QUEyQlY7Ozs7O0FBS0EyUCxpQkFBVyxFQUFFLFNBQVNBLFdBQVQsR0FBdUI7QUFDbEMsWUFBSXJPLE9BQU8sR0FBRzRHLEtBQUssQ0FBQ2QsUUFBTixDQUFlOUYsT0FBN0I7QUFDQSxZQUFJNE0sS0FBSyxHQUFHL0QsVUFBVSxDQUFDZSxJQUFYLENBQWdCQyxNQUFoQixDQUF1QmpELEtBQUssQ0FBQ1AsS0FBN0IsQ0FBWjs7QUFFQSxZQUFJdUcsS0FBSixFQUFXO0FBQ1RBLGVBQUssQ0FBQ0MsU0FBTixDQUFnQnlCLEdBQWhCLENBQW9CdE8sT0FBTyxDQUFDUyxXQUE1QjtBQUVBa0wsa0JBQVEsQ0FBQ2lCLEtBQUQsQ0FBUixDQUFnQmxHLE9BQWhCLENBQXdCLFVBQVU2SCxPQUFWLEVBQW1CO0FBQ3pDQSxtQkFBTyxDQUFDMUIsU0FBUixDQUFrQnRHLE1BQWxCLENBQXlCdkcsT0FBTyxDQUFDUyxXQUFqQztBQUNELFdBRkQ7QUFHRDtBQUNGLE9BM0NTOztBQThDVjs7Ozs7QUFLQStOLG1CQUFhLEVBQUUsU0FBU0EsYUFBVCxHQUF5QjtBQUN0QyxZQUFJeE8sT0FBTyxHQUFHNEcsS0FBSyxDQUFDZCxRQUFOLENBQWU5RixPQUE3QjtBQUVBNkksa0JBQVUsQ0FBQ2UsSUFBWCxDQUFnQjJDLElBQWhCLENBQXFCTSxTQUFyQixDQUErQnRHLE1BQS9CLENBQXNDdkcsT0FBTyxDQUFDNEcsS0FBSyxDQUFDZCxRQUFOLENBQWVwSCxJQUFoQixDQUE3QztBQUVBbUssa0JBQVUsQ0FBQ2UsSUFBWCxDQUFnQkMsTUFBaEIsQ0FBdUJuRCxPQUF2QixDQUErQixVQUFVNkgsT0FBVixFQUFtQjtBQUNoREEsaUJBQU8sQ0FBQzFCLFNBQVIsQ0FBa0J0RyxNQUFsQixDQUF5QnZHLE9BQU8sQ0FBQ1MsV0FBakM7QUFDRCxTQUZEO0FBR0Q7QUEzRFMsS0FBWjtBQThEQTs7Ozs7O0FBS0FxSSxVQUFNLENBQUM1QyxFQUFQLENBQVUsQ0FBQyxTQUFELEVBQVksUUFBWixDQUFWLEVBQWlDLFlBQVk7QUFDM0NpSSxXQUFLLENBQUNLLGFBQU47QUFDRCxLQUZEO0FBSUE7Ozs7OztBQUtBMUYsVUFBTSxDQUFDNUMsRUFBUCxDQUFVLENBQUMsUUFBRCxFQUFXLFFBQVgsQ0FBVixFQUFnQyxZQUFZO0FBQzFDaUksV0FBSyxDQUFDckosS0FBTjtBQUNELEtBRkQ7QUFJQTs7Ozs7QUFJQWdFLFVBQU0sQ0FBQzVDLEVBQVAsQ0FBVSxZQUFWLEVBQXdCLFlBQVk7QUFDbENpSSxXQUFLLENBQUNFLFdBQU47QUFDRCxLQUZEO0FBSUEsV0FBT0YsS0FBUDtBQUNEOztBQUVELFdBQVNGLE1BQVQsQ0FBaUJySCxLQUFqQixFQUF3QmlDLFVBQXhCLEVBQW9DQyxNQUFwQyxFQUE0QztBQUMxQyxRQUFJbUYsTUFBTSxHQUFHO0FBQ1g7OztBQUdBbkosV0FBSyxFQUFFLFNBQVNBLEtBQVQsR0FBaUI7QUFDdEIsYUFBSzJKLEtBQUwsR0FBYSxFQUFiOztBQUVBLFlBQUk3SCxLQUFLLENBQUN3QixNQUFOLENBQWEsVUFBYixDQUFKLEVBQThCO0FBQzVCLGVBQUtxRyxLQUFMLEdBQWEsS0FBS0MsT0FBTCxFQUFiO0FBQ0Q7QUFDRixPQVZVOztBQWFYOzs7OztBQUtBQSxhQUFPLEVBQUUsU0FBU0EsT0FBVCxHQUFtQjtBQUMxQixZQUFJRCxLQUFLLEdBQUcvTCxTQUFTLENBQUNaLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JZLFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUJXLFNBQXpDLEdBQXFEWCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxFQUFoRjtBQUNBLFlBQUltSCxNQUFNLEdBQUdoQixVQUFVLENBQUNlLElBQVgsQ0FBZ0JDLE1BQTdCO0FBQ0EsWUFBSThFLGVBQWUsR0FBRy9ILEtBQUssQ0FBQ2QsUUFBNUI7QUFBQSxZQUNJbEgsT0FBTyxHQUFHK1AsZUFBZSxDQUFDL1AsT0FEOUI7QUFBQSxZQUVJb0IsT0FBTyxHQUFHMk8sZUFBZSxDQUFDM08sT0FGOUI7QUFLQSxZQUFJNE8sZUFBZSxHQUFHLENBQUMsQ0FBQyxDQUFDaEksS0FBSyxDQUFDZCxRQUFOLENBQWVoRyxJQUF4QztBQUNBLFlBQUkrTyxJQUFJLEdBQUdqUSxPQUFPLEdBQUdnUSxlQUFyQjtBQUNBLFlBQUlFLEtBQUssR0FBR2pGLE1BQU0sQ0FBQzZDLEtBQVAsQ0FBYSxDQUFiLEVBQWdCbUMsSUFBaEIsQ0FBWjtBQUNBLFlBQUlFLEdBQUcsR0FBR2xGLE1BQU0sQ0FBQzZDLEtBQVAsQ0FBYSxDQUFDbUMsSUFBZCxDQUFWOztBQUVBLGFBQUssSUFBSWxKLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0RCxJQUFJLENBQUN5RixHQUFMLENBQVMsQ0FBVCxFQUFZekYsSUFBSSxDQUFDMEYsS0FBTCxDQUFXclEsT0FBTyxHQUFHaUwsTUFBTSxDQUFDL0gsTUFBNUIsQ0FBWixDQUFwQixFQUFzRTZELENBQUMsRUFBdkUsRUFBMkU7QUFDekUsZUFBSyxJQUFJOUQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2lOLEtBQUssQ0FBQ2hOLE1BQTFCLEVBQWtDRCxDQUFDLEVBQW5DLEVBQXVDO0FBQ3JDLGdCQUFJcU4sS0FBSyxHQUFHSixLQUFLLENBQUNqTixDQUFELENBQUwsQ0FBU3NOLFNBQVQsQ0FBbUIsSUFBbkIsQ0FBWjtBQUVBRCxpQkFBSyxDQUFDckMsU0FBTixDQUFnQnlCLEdBQWhCLENBQW9CdE8sT0FBTyxDQUFDTyxVQUE1QjtBQUVBa08saUJBQUssQ0FBQ25JLElBQU4sQ0FBVzRJLEtBQVg7QUFDRDs7QUFFRCxlQUFLLElBQUl4RyxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHcUcsR0FBRyxDQUFDak4sTUFBMUIsRUFBa0M0RyxFQUFFLEVBQXBDLEVBQXdDO0FBQ3RDLGdCQUFJMEcsTUFBTSxHQUFHTCxHQUFHLENBQUNyRyxFQUFELENBQUgsQ0FBUXlHLFNBQVIsQ0FBa0IsSUFBbEIsQ0FBYjs7QUFFQUMsa0JBQU0sQ0FBQ3ZDLFNBQVAsQ0FBaUJ5QixHQUFqQixDQUFxQnRPLE9BQU8sQ0FBQ08sVUFBN0I7O0FBRUFrTyxpQkFBSyxDQUFDWSxPQUFOLENBQWNELE1BQWQ7QUFDRDtBQUNGOztBQUVELGVBQU9YLEtBQVA7QUFDRCxPQWxEVTs7QUFxRFg7Ozs7O0FBS0FhLFlBQU0sRUFBRSxTQUFTQSxNQUFULEdBQWtCO0FBQ3hCLFlBQUliLEtBQUssR0FBRyxLQUFLQSxLQUFqQjtBQUNBLFlBQUljLGdCQUFnQixHQUFHMUcsVUFBVSxDQUFDZSxJQUFsQztBQUFBLFlBQ0k2QixPQUFPLEdBQUc4RCxnQkFBZ0IsQ0FBQzlELE9BRC9CO0FBQUEsWUFFSTVCLE1BQU0sR0FBRzBGLGdCQUFnQixDQUFDMUYsTUFGOUI7QUFLQSxZQUFJMkYsSUFBSSxHQUFHakcsSUFBSSxDQUFDMEYsS0FBTCxDQUFXUixLQUFLLENBQUMzTSxNQUFOLEdBQWUsQ0FBMUIsQ0FBWDtBQUNBLFlBQUkyTixPQUFPLEdBQUdoQixLQUFLLENBQUMvQixLQUFOLENBQVksQ0FBWixFQUFlOEMsSUFBZixFQUFxQkUsT0FBckIsRUFBZDtBQUNBLFlBQUlKLE1BQU0sR0FBR2IsS0FBSyxDQUFDL0IsS0FBTixDQUFZOEMsSUFBWixFQUFrQmYsS0FBSyxDQUFDM00sTUFBeEIsQ0FBYjtBQUNBLFlBQUk2TCxLQUFLLEdBQUc5RSxVQUFVLENBQUMyQyxLQUFYLENBQWlCK0IsVUFBakIsR0FBOEIsSUFBMUM7O0FBRUEsYUFBSyxJQUFJMUwsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3lOLE1BQU0sQ0FBQ3hOLE1BQTNCLEVBQW1DRCxDQUFDLEVBQXBDLEVBQXdDO0FBQ3RDNEosaUJBQU8sQ0FBQ2tFLFdBQVIsQ0FBb0JMLE1BQU0sQ0FBQ3pOLENBQUQsQ0FBMUI7QUFDRDs7QUFFRCxhQUFLLElBQUkrTixHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHSCxPQUFPLENBQUMzTixNQUFoQyxFQUF3QzhOLEdBQUcsRUFBM0MsRUFBK0M7QUFDN0NuRSxpQkFBTyxDQUFDb0UsWUFBUixDQUFxQkosT0FBTyxDQUFDRyxHQUFELENBQTVCLEVBQW1DL0YsTUFBTSxDQUFDLENBQUQsQ0FBekM7QUFDRDs7QUFFRCxhQUFLLElBQUlpRyxHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHckIsS0FBSyxDQUFDM00sTUFBOUIsRUFBc0NnTyxHQUFHLEVBQXpDLEVBQTZDO0FBQzNDckIsZUFBSyxDQUFDcUIsR0FBRCxDQUFMLENBQVcxRSxLQUFYLENBQWlCdUMsS0FBakIsR0FBeUJBLEtBQXpCO0FBQ0Q7QUFDRixPQWpGVTs7QUFvRlg7Ozs7O0FBS0FwSCxZQUFNLEVBQUUsU0FBU0EsTUFBVCxHQUFrQjtBQUN4QixZQUFJa0ksS0FBSyxHQUFHLEtBQUtBLEtBQWpCOztBQUdBLGFBQUssSUFBSTVNLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0TSxLQUFLLENBQUMzTSxNQUExQixFQUFrQ0QsQ0FBQyxFQUFuQyxFQUF1QztBQUNyQ2dILG9CQUFVLENBQUNlLElBQVgsQ0FBZ0I2QixPQUFoQixDQUF3QnNFLFdBQXhCLENBQW9DdEIsS0FBSyxDQUFDNU0sQ0FBRCxDQUF6QztBQUNEO0FBQ0Y7QUFoR1UsS0FBYjtBQW1HQXJELFVBQU0sQ0FBQ3lQLE1BQUQsRUFBUyxNQUFULEVBQWlCO0FBQ3JCOzs7OztBQUtBbkwsU0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixlQUFPLENBQUMrRixVQUFVLENBQUMyQyxLQUFYLENBQWlCK0IsVUFBakIsR0FBOEIxRSxVQUFVLENBQUNxQyxJQUFYLENBQWdCMUgsS0FBL0MsSUFBd0R5SyxNQUFNLENBQUNRLEtBQVAsQ0FBYTNNLE1BQTVFO0FBQ0Q7QUFSb0IsS0FBakIsQ0FBTjtBQVdBOzs7OztBQUlBZ0gsVUFBTSxDQUFDNUMsRUFBUCxDQUFVLFFBQVYsRUFBb0IsWUFBWTtBQUM5QitILFlBQU0sQ0FBQzFILE1BQVA7QUFDQTBILFlBQU0sQ0FBQ25KLEtBQVA7QUFDQW1KLFlBQU0sQ0FBQ3FCLE1BQVA7QUFDRCxLQUpEO0FBTUE7Ozs7O0FBSUF4RyxVQUFNLENBQUM1QyxFQUFQLENBQVUsY0FBVixFQUEwQixZQUFZO0FBQ3BDLFVBQUlVLEtBQUssQ0FBQ3dCLE1BQU4sQ0FBYSxVQUFiLENBQUosRUFBOEI7QUFDNUI2RixjQUFNLENBQUNxQixNQUFQO0FBQ0Q7QUFDRixLQUpEO0FBTUE7Ozs7O0FBSUF4RyxVQUFNLENBQUM1QyxFQUFQLENBQVUsU0FBVixFQUFxQixZQUFZO0FBQy9CK0gsWUFBTSxDQUFDMUgsTUFBUDtBQUNELEtBRkQ7QUFJQSxXQUFPMEgsTUFBUDtBQUNEOztBQUVELE1BQUkrQixZQUFZLEdBQUcsWUFBWTtBQUM3Qjs7O0FBR0EsYUFBU0EsWUFBVCxHQUF3QjtBQUN0QixVQUFJQyxTQUFTLEdBQUd2TixTQUFTLENBQUNaLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JZLFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUJXLFNBQXpDLEdBQXFEWCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxFQUFwRjtBQUNBckIsb0JBQWMsQ0FBQyxJQUFELEVBQU8yTyxZQUFQLENBQWQ7QUFFQSxXQUFLQyxTQUFMLEdBQWlCQSxTQUFqQjtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7O0FBV0F4TyxlQUFXLENBQUN1TyxZQUFELEVBQWUsQ0FBQztBQUN6QjNOLFNBQUcsRUFBRSxJQURvQjtBQUV6Qm1CLFdBQUssRUFBRSxTQUFTMEMsRUFBVCxDQUFZakIsTUFBWixFQUFvQmlMLEVBQXBCLEVBQXdCQyxPQUF4QixFQUFpQztBQUN0QyxZQUFJQyxPQUFPLEdBQUcxTixTQUFTLENBQUNaLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JZLFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUJXLFNBQXpDLEdBQXFEWCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxLQUFsRjs7QUFFQSxZQUFJNkIsUUFBUSxDQUFDVSxNQUFELENBQVosRUFBc0I7QUFDcEJBLGdCQUFNLEdBQUcsQ0FBQ0EsTUFBRCxDQUFUO0FBQ0Q7O0FBRUQsYUFBSyxJQUFJcEQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR29ELE1BQU0sQ0FBQ25ELE1BQTNCLEVBQW1DRCxDQUFDLEVBQXBDLEVBQXdDO0FBQ3RDLGVBQUtvTyxTQUFMLENBQWVoTCxNQUFNLENBQUNwRCxDQUFELENBQXJCLElBQTRCc08sT0FBNUI7QUFFQUQsWUFBRSxDQUFDRyxnQkFBSCxDQUFvQnBMLE1BQU0sQ0FBQ3BELENBQUQsQ0FBMUIsRUFBK0IsS0FBS29PLFNBQUwsQ0FBZWhMLE1BQU0sQ0FBQ3BELENBQUQsQ0FBckIsQ0FBL0IsRUFBMER1TyxPQUExRDtBQUNEO0FBQ0Y7QUFFRDs7Ozs7Ozs7O0FBaEJ5QixLQUFELEVBeUJ2QjtBQUNEL04sU0FBRyxFQUFFLEtBREo7QUFFRG1CLFdBQUssRUFBRSxTQUFTOE0sR0FBVCxDQUFhckwsTUFBYixFQUFxQmlMLEVBQXJCLEVBQXlCO0FBQzlCLFlBQUlFLE9BQU8sR0FBRzFOLFNBQVMsQ0FBQ1osTUFBVixHQUFtQixDQUFuQixJQUF3QlksU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQlcsU0FBekMsR0FBcURYLFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEtBQWxGOztBQUVBLFlBQUk2QixRQUFRLENBQUNVLE1BQUQsQ0FBWixFQUFzQjtBQUNwQkEsZ0JBQU0sR0FBRyxDQUFDQSxNQUFELENBQVQ7QUFDRDs7QUFFRCxhQUFLLElBQUlwRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHb0QsTUFBTSxDQUFDbkQsTUFBM0IsRUFBbUNELENBQUMsRUFBcEMsRUFBd0M7QUFDdENxTyxZQUFFLENBQUNLLG1CQUFILENBQXVCdEwsTUFBTSxDQUFDcEQsQ0FBRCxDQUE3QixFQUFrQyxLQUFLb08sU0FBTCxDQUFlaEwsTUFBTSxDQUFDcEQsQ0FBRCxDQUFyQixDQUFsQyxFQUE2RHVPLE9BQTdEO0FBQ0Q7QUFDRjtBQUVEOzs7Ozs7QUFkQyxLQXpCdUIsRUE2Q3ZCO0FBQ0QvTixTQUFHLEVBQUUsU0FESjtBQUVEbUIsV0FBSyxFQUFFLFNBQVN1RSxPQUFULEdBQW1CO0FBQ3hCLGVBQU8sS0FBS2tJLFNBQVo7QUFDRDtBQUpBLEtBN0N1QixDQUFmLENBQVg7QUFtREEsV0FBT0QsWUFBUDtBQUNELEdBMUVrQixFQUFuQjs7QUE0RUEsV0FBU1EsTUFBVCxDQUFpQjVKLEtBQWpCLEVBQXdCaUMsVUFBeEIsRUFBb0NDLE1BQXBDLEVBQTRDO0FBQzFDOzs7OztBQUtBLFFBQUkySCxNQUFNLEdBQUcsSUFBSVQsWUFBSixFQUFiO0FBRUEsUUFBSVEsTUFBTSxHQUFHO0FBQ1g7OztBQUdBMUwsV0FBSyxFQUFFLFNBQVNBLEtBQVQsR0FBaUI7QUFDdEIsYUFBSzRMLElBQUw7QUFDRCxPQU5VOztBQVNYOzs7Ozs7QUFNQUEsVUFBSSxFQUFFLFNBQVNBLElBQVQsR0FBZ0I7QUFDcEJELGNBQU0sQ0FBQ3ZLLEVBQVAsQ0FBVSxRQUFWLEVBQW9Ca0csTUFBcEIsRUFBNEJ4TSxRQUFRLENBQUMsWUFBWTtBQUMvQ2tKLGdCQUFNLENBQUN0QyxJQUFQLENBQVksUUFBWjtBQUNELFNBRm1DLEVBRWpDSSxLQUFLLENBQUNkLFFBQU4sQ0FBZWxHLFFBRmtCLENBQXBDO0FBR0QsT0FuQlU7O0FBc0JYOzs7OztBQUtBK1EsWUFBTSxFQUFFLFNBQVNBLE1BQVQsR0FBa0I7QUFDeEJGLGNBQU0sQ0FBQ0gsR0FBUCxDQUFXLFFBQVgsRUFBcUJsRSxNQUFyQjtBQUNEO0FBN0JVLEtBQWI7QUFnQ0E7Ozs7O0FBSUF0RCxVQUFNLENBQUM1QyxFQUFQLENBQVUsU0FBVixFQUFxQixZQUFZO0FBQy9Cc0ssWUFBTSxDQUFDRyxNQUFQO0FBQ0FGLFlBQU0sQ0FBQzFJLE9BQVA7QUFDRCxLQUhEO0FBS0EsV0FBT3lJLE1BQVA7QUFDRDs7QUFFRCxNQUFJSSxnQkFBZ0IsR0FBRyxDQUFDLEtBQUQsRUFBUSxLQUFSLENBQXZCO0FBQ0EsTUFBSUMsZ0JBQWdCLEdBQUc7QUFDckIsU0FBSyxHQURnQjtBQUVyQixTQUFLLEdBRmdCO0FBR3JCLFNBQUs7QUFIZ0IsR0FBdkI7O0FBTUEsV0FBU3hGLFNBQVQsQ0FBb0J6RSxLQUFwQixFQUEyQmlDLFVBQTNCLEVBQXVDQyxNQUF2QyxFQUErQztBQUM3QyxRQUFJdUMsU0FBUyxHQUFHO0FBQ2Q7Ozs7O0FBS0F2RyxXQUFLLEVBQUUsU0FBU0EsS0FBVCxHQUFpQjtBQUN0QixhQUFLdEIsS0FBTCxHQUFhb0QsS0FBSyxDQUFDZCxRQUFOLENBQWVqRyxTQUE1QjtBQUNELE9BUmE7O0FBV2Q7Ozs7OztBQU1BaVIsYUFBTyxFQUFFLFNBQVNBLE9BQVQsQ0FBaUJ2SixPQUFqQixFQUEwQjtBQUNqQyxZQUFJd0osS0FBSyxHQUFHeEosT0FBTyxDQUFDbUYsS0FBUixDQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBWjs7QUFFQSxZQUFJLEtBQUtlLEVBQUwsQ0FBUSxLQUFSLENBQUosRUFBb0I7QUFDbEIsaUJBQU9sRyxPQUFPLENBQUN5SixLQUFSLENBQWNELEtBQWQsRUFBcUJFLElBQXJCLENBQTBCSixnQkFBZ0IsQ0FBQ0UsS0FBRCxDQUExQyxDQUFQO0FBQ0Q7O0FBRUQsZUFBT3hKLE9BQVA7QUFDRCxPQXpCYTs7QUE0QmQ7Ozs7OztBQU1Ba0csUUFBRSxFQUFFLFNBQVNBLEVBQVQsQ0FBWTVOLFNBQVosRUFBdUI7QUFDekIsZUFBTyxLQUFLMkQsS0FBTCxLQUFlM0QsU0FBdEI7QUFDRCxPQXBDYTs7QUF1Q2Q7Ozs7O0FBS0FxUixjQUFRLEVBQUUsU0FBU0EsUUFBVCxHQUFvQjtBQUM1QnJJLGtCQUFVLENBQUNlLElBQVgsQ0FBZ0IyQyxJQUFoQixDQUFxQk0sU0FBckIsQ0FBK0J5QixHQUEvQixDQUFtQzFILEtBQUssQ0FBQ2QsUUFBTixDQUFlOUYsT0FBZixDQUF1QkgsU0FBdkIsQ0FBaUMsS0FBSzJELEtBQXRDLENBQW5DO0FBQ0QsT0E5Q2E7O0FBaURkOzs7OztBQUtBMk4saUJBQVcsRUFBRSxTQUFTQSxXQUFULEdBQXVCO0FBQ2xDdEksa0JBQVUsQ0FBQ2UsSUFBWCxDQUFnQjJDLElBQWhCLENBQXFCTSxTQUFyQixDQUErQnRHLE1BQS9CLENBQXNDSyxLQUFLLENBQUNkLFFBQU4sQ0FBZTlGLE9BQWYsQ0FBdUJILFNBQXZCLENBQWlDLEtBQUsyRCxLQUF0QyxDQUF0QztBQUNEO0FBeERhLEtBQWhCO0FBMkRBaEYsVUFBTSxDQUFDNk0sU0FBRCxFQUFZLE9BQVosRUFBcUI7QUFDekI7Ozs7O0FBS0F2SSxTQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGVBQU91SSxTQUFTLENBQUM4QixFQUFqQjtBQUNELE9BUndCOztBQVd6Qjs7Ozs7O0FBTUE1RSxTQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhL0UsS0FBYixFQUFvQjtBQUN2QixZQUFJb04sZ0JBQWdCLENBQUNRLE9BQWpCLENBQXlCNU4sS0FBekIsSUFBa0MsQ0FBQyxDQUF2QyxFQUEwQztBQUN4QzZILG1CQUFTLENBQUM4QixFQUFWLEdBQWUzSixLQUFmO0FBQ0QsU0FGRCxNQUVPO0FBQ0w3QyxjQUFJLENBQUMsd0NBQUQsQ0FBSjtBQUNEO0FBQ0Y7QUF2QndCLEtBQXJCLENBQU47QUEwQkE7Ozs7OztBQUtBbUksVUFBTSxDQUFDNUMsRUFBUCxDQUFVLENBQUMsU0FBRCxFQUFZLFFBQVosQ0FBVixFQUFpQyxZQUFZO0FBQzNDbUYsZUFBUyxDQUFDOEYsV0FBVjtBQUNELEtBRkQ7QUFJQTs7Ozs7QUFJQXJJLFVBQU0sQ0FBQzVDLEVBQVAsQ0FBVSxRQUFWLEVBQW9CLFlBQVk7QUFDOUJtRixlQUFTLENBQUN2RyxLQUFWO0FBQ0QsS0FGRDtBQUlBOzs7Ozs7QUFLQWdFLFVBQU0sQ0FBQzVDLEVBQVAsQ0FBVSxDQUFDLGNBQUQsRUFBaUIsUUFBakIsQ0FBVixFQUFzQyxZQUFZO0FBQ2hEbUYsZUFBUyxDQUFDNkYsUUFBVjtBQUNELEtBRkQ7QUFJQSxXQUFPN0YsU0FBUDtBQUNEO0FBRUQ7Ozs7Ozs7OztBQU9BLFdBQVNnRyxHQUFULENBQWN6SyxLQUFkLEVBQXFCaUMsVUFBckIsRUFBaUM7QUFDL0IsV0FBTztBQUNMOzs7Ozs7QUFNQXlJLFlBQU0sRUFBRSxTQUFTQSxNQUFULENBQWdCOUQsU0FBaEIsRUFBMkI7QUFDakMsWUFBSTNFLFVBQVUsQ0FBQ3dDLFNBQVgsQ0FBcUJvQyxFQUFyQixDQUF3QixLQUF4QixDQUFKLEVBQW9DO0FBQ2xDLGlCQUFPLENBQUNELFNBQVI7QUFDRDs7QUFFRCxlQUFPQSxTQUFQO0FBQ0Q7QUFiSSxLQUFQO0FBZUQ7QUFFRDs7Ozs7Ozs7O0FBT0EsV0FBUytELEdBQVQsQ0FBYzNLLEtBQWQsRUFBcUJpQyxVQUFyQixFQUFpQztBQUMvQixXQUFPO0FBQ0w7Ozs7OztBQU1BeUksWUFBTSxFQUFFLFNBQVNBLE1BQVQsQ0FBZ0I5RCxTQUFoQixFQUEyQjtBQUNqQyxlQUFPQSxTQUFTLEdBQUczRSxVQUFVLENBQUNxQyxJQUFYLENBQWdCMUgsS0FBaEIsR0FBd0JvRCxLQUFLLENBQUNQLEtBQWpEO0FBQ0Q7QUFUSSxLQUFQO0FBV0Q7QUFFRDs7Ozs7Ozs7O0FBT0EsV0FBU21MLElBQVQsQ0FBZTVLLEtBQWYsRUFBc0JpQyxVQUF0QixFQUFrQztBQUNoQyxXQUFPO0FBQ0w7Ozs7OztBQU1BeUksWUFBTSxFQUFFLFNBQVNBLE1BQVQsQ0FBZ0I5RCxTQUFoQixFQUEyQjtBQUNqQyxlQUFPQSxTQUFTLEdBQUczRSxVQUFVLENBQUNvRixNQUFYLENBQWtCRCxJQUFsQixHQUF5QixDQUE1QztBQUNEO0FBVEksS0FBUDtBQVdEO0FBRUQ7Ozs7Ozs7OztBQU9BLFdBQVN5RCxPQUFULENBQWtCN0ssS0FBbEIsRUFBeUJpQyxVQUF6QixFQUFxQztBQUNuQyxXQUFPO0FBQ0w7Ozs7OztBQU1BeUksWUFBTSxFQUFFLFNBQVNBLE1BQVQsQ0FBZ0I5RCxTQUFoQixFQUEyQjtBQUNqQyxZQUFJNUcsS0FBSyxDQUFDZCxRQUFOLENBQWVqSCxPQUFmLElBQTBCLENBQTlCLEVBQWlDO0FBQy9CLGNBQUlpQixJQUFJLEdBQUcrSSxVQUFVLENBQUNxRSxJQUFYLENBQWdCMUosS0FBM0I7O0FBRUEsY0FBSWdCLFFBQVEsQ0FBQzFFLElBQUQsQ0FBWixFQUFvQjtBQUNsQixtQkFBTzBOLFNBQVMsR0FBRzFOLElBQUksQ0FBQ3NOLE1BQXhCO0FBQ0Q7O0FBRUQsaUJBQU9JLFNBQVMsR0FBRzFOLElBQW5CO0FBQ0Q7O0FBRUQsZUFBTzBOLFNBQVA7QUFDRDtBQW5CSSxLQUFQO0FBcUJEO0FBRUQ7Ozs7Ozs7OztBQU9BLFdBQVNrRSxRQUFULENBQW1COUssS0FBbkIsRUFBMEJpQyxVQUExQixFQUFzQztBQUNwQyxXQUFPO0FBQ0w7Ozs7OztBQU1BeUksWUFBTSxFQUFFLFNBQVNBLE1BQVQsQ0FBZ0I5RCxTQUFoQixFQUEyQjtBQUNqQyxZQUFJMU8sR0FBRyxHQUFHK0osVUFBVSxDQUFDcUMsSUFBWCxDQUFnQjFILEtBQTFCO0FBQ0EsWUFBSW1LLEtBQUssR0FBRzlFLFVBQVUsQ0FBQzJDLEtBQVgsQ0FBaUJtQyxLQUE3QjtBQUNBLFlBQUk5TyxPQUFPLEdBQUcrSCxLQUFLLENBQUNkLFFBQU4sQ0FBZWpILE9BQTdCO0FBQ0EsWUFBSTBPLFVBQVUsR0FBRzFFLFVBQVUsQ0FBQzJDLEtBQVgsQ0FBaUIrQixVQUFsQzs7QUFFQSxZQUFJMU8sT0FBTyxLQUFLLFFBQWhCLEVBQTBCO0FBQ3hCLGlCQUFPMk8sU0FBUyxJQUFJRyxLQUFLLEdBQUcsQ0FBUixHQUFZSixVQUFVLEdBQUcsQ0FBN0IsQ0FBaEI7QUFDRDs7QUFFRCxlQUFPQyxTQUFTLEdBQUdELFVBQVUsR0FBRzFPLE9BQXpCLEdBQW1DQyxHQUFHLEdBQUdELE9BQWhEO0FBQ0Q7QUFsQkksS0FBUDtBQW9CRDtBQUVEOzs7Ozs7Ozs7QUFPQSxXQUFTOFMsT0FBVCxDQUFrQi9LLEtBQWxCLEVBQXlCaUMsVUFBekIsRUFBcUNDLE1BQXJDLEVBQTZDO0FBQzNDOzs7Ozs7O0FBT0EsUUFBSThJLFlBQVksR0FBRyxDQUFDTCxHQUFELEVBQU1DLElBQU4sRUFBWUMsT0FBWixFQUFxQkMsUUFBckIsRUFBK0JHLE1BQS9CLENBQXNDakwsS0FBSyxDQUFDRyxFQUE1QyxFQUFnRCxDQUFDc0ssR0FBRCxDQUFoRCxDQUFuQjtBQUVBLFdBQU87QUFDTDs7Ozs7O0FBTUFsSyxZQUFNLEVBQUUsU0FBU0EsTUFBVCxDQUFnQnFHLFNBQWhCLEVBQTJCO0FBQ2pDLGFBQUssSUFBSTNMLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcrUCxZQUFZLENBQUM5UCxNQUFqQyxFQUF5Q0QsQ0FBQyxFQUExQyxFQUE4QztBQUM1QyxjQUFJaVEsV0FBVyxHQUFHRixZQUFZLENBQUMvUCxDQUFELENBQTlCOztBQUVBLGNBQUk2QyxVQUFVLENBQUNvTixXQUFELENBQVYsSUFBMkJwTixVQUFVLENBQUNvTixXQUFXLEdBQUdSLE1BQWYsQ0FBekMsRUFBaUU7QUFDL0Q5RCxxQkFBUyxHQUFHc0UsV0FBVyxDQUFDbEwsS0FBRCxFQUFRaUMsVUFBUixFQUFvQkMsTUFBcEIsQ0FBWCxDQUF1Q3dJLE1BQXZDLENBQThDOUQsU0FBOUMsQ0FBWjtBQUNELFdBRkQsTUFFTztBQUNMN00sZ0JBQUksQ0FBQyxnRkFBRCxDQUFKO0FBQ0Q7QUFDRjs7QUFFRCxlQUFPNk0sU0FBUDtBQUNEO0FBbkJJLEtBQVA7QUFxQkQ7O0FBRUQsV0FBU3VFLFNBQVQsQ0FBb0JuTCxLQUFwQixFQUEyQmlDLFVBQTNCLEVBQXVDQyxNQUF2QyxFQUErQztBQUM3QyxRQUFJaUosU0FBUyxHQUFHO0FBQ2Q7Ozs7OztBQU1BeEosU0FBRyxFQUFFLFNBQVNBLEdBQVQsQ0FBYS9FLEtBQWIsRUFBb0I7QUFDdkIsWUFBSXdPLFNBQVMsR0FBR0wsT0FBTyxDQUFDL0ssS0FBRCxFQUFRaUMsVUFBUixDQUFQLENBQTJCMUIsTUFBM0IsQ0FBa0MzRCxLQUFsQyxDQUFoQjtBQUVBcUYsa0JBQVUsQ0FBQ2UsSUFBWCxDQUFnQjZCLE9BQWhCLENBQXdCTCxLQUF4QixDQUE4QjRHLFNBQTlCLEdBQTBDLGlCQUFpQixDQUFDLENBQUQsR0FBS0EsU0FBdEIsR0FBa0MsZUFBNUU7QUFDRCxPQVhhOztBQWNkOzs7OztBQUtBekwsWUFBTSxFQUFFLFNBQVNBLE1BQVQsR0FBa0I7QUFDeEJzQyxrQkFBVSxDQUFDZSxJQUFYLENBQWdCNkIsT0FBaEIsQ0FBd0JMLEtBQXhCLENBQThCNEcsU0FBOUIsR0FBMEMsRUFBMUM7QUFDRDtBQXJCYSxLQUFoQjtBQXdCQTs7Ozs7O0FBS0FsSixVQUFNLENBQUM1QyxFQUFQLENBQVUsTUFBVixFQUFrQixVQUFVTyxPQUFWLEVBQW1CO0FBQ25DLFVBQUkzSCxHQUFHLEdBQUcrSixVQUFVLENBQUNxQyxJQUFYLENBQWdCMUgsS0FBMUI7QUFDQSxVQUFJMUIsTUFBTSxHQUFHK0csVUFBVSxDQUFDMkMsS0FBWCxDQUFpQjFKLE1BQTlCO0FBQ0EsVUFBSTZMLEtBQUssR0FBRzlFLFVBQVUsQ0FBQzJDLEtBQVgsQ0FBaUIrQixVQUE3Qjs7QUFFQSxVQUFJM0csS0FBSyxDQUFDd0IsTUFBTixDQUFhLFVBQWIsS0FBNEJTLFVBQVUsQ0FBQ3JCLEdBQVgsQ0FBZTRCLFFBQWYsQ0FBd0IsR0FBeEIsQ0FBaEMsRUFBOEQ7QUFDNURQLGtCQUFVLENBQUNqQixVQUFYLENBQXNCcUIsS0FBdEIsQ0FBNEIsWUFBWTtBQUN0Q0gsZ0JBQU0sQ0FBQ3RDLElBQVAsQ0FBWSxnQkFBWjtBQUVBdUwsbUJBQVMsQ0FBQ3hKLEdBQVYsQ0FBY29GLEtBQUssSUFBSTdMLE1BQU0sR0FBRyxDQUFiLENBQW5CO0FBQ0QsU0FKRDtBQU1BLGVBQU9pUSxTQUFTLENBQUN4SixHQUFWLENBQWMsQ0FBQ29GLEtBQUQsR0FBUzdPLEdBQUcsR0FBR2dELE1BQTdCLENBQVA7QUFDRDs7QUFFRCxVQUFJOEUsS0FBSyxDQUFDd0IsTUFBTixDQUFhLFVBQWIsS0FBNEJTLFVBQVUsQ0FBQ3JCLEdBQVgsQ0FBZTRCLFFBQWYsQ0FBd0IsR0FBeEIsQ0FBaEMsRUFBOEQ7QUFDNURQLGtCQUFVLENBQUNqQixVQUFYLENBQXNCcUIsS0FBdEIsQ0FBNEIsWUFBWTtBQUN0Q0gsZ0JBQU0sQ0FBQ3RDLElBQVAsQ0FBWSxnQkFBWjtBQUVBdUwsbUJBQVMsQ0FBQ3hKLEdBQVYsQ0FBYyxDQUFkO0FBQ0QsU0FKRDtBQU1BLGVBQU93SixTQUFTLENBQUN4SixHQUFWLENBQWNvRixLQUFLLEdBQUc3TCxNQUFSLEdBQWlCaEQsR0FBRyxHQUFHZ0QsTUFBckMsQ0FBUDtBQUNEOztBQUVELGFBQU9pUSxTQUFTLENBQUN4SixHQUFWLENBQWM5QixPQUFPLENBQUM2RyxRQUF0QixDQUFQO0FBQ0QsS0ExQkQ7QUE0QkE7Ozs7O0FBSUF4RSxVQUFNLENBQUM1QyxFQUFQLENBQVUsU0FBVixFQUFxQixZQUFZO0FBQy9CNkwsZUFBUyxDQUFDeEwsTUFBVjtBQUNELEtBRkQ7QUFJQSxXQUFPd0wsU0FBUDtBQUNEOztBQUVELFdBQVNuSyxVQUFULENBQXFCaEIsS0FBckIsRUFBNEJpQyxVQUE1QixFQUF3Q0MsTUFBeEMsRUFBZ0Q7QUFDOUM7Ozs7OztBQU1BLFFBQUk3QixRQUFRLEdBQUcsS0FBZjtBQUVBLFFBQUlXLFVBQVUsR0FBRztBQUNmOzs7Ozs7QUFNQXFLLGFBQU8sRUFBRSxTQUFTQSxPQUFULENBQWlCalAsUUFBakIsRUFBMkI7QUFDbEMsWUFBSThDLFFBQVEsR0FBR2MsS0FBSyxDQUFDZCxRQUFyQjs7QUFFQSxZQUFJLENBQUNtQixRQUFMLEVBQWU7QUFDYixpQkFBT2pFLFFBQVEsR0FBRyxHQUFYLEdBQWlCLEtBQUtrUCxRQUF0QixHQUFpQyxLQUFqQyxHQUF5Q3BNLFFBQVEsQ0FBQ25HLG1CQUF6RDtBQUNEOztBQUVELGVBQU9xRCxRQUFRLEdBQUcsT0FBWCxHQUFxQjhDLFFBQVEsQ0FBQ25HLG1CQUFyQztBQUNELE9BZmM7O0FBa0JmOzs7Ozs7QUFNQTRJLFNBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsWUFBSXZGLFFBQVEsR0FBR04sU0FBUyxDQUFDWixNQUFWLEdBQW1CLENBQW5CLElBQXdCWSxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCVyxTQUF6QyxHQUFxRFgsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsV0FBbkY7QUFFQW1HLGtCQUFVLENBQUNlLElBQVgsQ0FBZ0I2QixPQUFoQixDQUF3QkwsS0FBeEIsQ0FBOEIrRyxVQUE5QixHQUEyQyxLQUFLRixPQUFMLENBQWFqUCxRQUFiLENBQTNDO0FBQ0QsT0E1QmM7O0FBK0JmOzs7OztBQUtBdUQsWUFBTSxFQUFFLFNBQVNBLE1BQVQsR0FBa0I7QUFDeEJzQyxrQkFBVSxDQUFDZSxJQUFYLENBQWdCNkIsT0FBaEIsQ0FBd0JMLEtBQXhCLENBQThCK0csVUFBOUIsR0FBMkMsRUFBM0M7QUFDRCxPQXRDYzs7QUF5Q2Y7Ozs7OztBQU1BbEosV0FBSyxFQUFFLFNBQVNBLEtBQVQsQ0FBZW1KLFFBQWYsRUFBeUI7QUFDOUJySCxrQkFBVSxDQUFDLFlBQVk7QUFDckJxSCxrQkFBUTtBQUNULFNBRlMsRUFFUCxLQUFLRixRQUZFLENBQVY7QUFHRCxPQW5EYzs7QUFzRGY7Ozs7O0FBS0EvSixZQUFNLEVBQUUsU0FBU0EsTUFBVCxHQUFrQjtBQUN4QmxCLGdCQUFRLEdBQUcsS0FBWDtBQUVBLGFBQUtzQixHQUFMO0FBQ0QsT0EvRGM7O0FBa0VmOzs7OztBQUtBVixhQUFPLEVBQUUsU0FBU0EsT0FBVCxHQUFtQjtBQUMxQlosZ0JBQVEsR0FBRyxJQUFYO0FBRUEsYUFBS3NCLEdBQUw7QUFDRDtBQTNFYyxLQUFqQjtBQThFQS9KLFVBQU0sQ0FBQ29KLFVBQUQsRUFBYSxVQUFiLEVBQXlCO0FBQzdCOzs7Ozs7QUFNQTlFLFNBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsWUFBSWdELFFBQVEsR0FBR2MsS0FBSyxDQUFDZCxRQUFyQjs7QUFFQSxZQUFJYyxLQUFLLENBQUN3QixNQUFOLENBQWEsUUFBYixLQUEwQlMsVUFBVSxDQUFDckIsR0FBWCxDQUFlNkYsTUFBN0MsRUFBcUQ7QUFDbkQsaUJBQU92SCxRQUFRLENBQUNwRyxjQUFoQjtBQUNEOztBQUVELGVBQU9vRyxRQUFRLENBQUN0RyxpQkFBaEI7QUFDRDtBQWY0QixLQUF6QixDQUFOO0FBa0JBOzs7OztBQUlBc0osVUFBTSxDQUFDNUMsRUFBUCxDQUFVLE1BQVYsRUFBa0IsWUFBWTtBQUM1QjBCLGdCQUFVLENBQUNXLEdBQVg7QUFDRCxLQUZEO0FBSUE7Ozs7Ozs7QUFNQU8sVUFBTSxDQUFDNUMsRUFBUCxDQUFVLENBQUMsY0FBRCxFQUFpQixRQUFqQixFQUEyQixnQkFBM0IsQ0FBVixFQUF3RCxZQUFZO0FBQ2xFMEIsZ0JBQVUsQ0FBQ0MsT0FBWDtBQUNELEtBRkQ7QUFJQTs7Ozs7QUFJQWlCLFVBQU0sQ0FBQzVDLEVBQVAsQ0FBVSxLQUFWLEVBQWlCLFlBQVk7QUFDM0IwQixnQkFBVSxDQUFDTyxNQUFYO0FBQ0QsS0FGRDtBQUlBOzs7OztBQUlBVyxVQUFNLENBQUM1QyxFQUFQLENBQVUsU0FBVixFQUFxQixZQUFZO0FBQy9CMEIsZ0JBQVUsQ0FBQ3JCLE1BQVg7QUFDRCxLQUZEO0FBSUEsV0FBT3FCLFVBQVA7QUFDRDtBQUVEOzs7Ozs7OztBQU9BLE1BQUl5SyxlQUFlLEdBQUcsS0FBdEI7O0FBRUEsTUFBSTtBQUNGLFFBQUlDLElBQUksR0FBR25RLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQixFQUF0QixFQUEwQixTQUExQixFQUFxQztBQUM5Q1UsU0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQnVQLHVCQUFlLEdBQUcsSUFBbEI7QUFDRDtBQUg2QyxLQUFyQyxDQUFYO0FBTUFqRyxVQUFNLENBQUNpRSxnQkFBUCxDQUF3QixhQUF4QixFQUF1QyxJQUF2QyxFQUE2Q2lDLElBQTdDO0FBQ0FsRyxVQUFNLENBQUNtRSxtQkFBUCxDQUEyQixhQUEzQixFQUEwQyxJQUExQyxFQUFnRCtCLElBQWhEO0FBQ0QsR0FURCxDQVNFLE9BQU9DLENBQVAsRUFBVSxDQUFFOztBQUVkLE1BQUlDLGlCQUFpQixHQUFHSCxlQUF4QjtBQUVBLE1BQUlJLFlBQVksR0FBRyxDQUFDLFlBQUQsRUFBZSxXQUFmLENBQW5CO0FBQ0EsTUFBSUMsV0FBVyxHQUFHLENBQUMsV0FBRCxFQUFjLFdBQWQsQ0FBbEI7QUFDQSxNQUFJQyxVQUFVLEdBQUcsQ0FBQyxVQUFELEVBQWEsYUFBYixFQUE0QixTQUE1QixFQUF1QyxZQUF2QyxDQUFqQjtBQUNBLE1BQUlDLFlBQVksR0FBRyxDQUFDLFdBQUQsRUFBYyxXQUFkLEVBQTJCLFNBQTNCLEVBQXNDLFlBQXRDLENBQW5COztBQUVBLFdBQVNDLEtBQVQsQ0FBZ0JqTSxLQUFoQixFQUF1QmlDLFVBQXZCLEVBQW1DQyxNQUFuQyxFQUEyQztBQUN6Qzs7Ozs7QUFLQSxRQUFJMkgsTUFBTSxHQUFHLElBQUlULFlBQUosRUFBYjtBQUVBLFFBQUk4QyxRQUFRLEdBQUcsQ0FBZjtBQUNBLFFBQUlDLFdBQVcsR0FBRyxDQUFsQjtBQUNBLFFBQUlDLFdBQVcsR0FBRyxDQUFsQjtBQUNBLFFBQUkvTCxRQUFRLEdBQUcsS0FBZjtBQUNBLFFBQUltSixPQUFPLEdBQUdvQyxpQkFBaUIsR0FBRztBQUFFUyxhQUFPLEVBQUU7QUFBWCxLQUFILEdBQXVCLEtBQXREO0FBRUEsUUFBSUosS0FBSyxHQUFHO0FBQ1Y7Ozs7O0FBS0EvTixXQUFLLEVBQUUsU0FBU0EsS0FBVCxHQUFpQjtBQUN0QixhQUFLb08sY0FBTDtBQUNELE9BUlM7O0FBV1Y7Ozs7OztBQU1BcEUsV0FBSyxFQUFFLFNBQVNBLEtBQVQsQ0FBZTNJLEtBQWYsRUFBc0I7QUFDM0IsWUFBSSxDQUFDYyxRQUFELElBQWEsQ0FBQ0wsS0FBSyxDQUFDSyxRQUF4QixFQUFrQztBQUNoQyxlQUFLWSxPQUFMO0FBRUEsY0FBSXNMLEtBQUssR0FBRyxLQUFLQyxPQUFMLENBQWFqTixLQUFiLENBQVo7QUFFQTJNLGtCQUFRLEdBQUcsSUFBWDtBQUNBQyxxQkFBVyxHQUFHNU8sS0FBSyxDQUFDZ1AsS0FBSyxDQUFDRSxLQUFQLENBQW5CO0FBQ0FMLHFCQUFXLEdBQUc3TyxLQUFLLENBQUNnUCxLQUFLLENBQUNHLEtBQVAsQ0FBbkI7QUFFQSxlQUFLQyxhQUFMO0FBQ0EsZUFBS0MsWUFBTDtBQUVBMUssZ0JBQU0sQ0FBQ3RDLElBQVAsQ0FBWSxhQUFaO0FBQ0Q7QUFDRixPQWhDUzs7QUFtQ1Y7Ozs7O0FBS0FrQixVQUFJLEVBQUUsU0FBU0EsSUFBVCxDQUFjdkIsS0FBZCxFQUFxQjtBQUN6QixZQUFJLENBQUNTLEtBQUssQ0FBQ0ssUUFBWCxFQUFxQjtBQUNuQixjQUFJMEgsZUFBZSxHQUFHL0gsS0FBSyxDQUFDZCxRQUE1QjtBQUFBLGNBQ0l2RyxVQUFVLEdBQUdvUCxlQUFlLENBQUNwUCxVQURqQztBQUFBLGNBRUlELFVBQVUsR0FBR3FQLGVBQWUsQ0FBQ3JQLFVBRmpDO0FBQUEsY0FHSVUsT0FBTyxHQUFHMk8sZUFBZSxDQUFDM08sT0FIOUI7QUFNQSxjQUFJbVQsS0FBSyxHQUFHLEtBQUtDLE9BQUwsQ0FBYWpOLEtBQWIsQ0FBWjtBQUVBLGNBQUlzTixPQUFPLEdBQUd0UCxLQUFLLENBQUNnUCxLQUFLLENBQUNFLEtBQVAsQ0FBTCxHQUFxQk4sV0FBbkM7QUFDQSxjQUFJVyxPQUFPLEdBQUd2UCxLQUFLLENBQUNnUCxLQUFLLENBQUNHLEtBQVAsQ0FBTCxHQUFxQk4sV0FBbkM7QUFDQSxjQUFJVyxLQUFLLEdBQUdwSyxJQUFJLENBQUNxSyxHQUFMLENBQVNILE9BQU8sSUFBSSxDQUFwQixDQUFaO0FBQ0EsY0FBSUksS0FBSyxHQUFHdEssSUFBSSxDQUFDcUssR0FBTCxDQUFTRixPQUFPLElBQUksQ0FBcEIsQ0FBWjtBQUNBLGNBQUlJLGVBQWUsR0FBR3ZLLElBQUksQ0FBQ3dLLElBQUwsQ0FBVUosS0FBSyxHQUFHRSxLQUFsQixDQUF0QjtBQUNBLGNBQUlHLGFBQWEsR0FBR3pLLElBQUksQ0FBQ3dLLElBQUwsQ0FBVUYsS0FBVixDQUFwQjtBQUVBZixrQkFBUSxHQUFHdkosSUFBSSxDQUFDMEssSUFBTCxDQUFVRCxhQUFhLEdBQUdGLGVBQTFCLENBQVg7O0FBRUEsY0FBSWhCLFFBQVEsR0FBRyxHQUFYLEdBQWlCdkosSUFBSSxDQUFDMkssRUFBdEIsR0FBMkIzVSxVQUEvQixFQUEyQztBQUN6QzRHLGlCQUFLLENBQUNnTyxlQUFOO0FBRUF0TCxzQkFBVSxDQUFDZixJQUFYLENBQWdCTCxJQUFoQixDQUFxQmdNLE9BQU8sR0FBR3BQLE9BQU8sQ0FBQy9FLFVBQUQsQ0FBdEM7QUFFQXVKLHNCQUFVLENBQUNlLElBQVgsQ0FBZ0IyQyxJQUFoQixDQUFxQk0sU0FBckIsQ0FBK0J5QixHQUEvQixDQUFtQ3RPLE9BQU8sQ0FBQ00sUUFBM0M7QUFFQXdJLGtCQUFNLENBQUN0QyxJQUFQLENBQVksWUFBWjtBQUNELFdBUkQsTUFRTztBQUNMLG1CQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0YsT0F2RVM7O0FBMEVWOzs7Ozs7QUFNQXVJLFNBQUcsRUFBRSxTQUFTQSxHQUFULENBQWE1SSxLQUFiLEVBQW9CO0FBQ3ZCLFlBQUksQ0FBQ1MsS0FBSyxDQUFDSyxRQUFYLEVBQXFCO0FBQ25CLGNBQUluQixRQUFRLEdBQUdjLEtBQUssQ0FBQ2QsUUFBckI7QUFFQSxjQUFJcU4sS0FBSyxHQUFHLEtBQUtDLE9BQUwsQ0FBYWpOLEtBQWIsQ0FBWjtBQUNBLGNBQUlpTyxTQUFTLEdBQUcsS0FBS0EsU0FBTCxDQUFlak8sS0FBZixDQUFoQjtBQUVBLGNBQUlrTyxhQUFhLEdBQUdsQixLQUFLLENBQUNFLEtBQU4sR0FBY04sV0FBbEM7QUFDQSxjQUFJdUIsUUFBUSxHQUFHeEIsUUFBUSxHQUFHLEdBQVgsR0FBaUJ2SixJQUFJLENBQUMySyxFQUFyQztBQUNBLGNBQUk3SyxLQUFLLEdBQUdFLElBQUksQ0FBQ2dMLEtBQUwsQ0FBV0YsYUFBYSxHQUFHeEwsVUFBVSxDQUFDMkMsS0FBWCxDQUFpQitCLFVBQTVDLENBQVo7QUFFQSxlQUFLcEYsTUFBTDs7QUFFQSxjQUFJa00sYUFBYSxHQUFHRCxTQUFoQixJQUE2QkUsUUFBUSxHQUFHeE8sUUFBUSxDQUFDdkcsVUFBckQsRUFBaUU7QUFDL0Q7QUFDQSxnQkFBSXVHLFFBQVEsQ0FBQ3pHLFFBQWIsRUFBdUI7QUFDckJnSyxtQkFBSyxHQUFHRSxJQUFJLENBQUNDLEdBQUwsQ0FBU0gsS0FBVCxFQUFnQmxGLEtBQUssQ0FBQzJCLFFBQVEsQ0FBQ3pHLFFBQVYsQ0FBckIsQ0FBUjtBQUNEOztBQUVELGdCQUFJd0osVUFBVSxDQUFDd0MsU0FBWCxDQUFxQm9DLEVBQXJCLENBQXdCLEtBQXhCLENBQUosRUFBb0M7QUFDbENwRSxtQkFBSyxHQUFHLENBQUNBLEtBQVQ7QUFDRDs7QUFFRFIsc0JBQVUsQ0FBQ3JCLEdBQVgsQ0FBZUMsSUFBZixDQUFvQm9CLFVBQVUsQ0FBQ3dDLFNBQVgsQ0FBcUJ5RixPQUFyQixDQUE2QixNQUFNekgsS0FBbkMsQ0FBcEI7QUFDRCxXQVhELE1BV08sSUFBSWdMLGFBQWEsR0FBRyxDQUFDRCxTQUFqQixJQUE4QkUsUUFBUSxHQUFHeE8sUUFBUSxDQUFDdkcsVUFBdEQsRUFBa0U7QUFDdkU7QUFDQSxnQkFBSXVHLFFBQVEsQ0FBQ3pHLFFBQWIsRUFBdUI7QUFDckJnSyxtQkFBSyxHQUFHRSxJQUFJLENBQUN5RixHQUFMLENBQVMzRixLQUFULEVBQWdCLENBQUNsRixLQUFLLENBQUMyQixRQUFRLENBQUN6RyxRQUFWLENBQXRCLENBQVI7QUFDRDs7QUFFRCxnQkFBSXdKLFVBQVUsQ0FBQ3dDLFNBQVgsQ0FBcUJvQyxFQUFyQixDQUF3QixLQUF4QixDQUFKLEVBQW9DO0FBQ2xDcEUsbUJBQUssR0FBRyxDQUFDQSxLQUFUO0FBQ0Q7O0FBRURSLHNCQUFVLENBQUNyQixHQUFYLENBQWVDLElBQWYsQ0FBb0JvQixVQUFVLENBQUN3QyxTQUFYLENBQXFCeUYsT0FBckIsQ0FBNkIsTUFBTXpILEtBQW5DLENBQXBCO0FBQ0QsV0FYTSxNQVdBO0FBQ0w7QUFDQVIsc0JBQVUsQ0FBQ2YsSUFBWCxDQUFnQkwsSUFBaEI7QUFDRDs7QUFFRG9CLG9CQUFVLENBQUNlLElBQVgsQ0FBZ0IyQyxJQUFoQixDQUFxQk0sU0FBckIsQ0FBK0J0RyxNQUEvQixDQUFzQ1QsUUFBUSxDQUFDOUYsT0FBVCxDQUFpQk0sUUFBdkQ7QUFFQSxlQUFLa1UsZUFBTDtBQUNBLGVBQUtDLGNBQUw7QUFFQTNMLGdCQUFNLENBQUN0QyxJQUFQLENBQVksV0FBWjtBQUNEO0FBQ0YsT0EvSFM7O0FBa0lWOzs7OztBQUtBME0sb0JBQWMsRUFBRSxTQUFTQSxjQUFULEdBQTBCO0FBQ3hDLFlBQUluSyxLQUFLLEdBQUcsSUFBWjs7QUFFQSxZQUFJakQsUUFBUSxHQUFHYyxLQUFLLENBQUNkLFFBQXJCOztBQUVBLFlBQUlBLFFBQVEsQ0FBQzNHLGNBQWIsRUFBNkI7QUFDM0JzUixnQkFBTSxDQUFDdkssRUFBUCxDQUFVdU0sWUFBWSxDQUFDLENBQUQsQ0FBdEIsRUFBMkI1SixVQUFVLENBQUNlLElBQVgsQ0FBZ0I2QixPQUEzQyxFQUFvRCxVQUFVdEYsS0FBVixFQUFpQjtBQUNuRTRDLGlCQUFLLENBQUMrRixLQUFOLENBQVkzSSxLQUFaO0FBQ0QsV0FGRCxFQUVHaUssT0FGSDtBQUdEOztBQUVELFlBQUl0SyxRQUFRLENBQUMxRyxhQUFiLEVBQTRCO0FBQzFCcVIsZ0JBQU0sQ0FBQ3ZLLEVBQVAsQ0FBVXVNLFlBQVksQ0FBQyxDQUFELENBQXRCLEVBQTJCNUosVUFBVSxDQUFDZSxJQUFYLENBQWdCNkIsT0FBM0MsRUFBb0QsVUFBVXRGLEtBQVYsRUFBaUI7QUFDbkU0QyxpQkFBSyxDQUFDK0YsS0FBTixDQUFZM0ksS0FBWjtBQUNELFdBRkQsRUFFR2lLLE9BRkg7QUFHRDtBQUNGLE9BdkpTOztBQTBKVjs7Ozs7QUFLQXNFLHNCQUFnQixFQUFFLFNBQVNBLGdCQUFULEdBQTRCO0FBQzVDakUsY0FBTSxDQUFDSCxHQUFQLENBQVdtQyxZQUFZLENBQUMsQ0FBRCxDQUF2QixFQUE0QjVKLFVBQVUsQ0FBQ2UsSUFBWCxDQUFnQjZCLE9BQTVDLEVBQXFEMkUsT0FBckQ7QUFDQUssY0FBTSxDQUFDSCxHQUFQLENBQVdtQyxZQUFZLENBQUMsQ0FBRCxDQUF2QixFQUE0QjVKLFVBQVUsQ0FBQ2UsSUFBWCxDQUFnQjZCLE9BQTVDLEVBQXFEMkUsT0FBckQ7QUFDRCxPQWxLUzs7QUFxS1Y7Ozs7O0FBS0FtRCxtQkFBYSxFQUFFLFNBQVNBLGFBQVQsR0FBeUI7QUFDdEMsWUFBSW9CLE1BQU0sR0FBRyxJQUFiOztBQUVBbEUsY0FBTSxDQUFDdkssRUFBUCxDQUFVd00sV0FBVixFQUF1QjdKLFVBQVUsQ0FBQ2UsSUFBWCxDQUFnQjZCLE9BQXZDLEVBQWdEN0wsUUFBUSxDQUFDLFVBQVV1RyxLQUFWLEVBQWlCO0FBQ3hFd08sZ0JBQU0sQ0FBQ2pOLElBQVAsQ0FBWXZCLEtBQVo7QUFDRCxTQUZ1RCxFQUVyRFMsS0FBSyxDQUFDZCxRQUFOLENBQWVsRyxRQUZzQyxDQUF4RCxFQUU2QndRLE9BRjdCO0FBR0QsT0FoTFM7O0FBbUxWOzs7OztBQUtBb0UscUJBQWUsRUFBRSxTQUFTQSxlQUFULEdBQTJCO0FBQzFDL0QsY0FBTSxDQUFDSCxHQUFQLENBQVdvQyxXQUFYLEVBQXdCN0osVUFBVSxDQUFDZSxJQUFYLENBQWdCNkIsT0FBeEMsRUFBaUQyRSxPQUFqRDtBQUNELE9BMUxTOztBQTZMVjs7Ozs7QUFLQW9ELGtCQUFZLEVBQUUsU0FBU0EsWUFBVCxHQUF3QjtBQUNwQyxZQUFJb0IsTUFBTSxHQUFHLElBQWI7O0FBRUFuRSxjQUFNLENBQUN2SyxFQUFQLENBQVV5TSxVQUFWLEVBQXNCOUosVUFBVSxDQUFDZSxJQUFYLENBQWdCNkIsT0FBdEMsRUFBK0MsVUFBVXRGLEtBQVYsRUFBaUI7QUFDOUR5TyxnQkFBTSxDQUFDN0YsR0FBUCxDQUFXNUksS0FBWDtBQUNELFNBRkQ7QUFHRCxPQXhNUzs7QUEyTVY7Ozs7O0FBS0FzTyxvQkFBYyxFQUFFLFNBQVNBLGNBQVQsR0FBMEI7QUFDeENoRSxjQUFNLENBQUNILEdBQVAsQ0FBV3FDLFVBQVgsRUFBdUI5SixVQUFVLENBQUNlLElBQVgsQ0FBZ0I2QixPQUF2QztBQUNELE9BbE5TOztBQXFOVjs7Ozs7QUFLQTJILGFBQU8sRUFBRSxTQUFTQSxPQUFULENBQWlCak4sS0FBakIsRUFBd0I7QUFDL0IsWUFBSXlNLFlBQVksQ0FBQ3hCLE9BQWIsQ0FBcUJqTCxLQUFLLENBQUN6SCxJQUEzQixJQUFtQyxDQUFDLENBQXhDLEVBQTJDO0FBQ3pDLGlCQUFPeUgsS0FBUDtBQUNEOztBQUVELGVBQU9BLEtBQUssQ0FBQ2lOLE9BQU4sQ0FBYyxDQUFkLEtBQW9Cak4sS0FBSyxDQUFDME8sY0FBTixDQUFxQixDQUFyQixDQUEzQjtBQUNELE9BaE9TOztBQW1PVjs7Ozs7QUFLQVQsZUFBUyxFQUFFLFNBQVNBLFNBQVQsQ0FBbUJqTyxLQUFuQixFQUEwQjtBQUNuQyxZQUFJTCxRQUFRLEdBQUdjLEtBQUssQ0FBQ2QsUUFBckI7O0FBRUEsWUFBSThNLFlBQVksQ0FBQ3hCLE9BQWIsQ0FBcUJqTCxLQUFLLENBQUN6SCxJQUEzQixJQUFtQyxDQUFDLENBQXhDLEVBQTJDO0FBQ3pDLGlCQUFPb0gsUUFBUSxDQUFDMUcsYUFBaEI7QUFDRDs7QUFFRCxlQUFPMEcsUUFBUSxDQUFDM0csY0FBaEI7QUFDRCxPQWhQUzs7QUFtUFY7Ozs7O0FBS0FnSixZQUFNLEVBQUUsU0FBU0EsTUFBVCxHQUFrQjtBQUN4QmxCLGdCQUFRLEdBQUcsS0FBWDtBQUVBNEIsa0JBQVUsQ0FBQ2pCLFVBQVgsQ0FBc0JPLE1BQXRCO0FBRUEsZUFBTyxJQUFQO0FBQ0QsT0E5UFM7O0FBaVFWOzs7OztBQUtBTixhQUFPLEVBQUUsU0FBU0EsT0FBVCxHQUFtQjtBQUMxQlosZ0JBQVEsR0FBRyxJQUFYO0FBRUE0QixrQkFBVSxDQUFDakIsVUFBWCxDQUFzQkMsT0FBdEI7QUFFQSxlQUFPLElBQVA7QUFDRDtBQTVRUyxLQUFaO0FBK1FBOzs7OztBQUlBaUIsVUFBTSxDQUFDNUMsRUFBUCxDQUFVLGFBQVYsRUFBeUIsWUFBWTtBQUNuQzJDLGdCQUFVLENBQUNlLElBQVgsQ0FBZ0IyQyxJQUFoQixDQUFxQk0sU0FBckIsQ0FBK0J5QixHQUEvQixDQUFtQzFILEtBQUssQ0FBQ2QsUUFBTixDQUFlOUYsT0FBZixDQUF1QkssU0FBMUQ7QUFDRCxLQUZEO0FBSUE7Ozs7O0FBSUF5SSxVQUFNLENBQUM1QyxFQUFQLENBQVUsU0FBVixFQUFxQixZQUFZO0FBQy9CMk0sV0FBSyxDQUFDNkIsZ0JBQU47QUFDQTdCLFdBQUssQ0FBQzJCLGVBQU47QUFDQTNCLFdBQUssQ0FBQzRCLGNBQU47QUFDQWhFLFlBQU0sQ0FBQzFJLE9BQVA7QUFDRCxLQUxEO0FBT0EsV0FBTzhLLEtBQVA7QUFDRDs7QUFFRCxXQUFTaUMsTUFBVCxDQUFpQmxPLEtBQWpCLEVBQXdCaUMsVUFBeEIsRUFBb0NDLE1BQXBDLEVBQTRDO0FBQzFDOzs7OztBQUtBLFFBQUkySCxNQUFNLEdBQUcsSUFBSVQsWUFBSixFQUFiO0FBRUEsUUFBSThFLE1BQU0sR0FBRztBQUNYOzs7OztBQUtBaFEsV0FBSyxFQUFFLFNBQVNBLEtBQVQsR0FBaUI7QUFDdEIsYUFBSzRMLElBQUw7QUFDRCxPQVJVOztBQVdYOzs7OztBQUtBQSxVQUFJLEVBQUUsU0FBU0EsSUFBVCxHQUFnQjtBQUNwQkQsY0FBTSxDQUFDdkssRUFBUCxDQUFVLFdBQVYsRUFBdUIyQyxVQUFVLENBQUNlLElBQVgsQ0FBZ0I2QixPQUF2QyxFQUFnRCxLQUFLc0osU0FBckQ7QUFDRCxPQWxCVTs7QUFxQlg7Ozs7O0FBS0FwRSxZQUFNLEVBQUUsU0FBU0EsTUFBVCxHQUFrQjtBQUN4QkYsY0FBTSxDQUFDSCxHQUFQLENBQVcsV0FBWCxFQUF3QnpILFVBQVUsQ0FBQ2UsSUFBWCxDQUFnQjZCLE9BQXhDO0FBQ0QsT0E1QlU7O0FBK0JYOzs7OztBQUtBc0osZUFBUyxFQUFFLFNBQVNBLFNBQVQsQ0FBbUI1TyxLQUFuQixFQUEwQjtBQUNuQ0EsYUFBSyxDQUFDNk8sY0FBTjtBQUNEO0FBdENVLEtBQWI7QUF5Q0E7Ozs7O0FBSUFsTSxVQUFNLENBQUM1QyxFQUFQLENBQVUsU0FBVixFQUFxQixZQUFZO0FBQy9CNE8sWUFBTSxDQUFDbkUsTUFBUDtBQUNBRixZQUFNLENBQUMxSSxPQUFQO0FBQ0QsS0FIRDtBQUtBLFdBQU8rTSxNQUFQO0FBQ0Q7O0FBRUQsV0FBU0csT0FBVCxDQUFrQnJPLEtBQWxCLEVBQXlCaUMsVUFBekIsRUFBcUNDLE1BQXJDLEVBQTZDO0FBQzNDOzs7OztBQUtBLFFBQUkySCxNQUFNLEdBQUcsSUFBSVQsWUFBSixFQUFiO0FBRUE7Ozs7Ozs7O0FBT0EsUUFBSWtGLFFBQVEsR0FBRyxLQUFmO0FBRUE7Ozs7Ozs7O0FBT0EsUUFBSUMsU0FBUyxHQUFHLEtBQWhCO0FBRUEsUUFBSUYsT0FBTyxHQUFHO0FBQ1o7Ozs7O0FBS0FuUSxXQUFLLEVBQUUsU0FBU0EsS0FBVCxHQUFpQjtBQUN0Qjs7Ozs7O0FBTUEsYUFBS3NRLEVBQUwsR0FBVXZNLFVBQVUsQ0FBQ2UsSUFBWCxDQUFnQjZCLE9BQWhCLENBQXdCNEosZ0JBQXhCLENBQXlDLEdBQXpDLENBQVY7QUFFQSxhQUFLM0UsSUFBTDtBQUNELE9BaEJXOztBQW1CWjs7Ozs7QUFLQUEsVUFBSSxFQUFFLFNBQVNBLElBQVQsR0FBZ0I7QUFDcEJELGNBQU0sQ0FBQ3ZLLEVBQVAsQ0FBVSxPQUFWLEVBQW1CMkMsVUFBVSxDQUFDZSxJQUFYLENBQWdCNkIsT0FBbkMsRUFBNEMsS0FBSzZKLEtBQWpEO0FBQ0QsT0ExQlc7O0FBNkJaOzs7OztBQUtBM0UsWUFBTSxFQUFFLFNBQVNBLE1BQVQsR0FBa0I7QUFDeEJGLGNBQU0sQ0FBQ0gsR0FBUCxDQUFXLE9BQVgsRUFBb0J6SCxVQUFVLENBQUNlLElBQVgsQ0FBZ0I2QixPQUFwQztBQUNELE9BcENXOztBQXVDWjs7Ozs7O0FBTUE2SixXQUFLLEVBQUUsU0FBU0EsS0FBVCxDQUFlblAsS0FBZixFQUFzQjtBQUMzQixZQUFJZ1AsU0FBSixFQUFlO0FBQ2JoUCxlQUFLLENBQUNnTyxlQUFOO0FBQ0FoTyxlQUFLLENBQUM2TyxjQUFOO0FBQ0Q7QUFDRixPQWxEVzs7QUFxRFo7Ozs7O0FBS0FPLFlBQU0sRUFBRSxTQUFTQSxNQUFULEdBQWtCO0FBQ3hCSixpQkFBUyxHQUFHLElBQVo7O0FBRUEsWUFBSSxDQUFDRCxRQUFMLEVBQWU7QUFDYixlQUFLLElBQUlyVCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUs0TSxLQUFMLENBQVczTSxNQUEvQixFQUF1Q0QsQ0FBQyxFQUF4QyxFQUE0QztBQUMxQyxpQkFBSzRNLEtBQUwsQ0FBVzVNLENBQVgsRUFBYzJULFNBQWQsR0FBMEIsS0FBMUI7QUFFQSxpQkFBSy9HLEtBQUwsQ0FBVzVNLENBQVgsRUFBYzRULFlBQWQsQ0FBMkIsV0FBM0IsRUFBd0MsS0FBS2hILEtBQUwsQ0FBVzVNLENBQVgsRUFBYzZULFlBQWQsQ0FBMkIsTUFBM0IsQ0FBeEM7QUFFQSxpQkFBS2pILEtBQUwsQ0FBVzVNLENBQVgsRUFBYzhULGVBQWQsQ0FBOEIsTUFBOUI7QUFDRDs7QUFFRFQsa0JBQVEsR0FBRyxJQUFYO0FBQ0Q7O0FBRUQsZUFBTyxJQUFQO0FBQ0QsT0ExRVc7O0FBNkVaOzs7OztBQUtBVSxZQUFNLEVBQUUsU0FBU0EsTUFBVCxHQUFrQjtBQUN4QlQsaUJBQVMsR0FBRyxLQUFaOztBQUVBLFlBQUlELFFBQUosRUFBYztBQUNaLGVBQUssSUFBSXJULENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBSzRNLEtBQUwsQ0FBVzNNLE1BQS9CLEVBQXVDRCxDQUFDLEVBQXhDLEVBQTRDO0FBQzFDLGlCQUFLNE0sS0FBTCxDQUFXNU0sQ0FBWCxFQUFjMlQsU0FBZCxHQUEwQixJQUExQjtBQUVBLGlCQUFLL0csS0FBTCxDQUFXNU0sQ0FBWCxFQUFjNFQsWUFBZCxDQUEyQixNQUEzQixFQUFtQyxLQUFLaEgsS0FBTCxDQUFXNU0sQ0FBWCxFQUFjNlQsWUFBZCxDQUEyQixXQUEzQixDQUFuQztBQUNEOztBQUVEUixrQkFBUSxHQUFHLEtBQVg7QUFDRDs7QUFFRCxlQUFPLElBQVA7QUFDRDtBQWhHVyxLQUFkO0FBbUdBMVcsVUFBTSxDQUFDeVcsT0FBRCxFQUFVLE9BQVYsRUFBbUI7QUFDdkI7Ozs7O0FBS0FuUyxTQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGVBQU9tUyxPQUFPLENBQUNHLEVBQWY7QUFDRDtBQVJzQixLQUFuQixDQUFOO0FBV0E7Ozs7O0FBSUF0TSxVQUFNLENBQUM1QyxFQUFQLENBQVUsWUFBVixFQUF3QixZQUFZO0FBQ2xDK08sYUFBTyxDQUFDTSxNQUFSO0FBQ0QsS0FGRDtBQUlBOzs7OztBQUlBek0sVUFBTSxDQUFDNUMsRUFBUCxDQUFVLFdBQVYsRUFBdUIsWUFBWTtBQUNqQzJDLGdCQUFVLENBQUNqQixVQUFYLENBQXNCcUIsS0FBdEIsQ0FBNEIsWUFBWTtBQUN0Q2dNLGVBQU8sQ0FBQ1csTUFBUjtBQUNELE9BRkQ7QUFHRCxLQUpEO0FBTUE7Ozs7O0FBSUE5TSxVQUFNLENBQUM1QyxFQUFQLENBQVUsU0FBVixFQUFxQixZQUFZO0FBQy9CK08sYUFBTyxDQUFDVyxNQUFSO0FBQ0FYLGFBQU8sQ0FBQ3RFLE1BQVI7QUFDQUYsWUFBTSxDQUFDMUksT0FBUDtBQUNELEtBSkQ7QUFNQSxXQUFPa04sT0FBUDtBQUNEOztBQUVELE1BQUlZLFlBQVksR0FBRyxpQ0FBbkI7QUFDQSxNQUFJQyxpQkFBaUIsR0FBRyw2QkFBeEI7O0FBRUEsV0FBU0MsUUFBVCxDQUFtQm5QLEtBQW5CLEVBQTBCaUMsVUFBMUIsRUFBc0NDLE1BQXRDLEVBQThDO0FBQzVDOzs7OztBQUtBLFFBQUkySCxNQUFNLEdBQUcsSUFBSVQsWUFBSixFQUFiO0FBRUEsUUFBSUksT0FBTyxHQUFHb0MsaUJBQWlCLEdBQUc7QUFBRVMsYUFBTyxFQUFFO0FBQVgsS0FBSCxHQUF1QixLQUF0RDtBQUVBLFFBQUk4QyxRQUFRLEdBQUc7QUFDYjs7Ozs7O0FBTUFqUixXQUFLLEVBQUUsU0FBU0EsS0FBVCxHQUFpQjtBQUN0Qjs7Ozs7O0FBTUEsYUFBS2tSLEVBQUwsR0FBVW5OLFVBQVUsQ0FBQ2UsSUFBWCxDQUFnQjJDLElBQWhCLENBQXFCOEksZ0JBQXJCLENBQXNDUSxZQUF0QyxDQUFWO0FBRUE7Ozs7Ozs7QUFNQSxhQUFLL08sRUFBTCxHQUFVK0IsVUFBVSxDQUFDZSxJQUFYLENBQWdCMkMsSUFBaEIsQ0FBcUI4SSxnQkFBckIsQ0FBc0NTLGlCQUF0QyxDQUFWO0FBRUEsYUFBS0csV0FBTDtBQUNELE9BekJZOztBQTRCYjs7Ozs7QUFLQUMsZUFBUyxFQUFFLFNBQVNBLFNBQVQsR0FBcUI7QUFDOUIsYUFBSyxJQUFJclUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLbVUsRUFBTCxDQUFRbFUsTUFBNUIsRUFBb0NELENBQUMsRUFBckMsRUFBeUM7QUFDdkMsZUFBS3FQLFFBQUwsQ0FBYyxLQUFLOEUsRUFBTCxDQUFRblUsQ0FBUixFQUFXNkosUUFBekI7QUFDRDtBQUNGLE9BckNZOztBQXdDYjs7Ozs7QUFLQXlLLGtCQUFZLEVBQUUsU0FBU0EsWUFBVCxHQUF3QjtBQUNwQyxhQUFLLElBQUl0VSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUttVSxFQUFMLENBQVFsVSxNQUE1QixFQUFvQ0QsQ0FBQyxFQUFyQyxFQUF5QztBQUN2QyxlQUFLc1AsV0FBTCxDQUFpQixLQUFLNkUsRUFBTCxDQUFRblUsQ0FBUixFQUFXNkosUUFBNUI7QUFDRDtBQUNGLE9BakRZOztBQW9EYjs7Ozs7O0FBTUF3RixjQUFRLEVBQUUsU0FBU0EsUUFBVCxDQUFrQmtGLFFBQWxCLEVBQTRCO0FBQ3BDLFlBQUl0USxRQUFRLEdBQUdjLEtBQUssQ0FBQ2QsUUFBckI7QUFDQSxZQUFJYSxJQUFJLEdBQUd5UCxRQUFRLENBQUN4UCxLQUFLLENBQUNQLEtBQVAsQ0FBbkI7O0FBRUEsWUFBSU0sSUFBSixFQUFVO0FBQ1JBLGNBQUksQ0FBQ2tHLFNBQUwsQ0FBZXlCLEdBQWYsQ0FBbUJ4SSxRQUFRLENBQUM5RixPQUFULENBQWlCUSxTQUFwQztBQUVBbUwsa0JBQVEsQ0FBQ2hGLElBQUQsQ0FBUixDQUFlRCxPQUFmLENBQXVCLFVBQVU2SCxPQUFWLEVBQW1CO0FBQ3hDQSxtQkFBTyxDQUFDMUIsU0FBUixDQUFrQnRHLE1BQWxCLENBQXlCVCxRQUFRLENBQUM5RixPQUFULENBQWlCUSxTQUExQztBQUNELFdBRkQ7QUFHRDtBQUNGLE9BckVZOztBQXdFYjs7Ozs7O0FBTUEyUSxpQkFBVyxFQUFFLFNBQVNBLFdBQVQsQ0FBcUJpRixRQUFyQixFQUErQjtBQUMxQyxZQUFJelAsSUFBSSxHQUFHeVAsUUFBUSxDQUFDeFAsS0FBSyxDQUFDUCxLQUFQLENBQW5COztBQUVBLFlBQUlNLElBQUosRUFBVTtBQUNSQSxjQUFJLENBQUNrRyxTQUFMLENBQWV0RyxNQUFmLENBQXNCSyxLQUFLLENBQUNkLFFBQU4sQ0FBZTlGLE9BQWYsQ0FBdUJRLFNBQTdDO0FBQ0Q7QUFDRixPQXBGWTs7QUF1RmI7Ozs7O0FBS0F5VixpQkFBVyxFQUFFLFNBQVNBLFdBQVQsR0FBdUI7QUFDbEMsYUFBSyxJQUFJcFUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLaUYsRUFBTCxDQUFRaEYsTUFBNUIsRUFBb0NELENBQUMsRUFBckMsRUFBeUM7QUFDdkMsZUFBSzZPLElBQUwsQ0FBVSxLQUFLNUosRUFBTCxDQUFRakYsQ0FBUixFQUFXNkosUUFBckI7QUFDRDtBQUNGLE9BaEdZOztBQW1HYjs7Ozs7QUFLQTJLLG9CQUFjLEVBQUUsU0FBU0EsY0FBVCxHQUEwQjtBQUN4QyxhQUFLLElBQUl4VSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtpRixFQUFMLENBQVFoRixNQUE1QixFQUFvQ0QsQ0FBQyxFQUFyQyxFQUF5QztBQUN2QyxlQUFLOE8sTUFBTCxDQUFZLEtBQUs3SixFQUFMLENBQVFqRixDQUFSLEVBQVc2SixRQUF2QjtBQUNEO0FBQ0YsT0E1R1k7O0FBK0diOzs7Ozs7QUFNQWdGLFVBQUksRUFBRSxTQUFTQSxJQUFULENBQWM0RixRQUFkLEVBQXdCO0FBQzVCLGFBQUssSUFBSXpVLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd5VSxRQUFRLENBQUN4VSxNQUE3QixFQUFxQ0QsQ0FBQyxFQUF0QyxFQUEwQztBQUN4QzRPLGdCQUFNLENBQUN2SyxFQUFQLENBQVUsT0FBVixFQUFtQm9RLFFBQVEsQ0FBQ3pVLENBQUQsQ0FBM0IsRUFBZ0MsS0FBS3lULEtBQXJDO0FBQ0E3RSxnQkFBTSxDQUFDdkssRUFBUCxDQUFVLFlBQVYsRUFBd0JvUSxRQUFRLENBQUN6VSxDQUFELENBQWhDLEVBQXFDLEtBQUt5VCxLQUExQyxFQUFpRGxGLE9BQWpEO0FBQ0Q7QUFDRixPQTFIWTs7QUE2SGI7Ozs7OztBQU1BTyxZQUFNLEVBQUUsU0FBU0EsTUFBVCxDQUFnQjJGLFFBQWhCLEVBQTBCO0FBQ2hDLGFBQUssSUFBSXpVLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd5VSxRQUFRLENBQUN4VSxNQUE3QixFQUFxQ0QsQ0FBQyxFQUF0QyxFQUEwQztBQUN4QzRPLGdCQUFNLENBQUNILEdBQVAsQ0FBVyxDQUFDLE9BQUQsRUFBVSxZQUFWLENBQVgsRUFBb0NnRyxRQUFRLENBQUN6VSxDQUFELENBQTVDO0FBQ0Q7QUFDRixPQXZJWTs7QUEwSWI7Ozs7Ozs7O0FBUUF5VCxXQUFLLEVBQUUsU0FBU0EsS0FBVCxDQUFlblAsS0FBZixFQUFzQjtBQUMzQkEsYUFBSyxDQUFDNk8sY0FBTjtBQUVBbk0sa0JBQVUsQ0FBQ3JCLEdBQVgsQ0FBZUMsSUFBZixDQUFvQm9CLFVBQVUsQ0FBQ3dDLFNBQVgsQ0FBcUJ5RixPQUFyQixDQUE2QjNLLEtBQUssQ0FBQ29RLGFBQU4sQ0FBb0JiLFlBQXBCLENBQWlDLGdCQUFqQyxDQUE3QixDQUFwQjtBQUNEO0FBdEpZLEtBQWY7QUF5SkFsWCxVQUFNLENBQUN1WCxRQUFELEVBQVcsT0FBWCxFQUFvQjtBQUN4Qjs7Ozs7QUFLQWpULFNBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsZUFBT2lULFFBQVEsQ0FBQ2pQLEVBQWhCO0FBQ0Q7QUFSdUIsS0FBcEIsQ0FBTjtBQVdBOzs7Ozs7QUFLQWdDLFVBQU0sQ0FBQzVDLEVBQVAsQ0FBVSxDQUFDLGFBQUQsRUFBZ0IsWUFBaEIsQ0FBVixFQUF5QyxZQUFZO0FBQ25ENlAsY0FBUSxDQUFDRyxTQUFUO0FBQ0QsS0FGRDtBQUlBOzs7OztBQUlBcE4sVUFBTSxDQUFDNUMsRUFBUCxDQUFVLFNBQVYsRUFBcUIsWUFBWTtBQUMvQjZQLGNBQVEsQ0FBQ00sY0FBVDtBQUNBTixjQUFRLENBQUNJLFlBQVQ7QUFDQTFGLFlBQU0sQ0FBQzFJLE9BQVA7QUFDRCxLQUpEO0FBTUEsV0FBT2dPLFFBQVA7QUFDRDs7QUFFRCxXQUFTUyxRQUFULENBQW1CNVAsS0FBbkIsRUFBMEJpQyxVQUExQixFQUFzQ0MsTUFBdEMsRUFBOEM7QUFDNUM7Ozs7O0FBS0EsUUFBSTJILE1BQU0sR0FBRyxJQUFJVCxZQUFKLEVBQWI7QUFFQSxRQUFJd0csUUFBUSxHQUFHO0FBQ2I7Ozs7O0FBS0ExUixXQUFLLEVBQUUsU0FBU0EsS0FBVCxHQUFpQjtBQUN0QixZQUFJOEIsS0FBSyxDQUFDZCxRQUFOLENBQWU3RyxRQUFuQixFQUE2QjtBQUMzQixlQUFLeVIsSUFBTDtBQUNEO0FBQ0YsT0FWWTs7QUFhYjs7Ozs7QUFLQUEsVUFBSSxFQUFFLFNBQVNBLElBQVQsR0FBZ0I7QUFDcEJELGNBQU0sQ0FBQ3ZLLEVBQVAsQ0FBVSxPQUFWLEVBQW1COEcsUUFBbkIsRUFBNkIsS0FBS3lKLEtBQWxDO0FBQ0QsT0FwQlk7O0FBdUJiOzs7OztBQUtBOUYsWUFBTSxFQUFFLFNBQVNBLE1BQVQsR0FBa0I7QUFDeEJGLGNBQU0sQ0FBQ0gsR0FBUCxDQUFXLE9BQVgsRUFBb0J0RCxRQUFwQjtBQUNELE9BOUJZOztBQWlDYjs7Ozs7O0FBTUF5SixXQUFLLEVBQUUsU0FBU0EsS0FBVCxDQUFldFEsS0FBZixFQUFzQjtBQUMzQixZQUFJQSxLQUFLLENBQUN1USxPQUFOLEtBQWtCLEVBQXRCLEVBQTBCO0FBQ3hCN04sb0JBQVUsQ0FBQ3JCLEdBQVgsQ0FBZUMsSUFBZixDQUFvQm9CLFVBQVUsQ0FBQ3dDLFNBQVgsQ0FBcUJ5RixPQUFyQixDQUE2QixHQUE3QixDQUFwQjtBQUNEOztBQUVELFlBQUkzSyxLQUFLLENBQUN1USxPQUFOLEtBQWtCLEVBQXRCLEVBQTBCO0FBQ3hCN04sb0JBQVUsQ0FBQ3JCLEdBQVgsQ0FBZUMsSUFBZixDQUFvQm9CLFVBQVUsQ0FBQ3dDLFNBQVgsQ0FBcUJ5RixPQUFyQixDQUE2QixHQUE3QixDQUFwQjtBQUNEO0FBQ0Y7QUEvQ1ksS0FBZjtBQWtEQTs7Ozs7O0FBS0FoSSxVQUFNLENBQUM1QyxFQUFQLENBQVUsQ0FBQyxTQUFELEVBQVksUUFBWixDQUFWLEVBQWlDLFlBQVk7QUFDM0NzUSxjQUFRLENBQUM3RixNQUFUO0FBQ0QsS0FGRDtBQUlBOzs7OztBQUlBN0gsVUFBTSxDQUFDNUMsRUFBUCxDQUFVLFFBQVYsRUFBb0IsWUFBWTtBQUM5QnNRLGNBQVEsQ0FBQzFSLEtBQVQ7QUFDRCxLQUZEO0FBSUE7Ozs7O0FBSUFnRSxVQUFNLENBQUM1QyxFQUFQLENBQVUsU0FBVixFQUFxQixZQUFZO0FBQy9CdUssWUFBTSxDQUFDMUksT0FBUDtBQUNELEtBRkQ7QUFJQSxXQUFPeU8sUUFBUDtBQUNEOztBQUVELFdBQVNHLFFBQVQsQ0FBbUIvUCxLQUFuQixFQUEwQmlDLFVBQTFCLEVBQXNDQyxNQUF0QyxFQUE4QztBQUM1Qzs7Ozs7QUFLQSxRQUFJMkgsTUFBTSxHQUFHLElBQUlULFlBQUosRUFBYjtBQUVBLFFBQUkyRyxRQUFRLEdBQUc7QUFDYjs7Ozs7QUFLQTdSLFdBQUssRUFBRSxTQUFTQSxLQUFULEdBQWlCO0FBQ3RCLGFBQUtnSyxLQUFMOztBQUVBLFlBQUlsSSxLQUFLLENBQUNkLFFBQU4sQ0FBZTlHLFVBQW5CLEVBQStCO0FBQzdCLGVBQUswUixJQUFMO0FBQ0Q7QUFDRixPQVpZOztBQWViOzs7Ozs7QUFNQTVCLFdBQUssRUFBRSxTQUFTQSxLQUFULEdBQWlCO0FBQ3RCLFlBQUkvRixLQUFLLEdBQUcsSUFBWjs7QUFFQSxZQUFJbkMsS0FBSyxDQUFDZCxRQUFOLENBQWUvRyxRQUFuQixFQUE2QjtBQUMzQixjQUFJNEYsV0FBVyxDQUFDLEtBQUsrRCxFQUFOLENBQWYsRUFBMEI7QUFDeEIsaUJBQUtBLEVBQUwsR0FBVWtPLFdBQVcsQ0FBQyxZQUFZO0FBQ2hDN04sbUJBQUssQ0FBQzhOLElBQU47O0FBRUFoTyx3QkFBVSxDQUFDckIsR0FBWCxDQUFlQyxJQUFmLENBQW9CLEdBQXBCOztBQUVBc0IsbUJBQUssQ0FBQytGLEtBQU47QUFDRCxhQU5vQixFQU1sQixLQUFLZ0ksSUFOYSxDQUFyQjtBQU9EO0FBQ0Y7QUFDRixPQW5DWTs7QUFzQ2I7Ozs7O0FBS0FELFVBQUksRUFBRSxTQUFTQSxJQUFULEdBQWdCO0FBQ3BCLGFBQUtuTyxFQUFMLEdBQVVxTyxhQUFhLENBQUMsS0FBS3JPLEVBQU4sQ0FBdkI7QUFDRCxPQTdDWTs7QUFnRGI7Ozs7O0FBS0FnSSxVQUFJLEVBQUUsU0FBU0EsSUFBVCxHQUFnQjtBQUNwQixZQUFJaUUsTUFBTSxHQUFHLElBQWI7O0FBRUFsRSxjQUFNLENBQUN2SyxFQUFQLENBQVUsV0FBVixFQUF1QjJDLFVBQVUsQ0FBQ2UsSUFBWCxDQUFnQjJDLElBQXZDLEVBQTZDLFlBQVk7QUFDdkRvSSxnQkFBTSxDQUFDa0MsSUFBUDtBQUNELFNBRkQ7QUFJQXBHLGNBQU0sQ0FBQ3ZLLEVBQVAsQ0FBVSxVQUFWLEVBQXNCMkMsVUFBVSxDQUFDZSxJQUFYLENBQWdCMkMsSUFBdEMsRUFBNEMsWUFBWTtBQUN0RG9JLGdCQUFNLENBQUM3RixLQUFQO0FBQ0QsU0FGRDtBQUdELE9BL0RZOztBQWtFYjs7Ozs7QUFLQTZCLFlBQU0sRUFBRSxTQUFTQSxNQUFULEdBQWtCO0FBQ3hCRixjQUFNLENBQUNILEdBQVAsQ0FBVyxDQUFDLFdBQUQsRUFBYyxVQUFkLENBQVgsRUFBc0N6SCxVQUFVLENBQUNlLElBQVgsQ0FBZ0IyQyxJQUF0RDtBQUNEO0FBekVZLEtBQWY7QUE0RUEvTixVQUFNLENBQUNtWSxRQUFELEVBQVcsTUFBWCxFQUFtQjtBQUN2Qjs7Ozs7O0FBTUE3VCxTQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLFlBQUkvRCxRQUFRLEdBQUc4SixVQUFVLENBQUNlLElBQVgsQ0FBZ0JDLE1BQWhCLENBQXVCakQsS0FBSyxDQUFDUCxLQUE3QixFQUFvQ3FQLFlBQXBDLENBQWlELHFCQUFqRCxDQUFmOztBQUVBLFlBQUkzVyxRQUFKLEVBQWM7QUFDWixpQkFBT29GLEtBQUssQ0FBQ3BGLFFBQUQsQ0FBWjtBQUNEOztBQUVELGVBQU9vRixLQUFLLENBQUN5QyxLQUFLLENBQUNkLFFBQU4sQ0FBZS9HLFFBQWhCLENBQVo7QUFDRDtBQWZzQixLQUFuQixDQUFOO0FBa0JBOzs7Ozs7QUFLQStKLFVBQU0sQ0FBQzVDLEVBQVAsQ0FBVSxDQUFDLFNBQUQsRUFBWSxRQUFaLENBQVYsRUFBaUMsWUFBWTtBQUMzQ3lRLGNBQVEsQ0FBQ2hHLE1BQVQ7QUFDRCxLQUZEO0FBSUE7Ozs7Ozs7OztBQVFBN0gsVUFBTSxDQUFDNUMsRUFBUCxDQUFVLENBQUMsWUFBRCxFQUFlLE9BQWYsRUFBd0IsU0FBeEIsRUFBbUMsYUFBbkMsRUFBa0QsUUFBbEQsQ0FBVixFQUF1RSxZQUFZO0FBQ2pGeVEsY0FBUSxDQUFDRSxJQUFUO0FBQ0QsS0FGRDtBQUlBOzs7Ozs7O0FBTUEvTixVQUFNLENBQUM1QyxFQUFQLENBQVUsQ0FBQyxXQUFELEVBQWMsTUFBZCxFQUFzQixXQUF0QixDQUFWLEVBQThDLFlBQVk7QUFDeER5USxjQUFRLENBQUM3SCxLQUFUO0FBQ0QsS0FGRDtBQUlBOzs7OztBQUlBaEcsVUFBTSxDQUFDNUMsRUFBUCxDQUFVLFFBQVYsRUFBb0IsWUFBWTtBQUM5QnlRLGNBQVEsQ0FBQzdSLEtBQVQ7QUFDRCxLQUZEO0FBSUE7Ozs7O0FBSUFnRSxVQUFNLENBQUM1QyxFQUFQLENBQVUsU0FBVixFQUFxQixZQUFZO0FBQy9CdUssWUFBTSxDQUFDMUksT0FBUDtBQUNELEtBRkQ7QUFJQSxXQUFPNE8sUUFBUDtBQUNEO0FBRUQ7Ozs7Ozs7O0FBTUEsV0FBU0ssZUFBVCxDQUF5QkMsTUFBekIsRUFBaUM7QUFDL0IsUUFBSXpTLFFBQVEsQ0FBQ3lTLE1BQUQsQ0FBWixFQUFzQjtBQUNwQixhQUFPMVIsUUFBUSxDQUFDMFIsTUFBRCxDQUFmO0FBQ0QsS0FGRCxNQUVPO0FBQ0x0VyxVQUFJLENBQUMsc0NBQUQsQ0FBSjtBQUNEOztBQUVELFdBQU8sRUFBUDtBQUNEOztBQUVELFdBQVN1VyxXQUFULENBQXNCdFEsS0FBdEIsRUFBNkJpQyxVQUE3QixFQUF5Q0MsTUFBekMsRUFBaUQ7QUFDL0M7Ozs7O0FBS0EsUUFBSTJILE1BQU0sR0FBRyxJQUFJVCxZQUFKLEVBQWI7QUFFQTs7Ozs7O0FBS0EsUUFBSWxLLFFBQVEsR0FBR2MsS0FBSyxDQUFDZCxRQUFyQjtBQUVBOzs7Ozs7OztBQU9BLFFBQUltUixNQUFNLEdBQUdELGVBQWUsQ0FBQ2xSLFFBQVEsQ0FBQy9GLFdBQVYsQ0FBNUI7QUFFQTs7Ozs7O0FBS0EsUUFBSXRCLFFBQVEsR0FBRytELFFBQVEsQ0FBQyxFQUFELEVBQUtzRCxRQUFMLENBQXZCOztBQUVBLFFBQUlvUixXQUFXLEdBQUc7QUFDaEI7Ozs7OztBQU1BQyxXQUFLLEVBQUUsU0FBU0EsS0FBVCxDQUFlRixNQUFmLEVBQXVCO0FBQzVCLFlBQUksT0FBTzdLLE1BQU0sQ0FBQ2dMLFVBQWQsS0FBNkIsV0FBakMsRUFBOEM7QUFDNUMsZUFBSyxJQUFJQyxLQUFULElBQWtCSixNQUFsQixFQUEwQjtBQUN4QixnQkFBSUEsTUFBTSxDQUFDclUsY0FBUCxDQUFzQnlVLEtBQXRCLENBQUosRUFBa0M7QUFDaEMsa0JBQUlqTCxNQUFNLENBQUNnTCxVQUFQLENBQWtCLGlCQUFpQkMsS0FBakIsR0FBeUIsS0FBM0MsRUFBa0RDLE9BQXRELEVBQStEO0FBQzdELHVCQUFPTCxNQUFNLENBQUNJLEtBQUQsQ0FBYjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELGVBQU81WSxRQUFQO0FBQ0Q7QUFuQmUsS0FBbEI7QUFzQkE7Ozs7O0FBSUErRCxZQUFRLENBQUNzRCxRQUFELEVBQVdvUixXQUFXLENBQUNDLEtBQVosQ0FBa0JGLE1BQWxCLENBQVgsQ0FBUjtBQUVBOzs7Ozs7QUFJQXhHLFVBQU0sQ0FBQ3ZLLEVBQVAsQ0FBVSxRQUFWLEVBQW9Ca0csTUFBcEIsRUFBNEJ4TSxRQUFRLENBQUMsWUFBWTtBQUMvQ2dILFdBQUssQ0FBQ2QsUUFBTixHQUFpQkQsWUFBWSxDQUFDQyxRQUFELEVBQVdvUixXQUFXLENBQUNDLEtBQVosQ0FBa0JGLE1BQWxCLENBQVgsQ0FBN0I7QUFDRCxLQUZtQyxFQUVqQ3JRLEtBQUssQ0FBQ2QsUUFBTixDQUFlbEcsUUFGa0IsQ0FBcEM7QUFJQTs7Ozs7QUFJQWtKLFVBQU0sQ0FBQzVDLEVBQVAsQ0FBVSxRQUFWLEVBQW9CLFlBQVk7QUFDOUIrUSxZQUFNLEdBQUdELGVBQWUsQ0FBQ0MsTUFBRCxDQUF4QjtBQUVBeFksY0FBUSxHQUFHK0QsUUFBUSxDQUFDLEVBQUQsRUFBS3NELFFBQUwsQ0FBbkI7QUFDRCxLQUpEO0FBTUE7Ozs7O0FBSUFnRCxVQUFNLENBQUM1QyxFQUFQLENBQVUsU0FBVixFQUFxQixZQUFZO0FBQy9CdUssWUFBTSxDQUFDSCxHQUFQLENBQVcsUUFBWCxFQUFxQmxFLE1BQXJCO0FBQ0QsS0FGRDtBQUlBLFdBQU84SyxXQUFQO0FBQ0Q7O0FBRUQsTUFBSUssVUFBVSxHQUFHO0FBQ2Y7QUFDQTNOLFFBQUksRUFBRUEsSUFGUztBQUdmbUksYUFBUyxFQUFFQSxTQUhJO0FBSWZuSyxjQUFVLEVBQUVBLFVBSkc7QUFLZnlELGFBQVMsRUFBRUEsU0FMSTtBQU1mNkIsUUFBSSxFQUFFQSxJQU5TO0FBT2YxQixTQUFLLEVBQUVBLEtBUFE7QUFRZk4sUUFBSSxFQUFFQSxJQVJTO0FBU2ZwRCxRQUFJLEVBQUVBLElBVFM7QUFVZm1HLFVBQU0sRUFBRUEsTUFWTztBQVdmdUMsVUFBTSxFQUFFQSxNQVhPO0FBWWZyQyxTQUFLLEVBQUVBLEtBWlE7QUFhZjNHLE9BQUcsRUFBRUEsR0FiVTtBQWVmO0FBQ0FxTCxTQUFLLEVBQUVBLEtBaEJRO0FBaUJmaUMsVUFBTSxFQUFFQSxNQWpCTztBQWtCZkcsV0FBTyxFQUFFQSxPQWxCTTtBQW1CZmMsWUFBUSxFQUFFQSxRQW5CSztBQW9CZlMsWUFBUSxFQUFFQSxRQXBCSztBQXFCZkcsWUFBUSxFQUFFQSxRQXJCSztBQXNCZk8sZUFBVyxFQUFFQTtBQXRCRSxHQUFqQjs7QUF5QkEsTUFBSU0sT0FBTyxHQUFHLFVBQVVDLEtBQVYsRUFBaUI7QUFDN0IvVCxZQUFRLENBQUNnVSxRQUFELEVBQVdELEtBQVgsQ0FBUjs7QUFFQSxhQUFTQyxRQUFULEdBQW9CO0FBQ2xCclcsb0JBQWMsQ0FBQyxJQUFELEVBQU9xVyxRQUFQLENBQWQ7QUFDQSxhQUFPMVQseUJBQXlCLENBQUMsSUFBRCxFQUFPLENBQUMwVCxRQUFRLENBQUMzVCxTQUFULElBQXNCNUIsTUFBTSxDQUFDb0IsY0FBUCxDQUFzQm1VLFFBQXRCLENBQXZCLEVBQXdEak4sS0FBeEQsQ0FBOEQsSUFBOUQsRUFBb0UvSCxTQUFwRSxDQUFQLENBQWhDO0FBQ0Q7O0FBRURqQixlQUFXLENBQUNpVyxRQUFELEVBQVcsQ0FBQztBQUNyQnJWLFNBQUcsRUFBRSxPQURnQjtBQUVyQm1CLFdBQUssRUFBRSxTQUFTc0IsS0FBVCxHQUFpQjtBQUN0QixZQUFJRSxVQUFVLEdBQUd0QyxTQUFTLENBQUNaLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JZLFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUJXLFNBQXpDLEdBQXFEWCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxFQUFyRjtBQUVBLGVBQU9JLEdBQUcsQ0FBQzRVLFFBQVEsQ0FBQ3RXLFNBQVQsQ0FBbUIyQyxTQUFuQixJQUFnQzVCLE1BQU0sQ0FBQ29CLGNBQVAsQ0FBc0JtVSxRQUFRLENBQUN0VyxTQUEvQixDQUFqQyxFQUE0RSxPQUE1RSxFQUFxRixJQUFyRixDQUFILENBQThGeUIsSUFBOUYsQ0FBbUcsSUFBbkcsRUFBeUdMLFFBQVEsQ0FBQyxFQUFELEVBQUsrVSxVQUFMLEVBQWlCdlMsVUFBakIsQ0FBakgsQ0FBUDtBQUNEO0FBTm9CLEtBQUQsQ0FBWCxDQUFYO0FBUUEsV0FBTzBTLFFBQVA7QUFDRCxHQWpCYSxDQWlCWjlRLEtBakJZLENBQWQ7O0FBbUJBLFNBQU80USxPQUFQO0FBRUQsQ0FybEhBLENBQUQsQzs7Ozs7Ozs7Ozs7OztBQ05BOzs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsQ0FBQyxVQUFTcEwsTUFBVCxFQUFpQjtBQUNkOztBQUVBLE1BQUl1TCxRQUFPLEdBQUcsSUFBZDtBQUFBLE1BQ0lDLENBQUMsR0FBUyxJQURkOztBQUdBLEdBQUMsWUFBVztBQUNSLFFBQUlDLE9BQU8sR0FBRyxDQUFDLFFBQUQsRUFBVyxLQUFYLEVBQWtCLEdBQWxCLEVBQXVCLElBQXZCLENBQWQ7QUFBQSxRQUNJQyxNQUFNLEdBQUkxTCxNQUFNLENBQUNZLFFBQVAsQ0FBZ0IrSyxhQUFoQixDQUE4QixLQUE5QixDQURkO0FBQUEsUUFFSWxXLENBQUMsR0FBUyxDQUFDLENBRmYsQ0FEUSxDQUtSOztBQUVBLFNBQUtBLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR2dXLE9BQU8sQ0FBQy9WLE1BQVosSUFBc0IsQ0FBQ3NLLE1BQU0sQ0FBQzRMLHFCQUExQyxFQUFpRW5XLENBQUMsRUFBbEUsRUFBc0U7QUFDbEV1SyxZQUFNLENBQUM0TCxxQkFBUCxHQUErQjVMLE1BQU0sQ0FBQ3lMLE9BQU8sQ0FBQ2hXLENBQUQsQ0FBUCxHQUFhLHVCQUFkLENBQXJDO0FBQ0gsS0FUTyxDQVdSOzs7QUFFQSxRQUFJLE9BQU9pVyxNQUFNLENBQUNHLGtCQUFkLEtBQXFDLFdBQXpDLEVBQXNEO0FBQ2xEOVYsWUFBTSxDQUFDQyxjQUFQLENBQXNCZ0ssTUFBTSxDQUFDOEwsT0FBUCxDQUFlOVcsU0FBckMsRUFBZ0Qsb0JBQWhELEVBQXNFO0FBQ2xFMEIsV0FBRyxFQUFFLGVBQVc7QUFDWixjQUFJb04sRUFBRSxHQUFHLEtBQUtqRSxXQUFkOztBQUVBLGlCQUFPaUUsRUFBUCxFQUFXO0FBQ1AsZ0JBQUlBLEVBQUUsQ0FBQ2hFLFFBQUgsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkIscUJBQU9nRSxFQUFQO0FBQ0g7O0FBRURBLGNBQUUsR0FBR0EsRUFBRSxDQUFDakUsV0FBUjtBQUNIOztBQUVELGlCQUFPLElBQVA7QUFDSDtBQWJpRSxPQUF0RTtBQWVILEtBN0JPLENBK0JSOzs7QUFFQSxLQUFDLFVBQVNrTSxnQkFBVCxFQUEyQjtBQUN4QkEsc0JBQWdCLENBQUNiLE9BQWpCLEdBQ0lhLGdCQUFnQixDQUFDYixPQUFqQixJQUNBYSxnQkFBZ0IsQ0FBQ0MsY0FEakIsSUFFQUQsZ0JBQWdCLENBQUNFLGtCQUZqQixJQUdBRixnQkFBZ0IsQ0FBQ0csaUJBSGpCLElBSUFILGdCQUFnQixDQUFDSSxnQkFKakIsSUFLQUosZ0JBQWdCLENBQUNLLHFCQUxqQixJQU1BLFVBQVUzUixRQUFWLEVBQW9CO0FBQ2hCLGVBQU9oQyxLQUFLLENBQUN6RCxTQUFOLENBQWdCZ1EsT0FBaEIsQ0FBd0J2TyxJQUF4QixDQUE2QixLQUFLNFYsYUFBTCxDQUFtQnBELGdCQUFuQixDQUFvQ3hPLFFBQXBDLENBQTdCLEVBQTRFLElBQTVFLElBQW9GLENBQUMsQ0FBNUY7QUFDSCxPQVRMO0FBVUgsS0FYRCxFQVdHdUYsTUFBTSxDQUFDOEwsT0FBUCxDQUFlOVcsU0FYbEIsRUFqQ1EsQ0E4Q1I7QUFDQTs7O0FBRUEsUUFBSSxDQUFDZSxNQUFNLENBQUNxRCxJQUFaLEVBQWtCO0FBQ2RyRCxZQUFNLENBQUNxRCxJQUFQLEdBQWUsWUFBVztBQUN0QixZQUFJNUMsY0FBYyxHQUFRVCxNQUFNLENBQUNmLFNBQVAsQ0FBaUJ3QixjQUEzQztBQUFBLFlBQ0k4VixjQUFjLEdBQVEsS0FEMUI7QUFBQSxZQUVJQyxTQUFTLEdBQWEsRUFGMUI7QUFBQSxZQUdJQyxlQUFlLEdBQU8sQ0FBQyxDQUgzQjtBQUtBRixzQkFBYyxHQUFHLENBQUU7QUFDZkcsa0JBQVEsRUFBRTtBQURLLFNBQUQsQ0FHYkMsb0JBSGEsQ0FHUSxVQUhSLENBQWxCO0FBS0FILGlCQUFTLEdBQUcsQ0FDUixVQURRLEVBRVIsZ0JBRlEsRUFHUixTQUhRLEVBSVIsZ0JBSlEsRUFLUixlQUxRLEVBTVIsc0JBTlEsRUFPUixhQVBRLENBQVo7QUFVQUMsdUJBQWUsR0FBR0QsU0FBUyxDQUFDN1csTUFBNUI7QUFFQSxlQUFPLFVBQVNaLEdBQVQsRUFBYztBQUNqQixjQUFJbUosTUFBTSxHQUFJLEVBQWQ7QUFBQSxjQUNJaEYsSUFBSSxHQUFNLEVBRGQ7QUFBQSxjQUVJeEQsQ0FBQyxHQUFTLENBQUMsQ0FGZjs7QUFJQSxjQUFJLFFBQU9YLEdBQVAsTUFBZSxRQUFmLEtBQTRCLE9BQU9BLEdBQVAsS0FBZSxVQUFmLElBQTZCQSxHQUFHLEtBQUssSUFBakUsQ0FBSixFQUE0RTtBQUN4RSxrQkFBTSxJQUFJTSxTQUFKLENBQWMsa0NBQWQsQ0FBTjtBQUNIOztBQUVELGVBQUs2RCxJQUFMLElBQWFuRSxHQUFiLEVBQWtCO0FBQ2QsZ0JBQUkwQixjQUFjLENBQUNDLElBQWYsQ0FBb0IzQixHQUFwQixFQUF5Qm1FLElBQXpCLENBQUosRUFBb0M7QUFDaENnRixvQkFBTSxDQUFDL0QsSUFBUCxDQUFZakIsSUFBWjtBQUNIO0FBQ0o7O0FBRUQsY0FBSXFULGNBQUosRUFBb0I7QUFDaEIsaUJBQUs3VyxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUcrVyxlQUFoQixFQUFpQy9XLENBQUMsRUFBbEMsRUFBc0M7QUFDbEMsa0JBQUllLGNBQWMsQ0FBQ0MsSUFBZixDQUFvQjNCLEdBQXBCLEVBQXlCeVgsU0FBUyxDQUFDOVcsQ0FBRCxDQUFsQyxDQUFKLEVBQTRDO0FBQ3hDd0ksc0JBQU0sQ0FBQy9ELElBQVAsQ0FBWXFTLFNBQVMsQ0FBQzlXLENBQUQsQ0FBckI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsaUJBQU93SSxNQUFQO0FBQ0gsU0F4QkQ7QUF5QkgsT0FoRGMsRUFBZjtBQWlESCxLQW5HTyxDQXFHUjtBQUNBOzs7QUFFQSxRQUFJLENBQUN4RixLQUFLLENBQUNELE9BQVgsRUFBb0I7QUFDaEJDLFdBQUssQ0FBQ0QsT0FBTixHQUFnQixVQUFTbVUsR0FBVCxFQUFjO0FBQzFCLGVBQU81VyxNQUFNLENBQUNmLFNBQVAsQ0FBaUJ5WCxRQUFqQixDQUEwQmhXLElBQTFCLENBQStCa1csR0FBL0IsTUFBd0MsZ0JBQS9DO0FBQ0gsT0FGRDtBQUdILEtBNUdPLENBOEdSO0FBQ0E7OztBQUVBLFFBQUksT0FBTzVXLE1BQU0sQ0FBQzBCLE1BQWQsS0FBeUIsVUFBN0IsRUFBeUM7QUFDckMxQixZQUFNLENBQUMwQixNQUFQLEdBQWlCLFVBQVNSLFNBQVQsRUFBb0I7QUFDakMsWUFBSTJWLElBQUksR0FBRyxTQUFQQSxJQUFPLEdBQVcsQ0FBRSxDQUF4Qjs7QUFFQSxlQUFPLFVBQVU1WCxTQUFWLEVBQXFCNlgsZ0JBQXJCLEVBQXVDO0FBQzFDLGNBQUk3WCxTQUFTLEtBQUtlLE1BQU0sQ0FBQ2YsU0FBRCxDQUFwQixJQUFtQ0EsU0FBUyxLQUFLLElBQXJELEVBQTJEO0FBQ3ZELGtCQUFNSSxTQUFTLENBQUMscUNBQUQsQ0FBZjtBQUNIOztBQUVEd1gsY0FBSSxDQUFDNVgsU0FBTCxHQUFpQkEsU0FBUyxJQUFJLEVBQTlCO0FBRUEsY0FBSWlKLE1BQU0sR0FBRyxJQUFJMk8sSUFBSixFQUFiO0FBRUFBLGNBQUksQ0FBQzVYLFNBQUwsR0FBaUIsSUFBakI7O0FBRUEsY0FBSTZYLGdCQUFnQixLQUFLNVYsU0FBekIsRUFBb0M7QUFDaENsQixrQkFBTSxDQUFDVCxnQkFBUCxDQUF3QjJJLE1BQXhCLEVBQWdDNE8sZ0JBQWhDO0FBQ0g7O0FBRUQsY0FBSTdYLFNBQVMsS0FBSyxJQUFsQixFQUF3QjtBQUNwQjtBQUNBaUosa0JBQU0sQ0FBQ3RHLFNBQVAsR0FBbUIsSUFBbkI7QUFDQTtBQUNIOztBQUVELGlCQUFPc0csTUFBUDtBQUNILFNBdEJEO0FBdUJILE9BMUJlLEVBQWhCO0FBMkJILEtBN0lPLENBK0lSOzs7QUFFQSxRQUFJLENBQUM2TyxNQUFNLENBQUM5WCxTQUFQLENBQWlCK1gsSUFBdEIsRUFBNEI7QUFDeEJELFlBQU0sQ0FBQzlYLFNBQVAsQ0FBaUIrWCxJQUFqQixHQUF3QixZQUFXO0FBQy9CLGVBQU8sS0FBS0MsT0FBTCxDQUFhLG9DQUFiLEVBQW1ELEVBQW5ELENBQVA7QUFDSCxPQUZEO0FBR0gsS0FySk8sQ0F1SlI7QUFDQTs7O0FBRUEsUUFBSSxDQUFDdlUsS0FBSyxDQUFDekQsU0FBTixDQUFnQmdRLE9BQXJCLEVBQThCO0FBQzFCdk0sV0FBSyxDQUFDekQsU0FBTixDQUFnQmdRLE9BQWhCLEdBQTBCLFVBQVNpSSxhQUFULEVBQXdCO0FBQzlDLFlBQUl2TixDQUFKLEVBQU9sRyxDQUFQLEVBQVVxSCxDQUFWLEVBQWE5QixHQUFiOztBQUVBLFlBQUksU0FBUyxJQUFiLEVBQW1CO0FBQ2YsZ0JBQU0sSUFBSTNKLFNBQUosRUFBTjtBQUNIOztBQUVEeUwsU0FBQyxHQUFHOUssTUFBTSxDQUFDLElBQUQsQ0FBVjtBQUVBZ0osV0FBRyxHQUFHOEIsQ0FBQyxDQUFDbkwsTUFBRixLQUFhLENBQW5COztBQUVBLFlBQUlxSixHQUFHLEtBQUssQ0FBWixFQUFlO0FBQ1gsaUJBQU8sQ0FBQyxDQUFSO0FBQ0g7O0FBRURXLFNBQUMsR0FBRyxDQUFKOztBQUVBLFlBQUlwSixTQUFTLENBQUNaLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDdEJnSyxXQUFDLEdBQUd3TixNQUFNLENBQUM1VyxTQUFTLENBQUMsQ0FBRCxDQUFWLENBQVY7O0FBRUEsY0FBSW9KLENBQUMsS0FBS0EsQ0FBVixFQUFhO0FBQ1RBLGFBQUMsR0FBRyxDQUFKO0FBQ0gsV0FGRCxNQUVPLElBQUlBLENBQUMsS0FBSyxDQUFOLElBQVdBLENBQUMsS0FBS3lOLFFBQWpCLElBQTZCek4sQ0FBQyxLQUFLLENBQUN5TixRQUF4QyxFQUFrRDtBQUNyRHpOLGFBQUMsR0FBRyxDQUFDQSxDQUFDLEdBQUcsQ0FBSixJQUFTLENBQUMsQ0FBWCxJQUFnQnZDLElBQUksQ0FBQzBGLEtBQUwsQ0FBVzFGLElBQUksQ0FBQ3FLLEdBQUwsQ0FBUzlILENBQVQsQ0FBWCxDQUFwQjtBQUNIO0FBQ0o7O0FBRUQsWUFBSUEsQ0FBQyxJQUFJWCxHQUFULEVBQWM7QUFDVixpQkFBTyxDQUFDLENBQVI7QUFDSDs7QUFFRCxhQUFLdkYsQ0FBQyxHQUFHa0csQ0FBQyxJQUFJLENBQUwsR0FBU0EsQ0FBVCxHQUFhdkMsSUFBSSxDQUFDeUYsR0FBTCxDQUFTN0QsR0FBRyxHQUFHNUIsSUFBSSxDQUFDcUssR0FBTCxDQUFTOUgsQ0FBVCxDQUFmLEVBQTRCLENBQTVCLENBQXRCLEVBQXNEbEcsQ0FBQyxHQUFHdUYsR0FBMUQsRUFBK0R2RixDQUFDLEVBQWhFLEVBQW9FO0FBQ2hFLGNBQUlBLENBQUMsSUFBSXFILENBQUwsSUFBVUEsQ0FBQyxDQUFDckgsQ0FBRCxDQUFELEtBQVN5VCxhQUF2QixFQUFzQztBQUNsQyxtQkFBT3pULENBQVA7QUFDSDtBQUNKOztBQUVELGVBQU8sQ0FBQyxDQUFSO0FBQ0gsT0F0Q0Q7QUF1Q0gsS0FsTU8sQ0FvTVI7QUFDQTs7O0FBRUEsUUFBSSxDQUFDMUMsUUFBUSxDQUFDOUIsU0FBVCxDQUFtQnNQLElBQXhCLEVBQThCO0FBQzFCeE4sY0FBUSxDQUFDOUIsU0FBVCxDQUFtQnNQLElBQW5CLEdBQTBCLFVBQVM4SSxLQUFULEVBQWdCO0FBQ3RDLFlBQUlDLEtBQUosRUFBV3hWLElBQVgsRUFBaUJ5VixJQUFqQixFQUF1QkMsTUFBdkI7O0FBRUEsWUFBSSxPQUFPLElBQVAsS0FBZ0IsVUFBcEIsRUFBZ0M7QUFDNUIsZ0JBQU0sSUFBSW5ZLFNBQUosRUFBTjtBQUNIOztBQUVEaVksYUFBSyxHQUFHNVUsS0FBSyxDQUFDekQsU0FBTixDQUFnQnNMLEtBQWhCLENBQXNCN0osSUFBdEIsQ0FBMkJILFNBQTNCLEVBQXNDLENBQXRDLENBQVI7QUFFQXVCLFlBQUksR0FBRyxJQUFQOztBQUVBeVYsWUFBSSxHQUFHLGdCQUFXLENBQUUsQ0FBcEI7O0FBRUFDLGNBQU0sR0FBRyxrQkFBVztBQUNoQixpQkFBTzFWLElBQUksQ0FBQ3dHLEtBQUwsQ0FBVyxnQkFBZ0JpUCxJQUFoQixHQUF1QixJQUF2QixHQUE4QkYsS0FBekMsRUFBZ0RDLEtBQUssQ0FBQzVILE1BQU4sQ0FBYWhOLEtBQUssQ0FBQ3pELFNBQU4sQ0FBZ0JzTCxLQUFoQixDQUFzQjdKLElBQXRCLENBQTJCSCxTQUEzQixDQUFiLENBQWhELENBQVA7QUFDSCxTQUZEOztBQUlBLFlBQUksS0FBS3RCLFNBQVQsRUFBb0I7QUFDaEJzWSxjQUFJLENBQUN0WSxTQUFMLEdBQWlCLEtBQUtBLFNBQXRCO0FBQ0g7O0FBRUR1WSxjQUFNLENBQUN2WSxTQUFQLEdBQW1CLElBQUlzWSxJQUFKLEVBQW5CO0FBRUEsZUFBT0MsTUFBUDtBQUNILE9BeEJEO0FBeUJILEtBak9PLENBbU9SOzs7QUFFQSxRQUFJLENBQUN2TixNQUFNLENBQUM4TCxPQUFQLENBQWU5VyxTQUFmLENBQXlCd1ksYUFBOUIsRUFBNkM7QUFDekN4TixZQUFNLENBQUM4TCxPQUFQLENBQWU5VyxTQUFmLENBQXlCd1ksYUFBekIsR0FBeUMsVUFBU3pULEtBQVQsRUFBZ0I7QUFDckQsWUFBSTtBQUNBLGlCQUFPLEtBQUswVCxTQUFMLENBQWUsT0FBTzFULEtBQUssQ0FBQ3pILElBQTVCLEVBQWtDeUgsS0FBbEMsQ0FBUDtBQUNILFNBRkQsQ0FFRSxPQUFPMlQsR0FBUCxFQUFZLENBQUU7QUFDbkIsT0FKRDtBQUtIO0FBQ0osR0E1T0Q7QUE4T0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2Q0FuQyxVQUFPLEdBQUcsaUJBQVNvQyxTQUFULEVBQW9CQyxNQUFwQixFQUE0QkMsVUFBNUIsRUFBd0M7QUFDOUMsUUFBSS9KLEVBQUUsR0FBb0IsSUFBMUI7QUFBQSxRQUNJZ0ssZ0JBQWdCLEdBQU0sS0FEMUI7QUFBQSxRQUVJNVksUUFBUSxHQUFjLElBRjFCO0FBQUEsUUFHSTZZLE1BQU0sR0FBZ0IsSUFIMUI7QUFBQSxRQUlJQyxHQUFHLEdBQW1CLElBSjFCO0FBQUEsUUFLSUMsTUFBTSxHQUFnQixJQUwxQjtBQUFBLFFBTUlDLFNBQVMsR0FBYSxFQU4xQjtBQUFBLFFBT0lDLEVBQUUsR0FBb0IsRUFQMUI7QUFBQSxRQVFJakUsUUFBUSxHQUFjLEVBUjFCO0FBQUEsUUFTSXpVLENBQUMsR0FBcUIsQ0FBQyxDQVQzQjtBQVdBdVksT0FBRyxHQUFHSCxVQUFVLElBQUk3TixNQUFNLENBQUNZLFFBQTNCOztBQUVBLFFBQUlrTixnQkFBZ0IsR0FBR3hYLFNBQVMsQ0FBQyxDQUFELENBQWhDLEVBQXFDO0FBQ2pDO0FBRUF3WCxzQkFBZ0IsR0FBRyxPQUFPQSxnQkFBUCxLQUE0QixTQUEvQztBQUNIOztBQUVELFFBQUksT0FBT0gsU0FBUCxLQUFxQixRQUF6QixFQUFtQztBQUMvQnpELGNBQVEsR0FBRzhELEdBQUcsQ0FBQy9FLGdCQUFKLENBQXFCMEUsU0FBckIsQ0FBWDtBQUNILEtBRkQsTUFFTyxJQUFJQSxTQUFTLElBQUksUUFBT0EsU0FBUCxNQUFxQixRQUFsQyxJQUE4Q25DLENBQUMsQ0FBQzRDLFNBQUYsQ0FBWVQsU0FBWixFQUF1QkssR0FBdkIsQ0FBbEQsRUFBK0U7QUFDbEY5RCxjQUFRLEdBQUcsQ0FBQ3lELFNBQUQsQ0FBWDtBQUNILEtBRk0sTUFFQSxJQUFJQSxTQUFTLElBQUksUUFBT0EsU0FBUCxNQUFxQixRQUFsQyxJQUE4Q0EsU0FBUyxDQUFDalksTUFBNUQsRUFBb0U7QUFDdkU7QUFDQTtBQUVBd1UsY0FBUSxHQUFHeUQsU0FBWDtBQUNILEtBTE0sTUFLQTtBQUNILFlBQU0sSUFBSVUsS0FBSixDQUFVOUMsUUFBTyxDQUFDK0MsUUFBUixDQUFpQkMsNEJBQWpCLEVBQVYsQ0FBTjtBQUNIOztBQUVELFFBQUlyRSxRQUFRLENBQUN4VSxNQUFULEdBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLFlBQU0sSUFBSTJZLEtBQUosQ0FBVTlDLFFBQU8sQ0FBQytDLFFBQVIsQ0FBaUJFLDZCQUFqQixFQUFWLENBQU47QUFDSDs7QUFFRCxTQUFLL1ksQ0FBQyxHQUFHLENBQVQsRUFBWXFPLEVBQUUsR0FBR29HLFFBQVEsQ0FBQ3pVLENBQUQsQ0FBekIsRUFBOEJBLENBQUMsRUFBL0IsRUFBbUM7QUFDL0IsVUFBSUEsQ0FBQyxHQUFHLENBQUosSUFBUyxDQUFDcVksZ0JBQWQsRUFBZ0M7O0FBRWhDLFVBQUksQ0FBQ2hLLEVBQUUsQ0FBQ3FLLEVBQVIsRUFBWTtBQUNSQSxVQUFFLEdBQUcsWUFBWTNDLENBQUMsQ0FBQ2lELFNBQUYsRUFBakI7QUFFQTNLLFVBQUUsQ0FBQ3FLLEVBQUgsR0FBUUEsRUFBUjtBQUNILE9BSkQsTUFJTztBQUNIQSxVQUFFLEdBQUdySyxFQUFFLENBQUNxSyxFQUFSO0FBQ0g7O0FBRUQsVUFBSTVDLFFBQU8sQ0FBQzJDLFNBQVIsQ0FBa0JDLEVBQWxCLGFBQWlDNUMsUUFBTyxDQUFDbUQsS0FBN0MsRUFBb0Q7QUFDaER4WixnQkFBUSxHQUFHcVcsUUFBTyxDQUFDMkMsU0FBUixDQUFrQkMsRUFBbEIsQ0FBWDs7QUFFQSxZQUFJLENBQUNQLE1BQUQsSUFBWUEsTUFBTSxJQUFJQSxNQUFNLENBQUNlLEtBQWpCLElBQTBCZixNQUFNLENBQUNlLEtBQVAsQ0FBYUMsWUFBYixLQUE4QixLQUF4RSxFQUFnRjtBQUM1RW5hLGlCQUFPLENBQUNGLElBQVIsQ0FBYWdYLFFBQU8sQ0FBQytDLFFBQVIsQ0FBaUJPLGlDQUFqQixFQUFiO0FBQ0g7QUFDSixPQU5ELE1BTU87QUFDSDNaLGdCQUFRLEdBQUcsSUFBSXFXLFFBQU8sQ0FBQ21ELEtBQVosRUFBWDtBQUVBeFosZ0JBQVEsQ0FBQ3NVLE1BQVQsQ0FBZ0IxRixFQUFoQixFQUFvQmtLLEdBQXBCLEVBQXlCRyxFQUF6QixFQUE2QlAsTUFBN0I7QUFFQXJDLGdCQUFPLENBQUMyQyxTQUFSLENBQWtCQyxFQUFsQixJQUF3QmpaLFFBQXhCO0FBQ0g7O0FBRUQ2WSxZQUFNLEdBQUcsSUFBSXhDLFFBQU8sQ0FBQ3VELE1BQVosQ0FBbUI1WixRQUFuQixDQUFUOztBQUVBLFVBQUkwWSxNQUFNLElBQUlBLE1BQU0sQ0FBQ2UsS0FBakIsSUFBMEJmLE1BQU0sQ0FBQ2UsS0FBUCxDQUFhNVMsTUFBM0MsRUFBbUQ7QUFDL0NtUyxpQkFBUyxDQUFDaFUsSUFBVixDQUFlaEYsUUFBZjtBQUNILE9BRkQsTUFFTztBQUNIZ1osaUJBQVMsQ0FBQ2hVLElBQVYsQ0FBZTZULE1BQWY7QUFDSDtBQUNKOztBQUVELFFBQUlELGdCQUFKLEVBQXNCO0FBQ2xCRyxZQUFNLEdBQUcsSUFBSTFDLFFBQU8sQ0FBQ3dELFVBQVosQ0FBdUJiLFNBQXZCLENBQVQ7QUFDSCxLQUZELE1BRU87QUFDSDtBQUVBRCxZQUFNLEdBQUdDLFNBQVMsQ0FBQyxDQUFELENBQWxCO0FBQ0g7O0FBRUQsV0FBT0QsTUFBUDtBQUNILEdBaEZEO0FBa0ZBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0ExQyxVQUFPLENBQUN5RCxHQUFSLEdBQWMsVUFBU0MsU0FBVCxFQUFvQjtBQUM5QjFELFlBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQWIsQ0FBdUJtYSxXQUF2QixDQUFtQzFZLElBQW5DLENBQXdDOFUsUUFBeEMsRUFBaUQsV0FBakQsRUFBOERqVixTQUE5RCxFQUQ4QixDQUc5QjtBQUNBOzs7QUFFQSxRQUFJLE9BQU8yWSxTQUFQLEtBQXFCLFVBQXJCLElBQW1DQSxTQUFTLENBQUNHLElBQVYsS0FBbUIsbUJBQTFELEVBQStFO0FBQzNFO0FBRUEsVUFBSSxPQUFPN0QsUUFBTyxDQUFDM1MsVUFBUixDQUFtQnFXLFNBQVMsQ0FBQ0ksSUFBN0IsQ0FBUCxLQUE4QyxXQUFsRCxFQUErRDtBQUMzREosaUJBQVMsQ0FBQzFELFFBQUQsQ0FBVDtBQUVBQSxnQkFBTyxDQUFDM1MsVUFBUixDQUFtQnFXLFNBQVMsQ0FBQ0ksSUFBN0IsSUFBcUNKLFNBQXJDO0FBQ0g7QUFDSixLQVJELE1BUU8sSUFBSUEsU0FBUyxDQUFDSyxFQUFWLElBQWdCTCxTQUFTLENBQUNLLEVBQVYsQ0FBYUMsTUFBakMsRUFBeUM7QUFDNUM7QUFFQWhFLGNBQU8sQ0FBQ2lFLFNBQVIsQ0FBa0JDLENBQWxCLEdBQXNCUixTQUF0QjtBQUNIOztBQUVEMUQsWUFBTyxDQUFDMkQsSUFBUixDQUFhbGEsU0FBYixDQUF1Qm1hLFdBQXZCLENBQW1DMVksSUFBbkMsQ0FBd0M4VSxRQUF4QyxFQUFpRCxVQUFqRCxFQUE2RGpWLFNBQTdEO0FBQ0gsR0FyQkQ7O0FBdUJBaVYsVUFBTyxDQUFDMkMsU0FBUixHQUFzQixFQUF0QjtBQUNBM0MsVUFBTyxDQUFDM1MsVUFBUixHQUFzQixFQUF0QjtBQUNBMlMsVUFBTyxDQUFDaUUsU0FBUixHQUFzQixFQUF0QjtBQUVBOzs7O0FBSUFoRSxHQUFDLEdBQUc7QUFFQTs7Ozs7O0FBT0FrRSxZQUFRLEVBQUUsa0JBQVM1TCxFQUFULEVBQWE2TCxHQUFiLEVBQWtCO0FBQ3hCLGFBQU8sQ0FBQyxDQUFDN0wsRUFBRSxDQUFDOEwsU0FBSCxDQUFhN0UsS0FBYixDQUFtQixJQUFJOEUsTUFBSixDQUFXLFlBQVlGLEdBQVosR0FBa0IsU0FBN0IsQ0FBbkIsQ0FBVDtBQUNILEtBWEQ7O0FBYUE7Ozs7OztBQU9BN0ssWUFBUSxFQUFFLGtCQUFTaEIsRUFBVCxFQUFhNkwsR0FBYixFQUFrQjtBQUN4QixVQUFJLENBQUMsS0FBS0QsUUFBTCxDQUFjNUwsRUFBZCxFQUFrQjZMLEdBQWxCLENBQUwsRUFBNkI3TCxFQUFFLENBQUM4TCxTQUFILElBQWdCOUwsRUFBRSxDQUFDOEwsU0FBSCxHQUFlLE1BQU1ELEdBQXJCLEdBQTJCQSxHQUEzQztBQUNoQyxLQXRCRDs7QUF3QkE7Ozs7OztBQU9BNUssZUFBVyxFQUFFLHFCQUFTakIsRUFBVCxFQUFhNkwsR0FBYixFQUFrQjtBQUMzQixVQUFJLEtBQUtELFFBQUwsQ0FBYzVMLEVBQWQsRUFBa0I2TCxHQUFsQixDQUFKLEVBQTRCO0FBQ3hCLFlBQUlHLEdBQUcsR0FBRyxJQUFJRCxNQUFKLENBQVcsWUFBWUYsR0FBWixHQUFrQixTQUE3QixDQUFWO0FBRUE3TCxVQUFFLENBQUM4TCxTQUFILEdBQWU5TCxFQUFFLENBQUM4TCxTQUFILENBQWE1QyxPQUFiLENBQXFCOEMsR0FBckIsRUFBMEIsR0FBMUIsRUFBK0IvQyxJQUEvQixFQUFmO0FBQ0g7QUFDSixLQXJDRDs7QUF1Q0E7Ozs7Ozs7Ozs7O0FBWUFnRCxVQUFNLEVBQUUsZ0JBQVNDLFdBQVQsRUFBc0J6WixNQUF0QixFQUE4QjBaLElBQTlCLEVBQW9DQyxZQUFwQyxFQUFrRDtBQUN0RCxVQUFJQyxVQUFVLEdBQUksRUFBbEI7QUFBQSxVQUNJbGEsR0FBRyxHQUFXLEVBRGxCO0FBQUEsVUFFSVIsQ0FBQyxHQUFhLENBQUMsQ0FGbkI7QUFJQXdhLFVBQUksR0FBR0EsSUFBSSxJQUFJLEtBQWY7QUFDQUMsa0JBQVksR0FBR0EsWUFBWSxJQUFJLEtBQS9COztBQUVBLFVBQUk7QUFDQSxZQUFJelgsS0FBSyxDQUFDRCxPQUFOLENBQWNqQyxNQUFkLENBQUosRUFBMkI7QUFDdkIsZUFBS2QsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHYyxNQUFNLENBQUNiLE1BQXZCLEVBQStCRCxDQUFDLEVBQWhDLEVBQW9DO0FBQ2hDMGEsc0JBQVUsQ0FBQ2pXLElBQVgsQ0FBZ0J6RSxDQUFoQjtBQUNIO0FBQ0osU0FKRCxNQUlPLElBQUljLE1BQUosRUFBWTtBQUNmNFosb0JBQVUsR0FBR3BhLE1BQU0sQ0FBQ3FELElBQVAsQ0FBWTdDLE1BQVosQ0FBYjtBQUNIOztBQUVELGFBQUtkLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRzBhLFVBQVUsQ0FBQ3phLE1BQTNCLEVBQW1DRCxDQUFDLEVBQXBDLEVBQXdDO0FBQ3BDUSxhQUFHLEdBQUdrYSxVQUFVLENBQUMxYSxDQUFELENBQWhCOztBQUVBLGNBQUksQ0FBQ3dhLElBQUQsSUFBUyxRQUFPMVosTUFBTSxDQUFDTixHQUFELENBQWIsTUFBdUIsUUFBaEMsSUFBNEMsS0FBS21ZLFNBQUwsQ0FBZTdYLE1BQU0sQ0FBQ04sR0FBRCxDQUFyQixDQUFoRCxFQUE2RTtBQUN6RTtBQUVBK1osdUJBQVcsQ0FBQy9aLEdBQUQsQ0FBWCxHQUFtQk0sTUFBTSxDQUFDTixHQUFELENBQXpCO0FBQ0gsV0FKRCxNQUlPLElBQUl3QyxLQUFLLENBQUNELE9BQU4sQ0FBY2pDLE1BQU0sQ0FBQ04sR0FBRCxDQUFwQixDQUFKLEVBQWdDO0FBQ25DO0FBRUEsZ0JBQUksQ0FBQytaLFdBQVcsQ0FBQy9aLEdBQUQsQ0FBaEIsRUFBdUI7QUFDbkIrWix5QkFBVyxDQUFDL1osR0FBRCxDQUFYLEdBQW1CLEVBQW5CO0FBQ0g7O0FBRUQsaUJBQUs4WixNQUFMLENBQVlDLFdBQVcsQ0FBQy9aLEdBQUQsQ0FBdkIsRUFBOEJNLE1BQU0sQ0FBQ04sR0FBRCxDQUFwQyxFQUEyQ2dhLElBQTNDLEVBQWlEQyxZQUFqRDtBQUNILFdBUk0sTUFRQTtBQUNIO0FBRUEsZ0JBQUksQ0FBQ0YsV0FBVyxDQUFDL1osR0FBRCxDQUFoQixFQUF1QjtBQUNuQitaLHlCQUFXLENBQUMvWixHQUFELENBQVgsR0FBbUIsRUFBbkI7QUFDSDs7QUFFRCxpQkFBSzhaLE1BQUwsQ0FBWUMsV0FBVyxDQUFDL1osR0FBRCxDQUF2QixFQUE4Qk0sTUFBTSxDQUFDTixHQUFELENBQXBDLEVBQTJDZ2EsSUFBM0MsRUFBaURDLFlBQWpEO0FBQ0g7QUFDSjtBQUNKLE9BbENELENBa0NFLE9BQU14QyxHQUFOLEVBQVc7QUFDVCxZQUFJd0MsWUFBSixFQUFrQjtBQUNkLGVBQUtFLGlCQUFMLENBQXVCMUMsR0FBdkIsRUFBNEJzQyxXQUE1QjtBQUNILFNBRkQsTUFFTztBQUNILGdCQUFNdEMsR0FBTjtBQUNIO0FBQ0o7O0FBRUQsYUFBT3NDLFdBQVA7QUFDSCxLQXRHRDs7QUF3R0E7Ozs7OztBQU9BSSxxQkFBaUIsRUFBRSwyQkFBUzFDLEdBQVQsRUFBY3NDLFdBQWQsRUFBMkI7QUFDMUMsVUFBSUssRUFBRSxHQUFvQixnQ0FBMUI7QUFBQSxVQUNJbkYsT0FBTyxHQUFlLElBRDFCO0FBQUEsVUFFSW9GLFNBQVMsR0FBYSxFQUYxQjtBQUFBLFVBR0lDLE9BQU8sR0FBZSxFQUgxQjtBQUFBLFVBSUlDLFVBQVUsR0FBWSxFQUoxQjtBQUFBLFVBS0lDLGFBQWEsR0FBUyxFQUwxQjtBQUFBLFVBTUl4YSxHQUFHLEdBQW1CLEVBTjFCO0FBQUEsVUFPSXlhLGlCQUFpQixHQUFLLENBQUMsQ0FQM0I7QUFBQSxVQVFJamIsQ0FBQyxHQUFxQixDQUFDLENBUjNCOztBQVVBLFVBQUlpWSxHQUFHLFlBQVl0WSxTQUFmLEtBQTZCOFYsT0FBTyxHQUFHbUYsRUFBRSxDQUFDTSxJQUFILENBQVFqRCxHQUFHLENBQUM2QyxPQUFaLENBQXZDLENBQUosRUFBa0U7QUFDOURELGlCQUFTLEdBQUdwRixPQUFPLENBQUMsQ0FBRCxDQUFuQjs7QUFFQSxhQUFLalYsR0FBTCxJQUFZK1osV0FBWixFQUF5QjtBQUNyQnZhLFdBQUMsR0FBRyxDQUFKOztBQUVBLGlCQUFPQSxDQUFDLEdBQUc2YSxTQUFTLENBQUM1YSxNQUFkLElBQXdCNGEsU0FBUyxDQUFDTSxNQUFWLENBQWlCbmIsQ0FBakIsTUFBd0JRLEdBQUcsQ0FBQzJhLE1BQUosQ0FBV25iLENBQVgsQ0FBdkQsRUFBc0U7QUFDbEVBLGFBQUM7QUFDSjs7QUFFRCxjQUFJQSxDQUFDLEdBQUdpYixpQkFBUixFQUEyQjtBQUN2QkEsNkJBQWlCLEdBQUdqYixDQUFwQjtBQUNBZ2IseUJBQWEsR0FBR3hhLEdBQWhCO0FBQ0g7QUFDSjs7QUFFRCxZQUFJeWEsaUJBQWlCLEdBQUcsQ0FBeEIsRUFBMkI7QUFDdkJGLG9CQUFVLEdBQUdqRixRQUFPLENBQUMrQyxRQUFSLENBQWlCdUMsb0NBQWpCLENBQXNEO0FBQy9ESix5QkFBYSxFQUFFQTtBQURnRCxXQUF0RCxDQUFiO0FBR0g7O0FBRURGLGVBQU8sR0FBR2hGLFFBQU8sQ0FBQytDLFFBQVIsQ0FBaUJ3QywwQkFBakIsQ0FBNEM7QUFDbERSLG1CQUFTLEVBQUVBLFNBRHVDO0FBRWxERSxvQkFBVSxFQUFFQTtBQUZzQyxTQUE1QyxDQUFWO0FBS0EsY0FBTSxJQUFJcGIsU0FBSixDQUFjbWIsT0FBZCxDQUFOO0FBQ0g7O0FBRUQsWUFBTTdDLEdBQU47QUFDSCxLQXpKRDs7QUEySkE7Ozs7O0FBTUFxRCxZQUFRLEVBQUUsa0JBQVNDLEdBQVQsRUFBYztBQUNwQixVQUFJWCxFQUFFLEdBQVksY0FBbEI7QUFBQSxVQUNJWSxRQUFRLEdBQU0sRUFEbEI7QUFBQSxVQUVJL0YsT0FBTyxHQUFPLElBRmxCOztBQUlBLGFBQVFBLE9BQU8sR0FBR21GLEVBQUUsQ0FBQ00sSUFBSCxDQUFRSyxHQUFSLENBQWxCLEVBQWlDO0FBQzdCQyxnQkFBUSxDQUFDL0YsT0FBTyxDQUFDLENBQUQsQ0FBUixDQUFSLEdBQXVCLElBQUkyRSxNQUFKLENBQVcsU0FBUzNFLE9BQU8sQ0FBQyxDQUFELENBQWhCLEdBQXNCLEdBQWpDLEVBQXNDLEdBQXRDLENBQXZCO0FBQ0g7O0FBRUQsYUFBTyxVQUFTZ0csSUFBVCxFQUFlO0FBQ2xCLFlBQUlqYixHQUFHLEdBQU8sRUFBZDtBQUFBLFlBQ0lnWSxNQUFNLEdBQUkrQyxHQURkO0FBR0FFLFlBQUksR0FBR0EsSUFBSSxJQUFJLEVBQWY7O0FBRUEsYUFBS2piLEdBQUwsSUFBWWdiLFFBQVosRUFBc0I7QUFDbEJoRCxnQkFBTSxHQUFHQSxNQUFNLENBQUNqQixPQUFQLENBQWVpRSxRQUFRLENBQUNoYixHQUFELENBQXZCLEVBQThCLE9BQU9pYixJQUFJLENBQUNqYixHQUFELENBQVgsS0FBcUIsV0FBckIsR0FBbUNpYixJQUFJLENBQUNqYixHQUFELENBQXZDLEdBQStDLEVBQTdFLENBQVQ7QUFDSDs7QUFFRCxlQUFPZ1ksTUFBUDtBQUNILE9BWEQ7QUFZSCxLQXRMRDs7QUF3TEE7Ozs7Ozs7O0FBU0FuVSxNQUFFLEVBQUUsWUFBU2dLLEVBQVQsRUFBYXhSLElBQWIsRUFBbUJnZCxFQUFuQixFQUF1QjZCLFVBQXZCLEVBQW1DO0FBQ25DLFVBQUksQ0FBQ3JOLEVBQUwsRUFBUzs7QUFFVCxVQUFJQSxFQUFFLENBQUNHLGdCQUFQLEVBQXlCO0FBQ3JCSCxVQUFFLENBQUNHLGdCQUFILENBQW9CM1IsSUFBcEIsRUFBMEJnZCxFQUExQixFQUE4QjZCLFVBQTlCO0FBQ0gsT0FGRCxNQUVPLElBQUlyTixFQUFFLENBQUNzTixXQUFQLEVBQW9CO0FBQ3ZCdE4sVUFBRSxDQUFDLE1BQU14UixJQUFOLEdBQWFnZCxFQUFkLENBQUYsR0FBc0JBLEVBQXRCOztBQUVBeEwsVUFBRSxDQUFDeFIsSUFBSSxHQUFHZ2QsRUFBUixDQUFGLEdBQWdCLFlBQVc7QUFDdkJ4TCxZQUFFLENBQUMsTUFBTXhSLElBQU4sR0FBYWdkLEVBQWQsQ0FBRixDQUFvQnRQLE1BQU0sQ0FBQ2pHLEtBQTNCO0FBQ0gsU0FGRDs7QUFJQStKLFVBQUUsQ0FBQ3NOLFdBQUgsQ0FBZSxPQUFPOWUsSUFBdEIsRUFBNEJ3UixFQUFFLENBQUN4UixJQUFJLEdBQUdnZCxFQUFSLENBQTlCO0FBQ0g7QUFDSixLQS9NRDs7QUFpTkE7Ozs7Ozs7QUFRQXBMLE9BQUcsRUFBRSxhQUFTSixFQUFULEVBQWF4UixJQUFiLEVBQW1CZ2QsRUFBbkIsRUFBdUI7QUFDeEIsVUFBSSxDQUFDeEwsRUFBTCxFQUFTOztBQUVULFVBQUlBLEVBQUUsQ0FBQ0ssbUJBQVAsRUFBNEI7QUFDeEJMLFVBQUUsQ0FBQ0ssbUJBQUgsQ0FBdUI3UixJQUF2QixFQUE2QmdkLEVBQTdCLEVBQWlDLEtBQWpDO0FBQ0gsT0FGRCxNQUVPLElBQUl4TCxFQUFFLENBQUN1TixXQUFQLEVBQW9CO0FBQ3ZCdk4sVUFBRSxDQUFDdU4sV0FBSCxDQUFlLE9BQU8vZSxJQUF0QixFQUE0QndSLEVBQUUsQ0FBQ3hSLElBQUksR0FBR2dkLEVBQVIsQ0FBOUI7QUFDQXhMLFVBQUUsQ0FBQ3hSLElBQUksR0FBR2dkLEVBQVIsQ0FBRixHQUFnQixJQUFoQjtBQUNIO0FBQ0osS0FsT0Q7O0FBb09BOzs7Ozs7O0FBUUFnQyxrQkFBYyxFQUFFLHdCQUFTQyxTQUFULEVBQW9CQyxNQUFwQixFQUE0QnhELEdBQTVCLEVBQWlDO0FBQzdDLFVBQUlqVSxLQUFLLEdBQUcsSUFBWjtBQUVBaVUsU0FBRyxHQUFHQSxHQUFHLElBQUloTyxNQUFNLENBQUNZLFFBQXBCOztBQUVBLFVBQUksT0FBT1osTUFBTSxDQUFDeVIsV0FBZCxLQUE4QixVQUFsQyxFQUE4QztBQUMxQzFYLGFBQUssR0FBRyxJQUFJaUcsTUFBTSxDQUFDeVIsV0FBWCxDQUF1QkYsU0FBdkIsRUFBa0M7QUFDdENDLGdCQUFNLEVBQUVBLE1BRDhCO0FBRXRDRSxpQkFBTyxFQUFFLElBRjZCO0FBR3RDQyxvQkFBVSxFQUFFO0FBSDBCLFNBQWxDLENBQVI7QUFLSCxPQU5ELE1BTU8sSUFBSSxPQUFPM0QsR0FBRyxDQUFDNEQsV0FBWCxLQUEyQixVQUEvQixFQUEyQztBQUM5QzdYLGFBQUssR0FBR2lVLEdBQUcsQ0FBQzRELFdBQUosQ0FBZ0IsYUFBaEIsQ0FBUjtBQUNBN1gsYUFBSyxDQUFDOFgsZUFBTixDQUFzQk4sU0FBdEIsRUFBaUMsSUFBakMsRUFBdUMsSUFBdkMsRUFBNkNDLE1BQTdDO0FBQ0gsT0FITSxNQUdBO0FBQ0h6WCxhQUFLLEdBQUdpVSxHQUFHLENBQUM4RCxpQkFBSixFQUFSLEVBQ0EvWCxLQUFLLENBQUN6SCxJQUFOLEdBQWFpZixTQURiO0FBR0F4WCxhQUFLLENBQUNnWSxXQUFOLEdBQW9CLEtBQXBCO0FBQ0FoWSxhQUFLLENBQUNpWSxZQUFOLEdBQXFCLEtBQXJCO0FBQ0FqWSxhQUFLLENBQUN5WCxNQUFOLEdBQWVBLE1BQWY7QUFDSDs7QUFFRCxhQUFPelgsS0FBUDtBQUNILEtBcFFEOztBQXNRQTs7Ozs7QUFNQWtZLG9CQUFnQixFQUFFLDBCQUFTOUwsQ0FBVCxFQUFZO0FBQzFCLFVBQUlBLENBQUMsQ0FBQ2EsT0FBRixJQUFhYixDQUFDLENBQUNhLE9BQUYsQ0FBVXRSLE1BQTNCLEVBQW1DO0FBQy9CLGVBQU95USxDQUFDLENBQUNhLE9BQUYsQ0FBVSxDQUFWLENBQVA7QUFDSCxPQUZELE1BRU8sSUFBSWIsQ0FBQyxDQUFDc0MsY0FBRixJQUFvQnRDLENBQUMsQ0FBQ3NDLGNBQUYsQ0FBaUIvUyxNQUF6QyxFQUFpRDtBQUNwRCxlQUFPeVEsQ0FBQyxDQUFDc0MsY0FBRixDQUFpQixDQUFqQixDQUFQO0FBQ0gsT0FGTSxNQUVBO0FBQ0gsZUFBT3RDLENBQVA7QUFDSDtBQUNKLEtBcFJEOztBQXNSQTs7Ozs7O0FBT0FsTSxTQUFLLEVBQUUsZUFBUzZKLEVBQVQsRUFBYXJKLFFBQWIsRUFBdUI7QUFDMUIsVUFBSWhGLENBQUMsR0FBRyxDQUFSOztBQUVBLGFBQU8sQ0FBQ3FPLEVBQUUsR0FBR0EsRUFBRSxDQUFDb08sc0JBQVQsTUFBcUMsSUFBNUMsRUFBa0Q7QUFDOUMsWUFBSSxDQUFDelgsUUFBRCxJQUFhcUosRUFBRSxDQUFDb0gsT0FBSCxDQUFXelEsUUFBWCxDQUFqQixFQUF1QztBQUNuQyxZQUFFaEYsQ0FBRjtBQUNIO0FBQ0o7O0FBRUQsYUFBT0EsQ0FBUDtBQUNILEtBdlNEOztBQXlTQTs7Ozs7Ozs7QUFTQTBjLGFBQVMsRUFBRSxtQkFBU25CLEdBQVQsRUFBYztBQUNyQixhQUFPQSxHQUFHLENBQUNvQixXQUFKLEdBQWtCcEYsT0FBbEIsQ0FBMEIsY0FBMUIsRUFBMEMsVUFBU3FGLEVBQVQsRUFBYTtBQUMxRCxlQUFPQSxFQUFFLENBQUNDLFdBQUgsR0FBaUJ0RixPQUFqQixDQUF5QixNQUF6QixFQUFpQyxFQUFqQyxDQUFQO0FBQ0gsT0FGTSxDQUFQO0FBR0gsS0F0VEQ7O0FBd1RBOzs7Ozs7OztBQVNBdUYsY0FBVSxFQUFFLG9CQUFTdkIsR0FBVCxFQUFjO0FBQ3RCLGFBQU8sQ0FBQ0EsR0FBRyxHQUFHLEtBQUttQixTQUFMLENBQWVuQixHQUFmLENBQVAsRUFBNEJKLE1BQTVCLENBQW1DLENBQW5DLEVBQXNDMEIsV0FBdEMsS0FBc0R0QixHQUFHLENBQUMxUSxLQUFKLENBQVUsQ0FBVixDQUE3RDtBQUNILEtBblVEOztBQXFVQTs7Ozs7OztBQVFBa1MsWUFBUSxFQUFFLGtCQUFTeEIsR0FBVCxFQUFjO0FBQ3BCLGFBQU9BLEdBQUcsQ0FBQ2hFLE9BQUosQ0FBWSxVQUFaLEVBQXdCLEtBQXhCLEVBQStCQSxPQUEvQixDQUF1QyxJQUF2QyxFQUE2QyxFQUE3QyxFQUFpRG9GLFdBQWpELEVBQVA7QUFDSCxLQS9VRDs7QUFpVkE7Ozs7OztBQU9BaEUsYUFBUyxFQUFFLG1CQUFTdEssRUFBVCxFQUFha0ssR0FBYixFQUFrQjtBQUN6QkEsU0FBRyxHQUFHQSxHQUFHLElBQUloTyxNQUFNLENBQUNZLFFBQXBCOztBQUVBLFVBQ0laLE1BQU0sQ0FBQ0MsV0FBUCxJQUNBNkQsRUFBRSxZQUFZOUQsTUFBTSxDQUFDQyxXQUZ6QixFQUdFO0FBQ0UsZUFBTyxJQUFQO0FBQ0gsT0FMRCxNQUtPLElBQ0grTixHQUFHLENBQUN5RSxXQUFKLElBQ0F6RSxHQUFHLENBQUN5RSxXQUFKLENBQWdCeFMsV0FEaEIsSUFFQTZELEVBQUUsWUFBWWtLLEdBQUcsQ0FBQ3lFLFdBQUosQ0FBZ0J4UyxXQUgzQixFQUlMO0FBQ0UsZUFBTyxJQUFQO0FBQ0gsT0FOTSxNQU1BO0FBQ0gsZUFDSTZELEVBQUUsS0FBSyxJQUFQLElBQ0FBLEVBQUUsQ0FBQ2hFLFFBQUgsS0FBZ0IsQ0FEaEIsSUFFQSxPQUFPZ0UsRUFBRSxDQUFDNE8sUUFBVixLQUF1QixRQUgzQjtBQUtIO0FBQ0osS0E3V0Q7O0FBK1dBOzs7Ozs7QUFPQS9HLGlCQUFhLEVBQUUsdUJBQVNnSCxVQUFULEVBQXFCM0UsR0FBckIsRUFBMEI7QUFDckMsVUFBSTRFLElBQUksR0FBRyxJQUFYO0FBQUEsVUFDSUMsSUFBSSxHQUFHLElBRFg7QUFHQTdFLFNBQUcsR0FBR0EsR0FBRyxJQUFJaE8sTUFBTSxDQUFDWSxRQUFwQjtBQUVBZ1MsVUFBSSxHQUFHNUUsR0FBRyxDQUFDOEUsc0JBQUosRUFBUDtBQUNBRCxVQUFJLEdBQUc3RSxHQUFHLENBQUNyQyxhQUFKLENBQWtCLEtBQWxCLENBQVA7QUFFQWtILFVBQUksQ0FBQ0UsU0FBTCxHQUFpQkosVUFBVSxDQUFDNUYsSUFBWCxFQUFqQjs7QUFFQSxhQUFPOEYsSUFBSSxDQUFDbFQsVUFBWixFQUF3QjtBQUNwQmlULFlBQUksQ0FBQ3JQLFdBQUwsQ0FBaUJzUCxJQUFJLENBQUNsVCxVQUF0QjtBQUNIOztBQUVELGFBQU9pVCxJQUFQO0FBQ0gsS0F0WUQ7O0FBd1lBOzs7OztBQU1BSSxvQkFBZ0IsRUFBRSwwQkFBU3hULElBQVQsRUFBZTtBQUM3QixVQUFJeVQsUUFBSjs7QUFFQSxhQUFPelQsSUFBSSxJQUFJQSxJQUFJLENBQUNrVCxRQUFMLEtBQWtCLE9BQWpDLEVBQTBDO0FBQ3RDTyxnQkFBUSxHQUFHelQsSUFBWDtBQUVBQSxZQUFJLEdBQUdBLElBQUksQ0FBQzBULGVBQVo7QUFFQUQsZ0JBQVEsQ0FBQzVHLGFBQVQsSUFBMEI0RyxRQUFRLENBQUM1RyxhQUFULENBQXVCMUksV0FBdkIsQ0FBbUNzUCxRQUFuQyxDQUExQjtBQUNIO0FBQ0osS0F4WkQ7O0FBMFpBOzs7Ozs7QUFPQUUsZ0JBQVksRUFBRSxzQkFBU0MsQ0FBVCxFQUFZQyxDQUFaLEVBQWU7QUFDekIsVUFBSTVkLENBQUMsR0FBRzJkLENBQUMsQ0FBQzFkLE1BQVY7QUFFQSxVQUFJRCxDQUFDLEtBQUs0ZCxDQUFDLENBQUMzZCxNQUFaLEVBQW9CLE9BQU8sS0FBUDs7QUFFcEIsYUFBT0QsQ0FBQyxFQUFSLEVBQVk7QUFDUixZQUFJMmQsQ0FBQyxDQUFDM2QsQ0FBRCxDQUFELEtBQVM0ZCxDQUFDLENBQUM1ZCxDQUFELENBQWQsRUFBbUIsT0FBTyxLQUFQO0FBQ3RCOztBQUVELGFBQU8sSUFBUDtBQUNILEtBM2FEOztBQTZhQTs7Ozs7O0FBT0E2ZCxjQUFVLEVBQUUsb0JBQVNGLENBQVQsRUFBWUMsQ0FBWixFQUFlO0FBQ3ZCLFVBQUlwZCxHQUFKOztBQUVBLFVBQUksUUFBT21kLENBQVAsTUFBYSxRQUFiLElBQXlCQSxDQUF6QixJQUE4QixRQUFPQyxDQUFQLE1BQWEsUUFBM0MsSUFBdURBLENBQTNELEVBQThEO0FBQzFELFlBQUl0ZCxNQUFNLENBQUNxRCxJQUFQLENBQVlnYSxDQUFaLEVBQWUxZCxNQUFmLEtBQTBCSyxNQUFNLENBQUNxRCxJQUFQLENBQVlpYSxDQUFaLEVBQWUzZCxNQUE3QyxFQUFxRCxPQUFPLEtBQVA7O0FBRXJELGFBQUtPLEdBQUwsSUFBWW1kLENBQVosRUFBZTtBQUNYLGNBQUksQ0FBQ0MsQ0FBQyxDQUFDN2MsY0FBRixDQUFpQlAsR0FBakIsQ0FBRCxJQUEwQixDQUFDLEtBQUtxZCxVQUFMLENBQWdCRixDQUFDLENBQUNuZCxHQUFELENBQWpCLEVBQXdCb2QsQ0FBQyxDQUFDcGQsR0FBRCxDQUF6QixDQUEvQixFQUFnRSxPQUFPLEtBQVA7QUFDbkU7QUFDSixPQU5ELE1BTU8sSUFBSW1kLENBQUMsS0FBS0MsQ0FBVixFQUFhO0FBQ2hCLGVBQU8sS0FBUDtBQUNIOztBQUVELGFBQU8sSUFBUDtBQUNILEtBbGNEOztBQW9jQTs7Ozs7QUFNQUUsZ0JBQVksRUFBRSxzQkFBU0MsUUFBVCxFQUFtQjtBQUM3QixVQUFJQyxRQUFRLEdBQU1ELFFBQVEsQ0FBQ2xULEtBQVQsRUFBbEI7QUFBQSxVQUNJdkIsR0FBRyxHQUFXMFUsUUFBUSxDQUFDL2QsTUFEM0I7QUFBQSxVQUVJRCxDQUFDLEdBQWFzSixHQUZsQjtBQUFBLFVBR0kyVSxDQUFDLEdBQWEsQ0FBQyxDQUhuQjtBQUFBLFVBSUk3UyxDQUFDLEdBQWEsRUFKbEI7O0FBTUEsYUFBT3BMLENBQUMsRUFBUixFQUFZO0FBQ1JpZSxTQUFDLEdBQUcsQ0FBQyxFQUFFdlcsSUFBSSxDQUFDd1csTUFBTCxLQUFnQjVVLEdBQWxCLENBQUw7QUFDQThCLFNBQUMsR0FBRzRTLFFBQVEsQ0FBQ2hlLENBQUQsQ0FBWjtBQUVBZ2UsZ0JBQVEsQ0FBQ2hlLENBQUQsQ0FBUixHQUFjZ2UsUUFBUSxDQUFDQyxDQUFELENBQXRCO0FBQ0FELGdCQUFRLENBQUNDLENBQUQsQ0FBUixHQUFjN1MsQ0FBZDtBQUNIOztBQUVELGFBQU80UyxRQUFQO0FBQ0gsS0ExZEQ7O0FBNGRBOzs7O0FBS0FHLGlCQUFhLEVBQUUsdUJBQVNDLElBQVQsRUFBZTtBQUMxQixVQUFJNUYsTUFBSixFQUFZeFksQ0FBWjs7QUFFQSxVQUFJO0FBQ0EsZUFBT2dELEtBQUssQ0FBQ3pELFNBQU4sQ0FBZ0JzTCxLQUFoQixDQUFzQjdKLElBQXRCLENBQTJCb2QsSUFBM0IsQ0FBUDtBQUNILE9BRkQsQ0FFRSxPQUFNbkcsR0FBTixFQUFXO0FBQ1RPLGNBQU0sR0FBRyxFQUFUOztBQUVBLGFBQUt4WSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdvZSxJQUFJLENBQUNuZSxNQUFyQixFQUE2QkQsQ0FBQyxFQUE5QixFQUFrQztBQUM5QndZLGdCQUFNLENBQUMvVCxJQUFQLENBQVkyWixJQUFJLENBQUNwZSxDQUFELENBQWhCO0FBQ0g7O0FBRUQsZUFBT3dZLE1BQVA7QUFDSDtBQUNKLEtBL2VEOztBQWlmQTs7Ozs7OztBQVFBNkYsWUFBUSxFQUFFLGtCQUFTalcsSUFBVCxFQUFlQyxJQUFmLEVBQXFCaVcsU0FBckIsRUFBZ0M7QUFDdEMsVUFBSWhXLE9BQUo7QUFFQSxhQUFPLFlBQVc7QUFDZCxZQUFJbEcsSUFBSSxHQUFPLElBQWY7QUFBQSxZQUNJbUcsSUFBSSxHQUFPMUgsU0FEZjtBQUFBLFlBRUkwZCxPQUFPLEdBQUlELFNBQVMsSUFBSSxDQUFDaFcsT0FGN0I7QUFBQSxZQUdJSSxLQUFLLEdBQU0sSUFIZjs7QUFLQUEsYUFBSyxHQUFHLGlCQUFXO0FBQ2ZKLGlCQUFPLEdBQUksSUFBWDs7QUFFQSxjQUFJLENBQUNnVyxTQUFMLEVBQWdCO0FBQ1psVyxnQkFBSSxDQUFDUSxLQUFMLENBQVd4RyxJQUFYLEVBQWlCbUcsSUFBakI7QUFDSDtBQUNKLFNBTkQ7O0FBUUFTLG9CQUFZLENBQUNWLE9BQUQsQ0FBWjtBQUVBQSxlQUFPLEdBQUdZLFVBQVUsQ0FBQ1IsS0FBRCxFQUFRTCxJQUFSLENBQXBCO0FBRUEsWUFBSWtXLE9BQUosRUFBYW5XLElBQUksQ0FBQ1EsS0FBTCxDQUFXeEcsSUFBWCxFQUFpQm1HLElBQWpCO0FBQ2hCLE9BbkJEO0FBb0JILEtBaGhCRDs7QUFraEJBOzs7OztBQU1BaVcsWUFBUSxFQUFFLGtCQUFTQyxPQUFULEVBQWtCO0FBQ3hCLFVBQUlDLFNBQVMsR0FBUyxDQUF0QjtBQUFBLFVBQ0lDLFNBQVMsR0FBUyxDQUR0QjtBQUFBLFVBRUlDLFlBQVksR0FBTUgsT0FGdEI7O0FBSUEsYUFBT0EsT0FBUCxFQUFnQjtBQUNaQyxpQkFBUyxJQUFJRCxPQUFPLENBQUNJLFVBQXJCO0FBQ0FGLGlCQUFTLElBQUlGLE9BQU8sQ0FBQ0ssU0FBckI7O0FBRUEsWUFBSUwsT0FBTyxLQUFLRyxZQUFoQixFQUE4QjtBQUMxQkYsbUJBQVMsSUFBSUQsT0FBTyxDQUFDTSxVQUFyQjtBQUNBSixtQkFBUyxJQUFJRixPQUFPLENBQUNPLFNBQXJCO0FBRUFKLHNCQUFZLEdBQUdILE9BQU8sQ0FBQ0csWUFBdkI7QUFDSDs7QUFFREgsZUFBTyxHQUFHQSxPQUFPLENBQUM3SCxhQUFsQjtBQUNIOztBQUVELGFBQU87QUFDSHFJLFNBQUMsRUFBRVAsU0FEQTtBQUVIUSxTQUFDLEVBQUVQO0FBRkEsT0FBUDtBQUlILEtBL2lCRDs7QUFpakJBOzs7Ozs7QUFPQVEsaUJBQWEsRUFBRSx1QkFBU0MsS0FBVCxFQUFnQkMsS0FBaEIsRUFBdUI7QUFDbEMsVUFBSUMsU0FBUyxHQUFHRixLQUFLLENBQUNILENBQU4sR0FBVUksS0FBSyxDQUFDSixDQUFoQztBQUFBLFVBQ0lNLFNBQVMsR0FBR0gsS0FBSyxDQUFDRixDQUFOLEdBQVVHLEtBQUssQ0FBQ0gsQ0FEaEM7QUFHQUksZUFBUyxHQUFHQSxTQUFTLEdBQUcsQ0FBWixHQUFnQkEsU0FBUyxHQUFHLENBQUMsQ0FBN0IsR0FBaUNBLFNBQTdDLEVBQ0FDLFNBQVMsR0FBR0EsU0FBUyxHQUFHLENBQVosR0FBZ0JBLFNBQVMsR0FBRyxDQUFDLENBQTdCLEdBQWlDQSxTQUQ3QztBQUdBLGFBQU83WCxJQUFJLENBQUN3SyxJQUFMLENBQVV4SyxJQUFJLENBQUM4WCxHQUFMLENBQVNGLFNBQVQsRUFBb0IsQ0FBcEIsSUFBeUI1WCxJQUFJLENBQUM4WCxHQUFMLENBQVNELFNBQVQsRUFBb0IsQ0FBcEIsQ0FBbkMsQ0FBUDtBQUNILEtBaGtCRDs7QUFra0JBOzs7Ozs7Ozs7QUFVQUUsd0JBQW9CLEVBQUUsOEJBQVNDLElBQVQsRUFBZUMsSUFBZixFQUFxQjtBQUN2QyxVQUFJQyxXQUFXLEdBQVdGLElBQUksQ0FBQzVULEtBQUwsR0FBYTRULElBQUksQ0FBQ0csTUFBNUM7QUFBQSxVQUNJQyxhQUFhLEdBQVMsQ0FBQyxDQUQzQjtBQUFBLFVBRUlDLGFBQWEsR0FBUyxDQUFDLENBRjNCO0FBQUEsVUFHSUMsZ0JBQWdCLEdBQU0sQ0FBQyxDQUgzQjtBQUFBLFVBSUlDLEtBQUssR0FBaUIsQ0FBQyxDQUozQjtBQU1BSCxtQkFBYSxHQUNUcFksSUFBSSxDQUFDeUYsR0FBTCxDQUFTLENBQVQsRUFBWXpGLElBQUksQ0FBQ0MsR0FBTCxDQUFTK1gsSUFBSSxDQUFDUSxJQUFMLEdBQVlSLElBQUksQ0FBQzVULEtBQTFCLEVBQWlDNlQsSUFBSSxDQUFDTyxJQUFMLEdBQVlQLElBQUksQ0FBQzdULEtBQWxELElBQTJEcEUsSUFBSSxDQUFDeUYsR0FBTCxDQUFTdVMsSUFBSSxDQUFDUSxJQUFkLEVBQW9CUCxJQUFJLENBQUNPLElBQXpCLENBQXZFLENBREo7QUFHQUgsbUJBQWEsR0FDVHJZLElBQUksQ0FBQ3lGLEdBQUwsQ0FBUyxDQUFULEVBQVl6RixJQUFJLENBQUNDLEdBQUwsQ0FBUytYLElBQUksQ0FBQ1MsR0FBTCxHQUFXVCxJQUFJLENBQUNHLE1BQXpCLEVBQWlDRixJQUFJLENBQUNRLEdBQUwsR0FBV1IsSUFBSSxDQUFDRSxNQUFqRCxJQUEyRG5ZLElBQUksQ0FBQ3lGLEdBQUwsQ0FBU3VTLElBQUksQ0FBQ1MsR0FBZCxFQUFtQlIsSUFBSSxDQUFDUSxHQUF4QixDQUF2RSxDQURKO0FBR0FILHNCQUFnQixHQUFHRCxhQUFhLEdBQUdELGFBQW5DO0FBRUFHLFdBQUssR0FBR0QsZ0JBQWdCLEdBQUdKLFdBQTNCO0FBRUEsYUFBT0ssS0FBUDtBQUNILEtBOWxCRDs7QUFnbUJBOzs7Ozs7OztBQVNBRyxpQkFBYSxFQUFFLHVCQUFTL1IsRUFBVCxFQUFhckosUUFBYixFQUF1QnFiLFdBQXZCLEVBQW9DOUgsR0FBcEMsRUFBeUM7QUFDcEQsVUFBSTlXLE1BQU0sR0FBSTRNLEVBQUUsQ0FBQ3JFLFVBQWpCO0FBRUF1TyxTQUFHLEdBQUdBLEdBQUcsSUFBSWhPLE1BQU0sQ0FBQ1ksUUFBcEI7O0FBRUEsVUFBSWtWLFdBQVcsSUFBSWhTLEVBQUUsQ0FBQ29ILE9BQUgsQ0FBV3pRLFFBQVgsQ0FBbkIsRUFBeUM7QUFDckMsZUFBT3FKLEVBQVA7QUFDSDs7QUFFRCxhQUFPNU0sTUFBTSxJQUFJQSxNQUFNLElBQUk4VyxHQUFHLENBQUMrSCxJQUEvQixFQUFxQztBQUNqQyxZQUFJN2UsTUFBTSxDQUFDZ1UsT0FBUCxJQUFrQmhVLE1BQU0sQ0FBQ2dVLE9BQVAsQ0FBZXpRLFFBQWYsQ0FBdEIsRUFBZ0Q7QUFDNUMsaUJBQU92RCxNQUFQO0FBQ0gsU0FGRCxNQUVPLElBQUlBLE1BQU0sQ0FBQ3VJLFVBQVgsRUFBdUI7QUFDMUJ2SSxnQkFBTSxHQUFHQSxNQUFNLENBQUN1SSxVQUFoQjtBQUNILFNBRk0sTUFFQTtBQUNILGlCQUFPLElBQVA7QUFDSDtBQUNKOztBQUVELGFBQU8sSUFBUDtBQUNILEtBN25CRDs7QUErbkJBOzs7Ozs7O0FBUUFILFlBQVEsRUFBRSxrQkFBU3dFLEVBQVQsRUFBYXJKLFFBQWIsRUFBdUJ1VCxHQUF2QixFQUE0QjtBQUNsQyxVQUFJMU8sUUFBUSxHQUFNLEVBQWxCO0FBQUEsVUFDSTBXLE1BQU0sR0FBUSxFQURsQjtBQUdBaEksU0FBRyxHQUFHQSxHQUFHLElBQUloTyxNQUFNLENBQUNnTyxHQUFwQjs7QUFFQSxVQUFJbEssRUFBSixFQUFRO0FBQ0osWUFBSSxDQUFDQSxFQUFFLENBQUNxSyxFQUFSLEVBQVk7QUFDUjZILGdCQUFNLEdBQUcsU0FBUyxLQUFLQyxZQUFMLEVBQWxCO0FBRUFuUyxZQUFFLENBQUNxSyxFQUFILEdBQVE2SCxNQUFSO0FBQ0g7O0FBRUQxVyxnQkFBUSxHQUFHME8sR0FBRyxDQUFDL0UsZ0JBQUosQ0FBcUIsTUFBTW5GLEVBQUUsQ0FBQ3FLLEVBQVQsR0FBYyxLQUFkLEdBQXNCMVQsUUFBM0MsQ0FBWDs7QUFFQSxZQUFJdWIsTUFBSixFQUFZO0FBQ1JsUyxZQUFFLENBQUN5RixlQUFILENBQW1CLElBQW5CO0FBQ0g7QUFDSjs7QUFFRCxhQUFPakssUUFBUDtBQUNILEtBNXBCRDs7QUE4cEJBOzs7Ozs7O0FBUUE0VyxTQUFLLEVBQUUsZUFBU0MsYUFBVCxFQUF3QjtBQUMzQixVQUFJQyxVQUFVLEdBQUcsRUFBakI7QUFBQSxVQUNJM2dCLENBQUMsR0FBRyxDQUFDLENBRFQ7O0FBR0EsV0FBS0EsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHMGdCLGFBQWEsQ0FBQ3pnQixNQUE5QixFQUFzQ0QsQ0FBQyxFQUF2QyxFQUEyQztBQUN2QyxZQUFJMGdCLGFBQWEsQ0FBQzFnQixDQUFELENBQWIsS0FBcUIsRUFBekIsRUFBNkI7QUFDekIyZ0Isb0JBQVUsQ0FBQ2xjLElBQVgsQ0FBZ0JpYyxhQUFhLENBQUMxZ0IsQ0FBRCxDQUE3QjtBQUNIO0FBQ0o7O0FBRUQsYUFBTzJnQixVQUFQO0FBQ0gsS0FqckJEOztBQW1yQkE7Ozs7Ozs7QUFRQUMsU0FBSyxFQUFFLGVBQVM3RyxTQUFULEVBQW9CO0FBQ3ZCLFVBQUk4RyxRQUFRLEdBQVMsSUFBckI7QUFBQSxVQUNJQyxjQUFjLEdBQUcsSUFEckI7QUFBQSxVQUVJOUcsQ0FBQyxHQUFnQixJQUZyQjtBQUlBOEcsb0JBQWMsR0FBRyxJQUFJLEtBQUtDLFFBQVQsRUFBakI7O0FBRUEsVUFBSWpMLFFBQU8sQ0FBQ2tMLFFBQVIsQ0FBaUJDLEdBQWpCLENBQXFCQyxRQUF6QixFQUFtQztBQUMvQjtBQUVBSixzQkFBYyxDQUFDSyxPQUFmLEdBQXlCLElBQUlDLE9BQUosQ0FBWSxVQUFTblMsT0FBVCxFQUFrQm9TLE1BQWxCLEVBQTBCO0FBQzNEUCx3QkFBYyxDQUFDN1IsT0FBZixHQUF5QkEsT0FBekI7QUFDQTZSLHdCQUFjLENBQUNPLE1BQWYsR0FBeUJBLE1BQXpCO0FBQ0gsU0FId0IsQ0FBekI7QUFJSCxPQVBELE1BT08sSUFBSSxDQUFDckgsQ0FBQyxHQUFJelAsTUFBTSxDQUFDK1csTUFBUCxJQUFpQnZILFNBQVMsQ0FBQ0MsQ0FBakMsS0FBd0MsT0FBT0EsQ0FBQyxDQUFDK0csUUFBVCxLQUFzQixVQUFsRSxFQUE4RTtBQUNqRjtBQUVBRixnQkFBUSxHQUFHN0csQ0FBQyxDQUFDK0csUUFBRixFQUFYO0FBRUFELHNCQUFjLENBQUNLLE9BQWYsR0FBeUJOLFFBQVEsQ0FBQ00sT0FBVCxFQUF6QjtBQUNBTCxzQkFBYyxDQUFDN1IsT0FBZixHQUF5QjRSLFFBQVEsQ0FBQzVSLE9BQWxDO0FBQ0E2UixzQkFBYyxDQUFDTyxNQUFmLEdBQXlCUixRQUFRLENBQUNRLE1BQWxDO0FBQ0gsT0FSTSxNQVFBLElBQUk5VyxNQUFNLENBQUN2TCxPQUFYLEVBQW9CO0FBQ3ZCO0FBRUFBLGVBQU8sQ0FBQ0YsSUFBUixDQUFhZ1gsUUFBTyxDQUFDK0MsUUFBUixDQUFpQjBJLDhCQUFqQixFQUFiO0FBQ0g7O0FBRUQsYUFBT1QsY0FBUDtBQUNILEtBeHRCRDs7QUEwdEJBOzs7Ozs7QUFPQVUsT0FBRyxFQUFFLGFBQVNDLEtBQVQsRUFBZ0IxSCxTQUFoQixFQUEyQjtBQUM1QixVQUFJQyxDQUFDLEdBQUcsSUFBUjs7QUFFQSxVQUFJbEUsUUFBTyxDQUFDa0wsUUFBUixDQUFpQkMsR0FBakIsQ0FBcUJDLFFBQXpCLEVBQW1DO0FBQy9CLGVBQU9FLE9BQU8sQ0FBQ0ksR0FBUixDQUFZQyxLQUFaLENBQVA7QUFDSCxPQUZELE1BRU8sSUFBSSxDQUFDekgsQ0FBQyxHQUFJelAsTUFBTSxDQUFDK1csTUFBUCxJQUFpQnZILFNBQVMsQ0FBQ0MsQ0FBakMsS0FBd0MsT0FBT0EsQ0FBQyxDQUFDMEgsSUFBVCxLQUFrQixVQUE5RCxFQUEwRTtBQUM3RSxlQUFPMUgsQ0FBQyxDQUFDMEgsSUFBRixDQUFPOVksS0FBUCxDQUFhb1IsQ0FBYixFQUFnQnlILEtBQWhCLEVBQ0ZFLElBREUsQ0FDRyxZQUFXO0FBQ2I7QUFFQSxpQkFBTzlnQixTQUFQO0FBQ0gsU0FMRSxDQUFQO0FBTUgsT0FaMkIsQ0FjNUI7OztBQUVBLFVBQUkwSixNQUFNLENBQUN2TCxPQUFYLEVBQW9CO0FBQ2hCQSxlQUFPLENBQUNGLElBQVIsQ0FBYWdYLFFBQU8sQ0FBQytDLFFBQVIsQ0FBaUIwSSw4QkFBakIsRUFBYjtBQUNIOztBQUVELGFBQU8sRUFBUDtBQUNILEtBdHZCRDs7QUF3dkJBOzs7Ozs7O0FBUUFLLGFBQVMsRUFBRSxtQkFBU3ZULEVBQVQsRUFBYWxOLFFBQWIsRUFBdUIwZ0IsT0FBdkIsRUFBZ0M7QUFDdkMsVUFBSTdoQixDQUFDLEdBQVMsQ0FBQyxDQUFmO0FBQUEsVUFDSThoQixNQUFNLEdBQUksRUFEZDtBQUdBLFVBQUkvTCxDQUFDLENBQUNnSCxRQUFGLENBQVc1YixRQUFYLEtBQXdCa04sRUFBRSxDQUFDOUUsS0FBL0IsRUFBc0MsT0FBTyxFQUFQOztBQUV0QyxXQUFLdkosQ0FBQyxHQUFHLENBQVQsRUFBWThoQixNQUFNLEdBQUdELE9BQU8sQ0FBQzdoQixDQUFELENBQTVCLEVBQWlDQSxDQUFDLEVBQWxDLEVBQXNDO0FBQ2xDLFlBQUk4aEIsTUFBTSxHQUFHM2dCLFFBQVQsSUFBcUJrTixFQUFFLENBQUM5RSxLQUE1QixFQUFtQztBQUMvQixpQkFBT3VZLE1BQU0sQ0FBQ25GLFdBQVAsRUFBUDtBQUNIO0FBQ0o7O0FBRUQsYUFBTyxhQUFQO0FBQ0gsS0E3d0JEOztBQSt3QkE7Ozs7QUFLQTNELGFBQVMsRUFBRSxxQkFBVztBQUNsQixhQUFPLENBQUMsVUFBVSxDQUFDdFIsSUFBSSxDQUFDd1csTUFBTCxLQUFnQixRQUFoQixJQUE0QixDQUE3QixFQUFnQ2xILFFBQWhDLENBQXlDLEVBQXpDLENBQVgsRUFBeURsUCxNQUF6RCxDQUFnRSxDQUFDLENBQWpFLEVBQW9FK1UsV0FBcEUsRUFBUDtBQUNILEtBdHhCRDs7QUF3eEJBOzs7OztBQU1Ba0Ysb0JBQWdCLEVBQUUsMEJBQVN4SixHQUFULEVBQWM7QUFDNUJBLFNBQUcsR0FBRyxRQUFPQSxHQUFHLENBQUMrSCxJQUFYLE1BQW9CLFFBQXBCLEdBQStCL0gsR0FBL0IsR0FBcUNoTyxNQUFNLENBQUNZLFFBQWxEO0FBRUEsYUFBTztBQUNIMlQsaUJBQVMsRUFBRXZVLE1BQU0sQ0FBQ3lYLFdBRGY7QUFFSG5ELGtCQUFVLEVBQUV0VSxNQUFNLENBQUMwWCxXQUZoQjtBQUdIQyxpQkFBUyxFQUFFM0osR0FBRyxDQUFDNEosZUFBSixDQUFvQkMsWUFINUI7QUFJSEMsZ0JBQVEsRUFBRTlKLEdBQUcsQ0FBQzRKLGVBQUosQ0FBb0JHLFdBSjNCO0FBS0hDLHNCQUFjLEVBQUVoSyxHQUFHLENBQUM0SixlQUFKLENBQW9CSyxZQUxqQztBQU1IQyxxQkFBYSxFQUFFbEssR0FBRyxDQUFDNEosZUFBSixDQUFvQk87QUFOaEMsT0FBUDtBQVFILEtBenlCRDs7QUEyeUJBOzs7Ozs7QUFPQTdULFFBQUksRUFBRSxjQUFTeFAsR0FBVCxFQUFjd2EsRUFBZCxFQUFrQjtBQUNwQixhQUFPLFlBQVc7QUFDZCxlQUFPQSxFQUFFLENBQUNqUixLQUFILENBQVN2SixHQUFULEVBQWN3QixTQUFkLENBQVA7QUFDSCxPQUZEO0FBR0gsS0F0ekJEOztBQXd6QkE7Ozs7O0FBTUE4aEIsYUFBUyxFQUFFLG1CQUFTdFUsRUFBVCxFQUFhO0FBQ3BCLFVBQUl1VSxNQUFNLEdBQUcsSUFBYjtBQUVBLFVBQUl2VSxFQUFFLENBQUN1USxZQUFQLEVBQXFCLE9BQU8sSUFBUDtBQUVyQmdFLFlBQU0sR0FBR3JZLE1BQU0sQ0FBQ3NZLGdCQUFQLENBQXdCeFUsRUFBeEIsQ0FBVDs7QUFFQSxVQUNJdVUsTUFBTSxDQUFDcEUsUUFBUCxLQUFvQixPQUFwQixJQUNBb0UsTUFBTSxDQUFDRSxVQUFQLEtBQXNCLFFBRHRCLElBRUFGLE1BQU0sQ0FBQ0csT0FBUCxLQUFtQixHQUh2QixFQUlFO0FBQ0U7QUFDQTtBQUVBLGVBQU8sSUFBUDtBQUNIOztBQUVELGFBQU8sS0FBUDtBQUNILEtBajFCRDs7QUFtMUJBOzs7O0FBS0FDLFFBQUksRUFBRSxjQUFTM2pCLEdBQVQsRUFBYztBQUNoQixVQUFJLE9BQU9pQixNQUFNLENBQUMwaUIsSUFBZCxLQUF1QixVQUEzQixFQUF1QztBQUNuQzFpQixjQUFNLENBQUMwaUIsSUFBUCxDQUFZM2pCLEdBQVo7QUFDSDtBQUNKLEtBNTFCRDs7QUE4MUJBOzs7O0FBS0E0akIsVUFBTSxFQUFFLGdCQUFTNWpCLEdBQVQsRUFBYztBQUNsQixVQUFJLE9BQU9pQixNQUFNLENBQUMyaUIsTUFBZCxLQUF5QixVQUE3QixFQUF5QztBQUNyQzNpQixjQUFNLENBQUMyaUIsTUFBUCxDQUFjNWpCLEdBQWQ7QUFDSDtBQUNKLEtBdjJCRDs7QUF5MkJBOzs7Ozs7QUFPQTZqQixtQkFBZSxFQUFFLHlCQUFTQyxPQUFULEVBQWtCQyxRQUFsQixFQUE0QjtBQUN6QyxVQUFJQyxZQUFZLEdBQU1GLE9BQU8sQ0FBQ2hVLEtBQVIsQ0FBYyxHQUFkLENBQXRCO0FBQUEsVUFDSW1VLGFBQWEsR0FBS0YsUUFBUSxDQUFDalUsS0FBVCxDQUFlLEdBQWYsQ0FEdEI7QUFBQSxVQUVJb1UsV0FBVyxHQUFPLENBQUMsQ0FGdkI7QUFBQSxVQUdJQyxZQUFZLEdBQU0sQ0FBQyxDQUh2QjtBQUFBLFVBSUl4akIsQ0FBQyxHQUFpQixDQUFDLENBSnZCOztBQU1BLFdBQUtBLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR3FqQixZQUFZLENBQUNwakIsTUFBN0IsRUFBcUNELENBQUMsRUFBdEMsRUFBMEM7QUFDdEN1akIsbUJBQVcsR0FBT2hoQixRQUFRLENBQUM4Z0IsWUFBWSxDQUFDcmpCLENBQUQsQ0FBWixDQUFnQnVYLE9BQWhCLENBQXdCLFNBQXhCLEVBQW1DLEVBQW5DLENBQUQsQ0FBMUI7QUFDQWlNLG9CQUFZLEdBQU1qaEIsUUFBUSxDQUFDK2dCLGFBQWEsQ0FBQ3RqQixDQUFELENBQWIsQ0FBaUJ1WCxPQUFqQixDQUF5QixTQUF6QixFQUFvQyxFQUFwQyxLQUEyQyxDQUE1QyxDQUExQjs7QUFFQSxZQUFJaU0sWUFBWSxHQUFHRCxXQUFuQixFQUFnQztBQUM1QixpQkFBTyxLQUFQO0FBQ0gsU0FGRCxNQUVPLElBQUlDLFlBQVksR0FBR0QsV0FBbkIsRUFBZ0M7QUFDbkMsaUJBQU8sSUFBUDtBQUNIO0FBQ0o7O0FBRUQsYUFBTyxJQUFQO0FBQ0gsS0FuNEJEOztBQXE0QkE7Ozs7QUFLQXhDLFlBQVEsRUFBRSxvQkFBVztBQUNqQixXQUFLSSxPQUFMLEdBQWtCLElBQWxCO0FBQ0EsV0FBS2xTLE9BQUwsR0FBa0IsSUFBbEI7QUFDQSxXQUFLb1MsTUFBTCxHQUFrQixJQUFsQjtBQUNBLFdBQUszSSxFQUFMLEdBQWtCM0MsQ0FBQyxDQUFDaUQsU0FBRixFQUFsQjtBQUNILEtBLzRCRDs7QUFpNUJBOzs7OztBQU1BeUssaUJBQWEsRUFBRSx1QkFBU3BrQixHQUFULEVBQWM7QUFDekIsVUFBSW1CLEdBQUcsR0FBRyxFQUFWOztBQUVBLFVBQUksT0FBT0YsTUFBTSxDQUFDcUQsSUFBZCxLQUF1QixVQUEzQixFQUF1QztBQUNuQyxlQUFPckQsTUFBTSxDQUFDcUQsSUFBUCxDQUFZdEUsR0FBWixFQUFpQlksTUFBakIsS0FBNEIsQ0FBbkM7QUFDSDs7QUFFRCxXQUFLTyxHQUFMLElBQVluQixHQUFaLEVBQWlCO0FBQ2IsWUFBSUEsR0FBRyxDQUFDMEIsY0FBSixDQUFtQlAsR0FBbkIsQ0FBSixFQUE2QjtBQUN6QixpQkFBTyxLQUFQO0FBQ0g7QUFDSjs7QUFFRCxhQUFPLElBQVA7QUFDSCxLQXI2QkQ7O0FBdTZCQTs7Ozs7O0FBT0FrakIsZ0JBQVksRUFBRSxzQkFBU0MsVUFBVCxFQUFxQkMsV0FBckIsRUFBa0NDLFFBQWxDLEVBQTRDO0FBQ3RELFVBQUlDLFNBQVMsR0FBRyxFQUFoQjtBQUVBQSxlQUFTLElBQUlILFVBQVUsQ0FBQ0ksS0FBeEI7O0FBRUEsVUFBSUQsU0FBUyxDQUFDN2pCLE1BQWQsRUFBc0I7QUFDbEI2akIsaUJBQVMsSUFBSUgsVUFBVSxDQUFDSyxpQkFBeEI7QUFDSDs7QUFFREYsZUFBUyxJQUFJSCxVQUFVLENBQUMsWUFBWSxLQUFLN0csVUFBTCxDQUFnQjhHLFdBQWhCLENBQWIsQ0FBdkI7QUFFQSxVQUFJLENBQUNDLFFBQUwsRUFBZSxPQUFPQyxTQUFQOztBQUVmLFVBQUlBLFNBQVMsQ0FBQzdqQixNQUFkLEVBQXNCO0FBQ2xCNmpCLGlCQUFTLElBQUlILFVBQVUsQ0FBQ00sa0JBQXhCO0FBQ0g7O0FBRURILGVBQVMsSUFBSUQsUUFBYjtBQUVBLGFBQU9DLFNBQVA7QUFDSCxLQWw4QkQ7O0FBbzhCQTs7Ozs7OztBQVFBSSxlQUFXLEVBQUUscUJBQVM3a0IsR0FBVCxFQUFjOGtCLFNBQWQsRUFBeUI7QUFDbEMsVUFBSUMsS0FBSyxHQUFhRCxTQUFTLENBQUNoVixLQUFWLENBQWdCLEdBQWhCLENBQXRCO0FBQUEsVUFDSWtWLGFBQWEsR0FBSyxJQUR0QjtBQUFBLFVBRUlDLE9BQU8sR0FBVyxFQUZ0QjtBQUFBLFVBR0l0a0IsQ0FBQyxHQUFpQixDQUh0Qjs7QUFLQSxVQUFJLENBQUNta0IsU0FBTCxFQUFnQjtBQUNaLGVBQU85a0IsR0FBUDtBQUNIOztBQUVEZ2xCLG1CQUFhLEdBQUcsdUJBQVNobEIsR0FBVCxFQUFjO0FBQzFCLFlBQUksQ0FBQ0EsR0FBTCxFQUFVO0FBQ04saUJBQU8sSUFBUDtBQUNILFNBRkQsTUFFTztBQUNILGlCQUFPQSxHQUFHLENBQUNpbEIsT0FBRCxDQUFWO0FBQ0g7QUFDSixPQU5EOztBQVFBLGFBQU90a0IsQ0FBQyxHQUFHb2tCLEtBQUssQ0FBQ25rQixNQUFqQixFQUF5QjtBQUNyQnFrQixlQUFPLEdBQUdGLEtBQUssQ0FBQ3BrQixDQUFELENBQWY7QUFFQVgsV0FBRyxHQUFHZ2xCLGFBQWEsQ0FBQ2hsQixHQUFELENBQW5CO0FBRUFXLFNBQUM7QUFDSjs7QUFFRCxVQUFJLE9BQU9YLEdBQVAsS0FBZSxXQUFuQixFQUFnQztBQUM1QixlQUFPQSxHQUFQO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsZUFBTyxJQUFQO0FBQ0g7QUFDSjtBQTMrQkQsR0FBSjtBQTgrQkF5VyxVQUFPLENBQUNDLENBQVIsR0FBWUEsQ0FBWjtBQUVBOzs7Ozs7Ozs7OztBQVdBRCxVQUFPLENBQUMyRCxJQUFSLEdBQWUsWUFBVyxDQUFFLENBQTVCOztBQUVBM0QsVUFBTyxDQUFDMkQsSUFBUixDQUFhbGEsU0FBYixHQUF5QjtBQUNyQkQsZUFBVyxFQUFFd1csUUFBTyxDQUFDMkQsSUFEQTs7QUFHckI7Ozs7Ozs7Ozs7O0FBWUFDLGVBQVcsRUFBRSxxQkFBUzZLLFVBQVQsRUFBcUJoYyxJQUFyQixFQUEyQjtBQUNwQyxVQUFJbkcsSUFBSSxHQUFjLElBQXRCO0FBQUEsVUFDSW9pQixLQUFLLEdBQWFwaUIsSUFBSSxDQUFDOUMsV0FBTCxDQUFpQm1sQixPQUFqQixDQUF5QkYsVUFBekIsQ0FEdEI7QUFBQSxVQUVJRyxhQUFhLEdBQUssRUFGdEI7QUFJQSxVQUFJLENBQUNGLEtBQUQsSUFBVXpPLENBQUMsQ0FBQzBOLGFBQUYsQ0FBZ0JlLEtBQWhCLENBQWQsRUFBc0M7O0FBRXRDLFdBQUtFLGFBQUwsSUFBc0JGLEtBQXRCLEVBQTZCO0FBQ3pCQSxhQUFLLENBQUNFLGFBQUQsQ0FBTCxDQUFxQjliLEtBQXJCLENBQTJCeEcsSUFBM0IsRUFBaUNtRyxJQUFqQztBQUNIO0FBQ0osS0F6Qm9COztBQTJCckI7Ozs7Ozs7Ozs7OztBQWFBb2MsZUFBVyxFQUFFLHFCQUFTQyxVQUFULEVBQXFCQyxLQUFyQixFQUE0QnRjLElBQTVCLEVBQWtDO0FBQzNDLFVBQUluRyxJQUFJLEdBQWMsSUFBdEI7QUFBQSxVQUNJb2lCLEtBQUssR0FBYXBpQixJQUFJLENBQUM5QyxXQUFMLENBQWlCd2xCLE9BQWpCLENBQXlCRixVQUF6QixDQUR0QjtBQUFBLFVBRUlwTSxNQUFNLEdBQVlxTSxLQUZ0QjtBQUFBLFVBR0lILGFBQWEsR0FBSyxFQUh0QjtBQUtBLFVBQUksQ0FBQ0YsS0FBRCxJQUFVek8sQ0FBQyxDQUFDME4sYUFBRixDQUFnQmUsS0FBaEIsQ0FBZCxFQUFzQyxPQUFPaE0sTUFBUDtBQUV0Q2pRLFVBQUksR0FBR0EsSUFBSSxJQUFJLEVBQWY7O0FBRUEsV0FBS21jLGFBQUwsSUFBc0JGLEtBQXRCLEVBQTZCO0FBQ3pCamMsWUFBSSxHQUFHd04sQ0FBQyxDQUFDb0ksYUFBRixDQUFnQjVWLElBQWhCLENBQVA7QUFFQUEsWUFBSSxDQUFDaUYsT0FBTCxDQUFhZ0wsTUFBYjtBQUVBQSxjQUFNLEdBQUdnTSxLQUFLLENBQUNFLGFBQUQsQ0FBTCxDQUFxQjliLEtBQXJCLENBQTJCeEcsSUFBM0IsRUFBaUNtRyxJQUFqQyxDQUFUO0FBQ0g7O0FBRUQsYUFBT2lRLE1BQVA7QUFDSDtBQTNEb0IsR0FBekI7QUE4REE7Ozs7Ozs7Ozs7OztBQVlBMUMsVUFBTyxDQUFDaVAsVUFBUixHQUFxQixZQUFXO0FBQzVCLFNBQUtOLE9BQUwsR0FBZSxFQUFmO0FBQ0EsU0FBS0ssT0FBTCxHQUFlLEVBQWY7QUFFQTs7Ozs7Ozs7Ozs7O0FBWUEsU0FBS3hLLE1BQUwsR0FBYyxVQUFTZCxTQUFULEVBQW9CO0FBQzlCekQsT0FBQyxDQUFDdUUsTUFBRixDQUFTLEtBQUsvYSxTQUFkLEVBQXlCaWEsU0FBekI7QUFDSCxLQUZEO0FBSUE7Ozs7Ozs7Ozs7Ozs7O0FBYUEsU0FBS3dMLGNBQUwsR0FBc0IsVUFBU0MsUUFBVCxFQUFtQlAsYUFBbkIsRUFBa0N0YyxJQUFsQyxFQUF3QztBQUMxRCxPQUFDLEtBQUtxYyxPQUFMLENBQWFRLFFBQWIsSUFBeUIsS0FBS1IsT0FBTCxDQUFhUSxRQUFiLEtBQTBCLEVBQXBELEVBQXdEUCxhQUF4RCxJQUF5RXRjLElBQXpFO0FBQ0gsS0FGRDtBQUlBOzs7Ozs7Ozs7Ozs7OztBQWFBLFNBQUs4YyxjQUFMLEdBQXNCLFVBQVNELFFBQVQsRUFBbUJQLGFBQW5CLEVBQWtDdGMsSUFBbEMsRUFBd0M7QUFDMUQsT0FBQyxLQUFLMGMsT0FBTCxDQUFhRyxRQUFiLElBQXlCLEtBQUtILE9BQUwsQ0FBYUcsUUFBYixLQUEwQixFQUFwRCxFQUF3RFAsYUFBeEQsSUFBeUV0YyxJQUF6RTtBQUNILEtBRkQ7QUFHSCxHQXJERDtBQXVEQTs7Ozs7Ozs7Ozs7Ozs7QUFhQTBOLFVBQU8sQ0FBQ3FQLFFBQVIsR0FBbUIsWUFBVztBQUMxQnJQLFlBQU8sQ0FBQzJELElBQVIsQ0FBYXpZLElBQWIsQ0FBa0IsSUFBbEI7O0FBRUEsU0FBSzBZLFdBQUwsQ0FBaUIsaUJBQWpCO0FBRUEsU0FBSzBMLGVBQUwsR0FBa0MsRUFBbEM7QUFDQSxTQUFLQyxlQUFMLEdBQWtDLEVBQWxDO0FBQ0EsU0FBS0MsZ0JBQUwsR0FBa0MsRUFBbEM7QUFFQSxTQUFLRixlQUFMLEdBQWtDLEVBQWxDO0FBQ0EsU0FBS0csYUFBTCxHQUFrQyxFQUFsQztBQUNBLFNBQUtDLGFBQUwsR0FBa0MsRUFBbEM7QUFDQSxTQUFLQyxjQUFMLEdBQWtDLEVBQWxDO0FBQ0EsU0FBS0MsZUFBTCxHQUFrQyxFQUFsQztBQUNBLFNBQUtDLHFCQUFMLEdBQWtDLEVBQWxDO0FBRUEsU0FBSzFFLEdBQUwsR0FBa0MsSUFBSW5MLFFBQU8sQ0FBQzhQLEdBQVosRUFBbEM7QUFFQSxTQUFLM1AsTUFBTCxHQUFrQyxJQUFsQztBQUVBLFNBQUs0UCxlQUFMLEdBQWtDLFdBQWxDO0FBQ0EsU0FBS0MsZUFBTCxHQUFrQyxZQUFsQztBQUNBLFNBQUtDLGNBQUwsR0FBa0MsV0FBbEM7QUFDQSxTQUFLQyxnQkFBTCxHQUFrQyxhQUFsQztBQUNBLFNBQUtDLHVCQUFMLEdBQWtDLG1CQUFsQztBQUNBLFNBQUtqUSxPQUFMLEdBQWtDLENBQUMsUUFBRCxFQUFXLEtBQVgsRUFBa0IsR0FBbEIsRUFBdUIsSUFBdkIsQ0FBbEM7QUFFQSxTQUFLa1EsU0FBTCxHQUFpQixDQUNiLFNBRGEsRUFFYixPQUZhLEVBRUosUUFGSSxFQUdiLGFBSGEsRUFHRSxjQUhGLEVBSWIsR0FKYSxFQUlSLEdBSlEsRUFLYixPQUxhLEVBTWIsWUFOYSxFQU1DLFlBTkQsRUFNZSxZQU5mLEVBT2IsU0FQYSxFQU9GLFNBUEUsRUFPUyxTQVBULENBQWpCO0FBVUEsU0FBS3hNLFdBQUwsQ0FBaUIsZ0JBQWpCO0FBQ0gsR0F0Q0Q7O0FBd0NBNUQsVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQ3FQLFFBQWhDOztBQUVBclAsVUFBTyxDQUFDcVAsUUFBUixDQUFpQjVsQixTQUFqQixHQUE2QmUsTUFBTSxDQUFDMEIsTUFBUCxDQUFjOFQsUUFBTyxDQUFDMkQsSUFBUixDQUFhbGEsU0FBM0IsQ0FBN0I7QUFFQXdXLEdBQUMsQ0FBQ3VFLE1BQUYsQ0FBU3hFLFFBQU8sQ0FBQ3FQLFFBQVIsQ0FBaUI1bEIsU0FBMUI7QUFDQTtBQUNBO0FBQ0lELGVBQVcsRUFBRXdXLFFBQU8sQ0FBQ3FQLFFBRHpCOztBQUdJOzs7O0FBS0FnQixRQUFJLEVBQUUsZ0JBQVc7QUFDYixVQUFJL2pCLElBQUksR0FBRyxJQUFYO0FBRUFBLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsWUFBakIsRUFBK0I3WSxTQUEvQjtBQUVBdUIsVUFBSSxDQUFDNlQsTUFBTCxHQUFjOUssUUFBUSxDQUFDK0ssYUFBVCxDQUF1QixLQUF2QixDQUFkO0FBRUE5VCxVQUFJLENBQUNna0IsV0FBTDtBQUNBaGtCLFVBQUksQ0FBQ2lrQixRQUFMO0FBRUFqa0IsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixZQUFqQixFQUErQjdZLFNBQS9CO0FBQ0gsS0FuQkw7O0FBcUJJOzs7O0FBS0F3bEIsWUFBUSxFQUFFLG9CQUFXO0FBQ2pCLFVBQUlqa0IsSUFBSSxHQUFHLElBQVg7QUFFQUEsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixnQkFBakIsRUFBbUM3WSxTQUFuQztBQUVBdUIsVUFBSSxDQUFDNmUsR0FBTCxDQUFTQyxRQUFULEdBQTBCLE9BQU8zVyxNQUFNLENBQUM2VyxPQUFkLEtBQTBCLFVBQXBEO0FBQ0FoZixVQUFJLENBQUM2ZSxHQUFMLENBQVNxRixXQUFULEdBQTBCbGtCLElBQUksQ0FBQ2tqQixnQkFBTCxLQUEwQixhQUFwRDtBQUVBbGpCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsZUFBakIsRUFBa0M3WSxTQUFsQztBQUVBa1YsT0FBQyxDQUFDa04sTUFBRixDQUFTN2dCLElBQUksQ0FBQzZlLEdBQWQ7QUFDSCxLQXJDTDs7QUF1Q0k7Ozs7QUFLQW1GLGVBQVcsRUFBRSx1QkFBVztBQUNwQixVQUFJaGtCLElBQUksR0FBRyxJQUFYO0FBRUFBLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsbUJBQWpCLEVBQXNDN1ksU0FBdEM7QUFFQXVCLFVBQUksQ0FBQ2tqQixnQkFBTCxHQUEwQnZQLENBQUMsQ0FBQzZMLFNBQUYsQ0FBWXhmLElBQUksQ0FBQzZULE1BQWpCLEVBQXlCLFlBQXpCLEVBQXVDN1QsSUFBSSxDQUFDNFQsT0FBNUMsQ0FBMUI7QUFDQTVULFVBQUksQ0FBQ2lqQixlQUFMLEdBQTBCdFAsQ0FBQyxDQUFDNkwsU0FBRixDQUFZeGYsSUFBSSxDQUFDNlQsTUFBakIsRUFBeUIsV0FBekIsRUFBc0M3VCxJQUFJLENBQUM0VCxPQUEzQyxDQUExQjtBQUNBNVQsVUFBSSxDQUFDZ2pCLGVBQUwsR0FBMEJyUCxDQUFDLENBQUM2TCxTQUFGLENBQVl4ZixJQUFJLENBQUM2VCxNQUFqQixFQUF5QixXQUF6QixFQUFzQzdULElBQUksQ0FBQzRULE9BQTNDLENBQTFCO0FBRUE1VCxVQUFJLENBQUNta0IsYUFBTCxHQUFxQm5rQixJQUFJLENBQUNnakIsZUFBTCxHQUNqQmhqQixJQUFJLENBQUNnakIsZUFBTCxHQUF1QnJQLENBQUMsQ0FBQytHLFVBQUYsQ0FBYTFhLElBQUksQ0FBQ3lqQixlQUFsQixDQUROLEdBQzJDempCLElBQUksQ0FBQ3lqQixlQURyRTtBQUdBempCLFVBQUksQ0FBQ3FqQixjQUFMLEdBQXNCcmpCLElBQUksQ0FBQ2tqQixnQkFBTCxHQUNsQmxqQixJQUFJLENBQUNrakIsZ0JBQUwsR0FBd0J2UCxDQUFDLENBQUMrRyxVQUFGLENBQWExYSxJQUFJLENBQUMwakIsZUFBbEIsQ0FETixHQUMyQzFqQixJQUFJLENBQUMwakIsZUFEdEU7QUFHQTFqQixVQUFJLENBQUNtakIsYUFBTCxHQUFxQm5qQixJQUFJLENBQUNpakIsZUFBTCxHQUNqQmpqQixJQUFJLENBQUNpakIsZUFBTCxHQUF1QnRQLENBQUMsQ0FBQytHLFVBQUYsQ0FBYTFhLElBQUksQ0FBQzJqQixjQUFsQixDQUROLEdBQzBDM2pCLElBQUksQ0FBQzJqQixjQURwRTtBQUdBM2pCLFVBQUksQ0FBQ29qQixhQUFMLEdBQXFCcGpCLElBQUksQ0FBQ2lqQixlQUFMLEdBQ2pCLE1BQU1qakIsSUFBSSxDQUFDaWpCLGVBQVgsR0FBNkIsR0FBN0IsR0FBbUNqakIsSUFBSSxDQUFDMmpCLGNBRHZCLEdBQ3dDM2pCLElBQUksQ0FBQzJqQixjQURsRTtBQUdBM2pCLFVBQUksQ0FBQ3NqQixlQUFMLEdBQXVCdGpCLElBQUksQ0FBQ2lqQixlQUFMLEdBQ25CampCLElBQUksQ0FBQ2lqQixlQUFMLEdBQXVCdFAsQ0FBQyxDQUFDK0csVUFBRixDQUFhMWEsSUFBSSxDQUFDNGpCLGdCQUFsQixDQURKLEdBQzBDNWpCLElBQUksQ0FBQzRqQixnQkFEdEU7QUFHQTVqQixVQUFJLENBQUN1akIscUJBQUwsR0FBNkJ2akIsSUFBSSxDQUFDaWpCLGVBQUwsR0FDekJqakIsSUFBSSxDQUFDaWpCLGVBQUwsR0FBdUJ0UCxDQUFDLENBQUMrRyxVQUFGLENBQWExYSxJQUFJLENBQUM2akIsdUJBQWxCLENBREUsR0FFekI3akIsSUFBSSxDQUFDNmpCLHVCQUZUO0FBSUE3akIsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixrQkFBakIsRUFBcUM3WSxTQUFyQztBQUNIO0FBekVMLEdBRkE7QUE4RUE7Ozs7Ozs7QUFPQWlWLFVBQU8sQ0FBQzhQLEdBQVIsR0FBYyxZQUFXO0FBQ3JCLFNBQUtVLFdBQUwsR0FBc0IsS0FBdEI7QUFDQSxTQUFLcEYsUUFBTCxHQUFzQixLQUF0QjtBQUVBbkwsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQUxELENBOXJEYyxDQXFzRGQ7OztBQUVBbE4sVUFBTyxDQUFDa0wsUUFBUixHQUFtQixJQUFJbEwsUUFBTyxDQUFDcVAsUUFBWixFQUFuQjs7QUFFQXJQLFVBQU8sQ0FBQ2tMLFFBQVIsQ0FBaUJtRixJQUFqQjtBQUVBOzs7Ozs7Ozs7Ozs7QUFXQXJRLFVBQU8sQ0FBQzBRLGVBQVIsR0FBMEIsWUFBVztBQUNqQzFRLFlBQU8sQ0FBQzJELElBQVIsQ0FBYXpZLElBQWIsQ0FBa0IsSUFBbEI7O0FBRUEsU0FBSzBZLFdBQUwsQ0FBaUIsaUJBQWpCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEsU0FBS3BULE1BQUwsR0FBYyxJQUFkO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkEsU0FBS21nQixPQUFMLEdBQWUsWUFBZjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBLFNBQUtDLFNBQUwsR0FBaUIsRUFBakI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxTQUFLQyxVQUFMLEdBQWtCLEVBQWxCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEsU0FBS3RXLFFBQUwsR0FBZ0IsR0FBaEI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkEsU0FBS3VXLE1BQUwsR0FBYyxNQUFkO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkEsU0FBS0MsZ0JBQUwsR0FBd0IsSUFBeEI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxTQUFLQyxtQkFBTCxHQUEyQixRQUEzQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBLFNBQUtDLGlCQUFMLEdBQXlCLFNBQXpCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQSxTQUFLQyxLQUFMLEdBQWEsSUFBYjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsU0FBS0MsVUFBTCxHQUFrQixDQUFsQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQSxTQUFLQyxzQkFBTCxHQUE4QixJQUE5QjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQSxTQUFLQyxvQkFBTCxHQUE0QixLQUE1QjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDQSxTQUFLQyxlQUFMLEdBQXVCLElBQXZCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQSxTQUFLQyxVQUFMLEdBQWtCLEtBQWxCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQSxTQUFLQyxLQUFMLEdBQWEsSUFBYjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkEsU0FBS0MsV0FBTCxHQUFtQixJQUFuQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkEsU0FBS0MsVUFBTCxHQUFrQixJQUFsQjtBQUVBLFNBQUs5TixXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQXZkRDs7QUF5ZEFsTixVQUFPLENBQUNpUCxVQUFSLENBQW1CL2pCLElBQW5CLENBQXdCOFUsUUFBTyxDQUFDMFEsZUFBaEM7O0FBRUExUSxVQUFPLENBQUMwUSxlQUFSLENBQXdCam5CLFNBQXhCLEdBQW9DZSxNQUFNLENBQUMwQixNQUFQLENBQWM4VCxRQUFPLENBQUMyRCxJQUFSLENBQWFsYSxTQUEzQixDQUFwQztBQUVBdVcsVUFBTyxDQUFDMFEsZUFBUixDQUF3QmpuQixTQUF4QixDQUFrQ0QsV0FBbEMsR0FBZ0R3VyxRQUFPLENBQUMwUSxlQUF4RDtBQUVBOzs7Ozs7Ozs7OztBQVdBMVEsVUFBTyxDQUFDMlIsY0FBUixHQUF5QixZQUFXO0FBQ2hDM1IsWUFBTyxDQUFDMkQsSUFBUixDQUFhelksSUFBYixDQUFrQixJQUFsQjs7QUFFQSxTQUFLMFksV0FBTCxDQUFpQixpQkFBakI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJDQSxTQUFLZ08sUUFBTCxHQUFnQixLQUFoQjtBQUVBLFNBQUtoTyxXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQXJERDs7QUF1REFsTixVQUFPLENBQUNpUCxVQUFSLENBQW1CL2pCLElBQW5CLENBQXdCOFUsUUFBTyxDQUFDMlIsY0FBaEM7O0FBRUEzUixVQUFPLENBQUMyUixjQUFSLENBQXVCbG9CLFNBQXZCLEdBQW1DZSxNQUFNLENBQUMwQixNQUFQLENBQWM4VCxRQUFPLENBQUMyRCxJQUFSLENBQWFsYSxTQUEzQixDQUFuQztBQUVBdVcsVUFBTyxDQUFDMlIsY0FBUixDQUF1QmxvQixTQUF2QixDQUFpQ0QsV0FBakMsR0FBK0N3VyxRQUFPLENBQUMyUixjQUF2RDtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEzUixVQUFPLENBQUM2UixlQUFSLEdBQTBCLFlBQVc7QUFDakM3UixZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQSxTQUFLa08sVUFBTCxHQUFrQixJQUFsQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkEsU0FBS0MsU0FBTCxHQUFrQixJQUFsQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQSxTQUFLQyxRQUFMLEdBQWtCLElBQWxCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBLFNBQUtDLFNBQUwsR0FBa0IsSUFBbEI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVEQSxTQUFLQyxVQUFMLEdBQWtCLElBQWxCO0FBRUEsU0FBS3RPLFdBQUwsQ0FBaUIsZ0JBQWpCO0FBRUEzRCxLQUFDLENBQUNpTixJQUFGLENBQU8sSUFBUDtBQUNILEdBN0pEOztBQStKQWxOLFVBQU8sQ0FBQ2lQLFVBQVIsQ0FBbUIvakIsSUFBbkIsQ0FBd0I4VSxRQUFPLENBQUM2UixlQUFoQzs7QUFFQTdSLFVBQU8sQ0FBQzZSLGVBQVIsQ0FBd0Jwb0IsU0FBeEIsR0FBb0NlLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYzhULFFBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQTNCLENBQXBDO0FBRUF1VyxVQUFPLENBQUM2UixlQUFSLENBQXdCcG9CLFNBQXhCLENBQWtDRCxXQUFsQyxHQUFnRHdXLFFBQU8sQ0FBQzZSLGVBQXhEO0FBRUE7Ozs7Ozs7Ozs7O0FBV0E3UixVQUFPLENBQUNtUyxjQUFSLEdBQXlCLFlBQVc7QUFDaENuUyxZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdDQSxTQUFLcFQsTUFBTCxHQUFjLElBQWQ7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQSxTQUFLNGhCLElBQUwsR0FBWSxLQUFaO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ0EsU0FBS0MsS0FBTCxHQUFhLFFBQWIsQ0FoSGdDLENBZ0hUOztBQUV2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBLFNBQUtDLFdBQUwsR0FBbUIsSUFBbkIsQ0E3SWdDLENBNklQOztBQUV6Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9EQSxTQUFLQyxhQUFMLEdBQXFCLEtBQXJCLENBbk1nQyxDQW1NSjs7QUFFNUIsU0FBSzNPLFdBQUwsQ0FBaUIsZ0JBQWpCO0FBRUEzRCxLQUFDLENBQUNpTixJQUFGLENBQU8sSUFBUDtBQUNILEdBeE1EOztBQTBNQWxOLFVBQU8sQ0FBQ2lQLFVBQVIsQ0FBbUIvakIsSUFBbkIsQ0FBd0I4VSxRQUFPLENBQUNtUyxjQUFoQzs7QUFFQW5TLFVBQU8sQ0FBQ21TLGNBQVIsQ0FBdUIxb0IsU0FBdkIsR0FBbUNlLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYzhULFFBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQTNCLENBQW5DO0FBRUF1VyxVQUFPLENBQUNtUyxjQUFSLENBQXVCMW9CLFNBQXZCLENBQWlDRCxXQUFqQyxHQUErQ3dXLFFBQU8sQ0FBQ21TLGNBQXZEO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBblMsVUFBTyxDQUFDd1MsZ0JBQVIsR0FBMkIsWUFBVztBQUNsQ3hTLFlBQU8sQ0FBQzJELElBQVIsQ0FBYXpZLElBQWIsQ0FBa0IsSUFBbEI7O0FBRUEsU0FBSzBZLFdBQUwsQ0FBaUIsaUJBQWpCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkEsU0FBS3FLLEtBQUwsR0FBYSxTQUFiO0FBRUE7Ozs7Ozs7Ozs7QUFVQSxTQUFLd0UsZ0JBQUwsR0FBd0IsV0FBeEI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0EsU0FBS0MsYUFBTCxHQUFxQixTQUFyQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdDQSxTQUFLQyxXQUFMLEdBQW1CLFNBQW5CO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NBLFNBQUtDLGVBQUwsR0FBdUIsU0FBdkI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0EsU0FBS0MsYUFBTCxHQUFxQixTQUFyQjtBQUVBOzs7Ozs7Ozs7QUFTQSxTQUFLQyxjQUFMLEdBQXNCLFFBQXRCO0FBRUE7Ozs7Ozs7Ozs7QUFVQSxTQUFLQyxnQkFBTCxHQUF3QixVQUF4QjtBQUVBOzs7Ozs7Ozs7O0FBVUEsU0FBS0MsY0FBTCxHQUFzQixRQUF0QjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkEsU0FBSzlFLGlCQUFMLEdBQXlCLEdBQXpCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkEsU0FBS0Msa0JBQUwsR0FBMEIsR0FBMUI7QUFFQSxTQUFLdkssV0FBTCxDQUFpQixnQkFBakI7QUFFQTNELEtBQUMsQ0FBQ2lOLElBQUYsQ0FBTyxJQUFQO0FBQ0gsR0E1UUQ7O0FBOFFBbE4sVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQ3dTLGdCQUFoQzs7QUFFQXhTLFVBQU8sQ0FBQ3dTLGdCQUFSLENBQXlCL29CLFNBQXpCLEdBQXFDZSxNQUFNLENBQUMwQixNQUFQLENBQWM4VCxRQUFPLENBQUMyRCxJQUFSLENBQWFsYSxTQUEzQixDQUFyQztBQUVBdVcsVUFBTyxDQUFDd1MsZ0JBQVIsQ0FBeUIvb0IsU0FBekIsQ0FBbUNELFdBQW5DLEdBQWlEd1csUUFBTyxDQUFDd1MsZ0JBQXpEO0FBRUE7Ozs7Ozs7Ozs7O0FBV0F4UyxVQUFPLENBQUNpVCxVQUFSLEdBQXFCLFlBQVc7QUFDNUJqVCxZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBLFNBQUtzUCxNQUFMLEdBQWMsRUFBZDtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0VBLFNBQUtDLFVBQUwsR0FBa0IsS0FBbEI7QUFFQSxTQUFLdlAsV0FBTCxDQUFpQixnQkFBakI7QUFFQTNELEtBQUMsQ0FBQ2lOLElBQUYsQ0FBTyxJQUFQO0FBQ0gsR0FsR0Q7O0FBb0dBbE4sVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQ2lULFVBQWhDOztBQUVBalQsVUFBTyxDQUFDaVQsVUFBUixDQUFtQnhwQixTQUFuQixHQUErQmUsTUFBTSxDQUFDMEIsTUFBUCxDQUFjOFQsUUFBTyxDQUFDMkQsSUFBUixDQUFhbGEsU0FBM0IsQ0FBL0I7QUFFQXVXLFVBQU8sQ0FBQ2lULFVBQVIsQ0FBbUJ4cEIsU0FBbkIsQ0FBNkJELFdBQTdCLEdBQTJDd1csUUFBTyxDQUFDaVQsVUFBbkQ7QUFFQTs7Ozs7Ozs7Ozs7QUFXQWpULFVBQU8sQ0FBQ29ULFdBQVIsR0FBc0IsWUFBVztBQUM3QnBULFlBQU8sQ0FBQzJELElBQVIsQ0FBYXpZLElBQWIsQ0FBa0IsSUFBbEI7O0FBRUEsU0FBSzBZLFdBQUwsQ0FBaUIsaUJBQWpCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQSxTQUFLcFQsTUFBTCxHQUFjLEtBQWQ7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQSxTQUFLNlMsWUFBTCxHQUFvQixJQUFwQjtBQUVBOzs7Ozs7Ozs7OztBQVdBLFNBQUtnUSxTQUFMLEdBQWlCLEtBQWpCO0FBRUEsU0FBS3pQLFdBQUwsQ0FBaUIsZ0JBQWpCO0FBRUEzRCxLQUFDLENBQUNpTixJQUFGLENBQU8sSUFBUDtBQUNILEdBdEZEOztBQXdGQWxOLFVBQU8sQ0FBQ2lQLFVBQVIsQ0FBbUIvakIsSUFBbkIsQ0FBd0I4VSxRQUFPLENBQUNvVCxXQUFoQzs7QUFFQXBULFVBQU8sQ0FBQ29ULFdBQVIsQ0FBb0IzcEIsU0FBcEIsR0FBZ0NlLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYzhULFFBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQTNCLENBQWhDO0FBRUF1VyxVQUFPLENBQUNvVCxXQUFSLENBQW9CM3BCLFNBQXBCLENBQThCRCxXQUE5QixHQUE0Q3dXLFFBQU8sQ0FBQ29ULFdBQXBEO0FBRUE7Ozs7Ozs7Ozs7O0FBV0FwVCxVQUFPLENBQUNzVCxZQUFSLEdBQXVCLFlBQVc7QUFDOUJ0VCxZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQSxTQUFLMlAsa0JBQUwsR0FBMEIsSUFBMUI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDQSxTQUFLQyxrQkFBTCxHQUEwQixFQUExQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkEsU0FBS0MsYUFBTCxHQUFxQixJQUFyQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkEsU0FBS0MsWUFBTCxHQUFvQixJQUFwQjtBQUVBLFNBQUs5UCxXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQTVIRDs7QUE4SEFsTixVQUFPLENBQUNpUCxVQUFSLENBQW1CL2pCLElBQW5CLENBQXdCOFUsUUFBTyxDQUFDc1QsWUFBaEM7O0FBRUF0VCxVQUFPLENBQUNzVCxZQUFSLENBQXFCN3BCLFNBQXJCLEdBQWlDZSxNQUFNLENBQUMwQixNQUFQLENBQWM4VCxRQUFPLENBQUMyRCxJQUFSLENBQWFsYSxTQUEzQixDQUFqQztBQUVBdVcsVUFBTyxDQUFDc1QsWUFBUixDQUFxQjdwQixTQUFyQixDQUErQkQsV0FBL0IsR0FBNkN3VyxRQUFPLENBQUNzVCxZQUFyRDtBQUVBOzs7Ozs7Ozs7OztBQVdBdFQsVUFBTyxDQUFDMlQsVUFBUixHQUFxQixZQUFXO0FBQzVCM1QsWUFBTyxDQUFDMkQsSUFBUixDQUFhelksSUFBYixDQUFrQixJQUFsQjs7QUFFQSxTQUFLMFksV0FBTCxDQUFpQixpQkFBakI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0EsU0FBSzVPLE1BQUwsR0FBYyxLQUFkO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQSxTQUFLbEgsSUFBTCxHQUFZLGFBQVo7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDQSxTQUFLOGxCLE9BQUwsR0FBZSxJQUFmO0FBRUEsU0FBS2hRLFdBQUwsQ0FBaUIsZ0JBQWpCO0FBRUEzRCxLQUFDLENBQUNpTixJQUFGLENBQU8sSUFBUDtBQUNILEdBM0dEOztBQTZHQWxOLFVBQU8sQ0FBQ2lQLFVBQVIsQ0FBbUIvakIsSUFBbkIsQ0FBd0I4VSxRQUFPLENBQUMyVCxVQUFoQzs7QUFFQTNULFVBQU8sQ0FBQzJULFVBQVIsQ0FBbUJscUIsU0FBbkIsR0FBK0JlLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYzhULFFBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQTNCLENBQS9CO0FBRUF1VyxVQUFPLENBQUMyVCxVQUFSLENBQW1CbHFCLFNBQW5CLENBQTZCRCxXQUE3QixHQUEyQ3dXLFFBQU8sQ0FBQzJULFVBQW5EO0FBRUE7Ozs7Ozs7Ozs7O0FBV0EzVCxVQUFPLENBQUM2VCxlQUFSLEdBQTBCLFlBQVc7QUFDakM3VCxZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JBLFNBQUs1WixNQUFMLEdBQWMsTUFBZDtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkEsU0FBS3FqQixPQUFMLEdBQWUsRUFBZjtBQUVBLFNBQUt6SixXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQXpFRDs7QUEyRUFsTixVQUFPLENBQUNpUCxVQUFSLENBQW1CL2pCLElBQW5CLENBQXdCOFUsUUFBTyxDQUFDNlQsZUFBaEM7O0FBRUE3VCxVQUFPLENBQUM2VCxlQUFSLENBQXdCcHFCLFNBQXhCLEdBQW9DZSxNQUFNLENBQUMwQixNQUFQLENBQWM4VCxRQUFPLENBQUMyRCxJQUFSLENBQWFsYSxTQUEzQixDQUFwQztBQUVBdVcsVUFBTyxDQUFDNlQsZUFBUixDQUF3QnBxQixTQUF4QixDQUFrQ0QsV0FBbEMsR0FBZ0R3VyxRQUFPLENBQUM2VCxlQUF4RDtBQUVBOzs7Ozs7Ozs7Ozs7O0FBYUE3VCxVQUFPLENBQUM4VCxZQUFSLEdBQXVCLFlBQVc7QUFDOUI5VCxZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9FQSxTQUFLNVosTUFBTCxHQUFjLElBQWQ7QUFFQSxTQUFLNFosV0FBTCxDQUFpQixnQkFBakI7QUFFQTNELEtBQUMsQ0FBQ2lOLElBQUYsQ0FBTyxJQUFQO0FBQ0gsR0E5RUQ7O0FBZ0ZBbE4sVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQzhULFlBQWhDOztBQUVBOVQsVUFBTyxDQUFDOFQsWUFBUixDQUFxQnJxQixTQUFyQixHQUFpQ2UsTUFBTSxDQUFDMEIsTUFBUCxDQUFjOFQsUUFBTyxDQUFDMkQsSUFBUixDQUFhbGEsU0FBM0IsQ0FBakM7QUFFQXVXLFVBQU8sQ0FBQzhULFlBQVIsQ0FBcUJycUIsU0FBckIsQ0FBK0JELFdBQS9CLEdBQTZDd1csUUFBTyxDQUFDOFQsWUFBckQ7QUFFQTs7Ozs7OztBQU9BOVQsVUFBTyxDQUFDK1QsZUFBUixHQUEwQixZQUFXO0FBQ2pDL1QsWUFBTyxDQUFDMkQsSUFBUixDQUFhelksSUFBYixDQUFrQixJQUFsQjs7QUFFQSxTQUFLMFksV0FBTCxDQUFpQixpQkFBakI7QUFFQSxTQUFLQSxXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQVJEOztBQVVBbE4sVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQytULGVBQWhDOztBQUVBL1QsVUFBTyxDQUFDK1QsZUFBUixDQUF3QnRxQixTQUF4QixHQUFvQ2UsTUFBTSxDQUFDMEIsTUFBUCxDQUFjOFQsUUFBTyxDQUFDMkQsSUFBUixDQUFhbGEsU0FBM0IsQ0FBcEM7QUFFQXVXLFVBQU8sQ0FBQytULGVBQVIsQ0FBd0J0cUIsU0FBeEIsQ0FBa0NELFdBQWxDLEdBQWdEd1csUUFBTyxDQUFDK1QsZUFBeEQ7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQ0EvVCxVQUFPLENBQUNnVSxNQUFSLEdBQWlCLFlBQVc7QUFDeEJoVSxZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBLFNBQUtxUSxTQUFMLEdBQTBCLElBQUlqVSxRQUFPLENBQUMwUSxlQUFaLEVBQTFCO0FBQ0EsU0FBS3dELFFBQUwsR0FBMEIsSUFBSWxVLFFBQU8sQ0FBQzJSLGNBQVosRUFBMUI7QUFDQSxTQUFLd0MsU0FBTCxHQUEwQixJQUFJblUsUUFBTyxDQUFDNlIsZUFBWixFQUExQjtBQUNBLFNBQUtwVCxRQUFMLEdBQTBCLElBQUl1QixRQUFPLENBQUNtUyxjQUFaLEVBQTFCO0FBQ0EsU0FBS3RFLFVBQUwsR0FBMEIsSUFBSTdOLFFBQU8sQ0FBQ3dTLGdCQUFaLEVBQTFCO0FBQ0EsU0FBSzdNLElBQUwsR0FBMEIsSUFBSTNGLFFBQU8sQ0FBQ2lULFVBQVosRUFBMUI7QUFDQSxTQUFLN1AsS0FBTCxHQUEwQixJQUFJcEQsUUFBTyxDQUFDb1QsV0FBWixFQUExQjtBQUNBLFNBQUtnQixNQUFMLEdBQTBCLElBQUlwVSxRQUFPLENBQUNzVCxZQUFaLEVBQTFCO0FBQ0EsU0FBS2UsSUFBTCxHQUEwQixJQUFJclUsUUFBTyxDQUFDMlQsVUFBWixFQUExQjtBQUNBLFNBQUtXLFNBQUwsR0FBMEIsSUFBSXRVLFFBQU8sQ0FBQzZULGVBQVosRUFBMUI7QUFDQSxTQUFLVSxNQUFMLEdBQTBCLElBQUl2VSxRQUFPLENBQUM4VCxZQUFaLEVBQTFCO0FBQ0EsU0FBS1UsU0FBTCxHQUEwQixJQUFJeFUsUUFBTyxDQUFDK1QsZUFBWixFQUExQjtBQUVBLFNBQUtuUSxXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQXJCRDs7QUF1QkFsTixVQUFPLENBQUNpUCxVQUFSLENBQW1CL2pCLElBQW5CLENBQXdCOFUsUUFBTyxDQUFDZ1UsTUFBaEM7O0FBRUFoVSxVQUFPLENBQUNnVSxNQUFSLENBQWV2cUIsU0FBZixHQUEyQmUsTUFBTSxDQUFDMEIsTUFBUCxDQUFjOFQsUUFBTyxDQUFDMkQsSUFBUixDQUFhbGEsU0FBM0IsQ0FBM0I7QUFFQXVXLFVBQU8sQ0FBQ2dVLE1BQVIsQ0FBZXZxQixTQUFmLENBQXlCRCxXQUF6QixHQUF1Q3dXLFFBQU8sQ0FBQ2dVLE1BQS9DO0FBRUE7Ozs7Ozs7QUFPQWhVLFVBQU8sQ0FBQ3lVLFFBQVIsR0FBbUIsWUFBVztBQUMxQnpVLFlBQU8sQ0FBQzJELElBQVIsQ0FBYXpZLElBQWIsQ0FBa0IsSUFBbEI7O0FBRUEsU0FBSzBZLFdBQUwsQ0FBaUIsaUJBQWpCO0FBRUEsU0FBS3ZPLFFBQUwsR0FBOEIsSUFBOUI7QUFDQSxTQUFLbVYsSUFBTCxHQUE4QixJQUE5QjtBQUNBLFNBQUtwSSxTQUFMLEdBQThCLElBQTlCO0FBQ0EsU0FBS3pXLE1BQUwsR0FBOEIsSUFBOUI7QUFDQSxTQUFLK29CLE9BQUwsR0FBOEIsRUFBOUI7QUFFQSxTQUFLOVEsV0FBTCxDQUFpQixnQkFBakI7QUFFQTNELEtBQUMsQ0FBQ2lOLElBQUYsQ0FBTyxJQUFQO0FBQ0gsR0FkRDs7QUFnQkFsTixVQUFPLENBQUNpUCxVQUFSLENBQW1CL2pCLElBQW5CLENBQXdCOFUsUUFBTyxDQUFDeVUsUUFBaEM7O0FBRUF6VSxVQUFPLENBQUN5VSxRQUFSLENBQWlCaHJCLFNBQWpCLEdBQTZCZSxNQUFNLENBQUMwQixNQUFQLENBQWM4VCxRQUFPLENBQUMyRCxJQUFSLENBQWFsYSxTQUEzQixDQUE3QjtBQUVBdVcsVUFBTyxDQUFDeVUsUUFBUixDQUFpQmhyQixTQUFqQixDQUEyQkQsV0FBM0IsR0FBeUN3VyxRQUFPLENBQUN5VSxRQUFqRDtBQUVBOzs7Ozs7O0FBT0F6VSxVQUFPLENBQUMyVSxZQUFSLEdBQXVCLFlBQVc7QUFDOUIzVSxZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBLFNBQUtnUixJQUFMLEdBQWtCLEVBQWxCO0FBQ0EsU0FBS0MsTUFBTCxHQUFrQixFQUFsQjtBQUNBLFNBQUt2bEIsUUFBTCxHQUFrQixFQUFsQjtBQUVBLFNBQUtzVSxXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQVpEOztBQWNBbE4sVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQzJVLFlBQWhDOztBQUVBM1UsVUFBTyxDQUFDMlUsWUFBUixDQUFxQmxyQixTQUFyQixHQUFpQ2UsTUFBTSxDQUFDMEIsTUFBUCxDQUFjOFQsUUFBTyxDQUFDMkQsSUFBUixDQUFhbGEsU0FBM0IsQ0FBakM7QUFFQXVXLFVBQU8sQ0FBQzJVLFlBQVIsQ0FBcUJsckIsU0FBckIsQ0FBK0JELFdBQS9CLEdBQTZDd1csUUFBTyxDQUFDMlUsWUFBckQ7QUFFQTs7Ozs7Ozs7O0FBU0EzVSxVQUFPLENBQUM4VSxjQUFSLEdBQXlCLFlBQVc7QUFDaEM5VSxZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBLFNBQUtnUSxPQUFMLEdBQWUsSUFBZjtBQUVBLFNBQUtoUSxXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQVZEOztBQVlBbE4sVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQzhVLGNBQWhDOztBQUVBOVUsVUFBTyxDQUFDOFUsY0FBUixDQUF1QnJyQixTQUF2QixHQUFtQ2UsTUFBTSxDQUFDMEIsTUFBUCxDQUFjOFQsUUFBTyxDQUFDMkQsSUFBUixDQUFhbGEsU0FBM0IsQ0FBbkM7QUFFQXVXLFVBQU8sQ0FBQzhVLGNBQVIsQ0FBdUJyckIsU0FBdkIsQ0FBaUNELFdBQWpDLEdBQStDd1csUUFBTyxDQUFDOFUsY0FBdkQ7QUFFQTs7Ozs7Ozs7O0FBU0E5VSxVQUFPLENBQUMrVSxlQUFSLEdBQTBCLFlBQVc7QUFDakMvVSxZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBLFNBQUs1TyxNQUFMLEdBQW9CLElBQXBCO0FBQ0EsU0FBS2xILElBQUwsR0FBb0IsSUFBcEI7QUFDQSxTQUFLa25CLE1BQUwsR0FBb0IsSUFBcEI7QUFDQSxTQUFLcG1CLE1BQUwsR0FBb0IsSUFBcEI7QUFDQSxTQUFLcW1CLFlBQUwsR0FBb0IsSUFBcEI7QUFFQSxTQUFLclIsV0FBTCxDQUFpQixnQkFBakI7QUFFQTNELEtBQUMsQ0FBQ2lOLElBQUYsQ0FBTyxJQUFQO0FBQ0gsR0FkRDs7QUFnQkFsTixVQUFPLENBQUNpUCxVQUFSLENBQW1CL2pCLElBQW5CLENBQXdCOFUsUUFBTyxDQUFDK1UsZUFBaEM7O0FBRUEvVSxVQUFPLENBQUMrVSxlQUFSLENBQXdCdHJCLFNBQXhCLEdBQW9DZSxNQUFNLENBQUMwQixNQUFQLENBQWM4VCxRQUFPLENBQUMyRCxJQUFSLENBQWFsYSxTQUEzQixDQUFwQztBQUVBdVcsVUFBTyxDQUFDK1UsZUFBUixDQUF3QnRyQixTQUF4QixDQUFrQ0QsV0FBbEMsR0FBZ0R3VyxRQUFPLENBQUMrVSxlQUF4RDtBQUVBOzs7Ozs7Ozs7QUFTQS9VLFVBQU8sQ0FBQ2tWLGFBQVIsR0FBd0IsWUFBVztBQUMvQmxWLFlBQU8sQ0FBQzJELElBQVIsQ0FBYXpZLElBQWIsQ0FBa0IsSUFBbEI7O0FBRUEsU0FBSzBZLFdBQUwsQ0FBaUIsaUJBQWpCO0FBRUEsU0FBSzFVLFFBQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLaW1CLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxTQUFLQyxNQUFMLEdBQWtCLE1BQWxCLENBUCtCLENBT0w7O0FBRTFCLFNBQUt4UixXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQVpEOztBQWNBbE4sVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQ2tWLGFBQWhDOztBQUVBbFYsVUFBTyxDQUFDa1YsYUFBUixDQUFzQnpyQixTQUF0QixHQUFrQ2UsTUFBTSxDQUFDMEIsTUFBUCxDQUFjOFQsUUFBTyxDQUFDMkQsSUFBUixDQUFhbGEsU0FBM0IsQ0FBbEM7QUFFQXVXLFVBQU8sQ0FBQ2tWLGFBQVIsQ0FBc0J6ckIsU0FBdEIsQ0FBZ0NELFdBQWhDLEdBQThDd1csUUFBTyxDQUFDa1YsYUFBdEQ7QUFFQTs7Ozs7Ozs7O0FBU0FsVixVQUFPLENBQUNxVixXQUFSLEdBQXNCLFlBQVc7QUFDN0JyVixZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBLFNBQUswUixVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsU0FBS0MsU0FBTCxHQUFrQixFQUFsQjtBQUNBLFNBQUtDLEtBQUwsR0FBa0IsS0FBbEI7QUFDQSxTQUFLTCxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsU0FBS00sSUFBTCxHQUFrQixJQUFsQjtBQUVBLFNBQUs3UixXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQWREOztBQWdCQWxOLFVBQU8sQ0FBQ2lQLFVBQVIsQ0FBbUIvakIsSUFBbkIsQ0FBd0I4VSxRQUFPLENBQUNxVixXQUFoQzs7QUFFQXJWLFVBQU8sQ0FBQ3FWLFdBQVIsQ0FBb0I1ckIsU0FBcEIsR0FBZ0NlLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYzhULFFBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQTNCLENBQWhDO0FBRUF1VyxVQUFPLENBQUNxVixXQUFSLENBQW9CNXJCLFNBQXBCLENBQThCRCxXQUE5QixHQUE0Q3dXLFFBQU8sQ0FBQ3FWLFdBQXBEO0FBRUE7Ozs7Ozs7OztBQVNBclYsVUFBTyxDQUFDMFYsYUFBUixHQUF3QixZQUFXO0FBQy9CMVYsWUFBTyxDQUFDMkQsSUFBUixDQUFhelksSUFBYixDQUFrQixJQUFsQjs7QUFFQSxTQUFLMFksV0FBTCxDQUFpQixpQkFBakI7QUFFQSxTQUFLbFYsS0FBTCxHQUFrQixDQUFsQjtBQUNBLFNBQUt5bUIsVUFBTCxHQUFrQixFQUFsQjtBQUNBLFNBQUt6TSxRQUFMLEdBQWtCLFFBQWxCLENBUCtCLENBT0g7O0FBQzVCLFNBQUs5UixPQUFMLEdBQWtCLElBQWxCO0FBRUEsU0FBS2dOLFdBQUwsQ0FBaUIsZ0JBQWpCO0FBRUEzRCxLQUFDLENBQUNpTixJQUFGLENBQU8sSUFBUDtBQUNILEdBYkQ7O0FBZUFsTixVQUFPLENBQUNpUCxVQUFSLENBQW1CL2pCLElBQW5CLENBQXdCOFUsUUFBTyxDQUFDMFYsYUFBaEM7O0FBRUExVixVQUFPLENBQUMwVixhQUFSLENBQXNCanNCLFNBQXRCLEdBQWtDZSxNQUFNLENBQUMwQixNQUFQLENBQWM4VCxRQUFPLENBQUMyRCxJQUFSLENBQWFsYSxTQUEzQixDQUFsQztBQUVBdVcsVUFBTyxDQUFDMFYsYUFBUixDQUFzQmpzQixTQUF0QixDQUFnQ0QsV0FBaEMsR0FBOEN3VyxRQUFPLENBQUMwVixhQUF0RDtBQUVBOzs7Ozs7Ozs7QUFTQTFWLFVBQU8sQ0FBQzJWLGFBQVIsR0FBd0IsWUFBVztBQUMvQjNWLFlBQU8sQ0FBQzJELElBQVIsQ0FBYXpZLElBQWIsQ0FBa0IsSUFBbEI7O0FBRUEsU0FBSzBZLFdBQUwsQ0FBaUIsaUJBQWpCO0FBRUEsU0FBSzhRLE9BQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLUyxVQUFMLEdBQWtCLEVBQWxCO0FBRUEsU0FBS3ZSLFdBQUwsQ0FBaUIsZ0JBQWpCO0FBRUEzRCxLQUFDLENBQUNpTixJQUFGLENBQU8sSUFBUDtBQUNILEdBWEQ7O0FBYUFsTixVQUFPLENBQUNpUCxVQUFSLENBQW1CL2pCLElBQW5CLENBQXdCOFUsUUFBTyxDQUFDMlYsYUFBaEM7O0FBRUEzVixVQUFPLENBQUMyVixhQUFSLENBQXNCbHNCLFNBQXRCLEdBQWtDZSxNQUFNLENBQUMwQixNQUFQLENBQWM4VCxRQUFPLENBQUMyRCxJQUFSLENBQWFsYSxTQUEzQixDQUFsQztBQUVBdVcsVUFBTyxDQUFDMlYsYUFBUixDQUFzQmxzQixTQUF0QixDQUFnQ0QsV0FBaEMsR0FBOEN3VyxRQUFPLENBQUMyVixhQUF0RDtBQUVBOzs7Ozs7Ozs7QUFTQTNWLFVBQU8sQ0FBQzRWLG1CQUFSLEdBQThCLFlBQVc7QUFDckM1VixZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBLFNBQUs0UCxrQkFBTCxHQUEwQixFQUExQjtBQUVBLFNBQUs1UCxXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQVZEOztBQVlBbE4sVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQzRWLG1CQUFoQzs7QUFFQTVWLFVBQU8sQ0FBQzRWLG1CQUFSLENBQTRCbnNCLFNBQTVCLEdBQXdDZSxNQUFNLENBQUMwQixNQUFQLENBQWM4VCxRQUFPLENBQUMyRCxJQUFSLENBQWFsYSxTQUEzQixDQUF4QztBQUVBdVcsVUFBTyxDQUFDNFYsbUJBQVIsQ0FBNEJuc0IsU0FBNUIsQ0FBc0NELFdBQXRDLEdBQW9Ed1csUUFBTyxDQUFDNFYsbUJBQTVEO0FBRUE7Ozs7Ozs7Ozs7OztBQVlBNVYsVUFBTyxDQUFDNlYsaUJBQVIsR0FBNEIsVUFBUzl1QixJQUFULEVBQWVtSSxRQUFmLEVBQXlCa2pCLElBQXpCLEVBQStCem1CLE1BQS9CLEVBQXVDO0FBQy9EcVUsWUFBTyxDQUFDMkQsSUFBUixDQUFhelksSUFBYixDQUFrQixJQUFsQjs7QUFFQSxTQUFLMFksV0FBTCxDQUFpQixpQkFBakI7QUFFQSxTQUFLN2MsSUFBTCxHQUFlQSxJQUFmO0FBQ0EsU0FBS21JLFFBQUwsR0FBaUJBLFFBQWpCO0FBQ0EsU0FBS2tqQixJQUFMLEdBQWlCQSxJQUFJLElBQUksS0FBekI7QUFDQSxTQUFLem1CLE1BQUwsR0FBaUJBLE1BQU0sSUFBSSxFQUEzQjtBQUVBLFNBQUtpWSxXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDa04sTUFBRixDQUFTLElBQVQ7QUFDQWxOLEtBQUMsQ0FBQ2lOLElBQUYsQ0FBTyxJQUFQO0FBQ0gsR0FkRDs7QUFnQkFsTixVQUFPLENBQUNpUCxVQUFSLENBQW1CL2pCLElBQW5CLENBQXdCOFUsUUFBTyxDQUFDNlYsaUJBQWhDOztBQUVBN1YsVUFBTyxDQUFDNlYsaUJBQVIsQ0FBMEJwc0IsU0FBMUIsR0FBc0NlLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYzhULFFBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQTNCLENBQXRDO0FBRUF1VyxVQUFPLENBQUM2VixpQkFBUixDQUEwQnBzQixTQUExQixDQUFvQ0QsV0FBcEMsR0FBa0R3VyxRQUFPLENBQUM2VixpQkFBMUQ7QUFFQTdWLFVBQU8sQ0FBQzhWLGtCQUFSLEdBQTZCLEVBQTdCOztBQUVBOVYsVUFBTyxDQUFDOFYsa0JBQVIsQ0FBMkJubkIsSUFBM0IsQ0FBZ0MsSUFBSXFSLFFBQU8sQ0FBQzZWLGlCQUFaLENBQThCLFVBQTlCLEVBQTBDLDBCQUExQyxDQUFoQzs7QUFDQTdWLFVBQU8sQ0FBQzhWLGtCQUFSLENBQTJCbm5CLElBQTNCLENBQWdDLElBQUlxUixRQUFPLENBQUM2VixpQkFBWixDQUE4QixRQUE5QixFQUF3QyxlQUF4QyxDQUFoQzs7QUFDQTdWLFVBQU8sQ0FBQzhWLGtCQUFSLENBQTJCbm5CLElBQTNCLENBQWdDLElBQUlxUixRQUFPLENBQUM2VixpQkFBWixDQUE4QixNQUE5QixFQUFzQyxhQUF0QyxDQUFoQzs7QUFDQTdWLFVBQU8sQ0FBQzhWLGtCQUFSLENBQTJCbm5CLElBQTNCLENBQWdDLElBQUlxUixRQUFPLENBQUM2VixpQkFBWixDQUE4QixRQUE5QixFQUF3QyxlQUF4QyxDQUFoQztBQUVBOzs7Ozs7OztBQU9BN1YsVUFBTyxDQUFDK1YsT0FBUixHQUFrQixZQUFXO0FBQ3pCL1YsWUFBTyxDQUFDMkQsSUFBUixDQUFhelksSUFBYixDQUFrQixJQUFsQjs7QUFFQSxTQUFLMFksV0FBTCxDQUFpQixpQkFBakI7QUFFQSxTQUFLckwsRUFBTCxHQUFrQixJQUFsQjtBQUNBLFNBQUtySixRQUFMLEdBQWtCLEVBQWxCO0FBQ0EsU0FBSzNILEtBQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLeXVCLE9BQUwsR0FBa0IsQ0FBQyxDQUFuQjtBQUNBLFNBQUtqdkIsSUFBTCxHQUFrQixFQUFsQjtBQUNBLFNBQUtrSyxNQUFMLEdBQWtCLFVBQWxCLENBVnlCLENBVUs7O0FBQzlCLFNBQUsrRCxNQUFMLEdBQWtCLEVBQWxCO0FBQ0EsU0FBS2xILElBQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLbW9CLFVBQUwsR0FBa0IsS0FBbEI7QUFDQSxTQUFLeG5CLE9BQUwsR0FBa0IsSUFBbEI7QUFDQSxTQUFLb2YsVUFBTCxHQUFrQixJQUFJN04sUUFBTyxDQUFDMlUsWUFBWixFQUFsQjtBQUVBLFNBQUsvUSxXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQXBCRDs7QUFzQkFsTixVQUFPLENBQUNpUCxVQUFSLENBQW1CL2pCLElBQW5CLENBQXdCOFUsUUFBTyxDQUFDK1YsT0FBaEM7O0FBRUEvVixVQUFPLENBQUMrVixPQUFSLENBQWdCdHNCLFNBQWhCLEdBQTRCZSxNQUFNLENBQUMwQixNQUFQLENBQWM4VCxRQUFPLENBQUMyRCxJQUFSLENBQWFsYSxTQUEzQixDQUE1QjtBQUVBd1csR0FBQyxDQUFDdUUsTUFBRixDQUFTeEUsUUFBTyxDQUFDK1YsT0FBUixDQUFnQnRzQixTQUF6QjtBQUNBO0FBQ0E7QUFDSUQsZUFBVyxFQUFFd1csUUFBTyxDQUFDK1YsT0FEekI7O0FBR0k7Ozs7OztBQU9BMUYsUUFBSSxFQUFFLGNBQVM5WCxFQUFULEVBQWF4UixJQUFiLEVBQW1CbUksUUFBbkIsRUFBNkI7QUFDL0IsVUFBSTVDLElBQUksR0FBRyxJQUFYO0FBRUEsV0FBS3NYLFdBQUwsQ0FBaUIsWUFBakIsRUFBK0I3WSxTQUEvQjtBQUVBdUIsVUFBSSxDQUFDaU0sRUFBTCxHQUFrQkEsRUFBbEI7QUFDQWpNLFVBQUksQ0FBQ3ZGLElBQUwsR0FBa0JBLElBQWxCO0FBQ0F1RixVQUFJLENBQUM0QyxRQUFMLEdBQWtCQSxRQUFsQjs7QUFFQSxVQUFJNUMsSUFBSSxDQUFDNEMsUUFBVCxFQUFtQjtBQUNmNUMsWUFBSSxDQUFDMkUsTUFBTCxHQUFjLE1BQWQ7QUFDSCxPQUZELE1BRU87QUFDSDNFLFlBQUksQ0FBQzJwQixVQUFMLEdBQWtCLE9BQU8zcEIsSUFBSSxDQUFDaU0sRUFBTCxDQUFRckksT0FBZixLQUEyQixTQUE3Qzs7QUFFQSxnQkFBUTVELElBQUksQ0FBQ3ZGLElBQWI7QUFDSSxlQUFLLFFBQUw7QUFDSXVGLGdCQUFJLENBQUMwSSxNQUFMLEdBQWMxSSxJQUFJLENBQUNpTSxFQUFMLENBQVF3RixZQUFSLENBQXFCLGFBQXJCLENBQWQ7QUFFQTs7QUFDSixlQUFLLFFBQUw7QUFDSXpSLGdCQUFJLENBQUMwSSxNQUFMLEdBQWMxSSxJQUFJLENBQUNpTSxFQUFMLENBQVF3RixZQUFSLENBQXFCLGFBQXJCLENBQWQ7QUFFQTs7QUFDSixlQUFLLE1BQUw7QUFDSXpSLGdCQUFJLENBQUN3QixJQUFMLEdBQWN4QixJQUFJLENBQUNpTSxFQUFMLENBQVF3RixZQUFSLENBQXFCLFdBQXJCLENBQWQ7QUFFQTs7QUFDSixlQUFLLFVBQUw7QUFDSXpSLGdCQUFJLENBQUMwSSxNQUFMLEdBQWMxSSxJQUFJLENBQUNpTSxFQUFMLENBQVF3RixZQUFSLENBQXFCLGFBQXJCLENBQWQ7QUFDQXpSLGdCQUFJLENBQUN3QixJQUFMLEdBQWN4QixJQUFJLENBQUNpTSxFQUFMLENBQVF3RixZQUFSLENBQXFCLFdBQXJCLENBQWQ7QUFFQTtBQWpCUjtBQW1CSDs7QUFFRHpSLFVBQUksQ0FBQzRwQixTQUFMOztBQUVBbFcsY0FBTyxDQUFDdkIsUUFBUixDQUFpQjlQLElBQWpCLENBQXNCckMsSUFBdEI7O0FBRUEsV0FBS3NYLFdBQUwsQ0FBaUIsV0FBakIsRUFBOEI3WSxTQUE5QjtBQUNILEtBbERMOztBQW9ESTs7Ozs7QUFNQW9yQixXQUFPLEVBQUUsaUJBQVNDLEtBQVQsRUFBZ0I7QUFDckIsVUFBSTlwQixJQUFJLEdBQU0sSUFBZDtBQUFBLFVBQ0k2cEIsT0FBTyxHQUFHLEtBRGQ7QUFHQSxXQUFLdlMsV0FBTCxDQUFpQixlQUFqQixFQUFrQzdZLFNBQWxDO0FBRUFvckIsYUFBTyxHQUFHN3BCLElBQUksQ0FBQy9FLEtBQUwsQ0FBV2tTLE9BQVgsQ0FBbUIyYyxLQUFuQixJQUE0QixDQUFDLENBQXZDO0FBRUEsYUFBTzlwQixJQUFJLENBQUN1aUIsV0FBTCxDQUFpQixjQUFqQixFQUFpQ3NILE9BQWpDLEVBQTBDcHJCLFNBQTFDLENBQVA7QUFDSCxLQW5FTDs7QUFxRUk7Ozs7O0FBTUFzckIsY0FBVSxFQUFFLG9CQUFTRCxLQUFULEVBQWdCO0FBQ3hCLFVBQUk5cEIsSUFBSSxHQUFHLElBQVg7QUFFQSxXQUFLc1gsV0FBTCxDQUFpQixrQkFBakIsRUFBcUM3WSxTQUFyQzs7QUFFQSxVQUFJLENBQUN1QixJQUFJLENBQUM2cEIsT0FBTCxFQUFMLEVBQXFCO0FBQ2pCN3BCLFlBQUksQ0FBQy9FLEtBQUwsQ0FBV29ILElBQVgsQ0FBZ0J5bkIsS0FBaEI7QUFDSDs7QUFFRCxXQUFLeFMsV0FBTCxDQUFpQixpQkFBakIsRUFBb0M3WSxTQUFwQztBQUNILEtBckZMOztBQXVGSTs7Ozs7QUFNQXVyQixpQkFBYSxFQUFFLHVCQUFTRixLQUFULEVBQWdCO0FBQzNCLFVBQUk5cEIsSUFBSSxHQUFVLElBQWxCO0FBQUEsVUFDSWlxQixXQUFXLEdBQUcsQ0FBQyxDQURuQjtBQUdBLFdBQUszUyxXQUFMLENBQWlCLHFCQUFqQixFQUF3QzdZLFNBQXhDOztBQUVBLFVBQUksQ0FBQ3dyQixXQUFXLEdBQUdqcUIsSUFBSSxDQUFDL0UsS0FBTCxDQUFXa1MsT0FBWCxDQUFtQjJjLEtBQW5CLENBQWYsSUFBNEMsQ0FBQyxDQUFqRCxFQUFvRDtBQUNoRDlwQixZQUFJLENBQUMvRSxLQUFMLENBQVdpdkIsTUFBWCxDQUFrQkQsV0FBbEIsRUFBK0IsQ0FBL0I7QUFDSDs7QUFFRCxVQUFJanFCLElBQUksQ0FBQy9FLEtBQUwsQ0FBVzRDLE1BQVgsR0FBb0IsQ0FBeEIsRUFBMkI7QUFDdkI7QUFFQW1DLFlBQUksQ0FBQ21xQixXQUFMLEdBSHVCLENBS3ZCOztBQUVBRixtQkFBVyxHQUFHdlcsUUFBTyxDQUFDdkIsUUFBUixDQUFpQmhGLE9BQWpCLENBQXlCbk4sSUFBekIsQ0FBZDs7QUFFQTBULGdCQUFPLENBQUN2QixRQUFSLENBQWlCK1gsTUFBakIsQ0FBd0JELFdBQXhCLEVBQXFDLENBQXJDOztBQUVBLFlBQUlqcUIsSUFBSSxDQUFDMkUsTUFBTCxLQUFnQixRQUFwQixFQUE4QjtBQUMxQjNFLGNBQUksQ0FBQ29xQixZQUFMLENBQWtCcHFCLElBQUksQ0FBQ2lNLEVBQXZCLEVBQTJCLFVBQTNCO0FBQ0g7QUFDSjs7QUFFRCxXQUFLcUwsV0FBTCxDQUFpQixvQkFBakIsRUFBdUM3WSxTQUF2QztBQUNILEtBeEhMOztBQTBISTs7OztBQUtBbXJCLGFBQVMsRUFBRSxxQkFBVztBQUNsQixVQUFJNXBCLElBQUksR0FBRyxJQUFYO0FBRUEsV0FBS3NYLFdBQUwsQ0FBaUIsaUJBQWpCLEVBQW9DN1ksU0FBcEM7O0FBRUF1QixVQUFJLENBQUNtQyxPQUFMLEdBQWUsVUFBU21NLENBQVQsRUFBWTtBQUN2QnRPLFlBQUksQ0FBQ3FxQixXQUFMLENBQWlCL2IsQ0FBakI7QUFDSCxPQUZEOztBQUlBcUYsT0FBQyxDQUFDMVIsRUFBRixDQUFLakMsSUFBSSxDQUFDaU0sRUFBVixFQUFjLE9BQWQsRUFBdUJqTSxJQUFJLENBQUNtQyxPQUE1QjtBQUVBLFdBQUttVixXQUFMLENBQWlCLGdCQUFqQixFQUFtQzdZLFNBQW5DO0FBQ0gsS0EzSUw7O0FBNklJOzs7O0FBS0EwckIsZUFBVyxFQUFFLHVCQUFXO0FBQ3BCLFVBQUlucUIsSUFBSSxHQUFHLElBQVg7QUFFQSxXQUFLc1gsV0FBTCxDQUFpQixtQkFBakIsRUFBc0M3WSxTQUF0QztBQUVBa1YsT0FBQyxDQUFDdEgsR0FBRixDQUFNck0sSUFBSSxDQUFDaU0sRUFBWCxFQUFlLE9BQWYsRUFBd0JqTSxJQUFJLENBQUNtQyxPQUE3QjtBQUVBbkMsVUFBSSxDQUFDbUMsT0FBTCxHQUFlLElBQWY7QUFFQSxXQUFLbVYsV0FBTCxDQUFpQixrQkFBakIsRUFBcUM3WSxTQUFyQztBQUNILEtBNUpMOztBQThKSTs7Ozs7QUFNQTRyQixlQUFXLEVBQUUscUJBQVMvYixDQUFULEVBQVk7QUFDckIsVUFBSXRPLElBQUksR0FBVSxJQUFsQjtBQUFBLFVBQ0lzcUIsTUFBTSxHQUFRLElBRGxCO0FBQUEsVUFFSVIsS0FBSyxHQUFTLElBRmxCO0FBQUEsVUFHSVMsUUFBUSxHQUFNLEtBSGxCO0FBQUEsVUFJSXJRLFdBQVcsR0FBRyxLQUFLLENBSnZCO0FBQUEsVUFLSXNRLE9BQU8sR0FBTyxFQUxsQjtBQUFBLFVBTUl2ZixLQUFLLEdBQVMsSUFObEI7QUFBQSxVQU9Jd2YsUUFBUSxHQUFNLEVBUGxCO0FBQUEsVUFRSTdzQixDQUFDLEdBQWEsQ0FBQyxDQVJuQjtBQVVBLFdBQUswWixXQUFMLENBQWlCLG1CQUFqQixFQUFzQzdZLFNBQXRDO0FBRUEsV0FBS2lyQixPQUFMLEdBQWUsQ0FBZjtBQUVBSSxXQUFLLEdBQUc5cEIsSUFBSSxDQUFDL0UsS0FBTCxDQUFXLENBQVgsQ0FBUjs7QUFFQSxVQUFJLENBQUMrRSxJQUFJLENBQUM0QyxRQUFWLEVBQW9CO0FBQ2hCMG5CLGNBQU0sR0FBR3RxQixJQUFJLENBQUNpTSxFQUFkO0FBQ0gsT0FGRCxNQUVPO0FBQ0hxZSxjQUFNLEdBQUczVyxDQUFDLENBQUNxSyxhQUFGLENBQWdCMVAsQ0FBQyxDQUFDNVEsTUFBbEIsRUFBMEJvc0IsS0FBSyxDQUFDL1QsTUFBTixDQUFhaVMsU0FBYixDQUF1QmpILE9BQXZCLEdBQWlDL2dCLElBQUksQ0FBQzRDLFFBQWhFLEVBQTBFLElBQTFFLEVBQWdGa25CLEtBQUssQ0FBQ1ksR0FBTixDQUFVM2hCLFFBQTFGLENBQVQ7QUFDSDs7QUFFRCxVQUFJLENBQUN1aEIsTUFBTCxFQUFhO0FBQ1R0cUIsWUFBSSxDQUFDc1gsV0FBTCxDQUFpQixrQkFBakIsRUFBcUM3WSxTQUFyQztBQUVBO0FBQ0g7O0FBRUQsY0FBUXVCLElBQUksQ0FBQ3ZGLElBQWI7QUFDSSxhQUFLLFFBQUw7QUFDSSt2QixpQkFBTyxDQUFDOWhCLE1BQVIsR0FBaUIxSSxJQUFJLENBQUMwSSxNQUFMLElBQWU0aEIsTUFBTSxDQUFDN1ksWUFBUCxDQUFvQixhQUFwQixDQUFoQztBQUVBOztBQUNKLGFBQUssTUFBTDtBQUNJK1ksaUJBQU8sQ0FBQ2hwQixJQUFSLEdBQWV4QixJQUFJLENBQUN3QixJQUFMLElBQWE4b0IsTUFBTSxDQUFDN1ksWUFBUCxDQUFvQixXQUFwQixDQUE1QjtBQUVBOztBQUNKLGFBQUssVUFBTDtBQUNJK1ksaUJBQU8sQ0FBQzloQixNQUFSLEdBQWtCMUksSUFBSSxDQUFDMEksTUFBTCxJQUFlNGhCLE1BQU0sQ0FBQzdZLFlBQVAsQ0FBb0IsYUFBcEIsQ0FBakM7QUFDQStZLGlCQUFPLENBQUNocEIsSUFBUixHQUFrQnhCLElBQUksQ0FBQ3dCLElBQUwsSUFBYThvQixNQUFNLENBQUM3WSxZQUFQLENBQW9CLFdBQXBCLENBQS9CO0FBRUE7O0FBQ0osYUFBSyxRQUFMO0FBQ0krWSxpQkFBTyxDQUFDOWhCLE1BQVIsR0FBa0IxSSxJQUFJLENBQUMwSSxNQUFMLElBQWU0aEIsTUFBTSxDQUFDN1ksWUFBUCxDQUFvQixhQUFwQixDQUFqQzs7QUFFQSxjQUFJelIsSUFBSSxDQUFDMkUsTUFBTCxLQUFnQixNQUFwQixFQUE0QjtBQUN4QjRsQixvQkFBUSxHQUFHNVcsQ0FBQyxDQUFDa0UsUUFBRixDQUFXeVMsTUFBWCxFQUFtQnRxQixJQUFJLENBQUN1aEIsVUFBTCxDQUFnQmdILE1BQW5DLENBQVg7QUFDSCxXQUZELE1BRU87QUFDSGdDLG9CQUFRLEdBQUd2cUIsSUFBSSxDQUFDMkUsTUFBTCxLQUFnQixRQUEzQjtBQUNIOztBQUVEO0FBdkJSOztBQTBCQSxXQUFLL0csQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHb0MsSUFBSSxDQUFDL0UsS0FBTCxDQUFXNEMsTUFBM0IsRUFBbUNELENBQUMsRUFBcEMsRUFBd0M7QUFDcEM7QUFFQXFOLGFBQUssR0FBRyxJQUFJeUksUUFBTyxDQUFDK1UsZUFBWixFQUFSO0FBRUE5VSxTQUFDLENBQUN1RSxNQUFGLENBQVNqTixLQUFULEVBQWdCdWYsT0FBaEI7QUFFQUMsZ0JBQVEsQ0FBQ3BvQixJQUFULENBQWM0SSxLQUFkO0FBQ0g7O0FBRUR3ZixjQUFRLEdBQUd6cUIsSUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIscUJBQWpCLEVBQXdDa0ksUUFBeEMsRUFBa0Roc0IsU0FBbEQsQ0FBWDtBQUVBdUIsVUFBSSxDQUFDMHBCLE9BQUwsR0FBZTFwQixJQUFJLENBQUMvRSxLQUFMLENBQVc0QyxNQUExQjs7QUFFQSxXQUFLRCxDQUFDLEdBQUcsQ0FBVCxFQUFZa3NCLEtBQUssR0FBRzlwQixJQUFJLENBQUMvRSxLQUFMLENBQVcyQyxDQUFYLENBQXBCLEVBQW1DQSxDQUFDLEVBQXBDLEVBQXdDO0FBQ3BDNHNCLGVBQU8sR0FBR0MsUUFBUSxDQUFDN3NCLENBQUQsQ0FBbEI7O0FBRUEsWUFBSSxDQUFDNHNCLE9BQUwsRUFBYztBQUNWO0FBRUE7QUFDSDs7QUFFRCxZQUFJLENBQUNWLEtBQUssQ0FBQ2EsV0FBWCxFQUF3QjtBQUNwQmIsZUFBSyxDQUFDYSxXQUFOLEdBQW9CTCxNQUFwQjtBQUNIOztBQUVENVcsZ0JBQU8sQ0FBQzFTLE1BQVIsQ0FBZTRwQixJQUFmLENBQW9CLFVBQXBCLEVBQWdDZCxLQUFLLENBQUNZLEdBQU4sQ0FBVTVVLFNBQTFDLEVBQXFEO0FBQ2pEK1UsZUFBSyxFQUFFZixLQUFLLENBQUNlLEtBRG9DO0FBRWpEeHRCLGtCQUFRLEVBQUV5c0IsS0FGdUM7QUFHakRnQix1QkFBYSxFQUFFeGMsQ0FIa0M7QUFJakR5UyxpQkFBTyxFQUFFK0ksS0FBSyxDQUFDYTtBQUprQyxTQUFyRCxFQUtHYixLQUFLLENBQUNZLEdBQU4sQ0FBVTNoQixRQUxiOztBQU9BLFlBQUksT0FBTytnQixLQUFLLENBQUMvVCxNQUFOLENBQWE4UixTQUFiLENBQXVCakMsVUFBOUIsS0FBNkMsVUFBakQsRUFBNkQ7QUFDekQxTCxxQkFBVyxHQUFHNFAsS0FBSyxDQUFDL1QsTUFBTixDQUFhOFIsU0FBYixDQUF1QmpDLFVBQXZCLENBQWtDaG5CLElBQWxDLENBQXVDa3JCLEtBQUssQ0FBQ2EsV0FBN0MsRUFBMERiLEtBQUssQ0FBQ2UsS0FBaEUsRUFBdUV2YyxDQUF2RSxFQUEwRXdiLEtBQTFFLENBQWQ7O0FBRUEsY0FBSTVQLFdBQVcsS0FBSyxLQUFwQixFQUEyQjtBQUN2QjtBQUVBO0FBQ0g7QUFDSjs7QUFFRCxZQUFJbGEsSUFBSSxDQUFDdkYsSUFBTCxLQUFjLFFBQWxCLEVBQTRCO0FBQ3hCOHZCLGtCQUFRLEdBQUdULEtBQUssQ0FBQ2lCLFNBQU4sQ0FBZ0JQLE9BQU8sQ0FBQzloQixNQUF4QixDQUFILEdBQXFDb2hCLEtBQUssQ0FBQ2tCLFFBQU4sQ0FBZVIsT0FBTyxDQUFDOWhCLE1BQXZCLENBQTdDO0FBQ0gsU0FGRCxNQUVPO0FBQ0hvaEIsZUFBSyxDQUFDbUIsUUFBTixDQUFlVCxPQUFmO0FBQ0g7QUFDSjs7QUFFRCxXQUFLbFQsV0FBTCxDQUFpQixrQkFBakIsRUFBcUM3WSxTQUFyQztBQUNILEtBL1FMOztBQWlSSTs7Ozs7QUFNQTJFLFVBQU0sRUFBRSxnQkFBU29uQixPQUFULEVBQWtCVSxXQUFsQixFQUErQjtBQUNuQyxVQUFJbHJCLElBQUksR0FBTSxJQUFkO0FBQUEsVUFDSXFpQixPQUFPLEdBQUcsSUFBSTNPLFFBQU8sQ0FBQytVLGVBQVosRUFEZDtBQUdBem9CLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsY0FBakIsRUFBaUM3WSxTQUFqQztBQUVBdUIsVUFBSSxDQUFDMHBCLE9BQUw7QUFFQTFwQixVQUFJLENBQUMwcEIsT0FBTCxHQUFlcGtCLElBQUksQ0FBQ3lGLEdBQUwsQ0FBUyxDQUFULEVBQVkvSyxJQUFJLENBQUMwcEIsT0FBakIsQ0FBZjtBQUVBLFVBQUkxcEIsSUFBSSxDQUFDMHBCLE9BQUwsR0FBZSxDQUFuQixFQUFzQjs7QUFFdEIsVUFBSTFwQixJQUFJLENBQUMyRSxNQUFMLEtBQWdCLE1BQXBCLEVBQTRCO0FBQ3hCO0FBRUEzRSxZQUFJLENBQUNtckIsVUFBTCxDQUFnQlgsT0FBaEIsRUFBeUJVLFdBQXpCO0FBQ0gsT0FKRCxNQUlPO0FBQ0g7QUFFQTdJLGVBQU8sQ0FBQzdnQixJQUFSLEdBQWtCeEIsSUFBSSxDQUFDd0IsSUFBdkI7QUFDQTZnQixlQUFPLENBQUMzWixNQUFSLEdBQWtCMUksSUFBSSxDQUFDMEksTUFBdkI7QUFFQTFJLFlBQUksQ0FBQ3VpQixXQUFMLENBQWlCLGVBQWpCLEVBQWtDRixPQUFsQyxFQUEyQzVqQixTQUEzQztBQUVBdUIsWUFBSSxDQUFDb3JCLGlCQUFMLENBQXVCcHJCLElBQUksQ0FBQ2lNLEVBQTVCLEVBQWdDdWUsT0FBaEMsRUFBeUNuSSxPQUF6QyxFQUFrRDZJLFdBQWxEO0FBQ0g7O0FBRURsckIsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixhQUFqQixFQUFnQzdZLFNBQWhDO0FBQ0gsS0FuVEw7O0FBcVRJOzs7OztBQU1BMHNCLGNBQVUsRUFBRSxvQkFBU1gsT0FBVCxFQUFrQlUsV0FBbEIsRUFBK0I7QUFDdkMsVUFBSWxyQixJQUFJLEdBQWMsSUFBdEI7QUFBQSxVQUNJcXJCLGNBQWMsR0FBSSxJQUR0QjtBQUFBLFVBRUloSixPQUFPLEdBQVcsSUFGdEI7QUFBQSxVQUdJaUksTUFBTSxHQUFZLElBSHRCO0FBQUEsVUFJSTFzQixDQUFDLEdBQWlCLENBQUMsQ0FKdkI7QUFNQW9DLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsa0JBQWpCLEVBQXFDN1ksU0FBckM7QUFFQSxVQUFJLENBQUN1QixJQUFJLENBQUNpTSxFQUFWLEVBQWM7QUFFZG9mLG9CQUFjLEdBQUdyckIsSUFBSSxDQUFDaU0sRUFBTCxDQUFRbUYsZ0JBQVIsQ0FBeUJwUixJQUFJLENBQUM0QyxRQUE5QixDQUFqQjs7QUFFQSxXQUFLaEYsQ0FBQyxHQUFHLENBQVQsRUFBWTBzQixNQUFNLEdBQUdlLGNBQWMsQ0FBQ3p0QixDQUFELENBQW5DLEVBQXdDQSxDQUFDLEVBQXpDLEVBQTZDO0FBQ3pDeWtCLGVBQU8sR0FBRyxJQUFJM08sUUFBTyxDQUFDK1UsZUFBWixFQUFWOztBQUVBLGdCQUFRem9CLElBQUksQ0FBQ3ZGLElBQWI7QUFDSSxlQUFLLFFBQUw7QUFDSTRuQixtQkFBTyxDQUFDM1osTUFBUixHQUFpQjRoQixNQUFNLENBQUM3WSxZQUFQLENBQW9CLGFBQXBCLENBQWpCO0FBRUE7O0FBQ0osZUFBSyxNQUFMO0FBQ0k0USxtQkFBTyxDQUFDN2dCLElBQVIsR0FBZThvQixNQUFNLENBQUM3WSxZQUFQLENBQW9CLFdBQXBCLENBQWY7QUFFQTs7QUFDSixlQUFLLFVBQUw7QUFDSTRRLG1CQUFPLENBQUMzWixNQUFSLEdBQWtCNGhCLE1BQU0sQ0FBQzdZLFlBQVAsQ0FBb0IsYUFBcEIsQ0FBbEI7QUFDQTRRLG1CQUFPLENBQUM3Z0IsSUFBUixHQUFrQjhvQixNQUFNLENBQUM3WSxZQUFQLENBQW9CLFdBQXBCLENBQWxCO0FBRUE7O0FBQ0osZUFBSyxRQUFMO0FBQ0k0USxtQkFBTyxDQUFDM1osTUFBUixHQUFrQjRoQixNQUFNLENBQUM3WSxZQUFQLENBQW9CLGFBQXBCLENBQWxCO0FBRUE7QUFqQlI7O0FBb0JBNFEsZUFBTyxHQUFHcmlCLElBQUksQ0FBQ3VpQixXQUFMLENBQWlCLG1CQUFqQixFQUFzQ0YsT0FBdEMsRUFBK0M1akIsU0FBL0MsQ0FBVjtBQUVBdUIsWUFBSSxDQUFDb3JCLGlCQUFMLENBQXVCZCxNQUF2QixFQUErQkUsT0FBL0IsRUFBd0NuSSxPQUF4QyxFQUFpRDZJLFdBQWpEO0FBQ0g7O0FBRURsckIsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixpQkFBakIsRUFBb0M3WSxTQUFwQztBQUNILEtBcldMOztBQXVXSTs7Ozs7OztBQVFBMnNCLHFCQUFpQixFQUFFLDJCQUFTZCxNQUFULEVBQWlCRSxPQUFqQixFQUEwQm5JLE9BQTFCLEVBQW1DNkksV0FBbkMsRUFBZ0Q7QUFDL0QsVUFBSWxyQixJQUFJLEdBQU0sSUFBZDtBQUFBLFVBQ0lzckIsS0FBSyxHQUFLLEVBRGQ7QUFBQSxVQUVJQyxNQUFNLEdBQUksRUFGZDtBQUFBLFVBR0kzdEIsQ0FBQyxHQUFTLENBQUMsQ0FIZjtBQUtBb0MsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQix5QkFBakIsRUFBNEM3WSxTQUE1Qzs7QUFFQSxjQUFRdUIsSUFBSSxDQUFDdkYsSUFBYjtBQUNJLGFBQUssUUFBTDtBQUNJLGNBQUkrdkIsT0FBTyxDQUFDOWhCLE1BQVIsS0FBbUIyWixPQUFPLENBQUMzWixNQUEvQixFQUF1QztBQUNuQzFJLGdCQUFJLENBQUNvcUIsWUFBTCxDQUFrQkUsTUFBbEIsRUFBMEIsUUFBMUI7QUFDSCxXQUZELE1BRU87QUFDSHRxQixnQkFBSSxDQUFDb3FCLFlBQUwsQ0FBa0JFLE1BQWxCLEVBQTBCLFVBQTFCO0FBQ0g7O0FBRUQ7O0FBQ0osYUFBSyxVQUFMO0FBQ0ksY0FBSUUsT0FBTyxDQUFDaHBCLElBQVIsS0FBaUI2Z0IsT0FBTyxDQUFDN2dCLElBQXpCLElBQWlDZ3BCLE9BQU8sQ0FBQzloQixNQUFSLEtBQW1CMlosT0FBTyxDQUFDM1osTUFBaEUsRUFBd0U7QUFDcEUxSSxnQkFBSSxDQUFDb3FCLFlBQUwsQ0FBa0JFLE1BQWxCLEVBQTBCLFFBQTFCO0FBQ0gsV0FGRCxNQUVPO0FBQ0h0cUIsZ0JBQUksQ0FBQ29xQixZQUFMLENBQWtCRSxNQUFsQixFQUEwQixVQUExQjtBQUNIOztBQUVEOztBQUNKLGFBQUssTUFBTDtBQUNJLGNBQUlFLE9BQU8sQ0FBQ2hwQixJQUFSLENBQWEwUixLQUFiLENBQW1CLE9BQW5CLENBQUosRUFBaUM7QUFDN0JvWSxpQkFBSyxHQUFHZCxPQUFPLENBQUNocEIsSUFBUixDQUFhMlQsT0FBYixDQUFxQixPQUFyQixFQUE4QixFQUE5QixDQUFSO0FBQ0g7O0FBRUQsY0FBSXFWLE9BQU8sQ0FBQ2hwQixJQUFSLEtBQWlCNmdCLE9BQU8sQ0FBQzdnQixJQUF6QixJQUFpQzhwQixLQUFLLEtBQUtqSixPQUFPLENBQUM3Z0IsSUFBdkQsRUFBNkQ7QUFDekR4QixnQkFBSSxDQUFDb3FCLFlBQUwsQ0FBa0JFLE1BQWxCLEVBQTBCLFFBQTFCO0FBQ0gsV0FGRCxNQUVPO0FBQ0h0cUIsZ0JBQUksQ0FBQ29xQixZQUFMLENBQWtCRSxNQUFsQixFQUEwQixVQUExQjtBQUNIOztBQUVEOztBQUNKLGFBQUssUUFBTDtBQUNJLGNBQUlZLFdBQVcsQ0FBQ3J0QixNQUFaLEdBQXFCLENBQXpCLEVBQTRCbUMsSUFBSSxDQUFDb3FCLFlBQUwsQ0FBa0JFLE1BQWxCLEVBQTBCLFVBQTFCOztBQUU1QixjQUFJRSxPQUFPLENBQUM5aEIsTUFBUixLQUFtQjJaLE9BQU8sQ0FBQzNaLE1BQS9CLEVBQXVDO0FBQ25DMUksZ0JBQUksQ0FBQ29xQixZQUFMLENBQWtCRSxNQUFsQixFQUEwQixRQUExQjtBQUNIOztBQUVELGVBQUsxc0IsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHc3RCLFdBQVcsQ0FBQ3J0QixNQUE1QixFQUFvQ0QsQ0FBQyxFQUFyQyxFQUF5QztBQUNyQzJ0QixrQkFBTSxHQUFHTCxXQUFXLENBQUN0dEIsQ0FBRCxDQUFwQjs7QUFFQSxnQkFBSTJ0QixNQUFNLEtBQUtsSixPQUFPLENBQUMzWixNQUF2QixFQUErQjtBQUMzQjtBQUVBMUksa0JBQUksQ0FBQ29xQixZQUFMLENBQWtCRSxNQUFsQixFQUEwQixRQUExQjtBQUVBO0FBQ0g7O0FBRUR0cUIsZ0JBQUksQ0FBQ29xQixZQUFMLENBQWtCRSxNQUFsQixFQUEwQixVQUExQjtBQUNIOztBQUVEO0FBbERSOztBQXFEQXRxQixVQUFJLENBQUNzWCxXQUFMLENBQWlCLHdCQUFqQixFQUEyQzdZLFNBQTNDO0FBQ0gsS0E3YUw7O0FBK2FJOzs7OztBQU1BMnJCLGdCQUFZLEVBQUUsc0JBQVNFLE1BQVQsRUFBaUIzbEIsTUFBakIsRUFBeUI7QUFDbkMsVUFBSTNFLElBQUksR0FBRyxJQUFYO0FBRUFBLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsb0JBQWpCLEVBQXVDN1ksU0FBdkM7O0FBRUEsY0FBUWtHLE1BQVI7QUFDSSxhQUFLLFFBQUw7QUFDSWdQLFdBQUMsQ0FBQzFHLFFBQUYsQ0FBV3FkLE1BQVgsRUFBbUJ0cUIsSUFBSSxDQUFDdWhCLFVBQUwsQ0FBZ0JnSCxNQUFuQztBQUNBNVUsV0FBQyxDQUFDekcsV0FBRixDQUFjb2QsTUFBZCxFQUFzQnRxQixJQUFJLENBQUN1aEIsVUFBTCxDQUFnQnZlLFFBQXRDO0FBRUEsY0FBSWhELElBQUksQ0FBQzJwQixVQUFULEVBQXFCM3BCLElBQUksQ0FBQ2lNLEVBQUwsQ0FBUWpKLFFBQVIsR0FBbUIsS0FBbkI7QUFFckI7O0FBQ0osYUFBSyxVQUFMO0FBQ0kyUSxXQUFDLENBQUN6RyxXQUFGLENBQWNvZCxNQUFkLEVBQXNCdHFCLElBQUksQ0FBQ3VoQixVQUFMLENBQWdCZ0gsTUFBdEM7QUFDQTVVLFdBQUMsQ0FBQ3pHLFdBQUYsQ0FBY29kLE1BQWQsRUFBc0J0cUIsSUFBSSxDQUFDdWhCLFVBQUwsQ0FBZ0J2ZSxRQUF0QztBQUVBLGNBQUloRCxJQUFJLENBQUMycEIsVUFBVCxFQUFxQjNwQixJQUFJLENBQUNpTSxFQUFMLENBQVFqSixRQUFSLEdBQW1CLEtBQW5CO0FBRXJCOztBQUNKLGFBQUssVUFBTDtBQUNJLGNBQUloRCxJQUFJLENBQUMycEIsVUFBVCxFQUFxQjNwQixJQUFJLENBQUNpTSxFQUFMLENBQVFqSixRQUFSLEdBQW1CLElBQW5CO0FBRXJCMlEsV0FBQyxDQUFDMUcsUUFBRixDQUFXcWQsTUFBWCxFQUFtQnRxQixJQUFJLENBQUN1aEIsVUFBTCxDQUFnQnZlLFFBQW5DO0FBQ0EyUSxXQUFDLENBQUN6RyxXQUFGLENBQWNvZCxNQUFkLEVBQXNCdHFCLElBQUksQ0FBQ3VoQixVQUFMLENBQWdCZ0gsTUFBdEM7QUFFQTtBQXJCUjs7QUF3QkEsVUFBSXZvQixJQUFJLENBQUMyRSxNQUFMLEtBQWdCLE1BQXBCLEVBQTRCO0FBQ3hCO0FBRUEzRSxZQUFJLENBQUMyRSxNQUFMLEdBQWNBLE1BQWQ7QUFDSDs7QUFFRDNFLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsbUJBQWpCLEVBQXNDN1ksU0FBdEM7QUFDSDtBQXpkTCxHQUZBO0FBOGRBaVYsVUFBTyxDQUFDdkIsUUFBUixHQUFtQixFQUFuQjtBQUVBOzs7Ozs7O0FBT0F1QixVQUFPLENBQUM4WCxTQUFSLEdBQW9CLFlBQVc7QUFDM0I5WCxZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBLFNBQUt1RixDQUFMLEdBQXNCLENBQXRCO0FBQ0EsU0FBS0MsQ0FBTCxHQUFzQixDQUF0QjtBQUNBLFNBQUtpQixHQUFMLEdBQXNCLENBQXRCO0FBQ0EsU0FBSzBOLEtBQUwsR0FBc0IsQ0FBdEI7QUFDQSxTQUFLQyxNQUFMLEdBQXNCLENBQXRCO0FBQ0EsU0FBSzVOLElBQUwsR0FBc0IsQ0FBdEI7QUFDQSxTQUFLcFUsS0FBTCxHQUFzQixDQUF0QjtBQUNBLFNBQUsrVCxNQUFMLEdBQXNCLENBQXRCO0FBQ0EsU0FBS25XLFdBQUwsR0FBc0IsQ0FBdEI7QUFDQSxTQUFLcWtCLFlBQUwsR0FBc0IsQ0FBdEI7QUFDQSxTQUFLaEwsT0FBTCxHQUFzQixDQUF0QjtBQUNBLFNBQUtpTCxLQUFMLEdBQXNCLElBQUlsWSxRQUFPLENBQUNtWSxhQUFaLEVBQXRCO0FBQ0EsU0FBS0MsVUFBTCxHQUFzQixJQUFJcFksUUFBTyxDQUFDbVksYUFBWixFQUF0QjtBQUNBLFNBQUtFLFVBQUwsR0FBc0IsSUFBSXJZLFFBQU8sQ0FBQ21ZLGFBQVosRUFBdEI7QUFDQSxTQUFLRyxVQUFMLEdBQXNCLElBQUl0WSxRQUFPLENBQUNtWSxhQUFaLEVBQXRCO0FBQ0EsU0FBS0ksT0FBTCxHQUFzQixJQUFJdlksUUFBTyxDQUFDbVksYUFBWixFQUF0QjtBQUNBLFNBQUtLLE9BQUwsR0FBc0IsSUFBSXhZLFFBQU8sQ0FBQ21ZLGFBQVosRUFBdEI7QUFDQSxTQUFLTSxPQUFMLEdBQXNCLElBQUl6WSxRQUFPLENBQUNtWSxhQUFaLEVBQXRCO0FBRUEsU0FBS3ZVLFdBQUwsQ0FBaUIsZ0JBQWpCO0FBRUEzRCxLQUFDLENBQUNpTixJQUFGLENBQU8sSUFBUDtBQUNILEdBM0JEOztBQTZCQWxOLFVBQU8sQ0FBQ2lQLFVBQVIsQ0FBbUIvakIsSUFBbkIsQ0FBd0I4VSxRQUFPLENBQUM4WCxTQUFoQzs7QUFFQTlYLFVBQU8sQ0FBQzhYLFNBQVIsQ0FBa0JydUIsU0FBbEIsR0FBOEJlLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYzhULFFBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQTNCLENBQTlCO0FBRUF1VyxVQUFPLENBQUM4WCxTQUFSLENBQWtCcnVCLFNBQWxCLENBQTRCRCxXQUE1QixHQUEwQ3dXLFFBQU8sQ0FBQzhYLFNBQWxEO0FBRUE7Ozs7Ozs7QUFPQTlYLFVBQU8sQ0FBQ21ZLGFBQVIsR0FBd0IsWUFBVztBQUMvQm5ZLFlBQU8sQ0FBQzJELElBQVIsQ0FBYXpZLElBQWIsQ0FBa0IsSUFBbEI7O0FBRUEsU0FBSzBZLFdBQUwsQ0FBaUIsaUJBQWpCO0FBRUEsU0FBSy9YLEtBQUwsR0FBYyxDQUFkO0FBQ0EsU0FBSzZzQixJQUFMLEdBQWMsRUFBZDtBQUVBLFNBQUs5VSxXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQVhEOztBQWFBbE4sVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQ21ZLGFBQWhDOztBQUVBblksVUFBTyxDQUFDbVksYUFBUixDQUFzQjF1QixTQUF0QixHQUFrQ2UsTUFBTSxDQUFDMEIsTUFBUCxDQUFjOFQsUUFBTyxDQUFDMkQsSUFBUixDQUFhbGEsU0FBM0IsQ0FBbEM7QUFFQXVXLFVBQU8sQ0FBQ21ZLGFBQVIsQ0FBc0IxdUIsU0FBdEIsQ0FBZ0NELFdBQWhDLEdBQThDd1csUUFBTyxDQUFDbVksYUFBdEQ7QUFFQTs7Ozs7OztBQU9BblksVUFBTyxDQUFDMlksaUJBQVIsR0FBNEIsWUFBVztBQUNuQzNZLFlBQU8sQ0FBQzhYLFNBQVIsQ0FBa0JobEIsS0FBbEIsQ0FBd0IsSUFBeEI7O0FBRUEsU0FBSzhRLFdBQUwsQ0FBaUIsaUJBQWpCO0FBRUEsU0FBS3NVLEtBQUwsQ0FBV3JzQixLQUFYLEdBQTBCLElBQTFCO0FBQ0EsU0FBS3FzQixLQUFMLENBQVdRLElBQVgsR0FBMEIsRUFBMUI7QUFFQSxTQUFLTixVQUFMLENBQWdCdnNCLEtBQWhCLEdBQTBCLEVBQTFCO0FBQ0EsU0FBS3VzQixVQUFMLENBQWdCTSxJQUFoQixHQUEwQixJQUExQjtBQUVBLFNBQUtMLFVBQUwsQ0FBZ0J4c0IsS0FBaEIsR0FBMEIsRUFBMUI7QUFDQSxTQUFLd3NCLFVBQUwsQ0FBZ0JLLElBQWhCLEdBQTBCLElBQTFCO0FBRUEsU0FBS0osVUFBTCxDQUFnQnpzQixLQUFoQixHQUEwQixFQUExQjtBQUNBLFNBQUt5c0IsVUFBTCxDQUFnQkksSUFBaEIsR0FBMEIsSUFBMUI7QUFFQSxTQUFLSCxPQUFMLENBQWExc0IsS0FBYixHQUEwQixFQUExQjtBQUNBLFNBQUswc0IsT0FBTCxDQUFhRyxJQUFiLEdBQTBCLEtBQTFCO0FBRUEsU0FBS0YsT0FBTCxDQUFhM3NCLEtBQWIsR0FBMEIsRUFBMUI7QUFDQSxTQUFLMnNCLE9BQUwsQ0FBYUUsSUFBYixHQUEwQixLQUExQjtBQUVBLFNBQUtILE9BQUwsQ0FBYTFzQixLQUFiLEdBQTBCLEVBQTFCO0FBQ0EsU0FBSzBzQixPQUFMLENBQWFHLElBQWIsR0FBMEIsS0FBMUI7QUFFQSxTQUFLRCxPQUFMLENBQWE1c0IsS0FBYixHQUEwQixHQUExQjtBQUNBLFNBQUs0c0IsT0FBTCxDQUFhQyxJQUFiLEdBQTBCLEtBQTFCO0FBRUEsU0FBSzlVLFdBQUwsQ0FBaUIsZ0JBQWpCO0FBRUEzRCxLQUFDLENBQUNpTixJQUFGLENBQU8sSUFBUDtBQUNILEdBaENEOztBQWtDQWxOLFVBQU8sQ0FBQ2lQLFVBQVIsQ0FBbUIvakIsSUFBbkIsQ0FBd0I4VSxRQUFPLENBQUMyWSxpQkFBaEM7O0FBRUEzWSxVQUFPLENBQUMyWSxpQkFBUixDQUEwQmx2QixTQUExQixHQUFzQ2UsTUFBTSxDQUFDMEIsTUFBUCxDQUFjOFQsUUFBTyxDQUFDOFgsU0FBUixDQUFrQnJ1QixTQUFoQyxDQUF0QztBQUVBdVcsVUFBTyxDQUFDMlksaUJBQVIsQ0FBMEJsdkIsU0FBMUIsQ0FBb0NELFdBQXBDLEdBQWtEd1csUUFBTyxDQUFDMlksaUJBQTFEO0FBRUE7Ozs7Ozs7QUFPQTNZLFVBQU8sQ0FBQzRZLGlCQUFSLEdBQTRCLElBQUk1WSxRQUFPLENBQUMyWSxpQkFBWixFQUE1QjtBQUVBOzs7Ozs7O0FBT0EzWSxVQUFPLENBQUM2WSxXQUFSLEdBQXNCLFlBQVc7QUFDN0IsU0FBSzFCLEtBQUwsR0FBc0IsSUFBdEI7QUFDQSxTQUFLMkIsV0FBTCxHQUFzQixJQUF0QjtBQUNBLFNBQUtudkIsUUFBTCxHQUFzQixJQUF0QjtBQUNBLFNBQUt5dEIsYUFBTCxHQUFzQixJQUF0QjtBQUNILEdBTEQ7QUFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQXBYLFVBQU8sQ0FBQzdPLE1BQVIsR0FBaUIsWUFBVztBQUN4QjZPLFlBQU8sQ0FBQzJELElBQVIsQ0FBYXpZLElBQWIsQ0FBa0IsSUFBbEI7O0FBRUEsU0FBSzBZLFdBQUwsQ0FBaUIsaUJBQWpCO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBY0EsU0FBS21WLFFBQUwsR0FBZ0IsSUFBaEI7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxTQUFLQyxPQUFMLEdBQWUsSUFBZjtBQUVBOzs7Ozs7Ozs7O0FBVUEsU0FBS0MsTUFBTCxHQUFjLElBQWQ7QUFFQTs7Ozs7Ozs7OztBQVVBLFNBQUtDLE9BQUwsR0FBZSxJQUFmO0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQSxTQUFLQyxRQUFMLEdBQWdCLElBQWhCO0FBRUEsU0FBS3ZWLFdBQUwsQ0FBaUIsZ0JBQWpCO0FBRUEzRCxLQUFDLENBQUNpTixJQUFGLENBQU8sSUFBUDtBQUNILEdBNUVEOztBQThFQWxOLFVBQU8sQ0FBQ2lQLFVBQVIsQ0FBbUIvakIsSUFBbkIsQ0FBd0I4VSxRQUFPLENBQUM3TyxNQUFoQzs7QUFFQTZPLFVBQU8sQ0FBQzdPLE1BQVIsQ0FBZTFILFNBQWYsR0FBMkJlLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYzhULFFBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQTNCLENBQTNCO0FBRUF1VyxVQUFPLENBQUM3TyxNQUFSLENBQWUxSCxTQUFmLENBQXlCRCxXQUF6QixHQUF1Q3dXLFFBQU8sQ0FBQzdPLE1BQS9DO0FBRUE7Ozs7Ozs7O0FBUUE2TyxVQUFPLENBQUM3TyxNQUFSLENBQWUxSCxTQUFmLENBQXlCeXRCLElBQXpCLEdBQWdDLFVBQVNsUixTQUFULEVBQW9Cek4sRUFBcEIsRUFBd0IwTixNQUF4QixFQUFnQ3hELEdBQWhDLEVBQXFDO0FBQ2pFLFFBQUluVyxJQUFJLEdBQVUsSUFBbEI7QUFBQSxRQUNJa0MsS0FBSyxHQUFTLElBRGxCO0FBQUEsUUFFSTRxQixXQUFXLEdBQUcsSUFBSXBaLFFBQU8sQ0FBQzZZLFdBQVosRUFGbEI7QUFJQXZzQixRQUFJLENBQUNzWCxXQUFMLENBQWlCLFlBQWpCLEVBQStCN1ksU0FBL0I7O0FBRUEsUUFBSSxPQUFPdUIsSUFBSSxDQUFDMFosU0FBRCxDQUFYLEtBQTJCLFdBQS9CLEVBQTRDO0FBQ3hDLFlBQU0sSUFBSWxELEtBQUosQ0FBVSxpQkFBaUJrRCxTQUFqQixHQUE2QixjQUF2QyxDQUFOO0FBQ0g7O0FBRURvVCxlQUFXLENBQUNqQyxLQUFaLEdBQW9CLElBQUluWCxRQUFPLENBQUNxWixLQUFaLEVBQXBCO0FBRUFwWixLQUFDLENBQUN1RSxNQUFGLENBQVM0VSxXQUFXLENBQUNqQyxLQUFyQixFQUE0QmxSLE1BQU0sQ0FBQ2tSLEtBQW5DOztBQUVBLFFBQUlsUixNQUFNLENBQUM2UyxXQUFYLEVBQXdCO0FBQ3BCTSxpQkFBVyxDQUFDTixXQUFaLEdBQTBCLElBQUk5WSxRQUFPLENBQUNxWixLQUFaLEVBQTFCO0FBRUFwWixPQUFDLENBQUN1RSxNQUFGLENBQVM0VSxXQUFXLENBQUNOLFdBQXJCLEVBQWtDN1MsTUFBTSxDQUFDNlMsV0FBekM7QUFDSDs7QUFFRE0sZUFBVyxDQUFDenZCLFFBQVosR0FBdUJzYyxNQUFNLENBQUN0YyxRQUE5Qjs7QUFFQSxRQUFJc2MsTUFBTSxDQUFDbVIsYUFBWCxFQUEwQjtBQUN0QmdDLGlCQUFXLENBQUNoQyxhQUFaLEdBQTRCblIsTUFBTSxDQUFDbVIsYUFBbkM7QUFDSDs7QUFFRDVvQixTQUFLLEdBQUd5UixDQUFDLENBQUM4RixjQUFGLENBQWlCQyxTQUFqQixFQUE0Qm9ULFdBQTVCLEVBQXlDM1csR0FBekMsQ0FBUjtBQUVBblcsUUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIsV0FBakIsRUFBOEJyZ0IsS0FBOUIsRUFBcUN6RCxTQUFyQztBQUVBd04sTUFBRSxDQUFDMEosYUFBSCxDQUFpQnpULEtBQWpCO0FBQ0gsR0FoQ0QsQ0EvdUpjLENBaXhKZDs7O0FBRUF3UixVQUFPLENBQUMxUyxNQUFSLEdBQWlCLElBQUkwUyxRQUFPLENBQUM3TyxNQUFaLEVBQWpCO0FBRUE7Ozs7Ozs7QUFPQTZPLFVBQU8sQ0FBQ3NaLFNBQVIsR0FBb0IsWUFBVztBQUMzQnRaLFlBQU8sQ0FBQzJELElBQVIsQ0FBYXpZLElBQWIsQ0FBa0IsSUFBbEI7O0FBRUEsU0FBSzBZLFdBQUwsQ0FBaUIsaUJBQWpCO0FBRUEsU0FBS25SLElBQUwsR0FBc0IsRUFBdEI7QUFDQSxTQUFLOG1CLFdBQUwsR0FBc0IsSUFBdEI7QUFDQSxTQUFLQyxjQUFMLEdBQXNCLElBQXRCO0FBQ0EsU0FBS3pPLFFBQUwsR0FBc0IsSUFBdEI7QUFDQSxTQUFLME8sVUFBTCxHQUFzQixLQUF0QjtBQUVBLFNBQUs3VixXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQWREOztBQWdCQWxOLFVBQU8sQ0FBQ2lQLFVBQVIsQ0FBbUIvakIsSUFBbkIsQ0FBd0I4VSxRQUFPLENBQUNzWixTQUFoQzs7QUFFQXRaLFVBQU8sQ0FBQ3NaLFNBQVIsQ0FBa0I3dkIsU0FBbEIsR0FBOEJlLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYzhULFFBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQTNCLENBQTlCO0FBRUF1VyxVQUFPLENBQUNzWixTQUFSLENBQWtCN3ZCLFNBQWxCLENBQTRCRCxXQUE1QixHQUEwQ3dXLFFBQU8sQ0FBQ3NaLFNBQWxEO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQWVBdFosVUFBTyxDQUFDbUQsS0FBUixHQUFnQixZQUFXO0FBQ3ZCbkQsWUFBTyxDQUFDMkQsSUFBUixDQUFhelksSUFBYixDQUFrQixJQUFsQjs7QUFFQSxTQUFLMFksV0FBTCxDQUFpQixpQkFBakI7QUFFQSxTQUFLdkIsTUFBTCxHQUF5QixJQUFJckMsUUFBTyxDQUFDZ1UsTUFBWixFQUF6QjtBQUVBLFNBQUtwUixFQUFMLEdBQXlCLEVBQXpCO0FBRUEsU0FBSzhXLE1BQUwsR0FBeUIsS0FBekI7QUFDQSxTQUFLRCxVQUFMLEdBQXlCLEtBQXpCO0FBQ0EsU0FBS0UsVUFBTCxHQUF5QixJQUF6QjtBQUVBLFNBQUtsYixRQUFMLEdBQXlCLEVBQXpCO0FBQ0EsU0FBS2lXLE9BQUwsR0FBeUIsRUFBekI7QUFDQSxTQUFLa0YsU0FBTCxHQUF5QixFQUF6QjtBQUNBLFNBQUtDLEtBQUwsR0FBeUIsRUFBekI7QUFFQSxTQUFLckMsV0FBTCxHQUF5QixFQUF6QjtBQUVBLFNBQUtzQyxZQUFMLEdBQXlCLENBQXpCO0FBQ0EsU0FBS0MsZ0JBQUwsR0FBeUIsQ0FBekI7QUFDQSxTQUFLQyxZQUFMLEdBQXlCLENBQXpCO0FBQ0EsU0FBS0MsV0FBTCxHQUF5QixDQUF6QjtBQUVBLFNBQUtDLGVBQUwsR0FBeUIsQ0FBekI7QUFDQSxTQUFLdEosU0FBTCxHQUF5QixJQUF6QjtBQUNBLFNBQUtDLFVBQUwsR0FBeUIsSUFBekI7QUFDQSxTQUFLc0osV0FBTCxHQUF5QixFQUF6QjtBQUNBLFNBQUtDLFlBQUwsR0FBeUIsRUFBekI7QUFDQSxTQUFLbEosS0FBTCxHQUF5QixFQUF6QjtBQUVBLFNBQUtpRyxLQUFMLEdBQXlCLElBQXpCO0FBQ0EsU0FBS2tELGFBQUwsR0FBeUIsSUFBekI7QUFDQSxTQUFLcEQsV0FBTCxHQUF5QixJQUF6QjtBQUNBLFNBQUtxRCxZQUFMLEdBQXlCLElBQXpCO0FBQ0EsU0FBS0MsWUFBTCxHQUF5QixJQUF6QjtBQUVBLFNBQUt2RCxHQUFMLEdBQXlCLElBQUloWCxRQUFPLENBQUN5VSxRQUFaLEVBQXpCO0FBRUEsU0FBSzdRLFdBQUwsQ0FBaUIsZ0JBQWpCO0FBRUEzRCxLQUFDLENBQUNpTixJQUFGLENBQU8sSUFBUDtBQUNILEdBM0NEOztBQTZDQWxOLFVBQU8sQ0FBQ2lQLFVBQVIsQ0FBbUIvakIsSUFBbkIsQ0FBd0I4VSxRQUFPLENBQUNtRCxLQUFoQzs7QUFFQW5ELFVBQU8sQ0FBQ21ELEtBQVIsQ0FBYzFaLFNBQWQsR0FBMEJlLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYzhULFFBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQTNCLENBQTFCO0FBRUF3VyxHQUFDLENBQUN1RSxNQUFGLENBQVN4RSxRQUFPLENBQUNtRCxLQUFSLENBQWMxWixTQUF2QjtBQUNBO0FBQ0E7QUFDSUQsZUFBVyxFQUFFd1csUUFBTyxDQUFDbUQsS0FEekI7O0FBR0k7Ozs7Ozs7OztBQVVBbEYsVUFBTSxFQUFFLGdCQUFTbUUsU0FBVCxFQUFvQi9NLFFBQXBCLEVBQThCdU4sRUFBOUIsRUFBa0NQLE1BQWxDLEVBQTBDO0FBQzlDLFVBQUkvVixJQUFJLEdBQU0sSUFBZDtBQUFBLFVBQ0l0QyxNQUFNLEdBQUksSUFEZDtBQUFBLFVBRUlFLENBQUMsR0FBUyxDQUFDLENBRmY7QUFJQW9DLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsY0FBakIsRUFBaUM3WSxTQUFqQztBQUVBdUIsVUFBSSxDQUFDc1csRUFBTCxHQUFVQSxFQUFWOztBQUVBLFVBQUlQLE1BQUosRUFBWTtBQUNScEMsU0FBQyxDQUFDdUUsTUFBRixDQUFTbFksSUFBSSxDQUFDK1YsTUFBZCxFQUFzQkEsTUFBdEIsRUFBOEIsSUFBOUIsRUFBb0MsSUFBcEM7QUFDSDs7QUFFRC9WLFVBQUksQ0FBQ2t1QixjQUFMO0FBRUFsdUIsVUFBSSxDQUFDbXVCLFFBQUwsQ0FBY3JZLFNBQWQsRUFBeUIvTSxRQUF6Qjs7QUFFQSxVQUFJL0ksSUFBSSxDQUFDK1YsTUFBTCxDQUFZK1IsTUFBWixDQUFtQlosa0JBQXZCLEVBQTJDO0FBQ3ZDdlQsU0FBQyxDQUFDMUcsUUFBRixDQUFXak4sSUFBSSxDQUFDMHFCLEdBQUwsQ0FBUzVVLFNBQXBCLEVBQStCOVYsSUFBSSxDQUFDK1YsTUFBTCxDQUFZK1IsTUFBWixDQUFtQlosa0JBQWxEO0FBQ0g7O0FBRUQsVUFBSSxDQUFDeFQsUUFBTyxDQUFDa0wsUUFBUixDQUFpQkMsR0FBakIsQ0FBcUJxRixXQUExQixFQUF1QztBQUNuQ2xrQixZQUFJLENBQUMrVixNQUFMLENBQVk0UixTQUFaLENBQXNCempCLE1BQXRCLEdBQStCLEtBQS9CO0FBQ0g7O0FBRUQsVUFBSSxPQUFPaUUsTUFBTSxDQUFDdkwsT0FBZCxLQUEwQixXQUE5QixFQUEyQztBQUN2Q29ELFlBQUksQ0FBQytWLE1BQUwsQ0FBWWUsS0FBWixDQUFrQkMsWUFBbEIsR0FBaUMsS0FBakM7QUFDSDs7QUFFRCxVQUFJL1csSUFBSSxDQUFDK1YsTUFBTCxDQUFZc0QsSUFBWixDQUFpQnVOLE1BQXJCLEVBQTZCO0FBQ3pCO0FBRUE1bUIsWUFBSSxDQUFDK1YsTUFBTCxDQUFZNUQsUUFBWixDQUFxQmpPLE1BQXJCLEdBQThCLEtBQTlCO0FBQ0g7O0FBRURsRSxVQUFJLENBQUNvdUIsWUFBTDtBQUVBcHVCLFVBQUksQ0FBQzZxQixLQUFMLEdBQWE3cUIsSUFBSSxDQUFDcXVCLGVBQUwsRUFBYjs7QUFFQSxXQUFLendCLENBQUMsR0FBRyxDQUFULEVBQVlGLE1BQU0sR0FBR3NDLElBQUksQ0FBQyt0QixhQUFMLENBQW1CTyxNQUFuQixDQUEwQjF3QixDQUExQixDQUFyQixFQUFtREEsQ0FBQyxFQUFwRCxFQUF3RDtBQUNwREYsY0FBTSxDQUFDNndCLElBQVA7QUFDSDs7QUFFRCxVQUFJdnVCLElBQUksQ0FBQytWLE1BQUwsQ0FBWTVELFFBQVosQ0FBcUJqTyxNQUF6QixFQUFpQztBQUM3QmxFLFlBQUksQ0FBQ3d1QixZQUFMO0FBRUF4dUIsWUFBSSxDQUFDeXVCLGdCQUFMLENBQXNCLElBQXRCLEVBQTRCenVCLElBQUksQ0FBQzZxQixLQUFqQztBQUVBN3FCLFlBQUksQ0FBQzB1QixjQUFMLENBQW9CO0FBQ2hCaG1CLGdCQUFNLEVBQUUxSSxJQUFJLENBQUM2cUIsS0FBTCxDQUFXOEQsWUFESDtBQUVoQm50QixjQUFJLEVBQUV4QixJQUFJLENBQUM2cUIsS0FBTCxDQUFXK0Q7QUFGRCxTQUFwQjtBQUlIOztBQUVENXVCLFVBQUksQ0FBQzZ1QixZQUFMO0FBRUE3dUIsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixhQUFqQixFQUFnQzdZLFNBQWhDO0FBQ0gsS0F0RUw7O0FBd0VJOzs7Ozs7QUFPQXl2QixrQkFBYyxFQUFFLDBCQUFXO0FBQ3ZCLFVBQUlsdUIsSUFBSSxHQUFHLElBQVg7QUFFQUEsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixzQkFBakIsRUFBeUM3WSxTQUF6QyxFQUh1QixDQUt2Qjs7QUFFQXVCLFVBQUksQ0FBQytWLE1BQUwsQ0FBWTVELFFBQVosQ0FBcUI0VCxLQUFyQixHQUFzQy9sQixJQUFJLENBQUMrVixNQUFMLENBQVk1RCxRQUFaLENBQXFCNFQsS0FBckIsQ0FBMkJ4TCxXQUEzQixHQUF5Q3JGLElBQXpDLEVBQXRDO0FBQ0FsVixVQUFJLENBQUMrVixNQUFMLENBQVk1RCxRQUFaLENBQXFCNlQsV0FBckIsR0FBc0NobUIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNUQsUUFBWixDQUFxQjZULFdBQXJCLENBQWlDekwsV0FBakMsR0FBK0NyRixJQUEvQyxFQUF0QztBQUNBbFYsVUFBSSxDQUFDK1YsTUFBTCxDQUFZNUQsUUFBWixDQUFxQjhULGFBQXJCLEdBQXNDam1CLElBQUksQ0FBQytWLE1BQUwsQ0FBWTVELFFBQVosQ0FBcUI4VCxhQUFyQixDQUFtQzFMLFdBQW5DLEdBQWlEckYsSUFBakQsRUFBdEM7QUFFQWxWLFVBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0J0RCxPQUF0QixHQUFzQ3JrQixJQUFJLENBQUMrVixNQUFMLENBQVk0UixTQUFaLENBQXNCdEQsT0FBdEIsQ0FBOEJuUCxJQUE5QixFQUF0QztBQUVBbFYsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixxQkFBakIsRUFBd0M3WSxTQUF4QztBQUNILEtBN0ZMOztBQStGSTs7Ozs7O0FBT0E0dkIsbUJBQWUsRUFBRSwyQkFBVztBQUN4QixVQUFJcnVCLElBQUksR0FBVSxJQUFsQjtBQUFBLFVBQ0k2cUIsS0FBSyxHQUFTLElBQUluWCxRQUFPLENBQUNxWixLQUFaLEVBRGxCO0FBQUEsVUFFSStCLFNBQVMsR0FBSyxJQUFJcGIsUUFBTyxDQUFDcWIsU0FBWixFQUZsQjtBQUlBL3VCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsdUJBQWpCLEVBQTBDN1ksU0FBMUMsRUFMd0IsQ0FPeEI7O0FBRUFvc0IsV0FBSyxDQUFDbUUsd0JBQU4sR0FBaUNodkIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZK1IsTUFBWixDQUFtQlosa0JBQXBEOztBQUVBLFVBQUlsbkIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZZ1MsSUFBWixDQUFpQlQsT0FBckIsRUFBOEI7QUFDMUI7QUFFQSxZQUFJLENBQUN0bkIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZc0QsSUFBWixDQUFpQnVOLE1BQWxCLElBQTRCLE9BQU81bUIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZc0QsSUFBWixDQUFpQnVOLE1BQXhCLEtBQW1DLFFBQW5FLEVBQTZFO0FBQ3pFLGdCQUFNLElBQUlycEIsU0FBSixDQUFjbVcsUUFBTyxDQUFDK0MsUUFBUixDQUFpQndZLDJCQUFqQixFQUFkLENBQU47QUFDSDs7QUFFREgsaUJBQVMsQ0FBQ0ksWUFBVixHQUF5QkosU0FBUyxDQUFDSyxVQUFWLEdBQXVCdEUsS0FBSyxDQUFDdUUsYUFBTixHQUFzQnB2QixJQUFJLENBQUMrVixNQUFMLENBQVlnUyxJQUFaLENBQWlCVCxPQUFqQixDQUF5QjdlLEtBQXpCLEVBQXRFO0FBQ0FxbUIsaUJBQVMsQ0FBQ08sdUJBQVYsR0FBb0NQLFNBQVMsQ0FBQ1EscUJBQVYsR0FBa0N6RSxLQUFLLENBQUNtRSx3QkFBNUU7QUFDQUYsaUJBQVMsQ0FBQ1MsSUFBVixHQUFpQnZ2QixJQUFJLENBQUNvb0IsT0FBTCxDQUFhM2YsS0FBYixFQUFqQjtBQUVBb2lCLGFBQUssR0FBRzdxQixJQUFJLENBQUN1aUIsV0FBTCxDQUFpQixzQkFBakIsRUFBeUNzSSxLQUF6QyxFQUFnRHBzQixTQUFoRCxDQUFSO0FBQ0gsT0FaRCxNQVlPO0FBQ0g7QUFFQW9zQixhQUFLLENBQUM4RCxZQUFOLEdBQWtDM3VCLElBQUksQ0FBQ3d2QixlQUFMLENBQXFCLENBQUN4dkIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZZ1MsSUFBWixDQUFpQnJmLE1BQWxCLENBQXJCLEVBQWdEOGhCLE9BQWxGO0FBQ0FLLGFBQUssQ0FBQytELFVBQU4sR0FBa0M1dUIsSUFBSSxDQUFDeXZCLGFBQUwsQ0FBbUIsQ0FBQ3p2QixJQUFJLENBQUMrVixNQUFMLENBQVlnUyxJQUFaLENBQWlCdm1CLElBQWxCLENBQW5CLEVBQTRDZ3BCLE9BQTlFO0FBQ0FLLGFBQUssQ0FBQzZFLFlBQU4sR0FBa0MxdkIsSUFBSSxDQUFDb29CLE9BQUwsQ0FBYXZxQixNQUEvQztBQUVBZ3RCLGFBQUssR0FBRzdxQixJQUFJLENBQUN1aUIsV0FBTCxDQUFpQixzQkFBakIsRUFBeUNzSSxLQUF6QyxFQUFnRHBzQixTQUFoRCxDQUFSOztBQUVBLFlBQ0lvc0IsS0FBSyxDQUFDK0QsVUFBTixDQUFpQi9GLFVBQWpCLElBQStCZ0MsS0FBSyxDQUFDK0QsVUFBTixDQUFpQjNGLFNBQWhELElBQ0E0QixLQUFLLENBQUMrRCxVQUFOLENBQWlCMUYsS0FBakIsS0FBMkIsUUFEM0IsSUFDdUMyQixLQUFLLENBQUMrRCxVQUFOLENBQWlCMUYsS0FBakIsS0FBMkIsTUFGdEUsRUFHRTtBQUNFO0FBRUE0RixtQkFBUyxDQUFDYSxPQUFWLEdBQW9COUUsS0FBSyxDQUFDK0QsVUFBMUI7QUFFQTV1QixjQUFJLENBQUM0dkIsYUFBTCxDQUFtQmQsU0FBbkI7QUFFQTl1QixjQUFJLENBQUM2dkIsU0FBTCxDQUFlLEtBQWYsRUFBc0JmLFNBQXRCO0FBRUE5dUIsY0FBSSxDQUFDb29CLE9BQUwsR0FBZTBHLFNBQVMsQ0FBQ2dCLFFBQXpCO0FBQ0gsU0FiRCxNQWFPO0FBQ0hoQixtQkFBUyxDQUFDaUIsVUFBVixHQUF1QmpCLFNBQVMsQ0FBQ2dCLFFBQVYsR0FBcUI5dkIsSUFBSSxDQUFDb29CLE9BQWpEO0FBQ0g7O0FBRUQwRyxpQkFBUyxDQUFDa0IsV0FBVixHQUFzQ2xCLFNBQVMsQ0FBQ21CLFNBQVYsR0FBb0NwRixLQUFLLENBQUM4RCxZQUFoRjtBQUNBRyxpQkFBUyxDQUFDb0IsU0FBVixHQUFzQ3BCLFNBQVMsQ0FBQ2EsT0FBVixHQUFvQzlFLEtBQUssQ0FBQytELFVBQWhGO0FBQ0FFLGlCQUFTLENBQUNPLHVCQUFWLEdBQXNDUCxTQUFTLENBQUNRLHFCQUFWLEdBQW9DekUsS0FBSyxDQUFDbUUsd0JBQWhGOztBQUVBLFlBQUlGLFNBQVMsQ0FBQ21CLFNBQVYsQ0FBb0JydEIsUUFBcEIsS0FBaUMsS0FBckMsRUFBNEM7QUFDeENrc0IsbUJBQVMsQ0FBQ21CLFNBQVYsQ0FBb0JydEIsUUFBcEIsR0FBK0I1QyxJQUFJLENBQUMrVixNQUFMLENBQVlpUyxTQUFaLENBQXNCdHFCLE1BQXJEO0FBQ0gsU0FGRCxNQUVPLElBQUlveEIsU0FBUyxDQUFDbUIsU0FBVixDQUFvQnJ0QixRQUFwQixLQUFpQyxNQUFyQyxFQUE2QztBQUNoRGtzQixtQkFBUyxDQUFDbUIsU0FBVixDQUFvQnJ0QixRQUFwQixHQUErQixFQUEvQjtBQUNIO0FBQ0o7O0FBRURrc0IsZUFBUyxHQUFHOXVCLElBQUksQ0FBQ3VpQixXQUFMLENBQWlCLDBCQUFqQixFQUE2Q3VNLFNBQTdDLEVBQXdELENBQUNqRSxLQUFELENBQXhELENBQVo7QUFFQTdxQixVQUFJLENBQUMrdEIsYUFBTCxHQUFxQmUsU0FBckI7O0FBRUEsVUFBSUEsU0FBUyxDQUFDbUIsU0FBZCxFQUF5QjtBQUNyQmp3QixZQUFJLENBQUNtd0IsZUFBTCxDQUFxQnJCLFNBQXJCO0FBQ0g7O0FBRURqRSxXQUFLLEdBQUc3cUIsSUFBSSxDQUFDb3dCLFVBQUwsQ0FBZ0J0QixTQUFoQixDQUFSO0FBRUEsYUFBT2pFLEtBQVA7QUFDSCxLQTdLTDs7QUErS0k7Ozs7Ozs7Ozs7QUFXQXNELFlBQVEsRUFBRSxrQkFBU2xpQixFQUFULEVBQWFsRCxRQUFiLEVBQXVCO0FBQzdCLFVBQUkvSSxJQUFJLEdBQU0sSUFBZDtBQUVBQSxVQUFJLENBQUNzWCxXQUFMLENBQWlCLGdCQUFqQixFQUFtQzdZLFNBQW5DO0FBRUF1QixVQUFJLENBQUMwcUIsR0FBTCxDQUFTM2hCLFFBQVQsR0FBcUJBLFFBQXJCO0FBQ0EvSSxVQUFJLENBQUMwcUIsR0FBTCxDQUFTeE0sSUFBVCxHQUFxQmxlLElBQUksQ0FBQzBxQixHQUFMLENBQVMzaEIsUUFBVCxDQUFrQlAsYUFBbEIsQ0FBZ0MsTUFBaEMsQ0FBckI7QUFDQXhJLFVBQUksQ0FBQzBxQixHQUFMLENBQVM1VSxTQUFULEdBQXFCN0osRUFBckI7QUFDQWpNLFVBQUksQ0FBQzBxQixHQUFMLENBQVNyckIsTUFBVCxHQUFxQjRNLEVBQXJCO0FBRUFqTSxVQUFJLENBQUNzWCxXQUFMLENBQWlCLGVBQWpCLEVBQWtDN1ksU0FBbEM7QUFDSCxLQXJNTDs7QUF1TUk7Ozs7Ozs7OztBQVVBMnZCLGdCQUFZLEVBQUUsd0JBQVc7QUFDckIsVUFBSXB1QixJQUFJLEdBQWMsSUFBdEI7QUFBQSxVQUNJdEMsTUFBTSxHQUFZLElBRHRCO0FBQUEsVUFFSXVPLEVBQUUsR0FBZ0IsSUFGdEI7QUFBQSxVQUdJcWIsT0FBTyxHQUFXLElBSHRCO0FBQUEsVUFJSTFwQixDQUFDLEdBQWlCLENBQUMsQ0FKdkI7QUFNQW9DLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsb0JBQWpCLEVBQXVDN1ksU0FBdkM7QUFFQXVCLFVBQUksQ0FBQzBxQixHQUFMLENBQVN0QyxPQUFULEdBQW1CcG9CLElBQUksQ0FBQytWLE1BQUwsQ0FBWStSLE1BQVosQ0FBbUJiLGtCQUFuQixHQUNmam5CLElBQUksQ0FBQzBxQixHQUFMLENBQVM1VSxTQUFULENBQW1CMUUsZ0JBQW5CLENBQW9DcFIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZaVMsU0FBWixDQUFzQnRxQixNQUExRCxDQURlLEdBRWZpVyxDQUFDLENBQUNsTSxRQUFGLENBQVd6SCxJQUFJLENBQUMwcUIsR0FBTCxDQUFTNVUsU0FBcEIsRUFBK0I5VixJQUFJLENBQUMrVixNQUFMLENBQVlpUyxTQUFaLENBQXNCdHFCLE1BQXJELEVBQTZEc0MsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBUzNoQixRQUF0RSxDQUZKO0FBSUEvSSxVQUFJLENBQUMwcUIsR0FBTCxDQUFTdEMsT0FBVCxHQUFtQnpVLENBQUMsQ0FBQ29JLGFBQUYsQ0FBZ0IvYixJQUFJLENBQUMwcUIsR0FBTCxDQUFTdEMsT0FBekIsQ0FBbkI7QUFFQXBvQixVQUFJLENBQUNvb0IsT0FBTCxHQUFlLEVBQWY7O0FBRUEsVUFBSSxDQUFDZCxPQUFPLEdBQUd0bkIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZZ1MsSUFBWixDQUFpQlQsT0FBNUIsS0FBd0NBLE9BQU8sQ0FBQ3pwQixNQUFSLEtBQW1CbUMsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3RDLE9BQVQsQ0FBaUJ2cUIsTUFBaEYsRUFBd0Y7QUFDcEYsY0FBTSxJQUFJMlksS0FBSixDQUFVOUMsUUFBTyxDQUFDK0MsUUFBUixDQUFpQjRaLCtCQUFqQixFQUFWLENBQU47QUFDSDs7QUFFRCxVQUFJcndCLElBQUksQ0FBQzBxQixHQUFMLENBQVN0QyxPQUFULENBQWlCdnFCLE1BQXJCLEVBQTZCO0FBQ3pCLGFBQUtELENBQUMsR0FBRyxDQUFULEVBQVlxTyxFQUFFLEdBQUdqTSxJQUFJLENBQUMwcUIsR0FBTCxDQUFTdEMsT0FBVCxDQUFpQnhxQixDQUFqQixDQUFqQixFQUFzQ0EsQ0FBQyxFQUF2QyxFQUEyQztBQUN2Q0YsZ0JBQU0sR0FBRyxJQUFJZ1csUUFBTyxDQUFDNGMsTUFBWixFQUFUO0FBRUE1eUIsZ0JBQU0sQ0FBQ3FtQixJQUFQLENBQVk5WCxFQUFaLEVBQWdCak0sSUFBaEIsRUFBc0JzbkIsT0FBTyxHQUFHQSxPQUFPLENBQUMxcEIsQ0FBRCxDQUFWLEdBQWdCLEtBQUssQ0FBbEQ7QUFFQUYsZ0JBQU0sQ0FBQzZ5QixPQUFQLEdBQWlCLElBQWpCO0FBRUF2d0IsY0FBSSxDQUFDb29CLE9BQUwsQ0FBYS9sQixJQUFiLENBQWtCM0UsTUFBbEI7QUFDSDs7QUFFRHNDLFlBQUksQ0FBQzBxQixHQUFMLENBQVNyckIsTUFBVCxHQUFrQlcsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3RDLE9BQVQsQ0FBaUIsQ0FBakIsRUFBb0I1VCxhQUFwQixLQUFzQ3hVLElBQUksQ0FBQzBxQixHQUFMLENBQVM1VSxTQUEvQyxHQUNkOVYsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBUzVVLFNBREssR0FFZDlWLElBQUksQ0FBQzBxQixHQUFMLENBQVN0QyxPQUFULENBQWlCLENBQWpCLEVBQW9CNVQsYUFGeEI7QUFHSDs7QUFFRHhVLFVBQUksQ0FBQ3N0QixTQUFMLEdBQWlCdHRCLElBQUksQ0FBQ29vQixPQUF0QjtBQUVBcG9CLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsbUJBQWpCLEVBQXNDN1ksU0FBdEM7QUFDSCxLQXpQTDtBQTJQSSt2QixnQkFBWSxFQUFFLHdCQUFXO0FBQ3JCLFVBQUl4dUIsSUFBSSxHQUFrQixJQUExQjtBQUFBLFVBQ0lxQixVQUFVLEdBQVksRUFEMUI7QUFBQSxVQUVJbXZCLGVBQWUsR0FBTyxJQUYxQjtBQUFBLFVBR0l2a0IsRUFBRSxHQUFvQixJQUgxQjtBQUFBLFVBSUk1TSxNQUFNLEdBQWdCLElBSjFCO0FBQUEsVUFLSW94QixVQUFVLEdBQVksSUFMMUI7QUFBQSxVQU1JMVAsT0FBTyxHQUFlLElBTjFCO0FBQUEsVUFPSW5qQixDQUFDLEdBQXFCLENBQUMsQ0FQM0I7QUFBQSxVQVFJOHlCLENBQUMsR0FBcUIsQ0FBQyxDQVIzQjtBQVVBMXdCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsb0JBQWpCLEVBQXVDN1ksU0FBdkM7O0FBRUEsY0FBUXVCLElBQUksQ0FBQytWLE1BQUwsQ0FBWTVELFFBQVosQ0FBcUI0VCxLQUE3QjtBQUNJLGFBQUssT0FBTDtBQUNJMW1CLGdCQUFNLEdBQUdXLElBQUksQ0FBQzBxQixHQUFMLENBQVM1VSxTQUFsQjtBQUVBOztBQUNKLGFBQUssUUFBTDtBQUNJelcsZ0JBQU0sR0FBR1csSUFBSSxDQUFDMHFCLEdBQUwsQ0FBUzNoQixRQUFsQjtBQUVBOztBQUNKO0FBQ0ksZ0JBQU0sSUFBSXlOLEtBQUosQ0FBVTlDLFFBQU8sQ0FBQytDLFFBQVIsQ0FBaUJrYSwrQkFBakIsRUFBVixDQUFOO0FBVlI7O0FBYUEsV0FBSy95QixDQUFDLEdBQUcsQ0FBVCxFQUFZeUQsVUFBVSxHQUFHcVMsUUFBTyxDQUFDOFYsa0JBQVIsQ0FBMkI1ckIsQ0FBM0IsQ0FBekIsRUFBd0RBLENBQUMsRUFBekQsRUFBNkQ7QUFDekQsWUFBSW9DLElBQUksQ0FBQytWLE1BQUwsQ0FBWTVELFFBQVosQ0FBcUIyVCxJQUFyQixJQUE2QnprQixVQUFVLENBQUN5a0IsSUFBNUMsRUFBa0Q7QUFDOUMsY0FBSXprQixVQUFVLENBQUNoQyxNQUFmLEVBQXVCO0FBQ25Cb3hCLHNCQUFVLEdBQUd6d0IsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3JwQixVQUFVLENBQUNoQyxNQUFwQixDQUFiO0FBRUEsZ0JBQUksQ0FBQ294QixVQUFELElBQWVBLFVBQVUsQ0FBQzV5QixNQUFYLEdBQW9CLENBQXZDLEVBQTBDOztBQUUxQyxnQkFBSSxPQUFPNHlCLFVBQVUsQ0FBQzV5QixNQUFsQixLQUE2QixRQUFqQyxFQUEyQztBQUN2QzR5Qix3QkFBVSxHQUFHLENBQUNBLFVBQUQsQ0FBYjtBQUNIO0FBQ0osV0FSRCxNQVFPO0FBQ0hBLHNCQUFVLEdBQUcsQ0FBQ3B4QixNQUFELENBQWI7QUFDSDs7QUFFRCxlQUFLcXhCLENBQUMsR0FBRyxDQUFULEVBQWF6a0IsRUFBRSxHQUFHd2tCLFVBQVUsQ0FBQ0MsQ0FBRCxDQUE1QixFQUFrQ0EsQ0FBQyxFQUFuQyxFQUF1QztBQUNuQzNQLG1CQUFPLEdBQUcvZ0IsSUFBSSxDQUFDNHdCLFVBQUwsQ0FBZ0Iza0IsRUFBaEIsRUFBcUI1SyxVQUFVLENBQUM1RyxJQUFoQyxFQUFzQzRHLFVBQVUsQ0FBQ3VCLFFBQWpELENBQVY7QUFFQTVDLGdCQUFJLENBQUNtUyxRQUFMLENBQWM5UCxJQUFkLENBQW1CMGUsT0FBbkI7QUFDSDtBQUNKLFNBbEJELE1Ba0JPO0FBQ0h5UCx5QkFBZSxHQUFHbnhCLE1BQU0sQ0FBQytSLGdCQUFQLENBQXdCcFIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZaVMsU0FBWixDQUFzQmpILE9BQXRCLEdBQWdDMWYsVUFBVSxDQUFDdUIsUUFBbkUsQ0FBbEI7O0FBRUEsZUFBSzh0QixDQUFDLEdBQUcsQ0FBVCxFQUFhemtCLEVBQUUsR0FBR3VrQixlQUFlLENBQUNFLENBQUQsQ0FBakMsRUFBdUNBLENBQUMsRUFBeEMsRUFBNEM7QUFDeEMzUCxtQkFBTyxHQUFHL2dCLElBQUksQ0FBQzR3QixVQUFMLENBQWdCM2tCLEVBQWhCLEVBQW9CNUssVUFBVSxDQUFDNUcsSUFBL0IsRUFBcUMsRUFBckMsQ0FBVjtBQUVBLGdCQUFJLENBQUNzbUIsT0FBTCxFQUFjO0FBRWQvZ0IsZ0JBQUksQ0FBQ21TLFFBQUwsQ0FBYzlQLElBQWQsQ0FBbUIwZSxPQUFuQjtBQUNIO0FBQ0o7QUFDSjs7QUFFRC9nQixVQUFJLENBQUNzWCxXQUFMLENBQWlCLG1CQUFqQixFQUFzQzdZLFNBQXRDO0FBQ0gsS0F0VEw7O0FBd1RJOzs7Ozs7Ozs7QUFVQW15QixjQUFVLEVBQUUsb0JBQVMza0IsRUFBVCxFQUFheFIsSUFBYixFQUFtQm1JLFFBQW5CLEVBQTZCO0FBQ3JDLFVBQUk1QyxJQUFJLEdBQU0sSUFBZDtBQUFBLFVBQ0krZ0IsT0FBTyxHQUFHLElBRGQ7QUFBQSxVQUVJbmpCLENBQUMsR0FBUyxDQUFDLENBRmY7QUFJQW9DLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsa0JBQWpCLEVBQXFDN1ksU0FBckM7O0FBRUEsVUFBSSxDQUFDbUUsUUFBTCxFQUFlO0FBQ1g7QUFFQSxhQUFLaEYsQ0FBQyxHQUFHLENBQVQsRUFBWW1qQixPQUFPLEdBQUdyTixRQUFPLENBQUN2QixRQUFSLENBQWlCdlUsQ0FBakIsQ0FBdEIsRUFBMkNBLENBQUMsRUFBNUMsRUFBZ0Q7QUFDNUMsY0FBSW1qQixPQUFPLENBQUM5VSxFQUFSLEtBQWVBLEVBQWYsSUFBcUI4VSxPQUFPLENBQUM4SSxPQUFSLENBQWdCN3BCLElBQWhCLENBQXpCLEVBQWdEO0FBQzVDO0FBRUE7QUFDQTtBQUVBLG1CQUFPQSxJQUFJLENBQUN1aUIsV0FBTCxDQUFpQixtQkFBakIsRUFBc0MsSUFBdEMsRUFBNEM5akIsU0FBNUMsQ0FBUDtBQUNILFdBUEQsTUFPTyxJQUFJc2lCLE9BQU8sQ0FBQzlVLEVBQVIsS0FBZUEsRUFBZixJQUFxQjhVLE9BQU8sQ0FBQ3RtQixJQUFSLEtBQWlCQSxJQUF0QyxJQUE4Q3NtQixPQUFPLENBQUNuZSxRQUFSLEtBQXFCQSxRQUF2RSxFQUFpRjtBQUNwRjtBQUVBbWUsbUJBQU8sQ0FBQ2dKLFVBQVIsQ0FBbUIvcEIsSUFBbkI7QUFFQSxtQkFBT0EsSUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIsbUJBQWpCLEVBQXNDeEIsT0FBdEMsRUFBK0N0aUIsU0FBL0MsQ0FBUDtBQUNIO0FBQ0o7QUFDSixPQTFCb0MsQ0E0QnJDOzs7QUFFQXNpQixhQUFPLEdBQUcsSUFBSXJOLFFBQU8sQ0FBQytWLE9BQVosRUFBVjtBQUVBMUksYUFBTyxDQUFDZ0QsSUFBUixDQUFhOVgsRUFBYixFQUFpQnhSLElBQWpCLEVBQXVCbUksUUFBdkI7QUFFQW1lLGFBQU8sQ0FBQ1EsVUFBUixDQUFtQitHLElBQW5CLEdBQThCM1UsQ0FBQyxDQUFDMk4sWUFBRixDQUFldGhCLElBQUksQ0FBQytWLE1BQUwsQ0FBWXdMLFVBQTNCLEVBQXVDOW1CLElBQXZDLENBQTlCO0FBQ0FzbUIsYUFBTyxDQUFDUSxVQUFSLENBQW1CZ0gsTUFBbkIsR0FBOEI1VSxDQUFDLENBQUMyTixZQUFGLENBQWV0aEIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZd0wsVUFBM0IsRUFBdUM5bUIsSUFBdkMsRUFBNkN1RixJQUFJLENBQUMrVixNQUFMLENBQVl3TCxVQUFaLENBQXVCaUYsY0FBcEUsQ0FBOUI7QUFDQXpGLGFBQU8sQ0FBQ1EsVUFBUixDQUFtQnZlLFFBQW5CLEdBQThCMlEsQ0FBQyxDQUFDMk4sWUFBRixDQUFldGhCLElBQUksQ0FBQytWLE1BQUwsQ0FBWXdMLFVBQTNCLEVBQXVDOW1CLElBQXZDLEVBQTZDdUYsSUFBSSxDQUFDK1YsTUFBTCxDQUFZd0wsVUFBWixDQUF1QmtGLGdCQUFwRSxDQUE5QixDQXBDcUMsQ0FzQ3JDOztBQUVBMUYsYUFBTyxDQUFDZ0osVUFBUixDQUFtQi9wQixJQUFuQjtBQUVBLGFBQU9BLElBQUksQ0FBQ3VpQixXQUFMLENBQWlCLG1CQUFqQixFQUFzQ3hCLE9BQXRDLEVBQStDdGlCLFNBQS9DLENBQVA7QUFDSCxLQTdXTDs7QUErV0k7Ozs7Ozs7OztBQVVBb3lCLHFCQUFpQixFQUFFLDZCQUFXO0FBQzFCLFVBQUk3d0IsSUFBSSxHQUFjLElBQXRCO0FBQUEsVUFDSTh3QixVQUFVLEdBQVE5d0IsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNUQsUUFBWixDQUFxQjZULFdBQXJCLEtBQXFDLElBQXJDLEdBQTRDLElBQTVDLEdBQW1ELEVBRHpFO0FBQUEsVUFFSStLLGNBQWMsR0FBSSxFQUZ0QjtBQUlBL3dCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIseUJBQWpCLEVBQTRDN1ksU0FBNUM7QUFFQXVCLFVBQUksQ0FBQ2tyQixXQUFMLEdBQW1CdlgsQ0FBQyxDQUFDMEssS0FBRixDQUFRcmUsSUFBSSxDQUFDa3JCLFdBQWIsQ0FBbkI7QUFFQTZGLG9CQUFjLEdBQUcvd0IsSUFBSSxDQUFDa3JCLFdBQUwsQ0FBaUJsZSxJQUFqQixDQUFzQjhqQixVQUF0QixDQUFqQjs7QUFFQSxVQUFJQyxjQUFjLEtBQUssRUFBdkIsRUFBMkI7QUFDdkJBLHNCQUFjLEdBQUcvd0IsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNUQsUUFBWixDQUFxQjhULGFBQXRDO0FBQ0g7O0FBRUQsYUFBT2ptQixJQUFJLENBQUN1aUIsV0FBTCxDQUFpQiwyQkFBakIsRUFBOEN3TyxjQUE5QyxFQUE4RHR5QixTQUE5RCxDQUFQO0FBQ0gsS0F6WUw7O0FBMllJOzs7Ozs7Ozs7Ozs7QUFhQWd3QixvQkFBZ0IsRUFBRSwwQkFBU2pFLE9BQVQsRUFBa0JLLEtBQWxCLEVBQXlCO0FBQ3ZDLFVBQUk3cUIsSUFBSSxHQUFzQixJQUE5QjtBQUFBLFVBQ0lneEIsb0JBQW9CLEdBQU0sRUFEOUI7QUFHQWh4QixVQUFJLENBQUNzWCxXQUFMLENBQWlCLHdCQUFqQixFQUEyQzdZLFNBQTNDOztBQUVBLFVBQUkrckIsT0FBTyxJQUFJQSxPQUFPLENBQUM5aEIsTUFBdkIsRUFBK0I7QUFDM0Jzb0IsNEJBQW9CLEdBQUd4RyxPQUFPLENBQUM5aEIsTUFBUixDQUFlOUYsUUFBZixDQUF3QnVTLE9BQXhCLENBQWdDLEtBQWhDLEVBQXVDLEVBQXZDLENBQXZCO0FBQ0gsT0FGRCxNQUVPLElBQUkwVixLQUFKLEVBQVc7QUFDZG1HLDRCQUFvQixHQUFHbkcsS0FBSyxDQUFDOEQsWUFBTixDQUFtQi9yQixRQUFuQixDQUE0QnVTLE9BQTVCLENBQW9DLEtBQXBDLEVBQTJDLEVBQTNDLENBQXZCO0FBQ0gsT0FGTSxNQUVBO0FBQ0g7QUFDSDs7QUFFRCxVQUFJNmIsb0JBQW9CLEtBQUtoeEIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZaVMsU0FBWixDQUFzQnRxQixNQUEvQyxJQUF5RHN6QixvQkFBb0IsS0FBSyxLQUF0RixFQUE2RjtBQUN6RkEsNEJBQW9CLEdBQUcsRUFBdkI7QUFDSDs7QUFFRCxVQUFJaHhCLElBQUksQ0FBQytWLE1BQUwsQ0FBWTVELFFBQVosQ0FBcUI2VCxXQUFyQixLQUFxQyxJQUF6QyxFQUErQztBQUMzQ2htQixZQUFJLENBQUNrckIsV0FBTCxHQUFtQjhGLG9CQUFvQixDQUFDamtCLEtBQXJCLENBQTJCLEdBQTNCLENBQW5CO0FBQ0gsT0FGRCxNQUVPO0FBQ0gvTSxZQUFJLENBQUNrckIsV0FBTCxHQUFtQmxyQixJQUFJLENBQUNpeEIscUJBQUwsQ0FBMkJELG9CQUEzQixDQUFuQjtBQUNIOztBQUVEaHhCLFVBQUksQ0FBQ2tyQixXQUFMLEdBQW1CdlgsQ0FBQyxDQUFDMEssS0FBRixDQUFRcmUsSUFBSSxDQUFDa3JCLFdBQWIsQ0FBbkI7QUFFQWxyQixVQUFJLENBQUNzWCxXQUFMLENBQWlCLHVCQUFqQixFQUEwQzdZLFNBQTFDO0FBQ0gsS0FuYkw7O0FBcWJJOzs7Ozs7Ozs7O0FBV0F3eUIseUJBQXFCLEVBQUUsK0JBQVNDLGdCQUFULEVBQTJCO0FBQzlDO0FBRUEsVUFBSUMsUUFBUSxHQUFNRCxnQkFBZ0IsQ0FBQ25rQixLQUFqQixDQUF1QixXQUF2QixDQUFsQjtBQUFBLFVBQ0ltZSxXQUFXLEdBQUcsRUFEbEI7QUFBQSxVQUVJdG9CLFFBQVEsR0FBTSxFQUZsQjtBQUFBLFVBR0loRixDQUFDLEdBQWEsQ0FBQyxDQUhuQjs7QUFLQSxVQUFJdXpCLFFBQVEsQ0FBQyxDQUFELENBQVIsS0FBZ0IsRUFBcEIsRUFBd0I7QUFDcEJBLGdCQUFRLENBQUNDLEtBQVQ7QUFDSDs7QUFFRCxXQUFLeHpCLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR3V6QixRQUFRLENBQUN0ekIsTUFBekIsRUFBaUNELENBQUMsRUFBbEMsRUFBc0M7QUFDbEMsWUFBSUEsQ0FBQyxHQUFHLENBQUosS0FBVSxDQUFkLEVBQWlCO0FBQ2JnRixrQkFBUSxHQUFHLEVBQVg7QUFDSDs7QUFFREEsZ0JBQVEsSUFBSXV1QixRQUFRLENBQUN2ekIsQ0FBRCxDQUFwQjs7QUFFQSxZQUFJQSxDQUFDLEdBQUcsQ0FBSixLQUFVLENBQWQsRUFBaUI7QUFDYnN0QixxQkFBVyxDQUFDN29CLElBQVosQ0FBaUJPLFFBQWpCO0FBQ0g7QUFDSjs7QUFFRCxhQUFPc29CLFdBQVA7QUFDSCxLQXpkTDs7QUEyZEk7Ozs7Ozs7Ozs7QUFXQXdELGtCQUFjLEVBQUUsd0JBQVNsRSxPQUFULEVBQWtCO0FBQzlCLFVBQUl4cUIsSUFBSSxHQUFNLElBQWQ7QUFBQSxVQUNJK2dCLE9BQU8sR0FBRyxJQURkO0FBQUEsVUFFSTNLLE1BQU0sR0FBSSxJQUFJMUMsUUFBTyxDQUFDK1UsZUFBWixFQUZkO0FBQUEsVUFHSTdxQixDQUFDLEdBQVMsQ0FBQyxDQUhmO0FBS0FvQyxVQUFJLENBQUNzWCxXQUFMLENBQWlCLHNCQUFqQixFQUF5QzdZLFNBQXpDLEVBTjhCLENBUTlCOztBQUVBLFVBQUkrckIsT0FBTyxDQUFDOWhCLE1BQVosRUFBb0I7QUFDaEIwTixjQUFNLENBQUMxTixNQUFQLEdBQWdCOGhCLE9BQU8sQ0FBQzloQixNQUFSLENBQWU5RixRQUEvQjtBQUNILE9BRkQsTUFFTztBQUNId1QsY0FBTSxDQUFDMU4sTUFBUCxHQUFnQjFJLElBQUksQ0FBQzZxQixLQUFMLENBQVc4RCxZQUFYLENBQXdCL3JCLFFBQXhDO0FBQ0g7O0FBRUQsVUFBSTRuQixPQUFPLENBQUNocEIsSUFBWixFQUFrQjtBQUNkNFUsY0FBTSxDQUFDNVUsSUFBUCxHQUFjeEIsSUFBSSxDQUFDcXhCLGVBQUwsQ0FBcUI3RyxPQUFPLENBQUNocEIsSUFBN0IsQ0FBZDtBQUNILE9BRkQsTUFFTztBQUNINFUsY0FBTSxDQUFDNVUsSUFBUCxHQUFjeEIsSUFBSSxDQUFDcXhCLGVBQUwsQ0FBcUJyeEIsSUFBSSxDQUFDNnFCLEtBQUwsQ0FBVytELFVBQWhDLENBQWQ7QUFDSDs7QUFFRCxVQUFJeFksTUFBTSxDQUFDMU4sTUFBUCxLQUFrQjFJLElBQUksQ0FBQytWLE1BQUwsQ0FBWWlTLFNBQVosQ0FBc0J0cUIsTUFBNUMsRUFBb0Q7QUFDaEQwWSxjQUFNLENBQUMxTixNQUFQLEdBQWdCLEtBQWhCO0FBQ0g7O0FBRUQsVUFBSTBOLE1BQU0sQ0FBQzFOLE1BQVAsS0FBa0IsRUFBdEIsRUFBMEI7QUFDdEIwTixjQUFNLENBQUMxTixNQUFQLEdBQWdCLE1BQWhCO0FBQ0g7O0FBRURpTCxPQUFDLENBQUNrTixNQUFGLENBQVN6SyxNQUFUOztBQUVBLFdBQUt4WSxDQUFDLEdBQUcsQ0FBVCxFQUFZbWpCLE9BQU8sR0FBRy9nQixJQUFJLENBQUNtUyxRQUFMLENBQWN2VSxDQUFkLENBQXRCLEVBQXdDQSxDQUFDLEVBQXpDLEVBQTZDO0FBQ3pDbWpCLGVBQU8sQ0FBQzNkLE1BQVIsQ0FBZWdULE1BQWYsRUFBdUJwVyxJQUFJLENBQUNrckIsV0FBNUI7QUFDSDs7QUFFRGxyQixVQUFJLENBQUNzWCxXQUFMLENBQWlCLHFCQUFqQixFQUF3QzdZLFNBQXhDO0FBQ0gsS0EzZ0JMOztBQTZnQkk7Ozs7Ozs7QUFRQTR5QixtQkFBZSxFQUFFLHlCQUFTN0csT0FBVCxFQUFrQjtBQUMvQixVQUFJeHFCLElBQUksR0FBTSxJQUFkO0FBQ0EsVUFBSW9XLE1BQU0sR0FBSSxFQUFkO0FBRUFBLFlBQU0sSUFBSW9VLE9BQU8sQ0FBQ3hCLFVBQWxCOztBQUVBLFVBQUl3QixPQUFPLENBQUNyQixJQUFaLEVBQWtCO0FBQ2QvUyxjQUFNLElBQUksTUFBTXBXLElBQUksQ0FBQ3F4QixlQUFMLENBQXFCN0csT0FBTyxDQUFDckIsSUFBN0IsQ0FBaEI7QUFDSDs7QUFFRCxhQUFPL1MsTUFBUDtBQUNILEtBaGlCTDs7QUFraUJJOzs7Ozs7OztBQVNBa2IsaUJBQWEsRUFBRSx1QkFBUzlHLE9BQVQsRUFBa0JzRSxTQUFsQixFQUE2QjtBQUN4QyxVQUFJOXVCLElBQUksR0FBYyxJQUF0QjtBQUFBLFVBQ0lnSSxXQUFXLEdBQU8sSUFEdEI7QUFBQSxVQUVJdXBCLGNBQWMsR0FBSSxDQUFDLENBRnZCO0FBQUEsVUFHSXhXLElBQUksR0FBYyxJQUh0QjtBQUFBLFVBSUlyZCxNQUFNLEdBQVksSUFKdEI7QUFBQSxVQUtJdU8sRUFBRSxHQUFnQixJQUx0QjtBQUFBLFVBTUlyTyxDQUFDLEdBQWlCLENBQUMsQ0FOdkI7QUFRQW9DLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIscUJBQWpCLEVBQXdDN1ksU0FBeEM7QUFFQSxVQUFJLE9BQU8rckIsT0FBTyxDQUFDcG9CLEtBQWYsS0FBeUIsV0FBN0IsRUFBMENvb0IsT0FBTyxDQUFDcG9CLEtBQVIsR0FBZ0IsQ0FBaEI7QUFFMUM0RixpQkFBVyxHQUFHaEksSUFBSSxDQUFDd3hCLGNBQUwsQ0FBb0JoSCxPQUFPLENBQUNwb0IsS0FBNUIsRUFBbUNvb0IsT0FBTyxDQUFDbGdCLE9BQTNDLEVBQW9Ea2dCLE9BQU8sQ0FBQ3BPLFFBQTVELENBQWQ7QUFDQXJCLFVBQUksR0FBVS9hLElBQUksQ0FBQzBxQixHQUFMLENBQVMzaEIsUUFBVCxDQUFrQmtTLHNCQUFsQixFQUFkOztBQUVBLFVBQUlqVCxXQUFKLEVBQWlCO0FBQ2J1cEIsc0JBQWMsR0FBRzVkLENBQUMsQ0FBQ3ZSLEtBQUYsQ0FBUTRGLFdBQVIsRUFBcUJoSSxJQUFJLENBQUMrVixNQUFMLENBQVlpUyxTQUFaLENBQXNCdHFCLE1BQTNDLENBQWpCO0FBQ0gsT0FGRCxNQUVPO0FBQ0g2ekIsc0JBQWMsR0FBR3Z4QixJQUFJLENBQUNvb0IsT0FBTCxDQUFhdnFCLE1BQTlCO0FBQ0g7O0FBRUQsVUFBSTJzQixPQUFPLENBQUMzQixVQUFaLEVBQXdCO0FBQ3BCLGFBQUtqckIsQ0FBQyxHQUFHLENBQVQsRUFBWXFPLEVBQUUsR0FBR3VlLE9BQU8sQ0FBQzNCLFVBQVIsQ0FBbUJqckIsQ0FBbkIsQ0FBakIsRUFBd0NBLENBQUMsRUFBekMsRUFBNkM7QUFDekMsY0FBSW9DLElBQUksQ0FBQzBxQixHQUFMLENBQVN0QyxPQUFULENBQWlCamIsT0FBakIsQ0FBeUJsQixFQUF6QixJQUErQixDQUFDLENBQXBDLEVBQXVDO0FBQ25DLGtCQUFNLElBQUl1SyxLQUFKLENBQVU5QyxRQUFPLENBQUMrQyxRQUFSLENBQWlCZ2IsNkJBQWpCLEVBQVYsQ0FBTjtBQUNILFdBSHdDLENBS3pDO0FBQ0E7OztBQUVBeGxCLFlBQUUsQ0FBQzlFLEtBQUgsQ0FBU3VxQixPQUFULEdBQW1CLE1BQW5CO0FBRUEzVyxjQUFJLENBQUNyUCxXQUFMLENBQWlCTyxFQUFqQjtBQUNBOE8sY0FBSSxDQUFDclAsV0FBTCxDQUFpQjFMLElBQUksQ0FBQzBxQixHQUFMLENBQVMzaEIsUUFBVCxDQUFrQjRvQixjQUFsQixDQUFpQyxHQUFqQyxDQUFqQjtBQUVBLGNBQUksQ0FBQ2hlLENBQUMsQ0FBQzRDLFNBQUYsQ0FBWXRLLEVBQVosRUFBZ0JqTSxJQUFJLENBQUMwcUIsR0FBTCxDQUFTM2hCLFFBQXpCLENBQUQsSUFBdUMsQ0FBQ2tELEVBQUUsQ0FBQ29ILE9BQUgsQ0FBV3JULElBQUksQ0FBQytWLE1BQUwsQ0FBWWlTLFNBQVosQ0FBc0J0cUIsTUFBakMsQ0FBNUMsRUFBc0Y7QUFFdEZBLGdCQUFNLEdBQUcsSUFBSWdXLFFBQU8sQ0FBQzRjLE1BQVosRUFBVDtBQUVBNXlCLGdCQUFNLENBQUNxbUIsSUFBUCxDQUFZOVgsRUFBWixFQUFnQmpNLElBQWhCO0FBRUF0QyxnQkFBTSxDQUFDNnlCLE9BQVAsR0FBaUIsSUFBakI7QUFFQXZ3QixjQUFJLENBQUNvb0IsT0FBTCxDQUFhOEIsTUFBYixDQUFvQnFILGNBQXBCLEVBQW9DLENBQXBDLEVBQXVDN3pCLE1BQXZDO0FBRUE2ekIsd0JBQWM7QUFDakI7O0FBRUR2eEIsWUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3JyQixNQUFULENBQWdCdU0sWUFBaEIsQ0FBNkJtUCxJQUE3QixFQUFtQy9TLFdBQW5DO0FBQ0gsT0FsRHVDLENBb0R4Qzs7O0FBRUE4bUIsZUFBUyxDQUFDaUIsVUFBVixHQUF1Qi92QixJQUFJLENBQUNzdEIsU0FBTCxHQUFpQnR0QixJQUFJLENBQUNvb0IsT0FBN0M7QUFFQXBvQixVQUFJLENBQUNzWCxXQUFMLENBQWlCLG9CQUFqQixFQUF1QzdZLFNBQXZDO0FBQ0gsS0FwbUJMOztBQXNtQkk7Ozs7Ozs7OztBQVVBK3lCLGtCQUFjLEVBQUUsd0JBQVNwdkIsS0FBVCxFQUFnQmtJLE9BQWhCLEVBQXlCOFIsUUFBekIsRUFBbUM7QUFDL0MsVUFBSXBjLElBQUksR0FBTSxJQUFkO0FBQUEsVUFDSXFjLE9BQU8sR0FBRyxJQURkO0FBR0FqYSxXQUFLLEdBQUdrRCxJQUFJLENBQUN5RixHQUFMLENBQVMzSSxLQUFULEVBQWdCLENBQWhCLENBQVI7O0FBRUEsVUFBSWtJLE9BQU8sSUFBSThSLFFBQVEsS0FBSyxRQUE1QixFQUFzQztBQUNsQztBQUVBQyxlQUFPLEdBQUcvUixPQUFWO0FBQ0gsT0FKRCxNQUlPLElBQUlBLE9BQU8sSUFBSThSLFFBQVEsS0FBSyxPQUE1QixFQUFxQztBQUN4QztBQUVBQyxlQUFPLEdBQUcvUixPQUFPLENBQUMwSixrQkFBUixJQUE4QixJQUF4QztBQUNILE9BSk0sTUFJQSxJQUFJaFUsSUFBSSxDQUFDb29CLE9BQUwsQ0FBYXZxQixNQUFiLEdBQXNCLENBQXRCLElBQTJCLE9BQU91RSxLQUFQLEtBQWlCLFdBQWhELEVBQTZEO0FBQ2hFO0FBRUFpYSxlQUFPLEdBQUlqYSxLQUFLLEdBQUdwQyxJQUFJLENBQUNvb0IsT0FBTCxDQUFhdnFCLE1BQXJCLElBQStCLENBQUNtQyxJQUFJLENBQUNvb0IsT0FBTCxDQUFhdnFCLE1BQTlDLEdBQ05tQyxJQUFJLENBQUNvb0IsT0FBTCxDQUFhaG1CLEtBQWIsRUFBb0Jzb0IsR0FBcEIsQ0FBd0J6ZSxFQURsQixHQUVOak0sSUFBSSxDQUFDb29CLE9BQUwsQ0FBYXBvQixJQUFJLENBQUNvb0IsT0FBTCxDQUFhdnFCLE1BQWIsR0FBc0IsQ0FBbkMsRUFBc0M2c0IsR0FBdEMsQ0FBMEN6ZSxFQUExQyxDQUE2QytILGtCQUZqRDtBQUdILE9BTk0sTUFNQSxJQUFJaFUsSUFBSSxDQUFDb29CLE9BQUwsQ0FBYXZxQixNQUFiLEtBQXdCLENBQXhCLElBQTZCbUMsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3JyQixNQUFULENBQWdCb0ksUUFBaEIsQ0FBeUI1SixNQUF6QixHQUFrQyxDQUFuRSxFQUFzRTtBQUN6RTtBQUVBLFlBQUltQyxJQUFJLENBQUMrVixNQUFMLENBQVkrUixNQUFaLENBQW1CVixZQUF2QixFQUFxQztBQUNqQy9LLGlCQUFPLEdBQUdyYyxJQUFJLENBQUMrVixNQUFMLENBQVkrUixNQUFaLENBQW1CVixZQUE3QjtBQUNILFNBRkQsTUFFTyxJQUFJcG5CLElBQUksQ0FBQytWLE1BQUwsQ0FBWStSLE1BQVosQ0FBbUJYLGFBQXZCLEVBQXNDO0FBQ3pDOUssaUJBQU8sR0FBR3JjLElBQUksQ0FBQytWLE1BQUwsQ0FBWStSLE1BQVosQ0FBbUJYLGFBQW5CLENBQWlDblQsa0JBQTNDO0FBQ0gsU0FGTSxNQUVBO0FBQ0hoVSxjQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0JvSSxRQUFoQixDQUF5QixDQUF6QjtBQUNIO0FBQ0osT0FWTSxNQVVBO0FBQ0g0VSxlQUFPLEtBQUssSUFBWjtBQUNIOztBQUVELGFBQU9yYyxJQUFJLENBQUN1aUIsV0FBTCxDQUFpQix1QkFBakIsRUFBMENsRyxPQUExQyxFQUFtRDVkLFNBQW5ELENBQVA7QUFDSCxLQW5wQkw7O0FBcXBCSTs7Ozs7OztBQVFBMHhCLG1CQUFlLEVBQUUseUJBQVNyQixTQUFULEVBQW9CO0FBQ2pDLFVBQUk5dUIsSUFBSSxHQUFVLElBQWxCO0FBQUEsVUFDSTR4QixVQUFVLEdBQUksS0FEbEI7QUFBQSxVQUVJeHZCLEtBQUssR0FBUyxDQUFDLENBRm5CO0FBQUEsVUFHSTBtQixNQUFNLEdBQVEsRUFIbEI7QUFBQSxVQUlJcHJCLE1BQU0sR0FBUSxJQUpsQjtBQUFBLFVBS0lFLENBQUMsR0FBYSxDQUFDLENBTG5CO0FBT0FvQyxVQUFJLENBQUNzWCxXQUFMLENBQWlCLHVCQUFqQixFQUEwQzdZLFNBQTFDO0FBRUFxcUIsWUFBTSxHQUFHZ0csU0FBUyxDQUFDbUIsU0FBVixDQUFvQm5ILE1BQTdCOztBQUVBLFdBQUtsckIsQ0FBQyxHQUFHLENBQVQsRUFBWUYsTUFBTSxHQUFHb3hCLFNBQVMsQ0FBQ2dCLFFBQVYsQ0FBbUJseUIsQ0FBbkIsQ0FBckIsRUFBNENBLENBQUMsRUFBN0MsRUFBaUQ7QUFDN0MsWUFBSWt4QixTQUFTLENBQUNtQixTQUFWLENBQW9CcEgsVUFBeEIsRUFBb0M7QUFDaEM7QUFFQStJLG9CQUFVLEdBQUc5QyxTQUFTLENBQUNtQixTQUFWLENBQW9CcEgsVUFBcEIsQ0FBK0IxYixPQUEvQixDQUF1Q3pQLE1BQU0sQ0FBQ2d0QixHQUFQLENBQVd6ZSxFQUFsRCxJQUF3RCxDQUFDLENBQXRFO0FBQ0gsU0FKRCxNQUlPO0FBQ0g7QUFFQSxjQUFJNmlCLFNBQVMsQ0FBQ21CLFNBQVYsQ0FBb0JydEIsUUFBcEIsS0FBaUMsRUFBckMsRUFBeUM7QUFDckNndkIsc0JBQVUsR0FBRyxLQUFiO0FBQ0gsV0FGRCxNQUVPO0FBQ0hBLHNCQUFVLEdBQUdsMEIsTUFBTSxDQUFDZ3RCLEdBQVAsQ0FBV3plLEVBQVgsQ0FBY29ILE9BQWQsQ0FBc0J5YixTQUFTLENBQUNtQixTQUFWLENBQW9CcnRCLFFBQTFDLENBQWI7QUFDSDtBQUNKOztBQUVENUMsWUFBSSxDQUFDNnhCLGdCQUFMLENBQXNCRCxVQUF0QixFQUFrQ2wwQixNQUFsQyxFQUEwQ29yQixNQUExQyxFQUFrRGdHLFNBQWxEO0FBQ0g7O0FBRUQsVUFBSUEsU0FBUyxDQUFDZ0QsUUFBVixDQUFtQmowQixNQUF2QixFQUErQjtBQUMzQixhQUFLRCxDQUFDLEdBQUcsQ0FBVCxFQUFZRixNQUFNLEdBQUdveEIsU0FBUyxDQUFDUyxJQUFWLENBQWUzeEIsQ0FBZixDQUFyQixFQUF3Q0EsQ0FBQyxFQUF6QyxFQUE2QztBQUN6QyxjQUFJa3hCLFNBQVMsQ0FBQ2dELFFBQVYsQ0FBbUIza0IsT0FBbkIsQ0FBMkJ6UCxNQUEzQixJQUFxQyxDQUFDLENBQTFDLEVBQTZDO0FBQ3pDO0FBRUFveEIscUJBQVMsQ0FBQ1MsSUFBVixDQUFlckYsTUFBZixDQUFzQnRzQixDQUF0QixFQUF5QixDQUF6Qjs7QUFFQSxnQkFBSSxDQUFDd0UsS0FBSyxHQUFHMHNCLFNBQVMsQ0FBQ2lELE1BQVYsQ0FBaUI1a0IsT0FBakIsQ0FBeUJ6UCxNQUF6QixDQUFULElBQTZDLENBQUMsQ0FBbEQsRUFBcUQ7QUFDakRveEIsdUJBQVMsQ0FBQ2lELE1BQVYsQ0FBaUI3SCxNQUFqQixDQUF3QjluQixLQUF4QixFQUErQixDQUEvQjtBQUNIOztBQUVEMHNCLHFCQUFTLENBQUNSLE1BQVYsQ0FBaUJqc0IsSUFBakIsQ0FBc0IzRSxNQUF0QjtBQUNBb3hCLHFCQUFTLENBQUNQLElBQVYsQ0FBZWxzQixJQUFmLENBQW9CM0UsTUFBcEI7QUFFQUUsYUFBQztBQUNKO0FBQ0o7QUFDSjs7QUFFRGt4QixlQUFTLENBQUNrRCxRQUFWLEdBQXFCbEQsU0FBUyxDQUFDUyxJQUFWLENBQWU5bUIsS0FBZixFQUFyQjs7QUFFQSxVQUFJcW1CLFNBQVMsQ0FBQ1MsSUFBVixDQUFlMXhCLE1BQWYsS0FBMEIsQ0FBMUIsSUFBK0JpeEIsU0FBUyxDQUFDbUIsU0FBVixDQUFvQnJ0QixRQUFwQixLQUFpQyxFQUFoRSxJQUFzRTVDLElBQUksQ0FBQ29vQixPQUFMLENBQWF2cUIsTUFBYixLQUF3QixDQUFsRyxFQUFxRztBQUNqR2l4QixpQkFBUyxDQUFDbUQsU0FBVixHQUFzQixJQUF0QjtBQUNIOztBQUVEanlCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsc0JBQWpCLEVBQXlDN1ksU0FBekM7QUFDSCxLQXJ0Qkw7O0FBdXRCSTs7Ozs7Ozs7OztBQVdBb3pCLG9CQUFnQixFQUFFLDBCQUFTRCxVQUFULEVBQXFCbDBCLE1BQXJCLEVBQTZCb3JCLE1BQTdCLEVBQXFDZ0csU0FBckMsRUFBZ0Q7QUFDOUQsVUFBSTl1QixJQUFJLEdBQUcsSUFBWDtBQUFBLFVBQ0lreUIsa0JBQWtCLEdBQUcsS0FEekI7QUFBQSxVQUVJL3JCLElBQUksR0FBR3ZGLEtBQUssQ0FBQ3pELFNBQU4sQ0FBZ0JzTCxLQUFoQixDQUFzQjdKLElBQXRCLENBQTJCSCxTQUEzQixFQUFzQyxDQUF0QyxDQUZYO0FBSUF5ekIsd0JBQWtCLEdBQUdseUIsSUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIsNEJBQWpCLEVBQStDcVAsVUFBL0MsRUFBMkR6ckIsSUFBM0QsQ0FBckI7QUFFQW5HLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsd0JBQWpCLEVBQTJDN1ksU0FBM0M7O0FBRUEsVUFDSXl6QixrQkFBa0IsS0FBSyxJQUF2QixJQUErQnBKLE1BQU0sS0FBSyxNQUExQyxJQUNBb0osa0JBQWtCLEtBQUssS0FBdkIsSUFBZ0NwSixNQUFNLEtBQUssTUFGL0MsRUFHRTtBQUNFZ0csaUJBQVMsQ0FBQ1MsSUFBVixDQUFlbHRCLElBQWYsQ0FBb0IzRSxNQUFwQjtBQUVBLFNBQUNBLE1BQU0sQ0FBQ3kwQixPQUFSLElBQW1CckQsU0FBUyxDQUFDaUQsTUFBVixDQUFpQjF2QixJQUFqQixDQUFzQjNFLE1BQXRCLENBQW5CO0FBQ0gsT0FQRCxNQU9PO0FBQ0hveEIsaUJBQVMsQ0FBQ1AsSUFBVixDQUFlbHNCLElBQWYsQ0FBb0IzRSxNQUFwQjtBQUVBQSxjQUFNLENBQUN5MEIsT0FBUCxJQUFrQnJELFNBQVMsQ0FBQ1IsTUFBVixDQUFpQmpzQixJQUFqQixDQUFzQjNFLE1BQXRCLENBQWxCO0FBQ0g7O0FBRURzQyxVQUFJLENBQUNzWCxXQUFMLENBQWlCLHVCQUFqQixFQUEwQzdZLFNBQTFDO0FBQ0gsS0F6dkJMOztBQTJ2Qkk7Ozs7Ozs7QUFRQW14QixpQkFBYSxFQUFFLHVCQUFTZCxTQUFULEVBQW9CO0FBQy9CLFVBQUk5dUIsSUFBSSxHQUFPLElBQWY7QUFBQSxVQUNJOHZCLFFBQVEsR0FBRyxFQURmO0FBQUEsVUFFSXB5QixNQUFNLEdBQUssSUFGZjtBQUFBLFVBR0l1TyxFQUFFLEdBQVMsSUFIZjtBQUFBLFVBSUlyTyxDQUFDLEdBQVUsQ0FBQyxDQUpoQjtBQU1Bb0MsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixxQkFBakIsRUFBd0M3WSxTQUF4QztBQUVBcXdCLGVBQVMsQ0FBQ2lCLFVBQVYsR0FBdUIvdkIsSUFBSSxDQUFDb29CLE9BQTVCOztBQUVBLFVBQUkwRyxTQUFTLENBQUNhLE9BQVYsQ0FBa0I5RyxVQUF0QixFQUFrQztBQUM5QjtBQUVBaUgsZ0JBQVEsR0FBRyxFQUFYOztBQUVBLGFBQUtseUIsQ0FBQyxHQUFHLENBQVQsRUFBYXFPLEVBQUUsR0FBRzZpQixTQUFTLENBQUNhLE9BQVYsQ0FBa0I5RyxVQUFsQixDQUE2QmpyQixDQUE3QixDQUFsQixFQUFvREEsQ0FBQyxFQUFyRCxFQUF5RDtBQUNyRCxjQUFJb0MsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3RDLE9BQVQsQ0FBaUJqYixPQUFqQixDQUF5QmxCLEVBQXpCLElBQStCLENBQW5DLEVBQXNDO0FBQ2xDLGtCQUFNLElBQUl1SyxLQUFKLENBQVU5QyxRQUFPLENBQUMrQyxRQUFSLENBQWlCMmIsMkJBQWpCLEVBQVYsQ0FBTjtBQUNIOztBQUVEMTBCLGdCQUFNLEdBQUcsSUFBSWdXLFFBQU8sQ0FBQzRjLE1BQVosRUFBVDtBQUVBNXlCLGdCQUFNLENBQUNxbUIsSUFBUCxDQUFZOVgsRUFBWixFQUFnQmpNLElBQWhCO0FBRUF0QyxnQkFBTSxDQUFDNnlCLE9BQVAsR0FBaUIsSUFBakI7QUFFQVQsa0JBQVEsQ0FBQ3p0QixJQUFULENBQWMzRSxNQUFkO0FBQ0g7O0FBRURveEIsaUJBQVMsQ0FBQ2dCLFFBQVYsR0FBcUJBLFFBQXJCO0FBQ0gsT0FwQkQsTUFvQk8sSUFBSWhCLFNBQVMsQ0FBQ2EsT0FBVixDQUFrQnpHLEtBQWxCLEtBQTRCLFFBQWhDLEVBQTBDO0FBQzdDO0FBRUE0RixpQkFBUyxDQUFDZ0IsUUFBVixHQUFxQm5jLENBQUMsQ0FBQytILFlBQUYsQ0FBZW9ULFNBQVMsQ0FBQ2lCLFVBQXpCLENBQXJCO0FBQ0gsT0FKTSxNQUlBLElBQUlqQixTQUFTLENBQUNhLE9BQVYsQ0FBa0IxRyxTQUFsQixLQUFnQyxFQUFwQyxFQUF3QztBQUMzQztBQUVBNkYsaUJBQVMsQ0FBQ2dCLFFBQVYsR0FBcUI5dkIsSUFBSSxDQUFDc3RCLFNBQUwsQ0FBZTdrQixLQUFmLEVBQXJCOztBQUVBLFlBQUlxbUIsU0FBUyxDQUFDYSxPQUFWLENBQWtCekcsS0FBbEIsS0FBNEIsTUFBaEMsRUFBd0M7QUFDcEM0RixtQkFBUyxDQUFDZ0IsUUFBVixDQUFtQnJrQixPQUFuQjtBQUNIO0FBQ0osT0FSTSxNQVFBO0FBQ0g7QUFFQXFqQixpQkFBUyxDQUFDZ0IsUUFBVixHQUFxQmhCLFNBQVMsQ0FBQ2lCLFVBQVYsQ0FBcUJ0bkIsS0FBckIsRUFBckI7QUFFQXFtQixpQkFBUyxDQUFDZ0IsUUFBVixDQUFtQnR1QixJQUFuQixDQUF3QixVQUFTK1osQ0FBVCxFQUFZQyxDQUFaLEVBQWU7QUFDbkMsaUJBQU94YixJQUFJLENBQUNxeUIsT0FBTCxDQUFhOVcsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJzVCxTQUFTLENBQUNhLE9BQTdCLENBQVA7QUFDSCxTQUZEO0FBR0g7O0FBRUQsVUFBSWhjLENBQUMsQ0FBQzJILFlBQUYsQ0FBZXdULFNBQVMsQ0FBQ2dCLFFBQXpCLEVBQW1DaEIsU0FBUyxDQUFDaUIsVUFBN0MsQ0FBSixFQUE4RDtBQUMxRGpCLGlCQUFTLENBQUN3RCxRQUFWLEdBQXFCLEtBQXJCO0FBQ0g7O0FBRUR0eUIsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixvQkFBakIsRUFBdUM3WSxTQUF2QztBQUNILEtBN3pCTDs7QUErekJJOzs7Ozs7Ozs7QUFVQTR6QixXQUFPLEVBQUUsaUJBQVM5VyxDQUFULEVBQVlDLENBQVosRUFBZWdQLE9BQWYsRUFBd0I7QUFDN0IsVUFBSXhxQixJQUFJLEdBQVUsSUFBbEI7QUFBQSxVQUNJa3BCLEtBQUssR0FBU3NCLE9BQU8sQ0FBQ3RCLEtBRDFCO0FBQUEsVUFFSXFKLEtBQUssR0FBU3Z5QixJQUFJLENBQUN3eUIsaUJBQUwsQ0FBdUJqWCxDQUF2QixFQUEwQmlQLE9BQU8sQ0FBQ3ZCLFNBQWxDLENBRmxCO0FBQUEsVUFHSXdKLEtBQUssR0FBU3p5QixJQUFJLENBQUN3eUIsaUJBQUwsQ0FBdUJoWCxDQUF2QixFQUEwQmdQLE9BQU8sQ0FBQ3ZCLFNBQWxDLENBSGxCOztBQUtBLFVBQUl5SixLQUFLLENBQUNILEtBQUssR0FBRyxDQUFULENBQUwsSUFBb0JHLEtBQUssQ0FBQ0QsS0FBSyxHQUFHLENBQVQsQ0FBN0IsRUFBMEM7QUFDdENGLGFBQUssR0FBR0EsS0FBSyxDQUFDaFksV0FBTixFQUFSO0FBQ0FrWSxhQUFLLEdBQUdBLEtBQUssQ0FBQ2xZLFdBQU4sRUFBUjtBQUNILE9BSEQsTUFHTztBQUNIZ1ksYUFBSyxHQUFHQSxLQUFLLEdBQUcsQ0FBaEI7QUFDQUUsYUFBSyxHQUFHQSxLQUFLLEdBQUcsQ0FBaEI7QUFDSDs7QUFFRCxVQUFJRixLQUFLLEdBQUdFLEtBQVosRUFBbUI7QUFDZixlQUFPdkosS0FBSyxLQUFLLEtBQVYsR0FBa0IsQ0FBQyxDQUFuQixHQUF1QixDQUE5QjtBQUNIOztBQUVELFVBQUlxSixLQUFLLEdBQUdFLEtBQVosRUFBbUI7QUFDZixlQUFPdkosS0FBSyxLQUFLLEtBQVYsR0FBa0IsQ0FBbEIsR0FBc0IsQ0FBQyxDQUE5QjtBQUNIOztBQUVELFVBQUlxSixLQUFLLEtBQUtFLEtBQVYsSUFBbUJqSSxPQUFPLENBQUNyQixJQUEvQixFQUFxQztBQUNqQyxlQUFPbnBCLElBQUksQ0FBQ3F5QixPQUFMLENBQWE5VyxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQmdQLE9BQU8sQ0FBQ3JCLElBQTNCLENBQVA7QUFDSDs7QUFFRCxhQUFPLENBQVA7QUFDSCxLQXAyQkw7O0FBczJCSTs7Ozs7Ozs7Ozs7QUFZQXFKLHFCQUFpQixFQUFFLDJCQUFTOTBCLE1BQVQsRUFBaUJ1ckIsU0FBakIsRUFBNEI7QUFDM0MsVUFBSWpwQixJQUFJLEdBQU0sSUFBZDtBQUFBLFVBQ0lULEtBQUssR0FBSyxFQURkO0FBR0FBLFdBQUssR0FBRzdCLE1BQU0sQ0FBQ2d0QixHQUFQLENBQVd6ZSxFQUFYLENBQWN3RixZQUFkLENBQTJCLFVBQVV3WCxTQUFyQyxDQUFSOztBQUVBLFVBQUkxcEIsS0FBSyxLQUFLLElBQWQsRUFBb0I7QUFDaEIsWUFBSVMsSUFBSSxDQUFDK1YsTUFBTCxDQUFZZSxLQUFaLENBQWtCQyxZQUF0QixFQUFvQztBQUNoQztBQUNBO0FBRUFuYSxpQkFBTyxDQUFDRixJQUFSLENBQWFnWCxRQUFPLENBQUMrQyxRQUFSLENBQWlCa2Msb0NBQWpCLENBQXNEO0FBQy9EMUoscUJBQVMsRUFBRSxVQUFVQTtBQUQwQyxXQUF0RCxDQUFiO0FBR0g7QUFDSixPQWYwQyxDQWlCM0M7OztBQUVBLGFBQU9qcEIsSUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIsd0JBQWpCLEVBQTJDaGpCLEtBQUssSUFBSSxDQUFwRCxFQUF1RGQsU0FBdkQsQ0FBUDtBQUNILEtBdDRCTDs7QUF3NEJJOzs7Ozs7Ozs7Ozs7QUFhQW94QixhQUFTLEVBQUUsbUJBQVMrQyxXQUFULEVBQXNCOUQsU0FBdEIsRUFBaUM7QUFDeEMsVUFBSTl1QixJQUFJLEdBQVUsSUFBbEI7QUFBQSxVQUNJK3ZCLFVBQVUsR0FBSTZDLFdBQVcsR0FBRzlELFNBQVMsQ0FBQ2dCLFFBQWIsR0FBd0JoQixTQUFTLENBQUNpQixVQUQvRDtBQUFBLFVBRUlELFFBQVEsR0FBTThDLFdBQVcsR0FBRzlELFNBQVMsQ0FBQ2lCLFVBQWIsR0FBMEJqQixTQUFTLENBQUNnQixRQUZqRTtBQUFBLFVBR0k5bkIsV0FBVyxHQUFHK25CLFVBQVUsQ0FBQ2x5QixNQUFYLEdBQW9Ca3lCLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDbHlCLE1BQVgsR0FBb0IsQ0FBckIsQ0FBVixDQUFrQzZzQixHQUFsQyxDQUFzQ3plLEVBQXRDLENBQXlDK0gsa0JBQTdELEdBQWtGLElBSHBHO0FBQUEsVUFJSStHLElBQUksR0FBVTVTLE1BQU0sQ0FBQ1ksUUFBUCxDQUFnQmtTLHNCQUFoQixFQUpsQjtBQUFBLFVBS0k0WCxVQUFVLEdBQUksSUFMbEI7QUFBQSxVQU1JbjFCLE1BQU0sR0FBUSxJQU5sQjtBQUFBLFVBT0l1TyxFQUFFLEdBQVksSUFQbEI7QUFBQSxVQVFJck8sQ0FBQyxHQUFhLENBQUMsQ0FSbkI7QUFVQW9DLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsaUJBQWpCLEVBQW9DN1ksU0FBcEMsRUFYd0MsQ0FheEM7O0FBRUEsV0FBS2IsQ0FBQyxHQUFHLENBQVQsRUFBWUYsTUFBTSxHQUFHcXlCLFVBQVUsQ0FBQ255QixDQUFELENBQS9CLEVBQW9DQSxDQUFDLEVBQXJDLEVBQXlDO0FBQ3JDcU8sVUFBRSxHQUFHdk8sTUFBTSxDQUFDZ3RCLEdBQVAsQ0FBV3plLEVBQWhCO0FBRUEsWUFBSUEsRUFBRSxDQUFDOUUsS0FBSCxDQUFTaVYsUUFBVCxLQUFzQixVQUExQixFQUFzQztBQUV0Q3pJLFNBQUMsQ0FBQ3dILGdCQUFGLENBQW1CbFAsRUFBRSxDQUFDb1AsZUFBdEI7QUFFQXBQLFVBQUUsQ0FBQ3VJLGFBQUgsQ0FBaUIxSSxXQUFqQixDQUE2QkcsRUFBN0I7QUFDSDs7QUFFRDRtQixnQkFBVSxHQUFHN3FCLFdBQVcsR0FBR0EsV0FBVyxDQUFDcVQsZUFBZixHQUFpQ3JiLElBQUksQ0FBQzBxQixHQUFMLENBQVNyckIsTUFBVCxDQUFnQnl6QixTQUF6RTs7QUFFQSxVQUFJRCxVQUFVLElBQUlBLFVBQVUsQ0FBQ2hZLFFBQVgsS0FBd0IsT0FBMUMsRUFBbUQ7QUFDL0NsSCxTQUFDLENBQUN3SCxnQkFBRixDQUFtQjBYLFVBQW5CO0FBQ0g7O0FBRUQsV0FBS2oxQixDQUFDLEdBQUcsQ0FBVCxFQUFZRixNQUFNLEdBQUdveUIsUUFBUSxDQUFDbHlCLENBQUQsQ0FBN0IsRUFBa0NBLENBQUMsRUFBbkMsRUFBdUM7QUFDbkM7QUFFQXFPLFVBQUUsR0FBR3ZPLE1BQU0sQ0FBQ2d0QixHQUFQLENBQVd6ZSxFQUFoQjs7QUFFQSxZQUFJMEgsQ0FBQyxDQUFDNEMsU0FBRixDQUFZd0UsSUFBSSxDQUFDK1gsU0FBakIsQ0FBSixFQUFpQztBQUM3Qi9YLGNBQUksQ0FBQ3JQLFdBQUwsQ0FBaUJ2RCxNQUFNLENBQUNZLFFBQVAsQ0FBZ0I0b0IsY0FBaEIsQ0FBK0IsR0FBL0IsQ0FBakI7QUFDSDs7QUFFRDVXLFlBQUksQ0FBQ3JQLFdBQUwsQ0FBaUJPLEVBQWpCO0FBQ0gsT0F6Q3VDLENBMkN4QztBQUNBOzs7QUFFQSxVQUFJak0sSUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3JyQixNQUFULENBQWdCeUksVUFBaEIsSUFBOEI5SCxJQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0J5SSxVQUFoQixLQUErQkUsV0FBakUsRUFBOEU7QUFDMUUrUyxZQUFJLENBQUNuUCxZQUFMLENBQWtCekQsTUFBTSxDQUFDWSxRQUFQLENBQWdCNG9CLGNBQWhCLENBQStCLEdBQS9CLENBQWxCLEVBQXVENVcsSUFBSSxDQUFDZ1ksVUFBTCxDQUFnQixDQUFoQixDQUF2RDtBQUNIOztBQUVELFVBQUkvcUIsV0FBSixFQUFpQjtBQUNiK1MsWUFBSSxDQUFDclAsV0FBTCxDQUFpQnZELE1BQU0sQ0FBQ1ksUUFBUCxDQUFnQjRvQixjQUFoQixDQUErQixHQUEvQixDQUFqQjtBQUVBM3hCLFlBQUksQ0FBQzBxQixHQUFMLENBQVNyckIsTUFBVCxDQUFnQnVNLFlBQWhCLENBQTZCbVAsSUFBN0IsRUFBbUMvUyxXQUFuQztBQUNILE9BSkQsTUFJTztBQUNIaEksWUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3JyQixNQUFULENBQWdCcU0sV0FBaEIsQ0FBNEJxUCxJQUE1QjtBQUNIOztBQUVEL2EsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixnQkFBakIsRUFBbUM3WSxTQUFuQztBQUNILEtBaDlCTDs7QUFrOUJJOzs7Ozs7Ozs7O0FBV0F1MEIsbUJBQWUsRUFBRSx5QkFBU2hLLFVBQVQsRUFBcUJ3QixPQUFyQixFQUE4QjtBQUMzQyxVQUFJeHFCLElBQUksR0FBVSxJQUFsQjtBQUFBLFVBQ0lpekIsS0FBSyxHQUFTakssVUFBVSxDQUFDamMsS0FBWCxDQUFpQixHQUFqQixDQURsQjtBQUFBLFVBRUltVixPQUFPLEdBQU9zSSxPQUZsQjtBQUFBLFVBR0kwSSxJQUFJLEdBQVUsRUFIbEI7QUFBQSxVQUlJdDFCLENBQUMsR0FBYSxDQUFDLENBSm5CLENBRDJDLENBTzNDOztBQUVBLFdBQUtBLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR3ExQixLQUFLLENBQUNwMUIsTUFBdEIsRUFBOEJELENBQUMsRUFBL0IsRUFBbUM7QUFDL0JzMUIsWUFBSSxHQUFHRCxLQUFLLENBQUNyMUIsQ0FBRCxDQUFMLENBQVNtUCxLQUFULENBQWUsR0FBZixDQUFQO0FBRUFtVixlQUFPLENBQUM4RyxVQUFSLEdBQXNCaUssS0FBSyxDQUFDcjFCLENBQUQsQ0FBM0I7QUFDQXNrQixlQUFPLENBQUMrRyxTQUFSLEdBQXNCdFYsQ0FBQyxDQUFDZ0gsUUFBRixDQUFXdVksSUFBSSxDQUFDLENBQUQsQ0FBZixDQUF0QjtBQUNBaFIsZUFBTyxDQUFDZ0gsS0FBUixHQUFzQmdLLElBQUksQ0FBQyxDQUFELENBQUosSUFBVyxLQUFqQzs7QUFFQSxnQkFBUWhSLE9BQU8sQ0FBQytHLFNBQWhCO0FBQ0ksZUFBSyxTQUFMO0FBQ0k7QUFFQS9HLG1CQUFPLENBQUMrRyxTQUFSLEdBQW9CLEVBQXBCO0FBRUE7O0FBQ0osZUFBSyxRQUFMO0FBQ0k7QUFFQS9HLG1CQUFPLENBQUMrRyxTQUFSLEdBQXNCLEVBQXRCO0FBQ0EvRyxtQkFBTyxDQUFDZ0gsS0FBUixHQUFzQixRQUF0QjtBQUVBO0FBYlI7O0FBZ0JBLFlBQUksQ0FBQ2hILE9BQU8sQ0FBQytHLFNBQVQsSUFBc0IvRyxPQUFPLENBQUNnSCxLQUFSLEtBQWtCLFFBQTVDLEVBQXNEOztBQUV0RCxZQUFJdHJCLENBQUMsR0FBR3ExQixLQUFLLENBQUNwMUIsTUFBTixHQUFlLENBQXZCLEVBQTBCO0FBQ3RCO0FBRUFxa0IsaUJBQU8sQ0FBQ2lILElBQVIsR0FBZSxJQUFJelYsUUFBTyxDQUFDcVYsV0FBWixFQUFmO0FBRUFwVixXQUFDLENBQUNrTixNQUFGLENBQVNxQixPQUFUO0FBRUFBLGlCQUFPLEdBQUdBLE9BQU8sQ0FBQ2lILElBQWxCO0FBQ0g7QUFDSjs7QUFFRCxhQUFPbnBCLElBQUksQ0FBQ3VpQixXQUFMLENBQWlCLG1CQUFqQixFQUFzQ2lJLE9BQXRDLEVBQStDL3JCLFNBQS9DLENBQVA7QUFDSCxLQTNnQ0w7O0FBNmdDSTs7Ozs7Ozs7O0FBVUFvd0IsZ0JBQVksRUFBRSx3QkFBVztBQUNyQixVQUFJN3VCLElBQUksR0FBYyxJQUF0QjtBQUFBLFVBQ0ltekIsYUFBYSxHQUFLLEVBRHRCO0FBQUEsVUFFSTdPLFNBQVMsR0FBU3RrQixJQUFJLENBQUMrVixNQUFMLENBQVk0UixTQUFaLENBQXNCckQsU0FBdEIsSUFBbUN0a0IsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQnRELE9BRi9FO0FBQUEsVUFHSUUsVUFBVSxHQUFRdmtCLElBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0JwRCxVQUF0QixJQUFvQ3ZrQixJQUFJLENBQUMrVixNQUFMLENBQVk0UixTQUFaLENBQXNCdEQsT0FIaEY7QUFLQXJrQixVQUFJLENBQUNzWCxXQUFMLENBQWlCLG9CQUFqQixFQUF1QzdZLFNBQXZDO0FBRUF1QixVQUFJLENBQUNza0IsU0FBTCxHQUFzQixJQUFJNVEsUUFBTyxDQUFDOFgsU0FBWixFQUF0QjtBQUNBeHJCLFVBQUksQ0FBQ3VrQixVQUFMLEdBQXNCLElBQUk3USxRQUFPLENBQUM4WCxTQUFaLEVBQXRCO0FBQ0F4ckIsVUFBSSxDQUFDNnRCLFdBQUwsR0FBc0IsRUFBdEI7QUFDQTd0QixVQUFJLENBQUM4dEIsWUFBTCxHQUFzQixFQUF0QjtBQUVBOXRCLFVBQUksQ0FBQ3NrQixTQUFMLENBQWUzRCxPQUFmLEdBQXlCM2dCLElBQUksQ0FBQ3VrQixVQUFMLENBQWdCNUQsT0FBaEIsR0FBMEIsQ0FBbkQ7QUFFQTNnQixVQUFJLENBQUNvekIsV0FBTCxDQUFpQixNQUFqQixFQUF5QjlPLFNBQXpCLEVBQW9DdGtCLElBQUksQ0FBQ3NrQixTQUF6QyxFQUFvRHRrQixJQUFJLENBQUM2dEIsV0FBekQ7QUFDQTd0QixVQUFJLENBQUNvekIsV0FBTCxDQUFpQixNQUFqQixFQUF5QjdPLFVBQXpCLEVBQXFDdmtCLElBQUksQ0FBQ3VrQixVQUExQyxFQUFzRHZrQixJQUFJLENBQUM4dEIsWUFBM0QsRUFBeUUsSUFBekU7O0FBRUEsV0FBS3FGLGFBQUwsSUFBc0J6ZixRQUFPLENBQUM0WSxpQkFBOUIsRUFBaUQ7QUFDN0MsWUFBSSxFQUFFNVksUUFBTyxDQUFDNFksaUJBQVIsQ0FBMEI2RyxhQUExQixhQUFvRHpmLFFBQU8sQ0FBQ21ZLGFBQTlELENBQUosRUFBa0Y7QUFDOUU7QUFDSDs7QUFFRDdyQixZQUFJLENBQUNvekIsV0FBTCxDQUFpQkQsYUFBakIsRUFBZ0M3TyxTQUFoQyxFQUEyQ3RrQixJQUFJLENBQUNza0IsU0FBaEQsRUFBMkR0a0IsSUFBSSxDQUFDNnRCLFdBQWhFO0FBQ0E3dEIsWUFBSSxDQUFDb3pCLFdBQUwsQ0FBaUJELGFBQWpCLEVBQWdDNU8sVUFBaEMsRUFBNEN2a0IsSUFBSSxDQUFDdWtCLFVBQWpELEVBQTZEdmtCLElBQUksQ0FBQzh0QixZQUFsRSxFQUFnRixJQUFoRjtBQUNIOztBQUVEOXRCLFVBQUksQ0FBQ296QixXQUFMLENBQWlCLFNBQWpCLEVBQTRCOU8sU0FBNUIsRUFBdUN0a0IsSUFBSSxDQUFDc2tCLFNBQTVDLEVBQXVEdGtCLElBQUksQ0FBQzZ0QixXQUE1RDtBQUNBN3RCLFVBQUksQ0FBQ296QixXQUFMLENBQWlCLFNBQWpCLEVBQTRCN08sVUFBNUIsRUFBd0N2a0IsSUFBSSxDQUFDdWtCLFVBQTdDLEVBQXlEdmtCLElBQUksQ0FBQzh0QixZQUE5RCxFQUE0RSxJQUE1RTtBQUVBOXRCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsbUJBQWpCLEVBQXNDN1ksU0FBdEM7QUFDSCxLQXRqQ0w7O0FBd2pDSTs7Ozs7Ozs7OztBQVdBMjBCLGVBQVcsRUFBRSxxQkFBU0MsVUFBVCxFQUFxQkMsWUFBckIsRUFBbUNqUCxPQUFuQyxFQUE0Q3RXLFNBQTVDLEVBQXVEd2xCLEtBQXZELEVBQThEO0FBQ3ZFLFVBQUl2ekIsSUFBSSxHQUFVLElBQWxCO0FBQUEsVUFDSXdZLEVBQUUsR0FBWSxhQURsQjtBQUFBLFVBRUlnYixTQUFTLEdBQUssQ0FBQyxDQUZuQjtBQUFBLFVBR0lyYSxHQUFHLEdBQVcsRUFIbEI7QUFBQSxVQUlJakcsS0FBSyxHQUFTLEVBSmxCO0FBQUEsVUFLSXVnQixHQUFHLEdBQVcsRUFMbEI7QUFBQSxVQU1JQyxLQUFLLEdBQVMsQ0FBQyxHQUFELEVBQU0sSUFBTixFQUFZLElBQVosRUFBa0IsS0FBbEIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0IsRUFBcUMsS0FBckMsQ0FObEI7QUFBQSxVQU9JdEgsSUFBSSxHQUFVLEVBUGxCO0FBQUEsVUFRSXh1QixDQUFDLEdBQWEsQ0FBQyxDQVJuQjtBQVVBb0MsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixtQkFBakIsRUFBc0M3WSxTQUF0Qzs7QUFFQSxVQUFJLE9BQU82MEIsWUFBUCxLQUF3QixRQUE1QixFQUFzQztBQUNsQyxjQUFNLElBQUkvMUIsU0FBSixDQUFjbVcsUUFBTyxDQUFDK0MsUUFBUixDQUFpQmtkLGtDQUFqQixFQUFkLENBQU47QUFDSDs7QUFFRCxVQUFJTCxZQUFZLENBQUNubUIsT0FBYixDQUFxQmttQixVQUFyQixJQUFtQyxDQUF2QyxFQUEwQztBQUN0QztBQUVBLFlBQUlBLFVBQVUsS0FBSyxTQUFuQixFQUE4QjtBQUMxQjtBQUVBcnpCLGNBQUksQ0FBQzR0QixlQUFMLEdBQXVCLENBQXZCO0FBQ0g7O0FBRUQ7QUFDSCxPQTNCc0UsQ0E2QnZFOzs7QUFFQTRGLGVBQVMsR0FBR0YsWUFBWSxDQUFDbm1CLE9BQWIsQ0FBcUJrbUIsVUFBVSxHQUFHLEdBQWxDLENBQVo7O0FBRUEsVUFBSUcsU0FBUyxHQUFHLENBQUMsQ0FBakIsRUFBb0I7QUFDaEI7QUFFQTtBQUVBcmEsV0FBRyxHQUFHbWEsWUFBWSxDQUFDTSxTQUFiLENBQXVCSixTQUF2QixDQUFOLENBTGdCLENBT2hCOztBQUVBdGdCLGFBQUssR0FBR3NGLEVBQUUsQ0FBQ00sSUFBSCxDQUFRSyxHQUFSLENBQVI7QUFFQXNhLFdBQUcsR0FBR3ZnQixLQUFLLENBQUMsQ0FBRCxDQUFYO0FBQ0g7O0FBRUQsY0FBUW1nQixVQUFSO0FBQ0ksYUFBSyxNQUFMO0FBQ0loUCxpQkFBTyxDQUFDMUQsT0FBUixHQUFrQjhTLEdBQUcsR0FBR3B6QixVQUFVLENBQUNvekIsR0FBRCxDQUFiLEdBQXFCLENBQTFDO0FBRUE7O0FBQ0osYUFBSyxTQUFMO0FBQ0l6ekIsY0FBSSxDQUFDNHRCLGVBQUwsR0FBdUI2RixHQUFHLEdBQUdwekIsVUFBVSxDQUFDb3pCLEdBQUQsQ0FBYixHQUFxQixHQUEvQyxDQURKLENBR0k7QUFDQTtBQUNBOztBQUVBOztBQUNKO0FBQ0k7QUFFQSxjQUFJRixLQUFLLElBQUl2ekIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQjFDLFVBQS9CLElBQTZDb08sVUFBVSxLQUFLLE9BQWhFLEVBQXlFO0FBQ3JFaFAsbUJBQU8sQ0FBQ2dQLFVBQUQsQ0FBUCxDQUFvQjl6QixLQUFwQixHQUNJLENBQUNrMEIsR0FBRyxHQUFHcHpCLFVBQVUsQ0FBQ296QixHQUFELENBQWIsR0FBcUIvZixRQUFPLENBQUM0WSxpQkFBUixDQUEwQitHLFVBQTFCLEVBQXNDOXpCLEtBQS9ELElBQXdFLENBQUMsQ0FEN0U7QUFFSCxXQUhELE1BR087QUFDSDhrQixtQkFBTyxDQUFDZ1AsVUFBRCxDQUFQLENBQW9COXpCLEtBQXBCLEdBQ0trMEIsR0FBRyxHQUFHcHpCLFVBQVUsQ0FBQ296QixHQUFELENBQWIsR0FBcUIvZixRQUFPLENBQUM0WSxpQkFBUixDQUEwQitHLFVBQTFCLEVBQXNDOXpCLEtBRG5FO0FBRUg7O0FBRUQsY0FBSWswQixHQUFKLEVBQVM7QUFDTCxpQkFBSzcxQixDQUFDLEdBQUcsQ0FBVCxFQUFZd3VCLElBQUksR0FBR3NILEtBQUssQ0FBQzkxQixDQUFELENBQXhCLEVBQTZCQSxDQUFDLEVBQTlCLEVBQWtDO0FBQzlCLGtCQUFJNjFCLEdBQUcsQ0FBQ3RtQixPQUFKLENBQVlpZixJQUFaLElBQW9CLENBQUMsQ0FBekIsRUFBNEI7QUFDeEIvSCx1QkFBTyxDQUFDZ1AsVUFBRCxDQUFQLENBQW9CakgsSUFBcEIsR0FBMkJBLElBQTNCO0FBRUE7QUFDSDtBQUNKO0FBQ0osV0FSRCxNQVFPO0FBQ0gvSCxtQkFBTyxDQUFDZ1AsVUFBRCxDQUFQLENBQW9CakgsSUFBcEIsR0FBMkIxWSxRQUFPLENBQUM0WSxpQkFBUixDQUEwQitHLFVBQTFCLEVBQXNDakgsSUFBakU7QUFDSDs7QUFFRHJlLG1CQUFTLENBQUMxTCxJQUFWLENBQ0lneEIsVUFBVSxHQUNWLEdBREEsR0FFQWhQLE9BQU8sQ0FBQ2dQLFVBQUQsQ0FBUCxDQUFvQjl6QixLQUZwQixHQUdBOGtCLE9BQU8sQ0FBQ2dQLFVBQUQsQ0FBUCxDQUFvQmpILElBSHBCLEdBSUEsR0FMSjtBQXBDUjs7QUE2Q0Fwc0IsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixrQkFBakIsRUFBcUM3WSxTQUFyQztBQUNILEtBaHFDTDs7QUFrcUNJOzs7Ozs7O0FBUUEyeEIsY0FBVSxFQUFFLG9CQUFTdEIsU0FBVCxFQUFvQjtBQUM1QixVQUFJOXVCLElBQUksR0FBVSxJQUFsQjtBQUFBLFVBQ0k2cUIsS0FBSyxHQUFTLElBQUluWCxRQUFPLENBQUNxWixLQUFaLEVBRGxCO0FBQUEsVUFFSXJ2QixNQUFNLEdBQVEsSUFGbEI7QUFBQSxVQUdJRSxDQUFDLEdBQWEsQ0FBQyxDQUhuQjtBQUtBb0MsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixrQkFBakIsRUFBcUM3WSxTQUFyQyxFQU40QixDQVE1QjtBQUNBOztBQUVBLFdBQUtiLENBQUMsR0FBRyxDQUFULEVBQVlGLE1BQU0sR0FBR3NDLElBQUksQ0FBQ29vQixPQUFMLENBQWF4cUIsQ0FBYixDQUFyQixFQUFzQ0EsQ0FBQyxFQUF2QyxFQUEyQztBQUN2QyxZQUFJLENBQUNreEIsU0FBUyxDQUFDZ0QsUUFBVixDQUFtQmowQixNQUFwQixJQUE4Qml4QixTQUFTLENBQUNnRCxRQUFWLENBQW1CM2tCLE9BQW5CLENBQTJCelAsTUFBM0IsSUFBcUMsQ0FBdkUsRUFBMEU7QUFDdEVtdEIsZUFBSyxDQUFDekMsT0FBTixDQUFjL2xCLElBQWQsQ0FBbUIzRSxNQUFNLENBQUNndEIsR0FBUCxDQUFXemUsRUFBOUI7QUFDSDtBQUNKOztBQUVELFdBQUtyTyxDQUFDLEdBQUcsQ0FBVCxFQUFZRixNQUFNLEdBQUdveEIsU0FBUyxDQUFDa0QsUUFBVixDQUFtQnAwQixDQUFuQixDQUFyQixFQUE0Q0EsQ0FBQyxFQUE3QyxFQUFpRDtBQUM3Q2l0QixhQUFLLENBQUNtSCxRQUFOLENBQWUzdkIsSUFBZixDQUFvQjNFLE1BQU0sQ0FBQ2d0QixHQUFQLENBQVd6ZSxFQUEvQjtBQUNIOztBQUVELFdBQUtyTyxDQUFDLEdBQUcsQ0FBVCxFQUFZRixNQUFNLEdBQUdveEIsU0FBUyxDQUFDUyxJQUFWLENBQWUzeEIsQ0FBZixDQUFyQixFQUF3Q0EsQ0FBQyxFQUF6QyxFQUE2QztBQUN6Q2l0QixhQUFLLENBQUMwRSxJQUFOLENBQVdsdEIsSUFBWCxDQUFnQjNFLE1BQU0sQ0FBQ2d0QixHQUFQLENBQVd6ZSxFQUEzQjtBQUNIOztBQUVELFdBQUtyTyxDQUFDLEdBQUcsQ0FBVCxFQUFZRixNQUFNLEdBQUdveEIsU0FBUyxDQUFDUCxJQUFWLENBQWUzd0IsQ0FBZixDQUFyQixFQUF3Q0EsQ0FBQyxFQUF6QyxFQUE2QztBQUN6QyxZQUFJLENBQUNreEIsU0FBUyxDQUFDZ0QsUUFBVixDQUFtQmowQixNQUFwQixJQUE4Qml4QixTQUFTLENBQUNnRCxRQUFWLENBQW1CM2tCLE9BQW5CLENBQTJCelAsTUFBM0IsSUFBcUMsQ0FBdkUsRUFBMEU7QUFDdEVtdEIsZUFBSyxDQUFDMEQsSUFBTixDQUFXbHNCLElBQVgsQ0FBZ0IzRSxNQUFNLENBQUNndEIsR0FBUCxDQUFXemUsRUFBM0I7QUFDSDtBQUNKOztBQUVENGUsV0FBSyxDQUFDdlUsRUFBTixHQUFrQ3RXLElBQUksQ0FBQ3NXLEVBQXZDO0FBQ0F1VSxXQUFLLENBQUMvVSxTQUFOLEdBQWtDOVYsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBUzVVLFNBQTNDO0FBQ0ErVSxXQUFLLENBQUM4RCxZQUFOLEdBQWtDRyxTQUFTLENBQUNtQixTQUE1QztBQUNBcEYsV0FBSyxDQUFDK0QsVUFBTixHQUFrQ0UsU0FBUyxDQUFDYSxPQUE1QztBQUNBOUUsV0FBSyxDQUFDdUUsYUFBTixHQUFrQ04sU0FBUyxDQUFDSyxVQUE1QztBQUNBdEUsV0FBSyxDQUFDbUUsd0JBQU4sR0FBa0NGLFNBQVMsQ0FBQ1EscUJBQTVDO0FBQ0F6RSxXQUFLLENBQUNvSCxTQUFOLEdBQWtDbkQsU0FBUyxDQUFDbUQsU0FBNUM7QUFDQXBILFdBQUssQ0FBQzZFLFlBQU4sR0FBa0MxdkIsSUFBSSxDQUFDb29CLE9BQUwsQ0FBYXZxQixNQUEvQztBQUNBZ3RCLFdBQUssQ0FBQ2dKLFNBQU4sR0FBa0MvRSxTQUFTLENBQUNTLElBQVYsQ0FBZTF4QixNQUFqRDtBQUNBZ3RCLFdBQUssQ0FBQ2lKLFNBQU4sR0FBa0NoRixTQUFTLENBQUNQLElBQVYsQ0FBZTF3QixNQUFqRDtBQUNBZ3RCLFdBQUssQ0FBQ2tKLGFBQU4sR0FBa0NqRixTQUFTLENBQUNrRCxRQUFWLENBQW1CbjBCLE1BQXJEO0FBQ0FndEIsV0FBSyxDQUFDcUMsY0FBTixHQUFrQzRCLFNBQVMsQ0FBQzVCLGNBQTVDO0FBRUEsYUFBT2x0QixJQUFJLENBQUN1aUIsV0FBTCxDQUFpQixpQkFBakIsRUFBb0NzSSxLQUFwQyxFQUEyQ3BzQixTQUEzQyxDQUFQO0FBQ0gsS0F2dENMOztBQXl0Q0k7Ozs7Ozs7O0FBU0F1MUIsU0FBSyxFQUFFLGVBQVNDLGFBQVQsRUFBd0JuRixTQUF4QixFQUFtQztBQUN0QyxVQUFJOXVCLElBQUksR0FBVSxJQUFsQjtBQUFBLFVBQ0l5ZSxRQUFRLEdBQU0sSUFEbEI7QUFHQXplLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsYUFBakIsRUFBZ0M3WSxTQUFoQyxFQUpzQyxDQU10QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUNJLENBQUN1QixJQUFJLENBQUMrVixNQUFMLENBQVk0UixTQUFaLENBQXNCMVosUUFBdkIsSUFBbUMsQ0FBQ2pPLElBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0J0RCxPQUExRCxJQUFxRSxDQUFDMVEsQ0FBQyxDQUFDNE0sU0FBRixDQUFZdmdCLElBQUksQ0FBQzBxQixHQUFMLENBQVM1VSxTQUFyQixDQUQxRSxFQUVFO0FBQ0VtZSxxQkFBYSxHQUFHLEtBQWhCO0FBQ0g7O0FBRUQsVUFDSSxDQUFDbkYsU0FBUyxDQUFDaUQsTUFBVixDQUFpQmwwQixNQUFsQixJQUNBLENBQUNpeEIsU0FBUyxDQUFDUixNQUFWLENBQWlCendCLE1BRGxCLElBRUEsQ0FBQ2l4QixTQUFTLENBQUN3RCxRQUZYLElBR0EsQ0FBQ3hELFNBQVMsQ0FBQ29GLGdCQUpmLEVBS0U7QUFDRTtBQUNBO0FBRUFELHFCQUFhLEdBQUcsS0FBaEI7QUFDSDs7QUFFRCxVQUNJLENBQUNuRixTQUFTLENBQUNxRixVQUFWLENBQXFCNUUsSUFBckIsQ0FBMEIxeEIsTUFBM0IsSUFDQSxDQUFDaXhCLFNBQVMsQ0FBQ1MsSUFBVixDQUFlMXhCLE1BRnBCLEVBR0U7QUFDRTtBQUVBbzJCLHFCQUFhLEdBQUcsS0FBaEI7QUFDSDs7QUFFRHZnQixjQUFPLENBQUMxUyxNQUFSLENBQWU0cEIsSUFBZixDQUFvQixVQUFwQixFQUFnQzVxQixJQUFJLENBQUMwcUIsR0FBTCxDQUFTNVUsU0FBekMsRUFBb0Q7QUFDaEQrVSxhQUFLLEVBQUVpRSxTQUFTLENBQUNxRixVQUQrQjtBQUVoRDNILG1CQUFXLEVBQUVzQyxTQUFTLENBQUNzRixRQUZ5QjtBQUdoRC8yQixnQkFBUSxFQUFFMkM7QUFIc0MsT0FBcEQsRUFJR0EsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBUzNoQixRQUpaOztBQU1BLFVBQUksT0FBTy9JLElBQUksQ0FBQytWLE1BQUwsQ0FBWThSLFNBQVosQ0FBc0JyQyxVQUE3QixLQUE0QyxVQUFoRCxFQUE0RDtBQUN4RHhsQixZQUFJLENBQUMrVixNQUFMLENBQVk4UixTQUFaLENBQXNCckMsVUFBdEIsQ0FBaUM1bUIsSUFBakMsQ0FDSW9CLElBQUksQ0FBQzBxQixHQUFMLENBQVM1VSxTQURiLEVBRUlnWixTQUFTLENBQUNxRixVQUZkLEVBR0lyRixTQUFTLENBQUNzRixRQUhkLEVBSUlwMEIsSUFKSjtBQU1IOztBQUVEMlQsT0FBQyxDQUFDekcsV0FBRixDQUFjbE4sSUFBSSxDQUFDMHFCLEdBQUwsQ0FBUzVVLFNBQXZCLEVBQWtDbkMsQ0FBQyxDQUFDMk4sWUFBRixDQUFldGhCLElBQUksQ0FBQytWLE1BQUwsQ0FBWXdMLFVBQTNCLEVBQXVDLFdBQXZDLEVBQW9EdmhCLElBQUksQ0FBQytWLE1BQUwsQ0FBWXdMLFVBQVosQ0FBdUJtRixjQUEzRSxDQUFsQzs7QUFFQSxVQUFJLENBQUMxbUIsSUFBSSxDQUFDaXVCLFlBQVYsRUFBd0I7QUFDcEI7QUFFQXhQLGdCQUFRLEdBQUd6ZSxJQUFJLENBQUNpdUIsWUFBTCxHQUFvQnRhLENBQUMsQ0FBQzZLLEtBQUYsQ0FBUTlLLFFBQU8sQ0FBQ2lFLFNBQWhCLENBQS9CO0FBQ0gsT0FKRCxNQUlPO0FBQ0g7QUFFQThHLGdCQUFRLEdBQUd6ZSxJQUFJLENBQUNpdUIsWUFBaEI7QUFDSDs7QUFFRGp1QixVQUFJLENBQUNvdEIsTUFBTCxHQUFjLElBQWQ7O0FBRUEsVUFBSSxDQUFDNkcsYUFBRCxJQUFrQixDQUFDdmdCLFFBQU8sQ0FBQ2tMLFFBQVIsQ0FBaUJDLEdBQWpCLENBQXFCcUYsV0FBNUMsRUFBeUQ7QUFDckQ7QUFFQSxZQUFJbGtCLElBQUksQ0FBQytWLE1BQUwsQ0FBWWUsS0FBWixDQUFrQmlRLFNBQXRCLEVBQWlDO0FBQzdCamdCLG9CQUFVLENBQUMsWUFBVztBQUNsQjlHLGdCQUFJLENBQUNxMEIsT0FBTCxDQUFhdkYsU0FBYjtBQUNILFdBRlMsRUFFUDl1QixJQUFJLENBQUMrVixNQUFMLENBQVk0UixTQUFaLENBQXNCMVosUUFGZixDQUFWO0FBR0gsU0FKRCxNQUlPO0FBQ0hqTyxjQUFJLENBQUNxMEIsT0FBTCxDQUFhdkYsU0FBYjtBQUNIOztBQUVELGVBQU85dUIsSUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIsY0FBakIsRUFBaUM5RCxRQUFRLENBQUNNLE9BQTFDLEVBQW1EdGdCLFNBQW5ELENBQVA7QUFDSCxPQS9FcUMsQ0FpRnRDOzs7QUFFQSxVQUFJMEosTUFBTSxDQUFDeVgsV0FBUCxLQUF1QmtQLFNBQVMsQ0FBQ3dGLFFBQVYsQ0FBbUI1WCxTQUE5QyxFQUF5RDtBQUNyRHZVLGNBQU0sQ0FBQ29zQixRQUFQLENBQWdCekYsU0FBUyxDQUFDd0YsUUFBVixDQUFtQjdYLFVBQW5DLEVBQStDcVMsU0FBUyxDQUFDd0YsUUFBVixDQUFtQjVYLFNBQWxFO0FBQ0g7O0FBRUQsVUFBSTFjLElBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0JsRCxnQkFBMUIsRUFBNEM7QUFDeEN6a0IsWUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3JyQixNQUFULENBQWdCOEgsS0FBaEIsQ0FBc0J1TSxRQUFPLENBQUNrTCxRQUFSLENBQWlCMEUsZUFBdkMsSUFDSXRqQixJQUFJLENBQUMrVixNQUFMLENBQVk0UixTQUFaLENBQXNCakQsbUJBRDFCO0FBR0Exa0IsWUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3JyQixNQUFULENBQWdCOEgsS0FBaEIsQ0FBc0J1TSxRQUFPLENBQUNrTCxRQUFSLENBQWlCMkUscUJBQXZDLElBQ0l2akIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQmhELGlCQUQxQjtBQUVIOztBQUVELFVBQ0kza0IsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQjdDLHNCQUF0QixJQUNBZ0ssU0FBUyxDQUFDMEYsV0FBVixLQUEwQjFGLFNBQVMsQ0FBQzJGLFNBRHBDLElBRUEzRixTQUFTLENBQUM0RixjQUFWLEtBQTZCNUYsU0FBUyxDQUFDMEYsV0FBVixHQUF3QjFGLFNBQVMsQ0FBQzJGLFNBSG5FLEVBSUU7QUFDRXowQixZQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0I4SCxLQUFoQixDQUFzQnNXLE1BQXRCLEdBQStCcVIsU0FBUyxDQUFDMEYsV0FBVixHQUF3QixJQUF2RDtBQUNIOztBQUVELFVBQ0l4MEIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQjdDLHNCQUF0QixJQUNBZ0ssU0FBUyxDQUFDNkYsVUFBVixLQUF5QjdGLFNBQVMsQ0FBQzhGLFFBRG5DLElBRUE5RixTQUFTLENBQUMrRixjQUFWLEtBQTZCL0YsU0FBUyxDQUFDNkYsVUFBVixHQUF1QjdGLFNBQVMsQ0FBQzhGLFFBSGxFLEVBSUU7QUFDRTUwQixZQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0I4SCxLQUFoQixDQUFzQnVDLEtBQXRCLEdBQThCb2xCLFNBQVMsQ0FBQzZGLFVBQVYsR0FBdUIsSUFBckQ7QUFDSDs7QUFFRCxVQUFJN0YsU0FBUyxDQUFDMEYsV0FBVixLQUEwQjFGLFNBQVMsQ0FBQzJGLFNBQXhDLEVBQW1EO0FBQy9DejBCLFlBQUksQ0FBQzBxQixHQUFMLENBQVNyckIsTUFBVCxDQUFnQjhILEtBQWhCLENBQXNCc1csTUFBdEIsR0FBK0JxUixTQUFTLENBQUMwRixXQUFWLEdBQXdCLElBQXZEO0FBQ0g7O0FBRUQsVUFBSTFGLFNBQVMsQ0FBQzZGLFVBQVYsS0FBeUI3RixTQUFTLENBQUM4RixRQUF2QyxFQUFpRDtBQUM3QzUwQixZQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0I4SCxLQUFoQixDQUFzQnVDLEtBQXRCLEdBQThCb2xCLFNBQVMsQ0FBQzZGLFVBQVYsR0FBdUIsSUFBckQ7QUFDSDs7QUFFRCxVQUFJN0YsU0FBUyxDQUFDMEYsV0FBVixLQUEwQjFGLFNBQVMsQ0FBQzJGLFNBQXBDLElBQWlEM0YsU0FBUyxDQUFDNkYsVUFBVixLQUF5QjdGLFNBQVMsQ0FBQzhGLFFBQXhGLEVBQWtHO0FBQzlGNTBCLFlBQUksQ0FBQzBxQixHQUFMLENBQVNyckIsTUFBVCxDQUFnQjhILEtBQWhCLENBQXNCMnRCLFFBQXRCLEdBQWlDLFFBQWpDO0FBQ0g7O0FBRUQvZ0IsMkJBQXFCLENBQUMsWUFBVztBQUM3Qi9ULFlBQUksQ0FBQyswQixXQUFMLENBQWlCakcsU0FBakI7QUFDSCxPQUZvQixDQUFyQjtBQUlBLGFBQU85dUIsSUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIsY0FBakIsRUFBaUM5RCxRQUFRLENBQUNNLE9BQTFDLEVBQW1EdGdCLFNBQW5ELENBQVA7QUFDSCxLQWwyQ0w7O0FBbzJDSTs7Ozs7OztBQVFBdTJCLG1CQUFlLEVBQUUseUJBQVNsRyxTQUFULEVBQW9CO0FBQ2pDLFVBQUk5dUIsSUFBSSxHQUFVLElBQWxCO0FBQUEsVUFDSWkxQixXQUFXLEdBQUc5c0IsTUFBTSxDQUFDc1ksZ0JBQVAsQ0FBd0J6Z0IsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3JyQixNQUFqQyxDQURsQjtBQUFBLFVBRUk2MUIsVUFBVSxHQUFJbDFCLElBQUksQ0FBQzBxQixHQUFMLENBQVNyckIsTUFBVCxDQUFnQjgxQixxQkFBaEIsRUFGbEI7QUFBQSxVQUdJejNCLE1BQU0sR0FBUSxJQUhsQjtBQUFBLFVBSUkyYixJQUFJLEdBQVUsRUFKbEI7QUFBQSxVQUtJemIsQ0FBQyxHQUFhLENBQUMsQ0FMbkI7QUFBQSxVQU1JdzNCLFNBQVMsR0FBS0gsV0FBVyxDQUFDdmhCLFFBQU8sQ0FBQ2tMLFFBQVIsQ0FBaUJ1RixhQUFsQixDQU43QjtBQVFBbmtCLFVBQUksQ0FBQ3F0QixVQUFMLEdBQW1CK0gsU0FBUyxLQUFLLFlBQWpDO0FBRUFwMUIsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQix1QkFBakIsRUFBMEM3WSxTQUExQzs7QUFFQSxXQUFLYixDQUFDLEdBQUcsQ0FBVCxFQUFZRixNQUFNLEdBQUdveEIsU0FBUyxDQUFDUyxJQUFWLENBQWUzeEIsQ0FBZixDQUFyQixFQUF3Q0EsQ0FBQyxFQUF6QyxFQUE2QztBQUN6Q3liLFlBQUksR0FBRzNiLE1BQU0sQ0FBQzIzQixVQUFQLEVBQVA7QUFFQXZHLGlCQUFTLENBQUN3RyxXQUFWLENBQXNCMTNCLENBQXRCLElBQTJCO0FBQ3ZCMjNCLHNCQUFZLEVBQUVsYztBQURTLFNBQTNCO0FBR0g7O0FBRUQsV0FBS3piLENBQUMsR0FBRyxDQUFULEVBQVlGLE1BQU0sR0FBR294QixTQUFTLENBQUNSLE1BQVYsQ0FBaUIxd0IsQ0FBakIsQ0FBckIsRUFBMENBLENBQUMsRUFBM0MsRUFBK0M7QUFDM0N5YixZQUFJLEdBQUczYixNQUFNLENBQUMyM0IsVUFBUCxFQUFQO0FBRUF2RyxpQkFBUyxDQUFDMEcsYUFBVixDQUF3QjUzQixDQUF4QixJQUE2QjtBQUN6QjIzQixzQkFBWSxFQUFFbGM7QUFEVyxTQUE3QjtBQUdIOztBQUVEeVYsZUFBUyxDQUFDMkcsTUFBVixHQUFtQlAsVUFBVSxDQUFDcFgsSUFBOUI7QUFDQWdSLGVBQVMsQ0FBQzRHLE1BQVYsR0FBbUJSLFVBQVUsQ0FBQ25YLEdBQTlCO0FBRUErUSxlQUFTLENBQUMwRixXQUFWLEdBQXdCeDBCLElBQUksQ0FBQ3F0QixVQUFMLEdBQ3BCNkgsVUFBVSxDQUFDelgsTUFEUyxHQUVwQnlYLFVBQVUsQ0FBQ3pYLE1BQVgsR0FDSXBkLFVBQVUsQ0FBQzQwQixXQUFXLENBQUNVLFVBQWIsQ0FEZCxHQUVJdDFCLFVBQVUsQ0FBQzQwQixXQUFXLENBQUNXLGFBQWIsQ0FGZCxHQUdJdjFCLFVBQVUsQ0FBQzQwQixXQUFXLENBQUNZLFNBQWIsQ0FIZCxHQUlJeDFCLFVBQVUsQ0FBQzQwQixXQUFXLENBQUNhLFlBQWIsQ0FObEI7QUFRQWhILGVBQVMsQ0FBQzZGLFVBQVYsR0FBdUIzMEIsSUFBSSxDQUFDcXRCLFVBQUwsR0FDbkI2SCxVQUFVLENBQUN4ckIsS0FEUSxHQUVuQndyQixVQUFVLENBQUN4ckIsS0FBWCxHQUNJckosVUFBVSxDQUFDNDBCLFdBQVcsQ0FBQ2MsV0FBYixDQURkLEdBRUkxMUIsVUFBVSxDQUFDNDBCLFdBQVcsQ0FBQ2UsWUFBYixDQUZkLEdBR0kzMUIsVUFBVSxDQUFDNDBCLFdBQVcsQ0FBQ2dCLFVBQWIsQ0FIZCxHQUlJNTFCLFVBQVUsQ0FBQzQwQixXQUFXLENBQUNpQixXQUFiLENBTmxCO0FBUUFsMkIsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixzQkFBakIsRUFBeUM3WSxTQUF6QztBQUNILEtBNzVDTDs7QUErNUNJOzs7Ozs7O0FBUUEwM0IsWUFBUSxFQUFFLGtCQUFTckgsU0FBVCxFQUFvQjtBQUMxQixVQUFJOXVCLElBQUksR0FBTSxJQUFkO0FBQUEsVUFDSXRDLE1BQU0sR0FBSSxJQURkO0FBQUEsVUFFSUUsQ0FBQyxHQUFTLENBQUMsQ0FGZjtBQUlBb0MsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixnQkFBakIsRUFBbUM3WSxTQUFuQyxFQUwwQixDQU8xQjs7QUFFQSxVQUFJdUIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQnhDLFdBQTFCLEVBQXVDO0FBQ25DbmxCLFlBQUksQ0FBQzBxQixHQUFMLENBQVNyckIsTUFBVCxDQUFnQjhILEtBQWhCLENBQXNCc1csTUFBdEIsR0FBa0NxUixTQUFTLENBQUMwRixXQUFWLEdBQXdCLElBQTFEO0FBQ0F4MEIsWUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3JyQixNQUFULENBQWdCOEgsS0FBaEIsQ0FBc0IydEIsUUFBdEIsR0FBa0MsUUFBbEM7QUFDSDs7QUFFRCxVQUFJOTBCLElBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0J2QyxVQUExQixFQUFzQztBQUNsQ3BsQixZQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0I4SCxLQUFoQixDQUFzQnVDLEtBQXRCLEdBQWtDb2xCLFNBQVMsQ0FBQzZGLFVBQVYsR0FBdUIsSUFBekQ7QUFDQTMwQixZQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0I4SCxLQUFoQixDQUFzQjJ0QixRQUF0QixHQUFrQyxRQUFsQztBQUNIOztBQUVELFdBQUtsM0IsQ0FBQyxHQUFHLENBQVQsRUFBWUYsTUFBTSxHQUFHb3hCLFNBQVMsQ0FBQ2lELE1BQVYsQ0FBaUJuMEIsQ0FBakIsQ0FBckIsRUFBMENBLENBQUMsRUFBM0MsRUFBK0M7QUFDM0NGLGNBQU0sQ0FBQzZ4QixJQUFQO0FBQ0g7O0FBRUQsVUFBSVQsU0FBUyxDQUFDb0YsZ0JBQWQsRUFBZ0M7QUFDNUJ2Z0IsU0FBQyxDQUFDekcsV0FBRixDQUFjbE4sSUFBSSxDQUFDMHFCLEdBQUwsQ0FBUzVVLFNBQXZCLEVBQWtDZ1osU0FBUyxDQUFDTyx1QkFBNUM7QUFDQTFiLFNBQUMsQ0FBQzFHLFFBQUYsQ0FBV2pOLElBQUksQ0FBQzBxQixHQUFMLENBQVM1VSxTQUFwQixFQUErQmdaLFNBQVMsQ0FBQ1EscUJBQXpDO0FBQ0g7O0FBRUR0dkIsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixlQUFqQixFQUFrQzdZLFNBQWxDO0FBQ0gsS0FwOENMOztBQXM4Q0k7Ozs7Ozs7QUFRQTIzQixtQkFBZSxFQUFFLHlCQUFTdEgsU0FBVCxFQUFvQjtBQUNqQyxVQUFJOXVCLElBQUksR0FBTSxJQUFkO0FBQUEsVUFDSXRDLE1BQU0sR0FBSSxJQURkO0FBQUEsVUFFSUUsQ0FBQyxHQUFTLENBQUMsQ0FGZjtBQUlBb0MsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQix1QkFBakIsRUFBMEM3WSxTQUExQzs7QUFFQSxXQUFLYixDQUFDLEdBQUcsQ0FBVCxFQUFZRixNQUFNLEdBQUdveEIsU0FBUyxDQUFDUyxJQUFWLENBQWUzeEIsQ0FBZixDQUFyQixFQUF3Q0EsQ0FBQyxFQUF6QyxFQUE2QztBQUN6Q2t4QixpQkFBUyxDQUFDd0csV0FBVixDQUFzQjEzQixDQUF0QixFQUF5Qnk0QixZQUF6QixHQUF3QzM0QixNQUFNLENBQUMyM0IsVUFBUCxFQUF4QztBQUNIOztBQUVELFdBQUt6M0IsQ0FBQyxHQUFHLENBQVQsRUFBWUYsTUFBTSxHQUFHb3hCLFNBQVMsQ0FBQ1IsTUFBVixDQUFpQjF3QixDQUFqQixDQUFyQixFQUEwQ0EsQ0FBQyxFQUEzQyxFQUErQztBQUMzQ2t4QixpQkFBUyxDQUFDMEcsYUFBVixDQUF3QjUzQixDQUF4QixFQUEyQnk0QixZQUEzQixHQUEwQzM0QixNQUFNLENBQUMyM0IsVUFBUCxFQUExQztBQUNIOztBQUVEcjFCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsc0JBQWpCLEVBQXlDN1ksU0FBekM7QUFDSCxLQTk5Q0w7O0FBZytDSTs7Ozs7OztBQVFBNjNCLFlBQVEsRUFBRSxrQkFBU3hILFNBQVQsRUFBb0I7QUFDMUIsVUFBSTl1QixJQUFJLEdBQU0sSUFBZDtBQUFBLFVBQ0l0QyxNQUFNLEdBQUksSUFEZDtBQUFBLFVBRUlFLENBQUMsR0FBUyxDQUFDLENBRmY7QUFJQW9DLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsZ0JBQWpCLEVBQW1DN1ksU0FBbkM7QUFFQXF3QixlQUFTLENBQUN3RCxRQUFWLElBQXNCdHlCLElBQUksQ0FBQzZ2QixTQUFMLENBQWUsS0FBZixFQUFzQmYsU0FBdEIsQ0FBdEI7O0FBRUEsV0FBS2x4QixDQUFDLEdBQUcsQ0FBVCxFQUFZRixNQUFNLEdBQUdveEIsU0FBUyxDQUFDUixNQUFWLENBQWlCMXdCLENBQWpCLENBQXJCLEVBQTBDQSxDQUFDLEVBQTNDLEVBQStDO0FBQzNDRixjQUFNLENBQUM2d0IsSUFBUDtBQUNIOztBQUVEdnVCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsZUFBakIsRUFBa0M3WSxTQUFsQztBQUNILEtBdC9DTDs7QUF3L0NJOzs7Ozs7O0FBUUE4M0IsbUJBQWUsRUFBRSx5QkFBU3pILFNBQVQsRUFBb0I7QUFDakMsVUFBSTl1QixJQUFJLEdBQVUsSUFBbEI7QUFBQSxVQUNJaTFCLFdBQVcsR0FBRyxJQURsQjtBQUFBLFVBRUlDLFVBQVUsR0FBSSxJQUZsQjtBQUFBLFVBR0l4M0IsTUFBTSxHQUFRLElBSGxCO0FBQUEsVUFJSUUsQ0FBQyxHQUFhLENBQUMsQ0FKbkI7QUFNQW9DLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsdUJBQWpCLEVBQTBDN1ksU0FBMUM7O0FBRUEsV0FBS2IsQ0FBQyxHQUFHLENBQVQsRUFBWUYsTUFBTSxHQUFHb3hCLFNBQVMsQ0FBQ1MsSUFBVixDQUFlM3hCLENBQWYsQ0FBckIsRUFBd0NBLENBQUMsRUFBekMsRUFBNkM7QUFDekNreEIsaUJBQVMsQ0FBQ3dHLFdBQVYsQ0FBc0IxM0IsQ0FBdEIsRUFBeUI0NEIsWUFBekIsR0FBd0M5NEIsTUFBTSxDQUFDMjNCLFVBQVAsRUFBeEM7QUFDSDs7QUFFRCxXQUFLejNCLENBQUMsR0FBRyxDQUFULEVBQVlGLE1BQU0sR0FBR294QixTQUFTLENBQUNSLE1BQVYsQ0FBaUIxd0IsQ0FBakIsQ0FBckIsRUFBMENBLENBQUMsRUFBM0MsRUFBK0M7QUFDM0NreEIsaUJBQVMsQ0FBQzBHLGFBQVYsQ0FBd0I1M0IsQ0FBeEIsRUFBMkI0NEIsWUFBM0IsR0FBMEM5NEIsTUFBTSxDQUFDMjNCLFVBQVAsRUFBMUM7QUFDSCxPQWZnQyxDQWlCakM7OztBQUVBLFVBQUlyMUIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQnhDLFdBQXRCLElBQXFDbmxCLElBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0J2QyxVQUEvRCxFQUEyRTtBQUN2RXBsQixZQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0I4SCxLQUFoQixDQUFzQnNXLE1BQXRCLEdBQ0F6ZCxJQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0I4SCxLQUFoQixDQUFzQnVDLEtBQXRCLEdBQ0ExSixJQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0I4SCxLQUFoQixDQUFzQjJ0QixRQUF0QixHQUFrQyxFQUZsQztBQUdIOztBQUVELFVBQUksQ0FBQzkwQixJQUFJLENBQUNxdEIsVUFBVixFQUFzQjtBQUNsQjRILG1CQUFXLEdBQUc5c0IsTUFBTSxDQUFDc1ksZ0JBQVAsQ0FBd0J6Z0IsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3JyQixNQUFqQyxDQUFkO0FBQ0g7O0FBRUQ2MUIsZ0JBQVUsR0FBSWwxQixJQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0I4MUIscUJBQWhCLEVBQWQ7QUFFQXJHLGVBQVMsQ0FBQzJILElBQVYsR0FBaUJ2QixVQUFVLENBQUNwWCxJQUE1QjtBQUNBZ1IsZUFBUyxDQUFDNEgsSUFBVixHQUFpQnhCLFVBQVUsQ0FBQ25YLEdBQTVCO0FBRUErUSxlQUFTLENBQUMyRixTQUFWLEdBQXNCejBCLElBQUksQ0FBQ3F0QixVQUFMLEdBQ2xCNkgsVUFBVSxDQUFDelgsTUFETyxHQUVsQnlYLFVBQVUsQ0FBQ3pYLE1BQVgsR0FDSXBkLFVBQVUsQ0FBQzQwQixXQUFXLENBQUNVLFVBQWIsQ0FEZCxHQUVJdDFCLFVBQVUsQ0FBQzQwQixXQUFXLENBQUNXLGFBQWIsQ0FGZCxHQUdJdjFCLFVBQVUsQ0FBQzQwQixXQUFXLENBQUNZLFNBQWIsQ0FIZCxHQUlJeDFCLFVBQVUsQ0FBQzQwQixXQUFXLENBQUNhLFlBQWIsQ0FObEI7QUFRQWhILGVBQVMsQ0FBQzhGLFFBQVYsR0FBcUI1MEIsSUFBSSxDQUFDcXRCLFVBQUwsR0FDakI2SCxVQUFVLENBQUN4ckIsS0FETSxHQUVqQndyQixVQUFVLENBQUN4ckIsS0FBWCxHQUNJckosVUFBVSxDQUFDNDBCLFdBQVcsQ0FBQ2MsV0FBYixDQURkLEdBRUkxMUIsVUFBVSxDQUFDNDBCLFdBQVcsQ0FBQ2UsWUFBYixDQUZkLEdBR0kzMUIsVUFBVSxDQUFDNDBCLFdBQVcsQ0FBQ2dCLFVBQWIsQ0FIZCxHQUlJNTFCLFVBQVUsQ0FBQzQwQixXQUFXLENBQUNpQixXQUFiLENBTmxCO0FBUUFwSCxlQUFTLENBQUMrRixjQUFWLEdBQTJCL0YsU0FBUyxDQUFDd0YsUUFBVixDQUFtQmpVLGFBQW5CLEdBQW1DLEtBQUtxSyxHQUFMLENBQVMzaEIsUUFBVCxDQUFrQmdYLGVBQWxCLENBQWtDTyxXQUFoRztBQUNBd08sZUFBUyxDQUFDNEYsY0FBVixHQUEyQjVGLFNBQVMsQ0FBQ3dGLFFBQVYsQ0FBbUJuVSxjQUFuQixHQUFvQyxLQUFLdUssR0FBTCxDQUFTM2hCLFFBQVQsQ0FBa0JnWCxlQUFsQixDQUFrQ0ssWUFBakc7O0FBRUEsVUFBSTBPLFNBQVMsQ0FBQ3dELFFBQWQsRUFBd0I7QUFDcEJ0eUIsWUFBSSxDQUFDNnZCLFNBQUwsQ0FBZSxJQUFmLEVBQXFCZixTQUFyQjtBQUNIOztBQUVELFdBQUtseEIsQ0FBQyxHQUFHLENBQVQsRUFBWUYsTUFBTSxHQUFHb3hCLFNBQVMsQ0FBQ2lELE1BQVYsQ0FBaUJuMEIsQ0FBakIsQ0FBckIsRUFBMENBLENBQUMsRUFBM0MsRUFBK0M7QUFDM0NGLGNBQU0sQ0FBQzZ3QixJQUFQO0FBQ0g7O0FBRUQsV0FBSzN3QixDQUFDLEdBQUcsQ0FBVCxFQUFZRixNQUFNLEdBQUdveEIsU0FBUyxDQUFDUixNQUFWLENBQWlCMXdCLENBQWpCLENBQXJCLEVBQTBDQSxDQUFDLEVBQTNDLEVBQStDO0FBQzNDRixjQUFNLENBQUM2eEIsSUFBUDtBQUNIOztBQUVELFVBQUlULFNBQVMsQ0FBQ29GLGdCQUFkLEVBQWdDO0FBQzVCdmdCLFNBQUMsQ0FBQ3pHLFdBQUYsQ0FBY2xOLElBQUksQ0FBQzBxQixHQUFMLENBQVM1VSxTQUF2QixFQUFrQ2daLFNBQVMsQ0FBQ1EscUJBQTVDO0FBQ0EzYixTQUFDLENBQUMxRyxRQUFGLENBQVdqTixJQUFJLENBQUMwcUIsR0FBTCxDQUFTNVUsU0FBcEIsRUFBK0I5VixJQUFJLENBQUMrVixNQUFMLENBQVkrUixNQUFaLENBQW1CWixrQkFBbEQ7QUFDSDs7QUFFRGxuQixVQUFJLENBQUNzWCxXQUFMLENBQWlCLHNCQUFqQixFQUF5QzdZLFNBQXpDO0FBQ0gsS0F2a0RMOztBQXlrREk7Ozs7OztBQU9BazRCLGdCQUFZLEVBQUUsc0JBQVM3SCxTQUFULEVBQW9CO0FBQzlCLFVBQUk5dUIsSUFBSSxHQUFjLElBQXRCO0FBQUEsVUFDSXRDLE1BQU0sR0FBWSxJQUR0QjtBQUFBLFVBRUlrNUIsT0FBTyxHQUFXLElBRnRCO0FBQUEsVUFHSUMsV0FBVyxHQUFPMzRCLE1BQU0sQ0FBQzQ0QixtQkFBUCxDQUEyQjkyQixJQUFJLENBQUNza0IsU0FBaEMsQ0FIdEI7QUFBQSxVQUlJK08sVUFBVSxHQUFRLEVBSnRCO0FBQUEsVUFLSTBELE1BQU0sR0FBWSxJQUx0QjtBQUFBLFVBTUlDLFdBQVcsR0FBTyxDQUFDLENBTnZCO0FBQUEsVUFPSUMsWUFBWSxHQUFNLENBQUMsQ0FQdkI7QUFBQSxVQVFJcjVCLENBQUMsR0FBaUIsQ0FBQyxDQVJ2QjtBQUFBLFVBU0k4eUIsQ0FBQyxHQUFpQixDQUFDLENBVHZCO0FBV0Exd0IsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixvQkFBakIsRUFBdUM3WSxTQUF2Qzs7QUFFQSxXQUFLYixDQUFDLEdBQUcsQ0FBVCxFQUFZRixNQUFNLEdBQUdveEIsU0FBUyxDQUFDUyxJQUFWLENBQWUzeEIsQ0FBZixDQUFyQixFQUF3Q0EsQ0FBQyxFQUF6QyxFQUE2QztBQUN6Q2c1QixlQUFPLEdBQWU5SCxTQUFTLENBQUN3RyxXQUFWLENBQXNCMTNCLENBQXRCLENBQXRCO0FBQ0FnNUIsZUFBTyxDQUFDTSxLQUFSLEdBQXNCLElBQUl4akIsUUFBTyxDQUFDOFgsU0FBWixFQUF0QjtBQUNBb0wsZUFBTyxDQUFDTyxNQUFSLEdBQXNCLElBQUl6akIsUUFBTyxDQUFDOFgsU0FBWixFQUF0QjtBQUNBb0wsZUFBTyxDQUFDUSxTQUFSLEdBQXNCLElBQUkxakIsUUFBTyxDQUFDOFgsU0FBWixFQUF0QixDQUp5QyxDQU16Qzs7QUFFQSxZQUFJOXRCLE1BQU0sQ0FBQ3kwQixPQUFYLEVBQW9CO0FBQ2hCeUUsaUJBQU8sQ0FBQ00sS0FBUixDQUFjcmEsQ0FBZCxHQUFrQitaLE9BQU8sQ0FBQ3JCLFlBQVIsQ0FBcUIxWSxDQUFyQixHQUF5QitaLE9BQU8sQ0FBQ1AsWUFBUixDQUFxQnhaLENBQWhFO0FBQ0ErWixpQkFBTyxDQUFDTSxLQUFSLENBQWNwYSxDQUFkLEdBQWtCOFosT0FBTyxDQUFDckIsWUFBUixDQUFxQnpZLENBQXJCLEdBQXlCOFosT0FBTyxDQUFDUCxZQUFSLENBQXFCdlosQ0FBaEU7QUFDSCxTQUhELE1BR087QUFDSDhaLGlCQUFPLENBQUNNLEtBQVIsQ0FBY3JhLENBQWQsR0FBa0IrWixPQUFPLENBQUNNLEtBQVIsQ0FBY3BhLENBQWQsR0FBa0IsQ0FBcEM7QUFDSDs7QUFFRDhaLGVBQU8sQ0FBQ08sTUFBUixDQUFldGEsQ0FBZixHQUFtQitaLE9BQU8sQ0FBQ0osWUFBUixDQUFxQjNaLENBQXJCLEdBQXlCK1osT0FBTyxDQUFDUCxZQUFSLENBQXFCeFosQ0FBakU7QUFDQStaLGVBQU8sQ0FBQ08sTUFBUixDQUFlcmEsQ0FBZixHQUFtQjhaLE9BQU8sQ0FBQ0osWUFBUixDQUFxQjFaLENBQXJCLEdBQXlCOFosT0FBTyxDQUFDUCxZQUFSLENBQXFCdlosQ0FBakUsQ0FoQnlDLENBa0J6Qzs7QUFFQThaLGVBQU8sQ0FBQ00sS0FBUixDQUFjdlcsT0FBZCxHQUE4QmpqQixNQUFNLENBQUN5MEIsT0FBUCxHQUFpQixDQUFqQixHQUFxQm55QixJQUFJLENBQUNza0IsU0FBTCxDQUFlM0QsT0FBbEU7QUFDQWlXLGVBQU8sQ0FBQ08sTUFBUixDQUFleFcsT0FBZixHQUE4QixDQUE5QjtBQUNBaVcsZUFBTyxDQUFDUSxTQUFSLENBQWtCelcsT0FBbEIsR0FBOEJpVyxPQUFPLENBQUNPLE1BQVIsQ0FBZXhXLE9BQWYsR0FBeUJpVyxPQUFPLENBQUNNLEtBQVIsQ0FBY3ZXLE9BQXJFLENBdEJ5QyxDQXdCekM7O0FBRUEsWUFBSSxDQUFDampCLE1BQU0sQ0FBQ3kwQixPQUFSLElBQW1CLENBQUNueUIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQnpDLEtBQTlDLEVBQXFEO0FBQ2pEMFIsaUJBQU8sQ0FBQ00sS0FBUixDQUFjcmEsQ0FBZCxHQUFrQitaLE9BQU8sQ0FBQ08sTUFBUixDQUFldGEsQ0FBakM7QUFDQStaLGlCQUFPLENBQUNNLEtBQVIsQ0FBY3BhLENBQWQsR0FBa0I4WixPQUFPLENBQUNPLE1BQVIsQ0FBZXJhLENBQWpDO0FBQ0g7O0FBRUQ4WixlQUFPLENBQUNRLFNBQVIsQ0FBa0J2YSxDQUFsQixHQUFzQitaLE9BQU8sQ0FBQ08sTUFBUixDQUFldGEsQ0FBZixHQUFtQitaLE9BQU8sQ0FBQ00sS0FBUixDQUFjcmEsQ0FBdkQ7QUFDQStaLGVBQU8sQ0FBQ1EsU0FBUixDQUFrQnRhLENBQWxCLEdBQXNCOFosT0FBTyxDQUFDTyxNQUFSLENBQWVyYSxDQUFmLEdBQW1COFosT0FBTyxDQUFDTSxLQUFSLENBQWNwYSxDQUF2RCxDQWhDeUMsQ0FrQ3pDOztBQUVBLFlBQUk5YyxJQUFJLENBQUMrVixNQUFMLENBQVk0UixTQUFaLENBQXNCNUMsb0JBQTFCLEVBQWdEO0FBQzVDNlIsaUJBQU8sQ0FBQ00sS0FBUixDQUFjeHRCLEtBQWQsR0FBMEJrdEIsT0FBTyxDQUFDckIsWUFBUixDQUFxQjdyQixLQUEvQztBQUNBa3RCLGlCQUFPLENBQUNNLEtBQVIsQ0FBY3paLE1BQWQsR0FBMEJtWixPQUFPLENBQUNyQixZQUFSLENBQXFCOVgsTUFBL0MsQ0FGNEMsQ0FJNUM7O0FBRUF1WixxQkFBVyxHQUFHLENBQUNKLE9BQU8sQ0FBQ3JCLFlBQVIsQ0FBcUI3ckIsS0FBckIsSUFBOEJrdEIsT0FBTyxDQUFDSixZQUFSLENBQXFCOXNCLEtBQXBELElBQTZEa3RCLE9BQU8sQ0FBQ1AsWUFBUixDQUFxQjNzQixLQUFoRztBQUVBa3RCLGlCQUFPLENBQUNNLEtBQVIsQ0FBYzV2QixXQUFkLEdBQTRCc3ZCLE9BQU8sQ0FBQ3JCLFlBQVIsQ0FBcUJqdUIsV0FBckIsR0FBbUMwdkIsV0FBL0Q7QUFFQUMsc0JBQVksR0FBRyxDQUFDTCxPQUFPLENBQUNyQixZQUFSLENBQXFCOVgsTUFBckIsSUFBK0JtWixPQUFPLENBQUNKLFlBQVIsQ0FBcUIvWSxNQUFyRCxJQUErRG1aLE9BQU8sQ0FBQ1AsWUFBUixDQUFxQjVZLE1BQW5HO0FBRUFtWixpQkFBTyxDQUFDTSxLQUFSLENBQWN2TCxZQUFkLEdBQTZCaUwsT0FBTyxDQUFDckIsWUFBUixDQUFxQjVKLFlBQXJCLEdBQW9Dc0wsWUFBakU7QUFFQUwsaUJBQU8sQ0FBQ08sTUFBUixDQUFlenRCLEtBQWYsR0FBMEJrdEIsT0FBTyxDQUFDSixZQUFSLENBQXFCOXNCLEtBQS9DO0FBQ0FrdEIsaUJBQU8sQ0FBQ08sTUFBUixDQUFlMVosTUFBZixHQUEwQm1aLE9BQU8sQ0FBQ0osWUFBUixDQUFxQi9ZLE1BQS9DO0FBRUF1WixxQkFBVyxHQUFHLENBQUNKLE9BQU8sQ0FBQ0osWUFBUixDQUFxQjlzQixLQUFyQixJQUE4Qmt0QixPQUFPLENBQUNyQixZQUFSLENBQXFCN3JCLEtBQXBELElBQTZEa3RCLE9BQU8sQ0FBQ1AsWUFBUixDQUFxQjNzQixLQUFoRztBQUVBa3RCLGlCQUFPLENBQUNPLE1BQVIsQ0FBZTd2QixXQUFmLEdBQTZCc3ZCLE9BQU8sQ0FBQ0osWUFBUixDQUFxQmx2QixXQUFyQixHQUFtQzB2QixXQUFoRTtBQUVBQyxzQkFBWSxHQUFHLENBQUNMLE9BQU8sQ0FBQ0osWUFBUixDQUFxQi9ZLE1BQXJCLElBQStCbVosT0FBTyxDQUFDckIsWUFBUixDQUFxQjlYLE1BQXJELElBQStEbVosT0FBTyxDQUFDUCxZQUFSLENBQXFCNVksTUFBbkc7QUFFQW1aLGlCQUFPLENBQUNPLE1BQVIsQ0FBZXhMLFlBQWYsR0FBOEJpTCxPQUFPLENBQUNKLFlBQVIsQ0FBcUI3SyxZQUFyQixHQUFvQ3NMLFlBQWxFO0FBRUFMLGlCQUFPLENBQUNRLFNBQVIsQ0FBa0IxdEIsS0FBbEIsR0FBa0NrdEIsT0FBTyxDQUFDTyxNQUFSLENBQWV6dEIsS0FBZixHQUF1Qmt0QixPQUFPLENBQUNNLEtBQVIsQ0FBY3h0QixLQUF2RTtBQUNBa3RCLGlCQUFPLENBQUNRLFNBQVIsQ0FBa0IzWixNQUFsQixHQUFrQ21aLE9BQU8sQ0FBQ08sTUFBUixDQUFlMVosTUFBZixHQUF3Qm1aLE9BQU8sQ0FBQ00sS0FBUixDQUFjelosTUFBeEU7QUFDQW1aLGlCQUFPLENBQUNRLFNBQVIsQ0FBa0I5dkIsV0FBbEIsR0FBa0NzdkIsT0FBTyxDQUFDTyxNQUFSLENBQWU3dkIsV0FBZixHQUE2QnN2QixPQUFPLENBQUNNLEtBQVIsQ0FBYzV2QixXQUE3RTtBQUNBc3ZCLGlCQUFPLENBQUNRLFNBQVIsQ0FBa0J6TCxZQUFsQixHQUFrQ2lMLE9BQU8sQ0FBQ08sTUFBUixDQUFleEwsWUFBZixHQUE4QmlMLE9BQU8sQ0FBQ00sS0FBUixDQUFjdkwsWUFBOUU7QUFDSCxTQWpFd0MsQ0FtRXpDOzs7QUFFQSxhQUFLK0UsQ0FBQyxHQUFHLENBQVQsRUFBWTJDLFVBQVUsR0FBR3dELFdBQVcsQ0FBQ25HLENBQUQsQ0FBcEMsRUFBeUNBLENBQUMsRUFBMUMsRUFBOEM7QUFDMUNxRyxnQkFBTSxHQUFHLzJCLElBQUksQ0FBQ3NrQixTQUFMLENBQWUrTyxVQUFmLENBQVQ7QUFFQSxjQUFJLEVBQUUwRCxNQUFNLFlBQVlyakIsUUFBTyxDQUFDbVksYUFBNUIsS0FBOEMsQ0FBQ2tMLE1BQU0sQ0FBQ3gzQixLQUExRCxFQUFpRTtBQUVqRXEzQixpQkFBTyxDQUFDTSxLQUFSLENBQWM3RCxVQUFkLEVBQTBCOXpCLEtBQTFCLEdBQXNDdzNCLE1BQU0sQ0FBQ3gzQixLQUE3QztBQUNBcTNCLGlCQUFPLENBQUNPLE1BQVIsQ0FBZTlELFVBQWYsRUFBMkI5ekIsS0FBM0IsR0FBc0MsQ0FBdEM7QUFFQXEzQixpQkFBTyxDQUFDUSxTQUFSLENBQWtCL0QsVUFBbEIsRUFBOEI5ekIsS0FBOUIsR0FDSXEzQixPQUFPLENBQUNPLE1BQVIsQ0FBZTlELFVBQWYsRUFBMkI5ekIsS0FBM0IsR0FBbUNxM0IsT0FBTyxDQUFDTSxLQUFSLENBQWM3RCxVQUFkLEVBQTBCOXpCLEtBRGpFO0FBR0FxM0IsaUJBQU8sQ0FBQ00sS0FBUixDQUFjN0QsVUFBZCxFQUEwQmpILElBQTFCLEdBQ0l3SyxPQUFPLENBQUNPLE1BQVIsQ0FBZTlELFVBQWYsRUFBMkJqSCxJQUEzQixHQUNBd0ssT0FBTyxDQUFDUSxTQUFSLENBQWtCL0QsVUFBbEIsRUFBOEJqSCxJQUE5QixHQUNBMkssTUFBTSxDQUFDM0ssSUFIWDtBQUlIO0FBQ0o7O0FBRUQsV0FBS3h1QixDQUFDLEdBQUcsQ0FBVCxFQUFZRixNQUFNLEdBQUdveEIsU0FBUyxDQUFDUixNQUFWLENBQWlCMXdCLENBQWpCLENBQXJCLEVBQTBDQSxDQUFDLEVBQTNDLEVBQStDO0FBQzNDZzVCLGVBQU8sR0FBZTlILFNBQVMsQ0FBQzBHLGFBQVYsQ0FBd0I1M0IsQ0FBeEIsQ0FBdEI7QUFDQWc1QixlQUFPLENBQUNNLEtBQVIsR0FBc0IsSUFBSXhqQixRQUFPLENBQUM4WCxTQUFaLEVBQXRCO0FBQ0FvTCxlQUFPLENBQUNPLE1BQVIsR0FBc0IsSUFBSXpqQixRQUFPLENBQUM4WCxTQUFaLEVBQXRCO0FBQ0FvTCxlQUFPLENBQUNRLFNBQVIsR0FBc0IsSUFBSTFqQixRQUFPLENBQUM4WCxTQUFaLEVBQXRCLENBSjJDLENBTTNDOztBQUVBb0wsZUFBTyxDQUFDTSxLQUFSLENBQWNyYSxDQUFkLEdBQXNCbmYsTUFBTSxDQUFDeTBCLE9BQVAsR0FBaUJ5RSxPQUFPLENBQUNyQixZQUFSLENBQXFCMVksQ0FBckIsR0FBeUIrWixPQUFPLENBQUNQLFlBQVIsQ0FBcUJ4WixDQUEvRCxHQUFtRSxDQUF6RjtBQUNBK1osZUFBTyxDQUFDTSxLQUFSLENBQWNwYSxDQUFkLEdBQXNCcGYsTUFBTSxDQUFDeTBCLE9BQVAsR0FBaUJ5RSxPQUFPLENBQUNyQixZQUFSLENBQXFCelksQ0FBckIsR0FBeUI4WixPQUFPLENBQUNQLFlBQVIsQ0FBcUJ2WixDQUEvRCxHQUFtRSxDQUF6RjtBQUNBOFosZUFBTyxDQUFDTyxNQUFSLENBQWV0YSxDQUFmLEdBQXNCN2MsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQnpDLEtBQXRCLEdBQThCLENBQTlCLEdBQWtDMFIsT0FBTyxDQUFDTSxLQUFSLENBQWNyYSxDQUF0RTtBQUNBK1osZUFBTyxDQUFDTyxNQUFSLENBQWVyYSxDQUFmLEdBQXNCOWMsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQnpDLEtBQXRCLEdBQThCLENBQTlCLEdBQWtDMFIsT0FBTyxDQUFDTSxLQUFSLENBQWNwYSxDQUF0RTtBQUNBOFosZUFBTyxDQUFDUSxTQUFSLENBQWtCdmEsQ0FBbEIsR0FBc0IrWixPQUFPLENBQUNPLE1BQVIsQ0FBZXRhLENBQWYsR0FBbUIrWixPQUFPLENBQUNNLEtBQVIsQ0FBY3JhLENBQXZEO0FBQ0ErWixlQUFPLENBQUNRLFNBQVIsQ0FBa0J0YSxDQUFsQixHQUFzQjhaLE9BQU8sQ0FBQ08sTUFBUixDQUFlcmEsQ0FBZixHQUFtQjhaLE9BQU8sQ0FBQ00sS0FBUixDQUFjcGEsQ0FBdkQsQ0FiMkMsQ0FlM0M7O0FBRUEsWUFBSTljLElBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0I1QyxvQkFBMUIsRUFBZ0Q7QUFDNUM2UixpQkFBTyxDQUFDTSxLQUFSLENBQWN4dEIsS0FBZCxHQUE4Qmt0QixPQUFPLENBQUNyQixZQUFSLENBQXFCN3JCLEtBQW5EO0FBQ0FrdEIsaUJBQU8sQ0FBQ00sS0FBUixDQUFjelosTUFBZCxHQUE4Qm1aLE9BQU8sQ0FBQ3JCLFlBQVIsQ0FBcUI5WCxNQUFuRDtBQUVBdVoscUJBQVcsR0FBR0osT0FBTyxDQUFDckIsWUFBUixDQUFxQjdyQixLQUFyQixHQUE2Qmt0QixPQUFPLENBQUNQLFlBQVIsQ0FBcUIzc0IsS0FBaEU7QUFFQWt0QixpQkFBTyxDQUFDTSxLQUFSLENBQWM1dkIsV0FBZCxHQUE0QnN2QixPQUFPLENBQUNyQixZQUFSLENBQXFCanVCLFdBQXJCLEdBQW1DMHZCLFdBQS9EO0FBRUFDLHNCQUFZLEdBQUdMLE9BQU8sQ0FBQ3JCLFlBQVIsQ0FBcUI5WCxNQUFyQixHQUE4Qm1aLE9BQU8sQ0FBQ1AsWUFBUixDQUFxQjVZLE1BQWxFO0FBRUFtWixpQkFBTyxDQUFDTSxLQUFSLENBQWN2TCxZQUFkLEdBQTZCaUwsT0FBTyxDQUFDckIsWUFBUixDQUFxQjVKLFlBQXJCLEdBQW9Dc0wsWUFBakU7QUFDSCxTQTVCMEMsQ0E4QjNDOzs7QUFFQUwsZUFBTyxDQUFDTSxLQUFSLENBQWN2VyxPQUFkLEdBQThCLENBQTlCO0FBQ0FpVyxlQUFPLENBQUNPLE1BQVIsQ0FBZXhXLE9BQWYsR0FBOEIzZ0IsSUFBSSxDQUFDdWtCLFVBQUwsQ0FBZ0I1RCxPQUE5QztBQUNBaVcsZUFBTyxDQUFDUSxTQUFSLENBQWtCelcsT0FBbEIsR0FBOEJpVyxPQUFPLENBQUNPLE1BQVIsQ0FBZXhXLE9BQWYsR0FBeUJpVyxPQUFPLENBQUNNLEtBQVIsQ0FBY3ZXLE9BQXJFLENBbEMyQyxDQW9DM0M7O0FBRUEsYUFBSytQLENBQUMsR0FBRyxDQUFULEVBQVkyQyxVQUFVLEdBQUd3RCxXQUFXLENBQUNuRyxDQUFELENBQXBDLEVBQXlDQSxDQUFDLEVBQTFDLEVBQThDO0FBQzFDcUcsZ0JBQU0sR0FBRy8yQixJQUFJLENBQUN1a0IsVUFBTCxDQUFnQjhPLFVBQWhCLENBQVQ7QUFFQSxjQUFJLEVBQUUwRCxNQUFNLFlBQVlyakIsUUFBTyxDQUFDbVksYUFBNUIsS0FBOEMsQ0FBQ2tMLE1BQU0sQ0FBQ3gzQixLQUExRCxFQUFpRTtBQUVqRXEzQixpQkFBTyxDQUFDTSxLQUFSLENBQWM3RCxVQUFkLEVBQTBCOXpCLEtBQTFCLEdBQXNDLENBQXRDO0FBQ0FxM0IsaUJBQU8sQ0FBQ08sTUFBUixDQUFlOUQsVUFBZixFQUEyQjl6QixLQUEzQixHQUFzQ3czQixNQUFNLENBQUN4M0IsS0FBN0M7QUFFQXEzQixpQkFBTyxDQUFDUSxTQUFSLENBQWtCL0QsVUFBbEIsRUFBOEI5ekIsS0FBOUIsR0FDSXEzQixPQUFPLENBQUNPLE1BQVIsQ0FBZTlELFVBQWYsRUFBMkI5ekIsS0FBM0IsR0FBbUNxM0IsT0FBTyxDQUFDTSxLQUFSLENBQWM3RCxVQUFkLEVBQTBCOXpCLEtBRGpFO0FBR0FxM0IsaUJBQU8sQ0FBQ00sS0FBUixDQUFjN0QsVUFBZCxFQUEwQmpILElBQTFCLEdBQ0l3SyxPQUFPLENBQUNPLE1BQVIsQ0FBZTlELFVBQWYsRUFBMkJqSCxJQUEzQixHQUNBd0ssT0FBTyxDQUFDUSxTQUFSLENBQWtCL0QsVUFBbEIsRUFBOEJqSCxJQUE5QixHQUNBMkssTUFBTSxDQUFDM0ssSUFIWDtBQUlIO0FBQ0o7O0FBRURwc0IsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixtQkFBakIsRUFBc0M3WSxTQUF0QztBQUNILEtBOXVETDs7QUFndkRJOzs7Ozs7O0FBUUFzMkIsZUFBVyxFQUFFLHFCQUFTakcsU0FBVCxFQUFvQjtBQUM3QixVQUFJOXVCLElBQUksR0FBYyxJQUF0QjtBQUFBLFVBQ0l0QyxNQUFNLEdBQVksSUFEdEI7QUFBQSxVQUVJMjVCLFFBQVEsR0FBVSxJQUZ0QjtBQUFBLFVBR0lULE9BQU8sR0FBVyxJQUh0QjtBQUFBLFVBSUlVLFlBQVksR0FBTSxFQUp0QjtBQUFBLFVBS0lDLGNBQWMsR0FBSSxLQUx0QjtBQUFBLFVBTUlDLFlBQVksR0FBTSxDQUFDLENBTnZCO0FBQUEsVUFPSTU1QixDQUFDLEdBQWlCLENBQUMsQ0FQdkI7QUFBQSxVQVFJNjVCLGFBQWEsR0FBS3ozQixJQUFJLENBQUN5M0IsYUFBTCxDQUFtQmhyQixJQUFuQixDQUF3QnpNLElBQXhCLENBUnRCO0FBVUFBLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsbUJBQWpCLEVBQXNDN1ksU0FBdEMsRUFYNkIsQ0FhN0I7QUFDQTs7QUFFQSxXQUFLYixDQUFDLEdBQUcsQ0FBVCxFQUFZRixNQUFNLEdBQUdveEIsU0FBUyxDQUFDUyxJQUFWLENBQWUzeEIsQ0FBZixDQUFyQixFQUF3Q0EsQ0FBQyxFQUF6QyxFQUE2QztBQUN6Q3k1QixnQkFBUSxHQUFNLElBQUkzakIsUUFBTyxDQUFDZ2tCLFNBQVosRUFBZDtBQUNBZCxlQUFPLEdBQU85SCxTQUFTLENBQUN3RyxXQUFWLENBQXNCMTNCLENBQXRCLENBQWQ7QUFFQTA1QixvQkFBWSxHQUFHNTVCLE1BQU0sQ0FBQ3kwQixPQUFQLEdBQWlCLE1BQWpCLEdBQTBCLE1BQXpDO0FBRUFvRixzQkFBYyxHQUFHdjNCLElBQUksQ0FBQ3UzQixjQUFMLENBQ2JELFlBRGEsRUFFYnhJLFNBQVMsQ0FBQzZJLFNBRkcsRUFHYmYsT0FBTyxDQUFDTSxLQUhLLEVBSWJOLE9BQU8sQ0FBQ08sTUFKSyxDQUFqQjs7QUFPQSxZQUFJSSxjQUFKLEVBQW9CO0FBQ2hCO0FBRUFDLHNCQUFZO0FBQ2Y7O0FBRUQ5NUIsY0FBTSxDQUFDNnhCLElBQVA7QUFFQThILGdCQUFRLENBQUNILEtBQVQsR0FBMEJOLE9BQU8sQ0FBQ00sS0FBbEM7QUFDQUcsZ0JBQVEsQ0FBQ0YsTUFBVCxHQUEwQlAsT0FBTyxDQUFDTyxNQUFsQztBQUNBRSxnQkFBUSxDQUFDQyxZQUFULEdBQTBCQSxZQUExQjtBQUNBRCxnQkFBUSxDQUFDRyxZQUFULEdBQTBCQSxZQUExQjtBQUNBSCxnQkFBUSxDQUFDdkksU0FBVCxHQUEwQkEsU0FBMUI7QUFDQXVJLGdCQUFRLENBQUNscEIsUUFBVCxHQUEwQm9wQixjQUFjLEdBQUdFLGFBQUgsR0FBbUIsSUFBM0Q7QUFFQS81QixjQUFNLENBQUMrRixJQUFQLENBQVk0ekIsUUFBWjtBQUNIOztBQUVELFdBQUt6NUIsQ0FBQyxHQUFHLENBQVQsRUFBWUYsTUFBTSxHQUFHb3hCLFNBQVMsQ0FBQ1IsTUFBVixDQUFpQjF3QixDQUFqQixDQUFyQixFQUEwQ0EsQ0FBQyxFQUEzQyxFQUErQztBQUMzQ2c1QixlQUFPLEdBQUk5SCxTQUFTLENBQUMwRyxhQUFWLENBQXdCNTNCLENBQXhCLENBQVg7QUFDQXk1QixnQkFBUSxHQUFHLElBQUkzakIsUUFBTyxDQUFDZ2tCLFNBQVosRUFBWDtBQUVBSixvQkFBWSxHQUFHLE1BQWY7QUFFQUMsc0JBQWMsR0FBR3YzQixJQUFJLENBQUN1M0IsY0FBTCxDQUFvQkQsWUFBcEIsRUFBa0NWLE9BQU8sQ0FBQ00sS0FBMUMsRUFBaUROLE9BQU8sQ0FBQ08sTUFBekQsQ0FBakI7QUFFQUUsZ0JBQVEsQ0FBQ0gsS0FBVCxHQUEwQk4sT0FBTyxDQUFDTSxLQUFsQztBQUNBRyxnQkFBUSxDQUFDRixNQUFULEdBQTBCUCxPQUFPLENBQUNPLE1BQWxDO0FBQ0FFLGdCQUFRLENBQUNDLFlBQVQsR0FBMEJBLFlBQTFCO0FBQ0FELGdCQUFRLENBQUNHLFlBQVQsR0FBMEI1NUIsQ0FBMUI7QUFDQXk1QixnQkFBUSxDQUFDdkksU0FBVCxHQUEwQkEsU0FBMUI7QUFDQXVJLGdCQUFRLENBQUNscEIsUUFBVCxHQUEwQm9wQixjQUFjLEdBQUdFLGFBQUgsR0FBbUIsSUFBM0Q7QUFFQS81QixjQUFNLENBQUMrRixJQUFQLENBQVk0ekIsUUFBWjtBQUNIOztBQUVELFVBQUlyM0IsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQjdDLHNCQUExQixFQUFrRDtBQUM5QzlrQixZQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0I4SCxLQUFoQixDQUFzQnVNLFFBQU8sQ0FBQ2tMLFFBQVIsQ0FBaUJ5RSxjQUF2QyxJQUNJLFlBQVlyakIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQjFaLFFBQWxDLEdBQTZDLFdBQTdDLEdBQ0EsUUFEQSxHQUNXak8sSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQjFaLFFBRGpDLEdBQzRDLFVBRmhEO0FBSUE4Riw2QkFBcUIsQ0FBQyxZQUFXO0FBQzdCLGNBQ0krYSxTQUFTLENBQUMwRixXQUFWLEtBQTBCMUYsU0FBUyxDQUFDMkYsU0FBcEMsSUFDQTNGLFNBQVMsQ0FBQzRGLGNBQVYsS0FBNkI1RixTQUFTLENBQUMwRixXQUFWLEdBQXdCMUYsU0FBUyxDQUFDMkYsU0FGbkUsRUFHRTtBQUNFejBCLGdCQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0I4SCxLQUFoQixDQUFzQnNXLE1BQXRCLEdBQStCcVIsU0FBUyxDQUFDMkYsU0FBVixHQUFzQixJQUFyRDtBQUNIOztBQUVELGNBQ0kzRixTQUFTLENBQUM2RixVQUFWLEtBQXlCN0YsU0FBUyxDQUFDOEYsUUFBbkMsSUFDQTlGLFNBQVMsQ0FBQytGLGNBQVYsS0FBNkIvRixTQUFTLENBQUM2RixVQUFWLEdBQXVCN0YsU0FBUyxDQUFDOEYsUUFGbEUsRUFHRTtBQUNFNTBCLGdCQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0I4SCxLQUFoQixDQUFzQnVDLEtBQXRCLEdBQThCb2xCLFNBQVMsQ0FBQzhGLFFBQVYsR0FBcUIsSUFBbkQ7QUFDSDtBQUNKLFNBZG9CLENBQXJCO0FBZUg7O0FBRUQsVUFBSTlGLFNBQVMsQ0FBQ29GLGdCQUFkLEVBQWdDO0FBQzVCdmdCLFNBQUMsQ0FBQ3pHLFdBQUYsQ0FBY2xOLElBQUksQ0FBQzBxQixHQUFMLENBQVM1VSxTQUF2QixFQUFrQzlWLElBQUksQ0FBQytWLE1BQUwsQ0FBWStSLE1BQVosQ0FBbUI4UCxrQkFBckQ7QUFDQWprQixTQUFDLENBQUMxRyxRQUFGLENBQVdqTixJQUFJLENBQUMwcUIsR0FBTCxDQUFTNVUsU0FBcEIsRUFBK0JnWixTQUFTLENBQUNRLHFCQUF6QztBQUNIOztBQUVEdHZCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsa0JBQWpCLEVBQXFDN1ksU0FBckM7QUFDSCxLQXIxREw7O0FBdTFESTs7Ozs7QUFNQWs1QixhQUFTLEVBQUUscUJBQVc7QUFDbEIsVUFBSTMzQixJQUFJLEdBQVUsSUFBbEI7QUFBQSxVQUNJNjNCLFdBQVcsR0FBRyxDQUNWLE9BRFUsRUFFVixZQUZVLEVBRUksWUFGSixFQUVrQixZQUZsQixFQUdWLFNBSFUsRUFHQyxTQUhELEVBR1ksU0FIWixDQURsQjtBQUFBLFVBTUl4RSxVQUFVLEdBQUksRUFObEI7QUFBQSxVQU9JMEQsTUFBTSxHQUFRLElBUGxCO0FBQUEsVUFRSTN3QixNQUFNLEdBQVEsS0FSbEI7QUFBQSxVQVNJN0csS0FBSyxHQUFTLENBQUMsQ0FUbkI7QUFBQSxVQVVJM0IsQ0FBQyxHQUFhLENBQUMsQ0FWbkI7O0FBWUEsVUFBSW9DLElBQUksQ0FBQ3NrQixTQUFMLENBQWUzRCxPQUFmLEtBQTJCLENBQS9CLEVBQWtDO0FBQzlCLGVBQU8zZ0IsSUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIsaUJBQWpCLEVBQW9DLElBQXBDLEVBQTBDOWpCLFNBQTFDLENBQVA7QUFDSDs7QUFFRCxXQUFLYixDQUFDLEdBQUcsQ0FBVCxFQUFZeTFCLFVBQVUsR0FBR3dFLFdBQVcsQ0FBQ2o2QixDQUFELENBQXBDLEVBQXlDQSxDQUFDLEVBQTFDLEVBQThDO0FBQzFDbTVCLGNBQU0sR0FBSS8yQixJQUFJLENBQUNza0IsU0FBTCxDQUFlK08sVUFBZixDQUFWO0FBQ0E5ekIsYUFBSyxHQUFNLFFBQU93M0IsTUFBUCxLQUFpQkEsTUFBTSxDQUFDeDNCLEtBQVAsS0FBaUIsV0FBbkMsR0FDTnczQixNQUFNLENBQUN4M0IsS0FERCxHQUNTdzNCLE1BRG5COztBQUdBLFlBQUl4M0IsS0FBSyxLQUFLLENBQWQsRUFBaUI7QUFDYjZHLGdCQUFNLEdBQUcsSUFBVDtBQUVBO0FBQ0g7QUFDSjs7QUFFRCxhQUFPcEcsSUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIsaUJBQWpCLEVBQW9DbmMsTUFBcEMsRUFBNEMzSCxTQUE1QyxDQUFQO0FBQ0gsS0EzM0RMOztBQTYzREk7Ozs7Ozs7Ozs7Ozs7O0FBZUE4NEIsa0JBQWMsRUFBRSx3QkFBU0QsWUFBVCxFQUF1QkssU0FBdkIsRUFBa0NULEtBQWxDLEVBQXlDQyxNQUF6QyxFQUFpRDtBQUM3RCxVQUFJbjNCLElBQUksR0FBTSxJQUFkO0FBQUEsVUFDSW9HLE1BQU0sR0FBSSxLQURkOztBQUdBLFVBQUksQ0FBQ3VOLENBQUMsQ0FBQzRNLFNBQUYsQ0FBWXZnQixJQUFJLENBQUMwcUIsR0FBTCxDQUFTNVUsU0FBckIsQ0FBTCxFQUFzQztBQUNsQztBQUNBO0FBRUExUCxjQUFNLEdBQUcsS0FBVDtBQUNILE9BTEQsTUFLTyxJQUNGa3hCLFlBQVksS0FBSyxNQUFqQixJQUEyQkssU0FBNUIsSUFDQVQsS0FBSyxDQUFDcmEsQ0FBTixLQUFZc2EsTUFBTSxDQUFDdGEsQ0FEbkIsSUFFQXFhLEtBQUssQ0FBQ3BhLENBQU4sS0FBWXFhLE1BQU0sQ0FBQ3JhLENBSGhCLEVBSUw7QUFDRTtBQUVBMVcsY0FBTSxHQUFHLElBQVQ7QUFDSCxPQVJNLE1BUUEsSUFBSXBHLElBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0I1QyxvQkFBMUIsRUFBZ0Q7QUFDbkQ7QUFFQTNlLGNBQU0sR0FDRjh3QixLQUFLLENBQUN4dEIsS0FBTixLQUFnQnl0QixNQUFNLENBQUN6dEIsS0FBdkIsSUFDQXd0QixLQUFLLENBQUN6WixNQUFOLEtBQWlCMFosTUFBTSxDQUFDMVosTUFEeEIsSUFFQXlaLEtBQUssQ0FBQzV2QixXQUFOLEtBQXNCNnZCLE1BQU0sQ0FBQzd2QixXQUY3QixJQUdBNHZCLEtBQUssQ0FBQ1ksU0FBTixLQUFvQlgsTUFBTSxDQUFDVyxTQUovQjtBQU1ILE9BVE0sTUFTQTtBQUNIMXhCLGNBQU0sR0FBRyxLQUFUO0FBQ0g7O0FBRUQsYUFBT3BHLElBQUksQ0FBQ3VpQixXQUFMLENBQWlCLHNCQUFqQixFQUF5Q25jLE1BQXpDLEVBQWlEM0gsU0FBakQsQ0FBUDtBQUNILEtBMzZETDs7QUE2NkRJOzs7Ozs7O0FBUUFnNUIsaUJBQWEsRUFBRSx1QkFBUzNJLFNBQVQsRUFBb0I7QUFDL0IsVUFBSTl1QixJQUFJLEdBQUcsSUFBWDtBQUVBQSxVQUFJLENBQUMydEIsV0FBTDs7QUFFQSxVQUFJM3RCLElBQUksQ0FBQzB0QixZQUFMLEtBQXNCMXRCLElBQUksQ0FBQzJ0QixXQUEvQixFQUE0QztBQUN4QzN0QixZQUFJLENBQUNxMEIsT0FBTCxDQUFhdkYsU0FBYjtBQUNIO0FBQ0osS0E3N0RMOztBQSs3REk7Ozs7Ozs7QUFRQXVGLFdBQU8sRUFBRSxpQkFBU3ZGLFNBQVQsRUFBb0I7QUFDekIsVUFBSTl1QixJQUFJLEdBQWtCLElBQTFCO0FBQUEsVUFDSXRDLE1BQU0sR0FBZ0IsSUFEMUI7QUFBQSxVQUVJcTZCLGdCQUFnQixHQUFNLElBRjFCO0FBQUEsVUFHSUMsZUFBZSxHQUFPLElBSDFCO0FBQUEsVUFJSUMsV0FBVyxHQUFXLElBSjFCO0FBQUEsVUFLSXI2QixDQUFDLEdBQXFCLENBQUMsQ0FMM0I7QUFPQW9DLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsZUFBakIsRUFBa0M3WSxTQUFsQztBQUVBdUIsVUFBSSxDQUFDd3RCLFlBQUwsR0FDSXh0QixJQUFJLENBQUN5dEIsZ0JBQUwsR0FDQXp0QixJQUFJLENBQUMwdEIsWUFBTCxHQUNBMXRCLElBQUksQ0FBQzJ0QixXQUFMLEdBQXlCLENBSDdCOztBQUtBLFdBQUsvdkIsQ0FBQyxHQUFHLENBQVQsRUFBWUYsTUFBTSxHQUFHb3hCLFNBQVMsQ0FBQ1MsSUFBVixDQUFlM3hCLENBQWYsQ0FBckIsRUFBd0NBLENBQUMsRUFBekMsRUFBNkM7QUFDekNGLGNBQU0sQ0FBQzIyQixPQUFQO0FBRUEzMkIsY0FBTSxDQUFDNnhCLElBQVA7QUFDSDs7QUFFRCxXQUFLM3hCLENBQUMsR0FBRyxDQUFULEVBQVlGLE1BQU0sR0FBR294QixTQUFTLENBQUNSLE1BQVYsQ0FBaUIxd0IsQ0FBakIsQ0FBckIsRUFBMENBLENBQUMsRUFBM0MsRUFBK0M7QUFDM0NGLGNBQU0sQ0FBQzIyQixPQUFQO0FBRUEzMkIsY0FBTSxDQUFDNndCLElBQVA7QUFDSDs7QUFFRCxVQUFJTyxTQUFTLENBQUN3RCxRQUFkLEVBQXdCO0FBQ3BCdHlCLFlBQUksQ0FBQzZ2QixTQUFMLENBQWUsS0FBZixFQUFzQmYsU0FBdEI7QUFDSCxPQTdCd0IsQ0ErQnpCOzs7QUFFQTl1QixVQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0I4SCxLQUFoQixDQUFzQnVNLFFBQU8sQ0FBQ2tMLFFBQVIsQ0FBaUJ5RSxjQUF2QyxJQUNJcmpCLElBQUksQ0FBQzBxQixHQUFMLENBQVNyckIsTUFBVCxDQUFnQjhILEtBQWhCLENBQXNCc1csTUFBdEIsR0FDQXpkLElBQUksQ0FBQzBxQixHQUFMLENBQVNyckIsTUFBVCxDQUFnQjhILEtBQWhCLENBQXNCdUMsS0FBdEIsR0FDQTFKLElBQUksQ0FBQzBxQixHQUFMLENBQVNyckIsTUFBVCxDQUFnQjhILEtBQWhCLENBQXNCMnRCLFFBQXRCLEdBQ0E5MEIsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3JyQixNQUFULENBQWdCOEgsS0FBaEIsQ0FBc0J1TSxRQUFPLENBQUNrTCxRQUFSLENBQWlCMEUsZUFBdkMsSUFDQXRqQixJQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0I4SCxLQUFoQixDQUFzQnVNLFFBQU8sQ0FBQ2tMLFFBQVIsQ0FBaUIyRSxxQkFBdkMsSUFBaUUsRUFMckU7O0FBT0EsVUFBSXVMLFNBQVMsQ0FBQ29GLGdCQUFkLEVBQWdDO0FBQzVCdmdCLFNBQUMsQ0FBQ3pHLFdBQUYsQ0FBY2xOLElBQUksQ0FBQzBxQixHQUFMLENBQVM1VSxTQUF2QixFQUFrQ2daLFNBQVMsQ0FBQ08sdUJBQTVDO0FBQ0ExYixTQUFDLENBQUMxRyxRQUFGLENBQVdqTixJQUFJLENBQUMwcUIsR0FBTCxDQUFTNVUsU0FBcEIsRUFBK0JnWixTQUFTLENBQUNRLHFCQUF6QztBQUNIOztBQUVELFVBQUlSLFNBQVMsQ0FBQ2dELFFBQVYsQ0FBbUJqMEIsTUFBdkIsRUFBK0I7QUFDM0IsYUFBS0QsQ0FBQyxHQUFHLENBQVQsRUFBWUYsTUFBTSxHQUFHc0MsSUFBSSxDQUFDb29CLE9BQUwsQ0FBYXhxQixDQUFiLENBQXJCLEVBQXNDQSxDQUFDLEVBQXZDLEVBQTJDO0FBQ3ZDLGNBQUlreEIsU0FBUyxDQUFDZ0QsUUFBVixDQUFtQjNrQixPQUFuQixDQUEyQnpQLE1BQTNCLElBQXFDLENBQUMsQ0FBMUMsRUFBNkM7QUFDekMsZ0JBQ0ksQ0FBQ3E2QixnQkFBZ0IsR0FBR3I2QixNQUFNLENBQUNndEIsR0FBUCxDQUFXemUsRUFBWCxDQUFjb1AsZUFBbEMsS0FBc0QwYyxnQkFBZ0IsQ0FBQ2xkLFFBQWpCLEtBQThCLE9BQXBGLEtBQ0NtZCxlQUFlLEdBQUd0NkIsTUFBTSxDQUFDZ3RCLEdBQVAsQ0FBV3plLEVBQVgsQ0FBY2pFLFdBRGpDLEtBQ2lEZ3dCLGVBQWUsQ0FBQ25kLFFBQWhCLEtBQTZCLE9BRmxGLEVBR0U7QUFDRWxILGVBQUMsQ0FBQ3dILGdCQUFGLENBQW1CNGMsZ0JBQW5CO0FBQ0g7O0FBRUQsZ0JBQUksQ0FBQ2pKLFNBQVMsQ0FBQ3dELFFBQWYsRUFBeUI7QUFDckI7QUFFQXR5QixrQkFBSSxDQUFDMHFCLEdBQUwsQ0FBU3JyQixNQUFULENBQWdCeU0sV0FBaEIsQ0FBNEJwTyxNQUFNLENBQUNndEIsR0FBUCxDQUFXemUsRUFBdkM7QUFDSDs7QUFFRGpNLGdCQUFJLENBQUNvb0IsT0FBTCxDQUFhOEIsTUFBYixDQUFvQnRzQixDQUFwQixFQUF1QixDQUF2QjtBQUVBRixrQkFBTSxDQUFDNnlCLE9BQVAsR0FBaUIsS0FBakI7QUFFQTN5QixhQUFDO0FBQ0o7QUFDSixTQXRCMEIsQ0F3QjNCOzs7QUFFQW9DLFlBQUksQ0FBQ3N0QixTQUFMLEdBQWlCdHRCLElBQUksQ0FBQ29vQixPQUF0QjtBQUNIOztBQUVELFVBQUkwRyxTQUFTLENBQUN3RCxRQUFkLEVBQXdCO0FBQ3BCdHlCLFlBQUksQ0FBQ29vQixPQUFMLEdBQWUwRyxTQUFTLENBQUNnQixRQUF6QjtBQUNIOztBQUVEOXZCLFVBQUksQ0FBQzZxQixLQUFMLEdBQWFpRSxTQUFTLENBQUNzRixRQUF2QjtBQUNBcDBCLFVBQUksQ0FBQyt0QixhQUFMLEdBQXFCZSxTQUFyQjtBQUVBOXVCLFVBQUksQ0FBQzBxQixHQUFMLENBQVN0QyxPQUFULEdBQW1CcG9CLElBQUksQ0FBQzZxQixLQUFMLENBQVd6QyxPQUE5QixDQWpGeUIsQ0FtRnpCOztBQUVBMVUsY0FBTyxDQUFDMVMsTUFBUixDQUFlNHBCLElBQWYsQ0FBb0IsUUFBcEIsRUFBOEI1cUIsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBUzVVLFNBQXZDLEVBQWtEO0FBQzlDK1UsYUFBSyxFQUFFN3FCLElBQUksQ0FBQzZxQixLQURrQztBQUU5Q3h0QixnQkFBUSxFQUFFMkM7QUFGb0MsT0FBbEQsRUFHR0EsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBUzNoQixRQUhaOztBQUtBLFVBQUksT0FBTy9JLElBQUksQ0FBQytWLE1BQUwsQ0FBWThSLFNBQVosQ0FBc0JuQyxRQUE3QixLQUEwQyxVQUE5QyxFQUEwRDtBQUN0RDFsQixZQUFJLENBQUMrVixNQUFMLENBQVk4UixTQUFaLENBQXNCbkMsUUFBdEIsQ0FBK0I5bUIsSUFBL0IsQ0FBb0NvQixJQUFJLENBQUMwcUIsR0FBTCxDQUFTNVUsU0FBN0MsRUFBd0Q5VixJQUFJLENBQUM2cUIsS0FBN0QsRUFBb0U3cUIsSUFBcEU7QUFDSDs7QUFFRCxVQUFJOHVCLFNBQVMsQ0FBQ21ELFNBQWQsRUFBeUI7QUFDckI7QUFFQXZlLGdCQUFPLENBQUMxUyxNQUFSLENBQWU0cEIsSUFBZixDQUFvQixTQUFwQixFQUErQjVxQixJQUFJLENBQUMwcUIsR0FBTCxDQUFTNVUsU0FBeEMsRUFBbUQ7QUFDL0MrVSxlQUFLLEVBQUU3cUIsSUFBSSxDQUFDNnFCLEtBRG1DO0FBRS9DeHRCLGtCQUFRLEVBQUUyQztBQUZxQyxTQUFuRCxFQUdHQSxJQUFJLENBQUMwcUIsR0FBTCxDQUFTM2hCLFFBSFo7O0FBS0EsWUFBSSxPQUFPL0ksSUFBSSxDQUFDK1YsTUFBTCxDQUFZOFIsU0FBWixDQUFzQmxDLFNBQTdCLEtBQTJDLFVBQS9DLEVBQTJEO0FBQ3ZEM2xCLGNBQUksQ0FBQytWLE1BQUwsQ0FBWThSLFNBQVosQ0FBc0JsQyxTQUF0QixDQUFnQy9tQixJQUFoQyxDQUFxQ29CLElBQUksQ0FBQzBxQixHQUFMLENBQVM1VSxTQUE5QyxFQUF5RDlWLElBQUksQ0FBQzZxQixLQUE5RCxFQUFxRTdxQixJQUFyRTtBQUNIOztBQUVEMlQsU0FBQyxDQUFDMUcsUUFBRixDQUFXak4sSUFBSSxDQUFDMHFCLEdBQUwsQ0FBUzVVLFNBQXBCLEVBQStCbkMsQ0FBQyxDQUFDMk4sWUFBRixDQUFldGhCLElBQUksQ0FBQytWLE1BQUwsQ0FBWXdMLFVBQTNCLEVBQXVDLFdBQXZDLEVBQW9EdmhCLElBQUksQ0FBQytWLE1BQUwsQ0FBWXdMLFVBQVosQ0FBdUJtRixjQUEzRSxDQUEvQjtBQUNILE9BM0d3QixDQTZHekI7OztBQUVBLFVBQUksT0FBTzFtQixJQUFJLENBQUNndUIsWUFBWixLQUE2QixVQUFqQyxFQUE2QztBQUN6Q2h1QixZQUFJLENBQUNndUIsWUFBTCxDQUFrQnB2QixJQUFsQixDQUF1Qm9CLElBQUksQ0FBQzBxQixHQUFMLENBQVM1VSxTQUFoQyxFQUEyQzlWLElBQUksQ0FBQzZxQixLQUFoRCxFQUF1RDdxQixJQUF2RDtBQUNIOztBQUVELFVBQUksT0FBT0EsSUFBSSxDQUFDaXVCLFlBQUwsQ0FBa0JwaEIsT0FBekIsS0FBcUMsVUFBekMsRUFBcUQ7QUFDakQ3TSxZQUFJLENBQUNpdUIsWUFBTCxDQUFrQnBoQixPQUFsQixDQUEwQjdNLElBQUksQ0FBQzZxQixLQUEvQjtBQUNIOztBQUVEN3FCLFVBQUksQ0FBQ2d1QixZQUFMLEdBQXFCLElBQXJCO0FBQ0FodUIsVUFBSSxDQUFDaXVCLFlBQUwsR0FBcUIsSUFBckI7QUFDQWp1QixVQUFJLENBQUMycUIsV0FBTCxHQUFxQixJQUFyQjtBQUNBM3FCLFVBQUksQ0FBQ210QixVQUFMLEdBQXFCLEtBQXJCO0FBQ0FudEIsVUFBSSxDQUFDb3RCLE1BQUwsR0FBcUIsS0FBckI7O0FBRUEsVUFBSXB0QixJQUFJLENBQUM0a0IsS0FBTCxDQUFXL21CLE1BQWYsRUFBdUI7QUFDbkJtQyxZQUFJLENBQUNzWCxXQUFMLENBQWlCLHdCQUFqQixFQUEyQzdZLFNBQTNDO0FBRUF3NUIsbUJBQVcsR0FBR2o0QixJQUFJLENBQUM0a0IsS0FBTCxDQUFXd00sS0FBWCxFQUFkLENBSG1CLENBS25COztBQUVBcHhCLFlBQUksQ0FBQ2l1QixZQUFMLEdBQXFCZ0ssV0FBVyxDQUFDeFosUUFBakM7QUFDQXplLFlBQUksQ0FBQ210QixVQUFMLEdBQXFCOEssV0FBVyxDQUFDOUssVUFBakM7QUFDQW50QixZQUFJLENBQUMycUIsV0FBTCxHQUFxQnNOLFdBQVcsQ0FBQy9LLGNBQWpDOztBQUVBLFlBQUkrSyxXQUFXLENBQUNoTCxXQUFaLENBQXdCekMsT0FBeEIsWUFBMkM5VyxRQUFPLENBQUMrVSxlQUF2RCxFQUF3RTtBQUNwRXpvQixjQUFJLENBQUNpckIsUUFBTCxDQUFjemtCLEtBQWQsQ0FBb0J4RyxJQUFwQixFQUEwQmk0QixXQUFXLENBQUM5eEIsSUFBdEM7QUFDSCxTQUZELE1BRU87QUFDSG5HLGNBQUksQ0FBQ3NuQixPQUFMLENBQWE5Z0IsS0FBYixDQUFtQnhHLElBQW5CLEVBQXlCaTRCLFdBQVcsQ0FBQzl4QixJQUFyQztBQUNIO0FBQ0o7O0FBRURuRyxVQUFJLENBQUNzWCxXQUFMLENBQWlCLGNBQWpCLEVBQWlDN1ksU0FBakM7QUFDSCxLQXZsRUw7O0FBeWxFSTs7Ozs7OztBQVFBeTVCLHFCQUFpQixFQUFFLDJCQUFTL3hCLElBQVQsRUFBZTtBQUM5QixVQUFJbkcsSUFBSSxHQUFVLElBQWxCO0FBQUEsVUFDSWl0QixXQUFXLEdBQUcsSUFBSXZaLFFBQU8sQ0FBQ3lrQixlQUFaLEVBRGxCO0FBQUEsVUFFSXJqQixHQUFHLEdBQVcsSUFGbEI7QUFBQSxVQUdJbFgsQ0FBQyxHQUFhLENBQUMsQ0FIbkI7QUFLQXF2QixpQkFBVyxDQUFDbUwsT0FBWixHQUFzQnA0QixJQUFJLENBQUMrVixNQUFMLENBQVk0UixTQUFaLENBQXNCempCLE1BQTVDO0FBQ0Erb0IsaUJBQVcsQ0FBQ3pDLE9BQVosR0FBc0IsSUFBSTlXLFFBQU8sQ0FBQytVLGVBQVosRUFBdEI7O0FBRUEsV0FBSzdxQixDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUd1SSxJQUFJLENBQUN0SSxNQUFyQixFQUE2QkQsQ0FBQyxFQUE5QixFQUFrQztBQUM5QmtYLFdBQUcsR0FBRzNPLElBQUksQ0FBQ3ZJLENBQUQsQ0FBVjtBQUVBLFlBQUlrWCxHQUFHLEtBQUssSUFBWixFQUFrQjs7QUFFbEIsWUFBSSxRQUFPQSxHQUFQLE1BQWUsUUFBbkIsRUFBNkI7QUFDekJuQixXQUFDLENBQUN1RSxNQUFGLENBQVMrVSxXQUFXLENBQUN6QyxPQUFyQixFQUE4QjFWLEdBQTlCO0FBQ0gsU0FGRCxNQUVPLElBQUksT0FBT0EsR0FBUCxLQUFlLFNBQW5CLEVBQThCO0FBQ2pDbVkscUJBQVcsQ0FBQ21MLE9BQVosR0FBc0J0akIsR0FBdEI7QUFDSCxTQUZNLE1BRUEsSUFBSSxPQUFPQSxHQUFQLEtBQWUsVUFBbkIsRUFBK0I7QUFDbENtWSxxQkFBVyxDQUFDOWUsUUFBWixHQUF1QjJHLEdBQXZCO0FBQ0g7QUFDSixPQXJCNkIsQ0F1QjlCOzs7QUFFQSxVQUFJbVksV0FBVyxDQUFDekMsT0FBWixDQUFvQjlCLE1BQXBCLElBQThCLEVBQUV1RSxXQUFXLENBQUN6QyxPQUFaLENBQW9COUIsTUFBcEIsWUFBc0NoVixRQUFPLENBQUMwVixhQUFoRCxDQUFsQyxFQUFrRztBQUM5RjZELG1CQUFXLENBQUN6QyxPQUFaLENBQW9COUIsTUFBcEIsR0FBNkIxb0IsSUFBSSxDQUFDcTRCLGVBQUwsQ0FBcUIsQ0FBQ3BMLFdBQVcsQ0FBQ3pDLE9BQVosQ0FBb0I5QixNQUFyQixDQUFyQixFQUFtRDhCLE9BQWhGO0FBQ0g7O0FBRUQsVUFBSXlDLFdBQVcsQ0FBQ3pDLE9BQVosQ0FBb0Jsb0IsTUFBcEIsSUFBOEIsRUFBRTJxQixXQUFXLENBQUN6QyxPQUFaLENBQW9CbG9CLE1BQXBCLFlBQXNDb1IsUUFBTyxDQUFDMlYsYUFBaEQsQ0FBbEMsRUFBa0c7QUFDOUY0RCxtQkFBVyxDQUFDekMsT0FBWixDQUFvQmxvQixNQUFwQixHQUE2QnRDLElBQUksQ0FBQ3M0QixlQUFMLENBQXFCLENBQUNyTCxXQUFXLENBQUN6QyxPQUFaLENBQW9CbG9CLE1BQXJCLENBQXJCLEVBQW1Ea29CLE9BQWhGO0FBQ0g7O0FBRUQsVUFBSXlDLFdBQVcsQ0FBQ3pDLE9BQVosQ0FBb0I5aEIsTUFBcEIsSUFBOEIsRUFBRXVrQixXQUFXLENBQUN6QyxPQUFaLENBQW9COWhCLE1BQXBCLFlBQXNDZ0wsUUFBTyxDQUFDa1YsYUFBaEQsQ0FBbEMsRUFBa0c7QUFDOUZxRSxtQkFBVyxDQUFDekMsT0FBWixDQUFvQjloQixNQUFwQixHQUE2QjFJLElBQUksQ0FBQ3d2QixlQUFMLENBQXFCLENBQUN2QyxXQUFXLENBQUN6QyxPQUFaLENBQW9COWhCLE1BQXJCLENBQXJCLEVBQW1EOGhCLE9BQWhGO0FBQ0g7O0FBRUQsVUFBSXlDLFdBQVcsQ0FBQ3pDLE9BQVosQ0FBb0JocEIsSUFBcEIsSUFBNEIsRUFBRXlyQixXQUFXLENBQUN6QyxPQUFaLENBQW9CaHBCLElBQXBCLFlBQW9Da1MsUUFBTyxDQUFDcVYsV0FBOUMsQ0FBaEMsRUFBNEY7QUFDeEZrRSxtQkFBVyxDQUFDekMsT0FBWixDQUFvQmhwQixJQUFwQixHQUEyQnhCLElBQUksQ0FBQ3l2QixhQUFMLENBQW1CLENBQUN4QyxXQUFXLENBQUN6QyxPQUFaLENBQW9CaHBCLElBQXJCLENBQW5CLEVBQStDZ3BCLE9BQTFFO0FBQ0g7O0FBRUQsVUFBSXlDLFdBQVcsQ0FBQ3pDLE9BQVosQ0FBb0I3QixZQUFwQixJQUFvQyxFQUFFc0UsV0FBVyxDQUFDekMsT0FBWixDQUFvQjdCLFlBQXBCLFlBQTRDalYsUUFBTyxDQUFDNFYsbUJBQXRELENBQXhDLEVBQW9IO0FBQ2hIMkQsbUJBQVcsQ0FBQ3pDLE9BQVosQ0FBb0I3QixZQUFwQixHQUFtQzNvQixJQUFJLENBQUN1NEIscUJBQUwsQ0FBMkIsQ0FBQ3RMLFdBQVcsQ0FBQ3pDLE9BQVosQ0FBb0I3QixZQUFyQixDQUEzQixFQUErRDZCLE9BQWxHO0FBQ0g7O0FBRUR5QyxpQkFBVyxHQUFHanRCLElBQUksQ0FBQ3VpQixXQUFMLENBQWlCLDhCQUFqQixFQUFpRDBLLFdBQWpELEVBQThEeHVCLFNBQTlELENBQWQ7QUFFQWtWLE9BQUMsQ0FBQ2tOLE1BQUYsQ0FBU29NLFdBQVQ7QUFFQSxhQUFPQSxXQUFQO0FBQ0gsS0FucEVMOztBQXFwRUk7Ozs7Ozs7QUFRQXVDLG1CQUFlLEVBQUUseUJBQVNycEIsSUFBVCxFQUFlO0FBQzVCLFVBQUluRyxJQUFJLEdBQVUsSUFBbEI7QUFBQSxVQUNJaXRCLFdBQVcsR0FBRyxJQUFJdlosUUFBTyxDQUFDeWtCLGVBQVosRUFEbEI7QUFBQSxVQUVJcmpCLEdBQUcsR0FBVyxJQUZsQjtBQUFBLFVBR0lsWCxDQUFDLEdBQWEsQ0FBQyxDQUhuQjtBQUtBcXZCLGlCQUFXLENBQUNtTCxPQUFaLEdBQXNCcDRCLElBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0J6akIsTUFBNUM7QUFDQStvQixpQkFBVyxDQUFDekMsT0FBWixHQUFzQixJQUFJOVcsUUFBTyxDQUFDa1YsYUFBWixFQUF0Qjs7QUFFQSxXQUFLaHJCLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR3VJLElBQUksQ0FBQ3RJLE1BQXJCLEVBQTZCRCxDQUFDLEVBQTlCLEVBQWtDO0FBQzlCa1gsV0FBRyxHQUFHM08sSUFBSSxDQUFDdkksQ0FBRCxDQUFWOztBQUVBLFlBQUksT0FBT2tYLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUN6QjtBQUVBbVkscUJBQVcsQ0FBQ3pDLE9BQVosQ0FBb0I1bkIsUUFBcEIsR0FBK0JrUyxHQUEvQjtBQUNILFNBSkQsTUFJTyxJQUFJQSxHQUFHLEtBQUssSUFBWixFQUFrQjtBQUNyQm1ZLHFCQUFXLENBQUN6QyxPQUFaLENBQW9CM0IsVUFBcEIsR0FBaUMsRUFBakM7QUFDSCxTQUZNLE1BRUEsSUFBSSxRQUFPL1QsR0FBUCxNQUFlLFFBQWYsSUFBMkJuQixDQUFDLENBQUM0QyxTQUFGLENBQVl6QixHQUFaLEVBQWlCOVUsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBUzNoQixRQUExQixDQUEvQixFQUFvRTtBQUN2RTtBQUVBa2tCLHFCQUFXLENBQUN6QyxPQUFaLENBQW9CM0IsVUFBcEIsR0FBaUMsQ0FBQy9ULEdBQUQsQ0FBakM7QUFDSCxTQUpNLE1BSUEsSUFBSSxRQUFPQSxHQUFQLE1BQWUsUUFBZixJQUEyQixPQUFPQSxHQUFHLENBQUNqWCxNQUFYLEtBQXNCLFdBQXJELEVBQWtFO0FBQ3JFO0FBRUFvdkIscUJBQVcsQ0FBQ3pDLE9BQVosQ0FBb0IzQixVQUFwQixHQUFpQ2xWLENBQUMsQ0FBQ29JLGFBQUYsQ0FBZ0JqSCxHQUFoQixDQUFqQztBQUNILFNBSk0sTUFJQSxJQUFJLFFBQU9BLEdBQVAsTUFBZSxRQUFuQixFQUE2QjtBQUNoQztBQUVBbkIsV0FBQyxDQUFDdUUsTUFBRixDQUFTK1UsV0FBVyxDQUFDekMsT0FBckIsRUFBOEIxVixHQUE5QjtBQUNILFNBSk0sTUFJQSxJQUFJLE9BQU9BLEdBQVAsS0FBZSxTQUFuQixFQUE4QjtBQUNqQ21ZLHFCQUFXLENBQUNtTCxPQUFaLEdBQXNCdGpCLEdBQXRCO0FBQ0gsU0FGTSxNQUVBLElBQUksT0FBT0EsR0FBUCxLQUFlLFVBQW5CLEVBQStCO0FBQ2xDbVkscUJBQVcsQ0FBQzllLFFBQVosR0FBdUIyRyxHQUF2QjtBQUNIO0FBQ0o7O0FBRUQsVUFBSW1ZLFdBQVcsQ0FBQ3pDLE9BQVosQ0FBb0I1bkIsUUFBcEIsSUFBZ0NxcUIsV0FBVyxDQUFDekMsT0FBWixDQUFvQjNCLFVBQXhELEVBQW9FO0FBQ2hFLGNBQU0sSUFBSXJTLEtBQUosQ0FBVTlDLFFBQU8sQ0FBQytDLFFBQVIsQ0FBaUIraEIsMkJBQWpCLEVBQVYsQ0FBTjtBQUNIOztBQUVEdkwsaUJBQVcsR0FBR2p0QixJQUFJLENBQUN1aUIsV0FBTCxDQUFpQiw0QkFBakIsRUFBK0MwSyxXQUEvQyxFQUE0RHh1QixTQUE1RCxDQUFkO0FBRUFrVixPQUFDLENBQUNrTixNQUFGLENBQVNvTSxXQUFUO0FBRUEsYUFBT0EsV0FBUDtBQUNILEtBM3NFTDtBQTZzRUl3QyxpQkFBYSxFQUFFLHVCQUFTdHBCLElBQVQsRUFBZTtBQUMxQixVQUFJbkcsSUFBSSxHQUFVLElBQWxCO0FBQUEsVUFDSWl0QixXQUFXLEdBQUcsSUFBSXZaLFFBQU8sQ0FBQ3lrQixlQUFaLEVBRGxCO0FBQUEsVUFFSXJqQixHQUFHLEdBQVcsSUFGbEI7QUFBQSxVQUdJa1UsVUFBVSxHQUFJLEVBSGxCO0FBQUEsVUFJSXByQixDQUFDLEdBQWEsQ0FBQyxDQUpuQjtBQU1BcXZCLGlCQUFXLENBQUNtTCxPQUFaLEdBQXNCcDRCLElBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0J6akIsTUFBNUM7QUFDQStvQixpQkFBVyxDQUFDekMsT0FBWixHQUFzQixJQUFJOVcsUUFBTyxDQUFDcVYsV0FBWixFQUF0Qjs7QUFFQSxXQUFLbnJCLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR3VJLElBQUksQ0FBQ3RJLE1BQXJCLEVBQTZCRCxDQUFDLEVBQTlCLEVBQWtDO0FBQzlCa1gsV0FBRyxHQUFHM08sSUFBSSxDQUFDdkksQ0FBRCxDQUFWO0FBRUEsWUFBSWtYLEdBQUcsS0FBSyxJQUFaLEVBQWtCOztBQUVsQix3QkFBZUEsR0FBZjtBQUNJLGVBQUssUUFBTDtBQUNJO0FBRUFrVSxzQkFBVSxHQUFHbFUsR0FBYjtBQUVBOztBQUNKLGVBQUssUUFBTDtBQUNJO0FBRUEsZ0JBQUlBLEdBQUcsQ0FBQ2pYLE1BQVIsRUFBZ0I7QUFDWm92Qix5QkFBVyxDQUFDekMsT0FBWixDQUFvQjNCLFVBQXBCLEdBQWlDbFYsQ0FBQyxDQUFDb0ksYUFBRixDQUFnQmpILEdBQWhCLENBQWpDO0FBQ0g7O0FBRUQ7O0FBQ0osZUFBSyxTQUFMO0FBQ0ltWSx1QkFBVyxDQUFDbUwsT0FBWixHQUFzQnRqQixHQUF0QjtBQUVBOztBQUNKLGVBQUssVUFBTDtBQUNJbVksdUJBQVcsQ0FBQzllLFFBQVosR0FBdUIyRyxHQUF2QjtBQUVBO0FBdEJSO0FBd0JIOztBQUVELFVBQUlrVSxVQUFKLEVBQWdCO0FBQ1ppRSxtQkFBVyxDQUFDekMsT0FBWixHQUFzQnhxQixJQUFJLENBQUNnekIsZUFBTCxDQUFxQmhLLFVBQXJCLEVBQWlDaUUsV0FBVyxDQUFDekMsT0FBN0MsQ0FBdEI7QUFDSDs7QUFFRHlDLGlCQUFXLEdBQUdqdEIsSUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIsMEJBQWpCLEVBQTZDMEssV0FBN0MsRUFBMER4dUIsU0FBMUQsQ0FBZDtBQUVBa1YsT0FBQyxDQUFDa04sTUFBRixDQUFTb00sV0FBVDtBQUVBLGFBQU9BLFdBQVA7QUFDSCxLQS92RUw7O0FBaXdFSTs7Ozs7OztBQVFBb0wsbUJBQWUsRUFBRSx5QkFBU2x5QixJQUFULEVBQWU7QUFDNUIsVUFBSW5HLElBQUksR0FBVSxJQUFsQjtBQUFBLFVBQ0lpdEIsV0FBVyxHQUFHLElBQUl2WixRQUFPLENBQUN5a0IsZUFBWixFQURsQjtBQUFBLFVBRUlyakIsR0FBRyxHQUFXLElBRmxCO0FBQUEsVUFHSWxYLENBQUMsR0FBYSxDQUFDLENBSG5CO0FBS0FxdkIsaUJBQVcsQ0FBQ21MLE9BQVosR0FBc0JwNEIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQnpqQixNQUE1QztBQUNBK29CLGlCQUFXLENBQUN6QyxPQUFaLEdBQXNCLElBQUk5VyxRQUFPLENBQUMwVixhQUFaLEVBQXRCOztBQUVBLFdBQUt4ckIsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHdUksSUFBSSxDQUFDdEksTUFBckIsRUFBNkJELENBQUMsRUFBOUIsRUFBa0M7QUFDOUJrWCxXQUFHLEdBQUczTyxJQUFJLENBQUN2SSxDQUFELENBQVY7QUFFQSxZQUFJa1gsR0FBRyxLQUFLLElBQVosRUFBa0I7O0FBRWxCLFlBQUksT0FBT0EsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQ3pCO0FBRUFtWSxxQkFBVyxDQUFDekMsT0FBWixDQUFvQnBvQixLQUFwQixHQUE0QjBTLEdBQTVCO0FBQ0gsU0FKRCxNQUlPLElBQUksT0FBT0EsR0FBUCxLQUFlLFFBQWYsSUFBMkIsQ0FBQyxRQUFELEVBQVcsT0FBWCxFQUFvQjNILE9BQXBCLENBQTRCMkgsR0FBNUIsSUFBbUMsQ0FBQyxDQUFuRSxFQUFzRTtBQUN6RTtBQUVBbVkscUJBQVcsQ0FBQ3pDLE9BQVosQ0FBb0JwTyxRQUFwQixHQUErQnRILEdBQS9CO0FBQ0gsU0FKTSxNQUlBLElBQUksT0FBT0EsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQ2hDO0FBRUFtWSxxQkFBVyxDQUFDekMsT0FBWixDQUFvQjNCLFVBQXBCLEdBQ0lsVixDQUFDLENBQUNvSSxhQUFGLENBQWdCcEksQ0FBQyxDQUFDRyxhQUFGLENBQWdCZ0IsR0FBaEIsRUFBcUJpZSxVQUFyQyxDQURKO0FBRUgsU0FMTSxNQUtBLElBQUksUUFBT2plLEdBQVAsTUFBZSxRQUFmLElBQTJCbkIsQ0FBQyxDQUFDNEMsU0FBRixDQUFZekIsR0FBWixFQUFpQjlVLElBQUksQ0FBQzBxQixHQUFMLENBQVMzaEIsUUFBMUIsQ0FBL0IsRUFBb0U7QUFDdkU7QUFFQSxXQUFDa2tCLFdBQVcsQ0FBQ3pDLE9BQVosQ0FBb0IzQixVQUFwQixDQUErQmhyQixNQUFoQyxHQUNLb3ZCLFdBQVcsQ0FBQ3pDLE9BQVosQ0FBb0IzQixVQUFwQixHQUFpQyxDQUFDL1QsR0FBRCxDQUR0QyxHQUVLbVksV0FBVyxDQUFDekMsT0FBWixDQUFvQmxnQixPQUFwQixHQUE4QndLLEdBRm5DO0FBR0gsU0FOTSxNQU1BLElBQUksUUFBT0EsR0FBUCxNQUFlLFFBQWYsSUFBMkJBLEdBQUcsQ0FBQ2pYLE1BQW5DLEVBQTJDO0FBQzlDO0FBRUEsV0FBQ292QixXQUFXLENBQUN6QyxPQUFaLENBQW9CM0IsVUFBcEIsQ0FBK0JockIsTUFBaEMsR0FDS292QixXQUFXLENBQUN6QyxPQUFaLENBQW9CM0IsVUFBcEIsR0FBaUMvVCxHQUR0QyxHQUVJbVksV0FBVyxDQUFDekMsT0FBWixDQUFvQmxnQixPQUFwQixHQUE4QndLLEdBQUcsQ0FBQyxDQUFELENBRnJDO0FBR0gsU0FOTSxNQU1BLElBQUksUUFBT0EsR0FBUCxNQUFlLFFBQWYsSUFBMkJBLEdBQUcsQ0FBQ2llLFVBQS9CLElBQTZDamUsR0FBRyxDQUFDaWUsVUFBSixDQUFlbDFCLE1BQWhFLEVBQXdFO0FBQzNFO0FBRUEsV0FBQ292QixXQUFXLENBQUN6QyxPQUFaLENBQW9CM0IsVUFBcEIsQ0FBK0JockIsTUFBaEMsR0FDSW92QixXQUFXLENBQUN6QyxPQUFaLENBQW9CM0IsVUFBcEIsR0FBaUNsVixDQUFDLENBQUNvSSxhQUFGLENBQWdCakgsR0FBRyxDQUFDaWUsVUFBcEIsQ0FEckMsR0FFSTlGLFdBQVcsQ0FBQ3pDLE9BQVosQ0FBb0JsZ0IsT0FBcEIsR0FBOEJ3SyxHQUFHLENBQUNpZSxVQUFKLENBQWUsQ0FBZixDQUZsQztBQUdILFNBTk0sTUFNQSxJQUFJLFFBQU9qZSxHQUFQLE1BQWUsUUFBbkIsRUFBNkI7QUFDaEM7QUFFQW5CLFdBQUMsQ0FBQ3VFLE1BQUYsQ0FBUytVLFdBQVcsQ0FBQ3pDLE9BQXJCLEVBQThCMVYsR0FBOUI7QUFDSCxTQUpNLE1BSUEsSUFBSSxPQUFPQSxHQUFQLEtBQWUsU0FBbkIsRUFBOEI7QUFDakNtWSxxQkFBVyxDQUFDbUwsT0FBWixHQUFzQnRqQixHQUF0QjtBQUNILFNBRk0sTUFFQSxJQUFJLE9BQU9BLEdBQVAsS0FBZSxVQUFuQixFQUErQjtBQUNsQ21ZLHFCQUFXLENBQUM5ZSxRQUFaLEdBQXVCMkcsR0FBdkI7QUFDSDtBQUNKOztBQUVELFVBQUltWSxXQUFXLENBQUN6QyxPQUFaLENBQW9CcG9CLEtBQXBCLElBQTZCNnFCLFdBQVcsQ0FBQ3pDLE9BQVosQ0FBb0JsZ0IsT0FBckQsRUFBOEQ7QUFDMUQsY0FBTSxJQUFJa00sS0FBSixDQUFVOUMsUUFBTyxDQUFDK0MsUUFBUixDQUFpQmdpQiwyQkFBakIsRUFBVixDQUFOO0FBQ0g7O0FBRUQsVUFBSSxDQUFDeEwsV0FBVyxDQUFDekMsT0FBWixDQUFvQjNCLFVBQXBCLENBQStCaHJCLE1BQWhDLElBQTBDbUMsSUFBSSxDQUFDK1YsTUFBTCxDQUFZZSxLQUFaLENBQWtCQyxZQUFoRSxFQUE4RTtBQUMxRW5hLGVBQU8sQ0FBQ0YsSUFBUixDQUFhZ1gsUUFBTyxDQUFDK0MsUUFBUixDQUFpQmlpQix1QkFBakIsRUFBYjtBQUNIOztBQUVEekwsaUJBQVcsR0FBR2p0QixJQUFJLENBQUN1aUIsV0FBTCxDQUFpQiw0QkFBakIsRUFBK0MwSyxXQUEvQyxFQUE0RHh1QixTQUE1RCxDQUFkO0FBRUFrVixPQUFDLENBQUNrTixNQUFGLENBQVNvTSxXQUFUO0FBRUEsYUFBT0EsV0FBUDtBQUNILEtBOTBFTDs7QUFnMUVJOzs7Ozs7O0FBUUFxTCxtQkFBZSxFQUFFLHlCQUFTbnlCLElBQVQsRUFBZTtBQUM1QixVQUFJbkcsSUFBSSxHQUFVLElBQWxCO0FBQUEsVUFDSWl0QixXQUFXLEdBQUcsSUFBSXZaLFFBQU8sQ0FBQ3lrQixlQUFaLEVBRGxCO0FBQUEsVUFFSXo2QixNQUFNLEdBQVEsSUFGbEI7QUFBQSxVQUdJb1gsR0FBRyxHQUFXLElBSGxCO0FBQUEsVUFJSWxYLENBQUMsR0FBYSxDQUFDLENBSm5CO0FBTUFxdkIsaUJBQVcsQ0FBQ21MLE9BQVosR0FBc0JwNEIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQnpqQixNQUE1QztBQUNBK29CLGlCQUFXLENBQUN6QyxPQUFaLEdBQXNCLElBQUk5VyxRQUFPLENBQUMyVixhQUFaLEVBQXRCOztBQUVBLFdBQUt6ckIsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHdUksSUFBSSxDQUFDdEksTUFBckIsRUFBNkJELENBQUMsRUFBOUIsRUFBa0M7QUFDOUJrWCxXQUFHLEdBQUczTyxJQUFJLENBQUN2SSxDQUFELENBQVY7QUFFQSxZQUFJa1gsR0FBRyxLQUFLLElBQVosRUFBa0I7O0FBRWxCLHdCQUFlQSxHQUFmO0FBQ0ksZUFBSyxRQUFMO0FBQ0ksZ0JBQUk5VSxJQUFJLENBQUNvb0IsT0FBTCxDQUFhdFQsR0FBYixDQUFKLEVBQXVCO0FBQ25CbVkseUJBQVcsQ0FBQ3pDLE9BQVosQ0FBb0JwQyxPQUFwQixDQUE0QixDQUE1QixJQUFpQ3BvQixJQUFJLENBQUNvb0IsT0FBTCxDQUFhdFQsR0FBYixDQUFqQztBQUNIOztBQUVEOztBQUNKLGVBQUssUUFBTDtBQUNJbVksdUJBQVcsQ0FBQ3pDLE9BQVosQ0FBb0IzQixVQUFwQixHQUFpQ2xWLENBQUMsQ0FBQ29JLGFBQUYsQ0FBZ0IvYixJQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0IrUixnQkFBaEIsQ0FBaUMwRCxHQUFqQyxDQUFoQixDQUFqQztBQUVBOztBQUNKLGVBQUssUUFBTDtBQUNJLGdCQUFJQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ2pYLE1BQWYsRUFBdUI7QUFDbkJvdkIseUJBQVcsQ0FBQ3pDLE9BQVosQ0FBb0IzQixVQUFwQixHQUFpQy9ULEdBQWpDO0FBQ0gsYUFGRCxNQUVPLElBQUluQixDQUFDLENBQUM0QyxTQUFGLENBQVl6QixHQUFaLEVBQWlCOVUsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBUzNoQixRQUExQixDQUFKLEVBQXlDO0FBQzVDa2tCLHlCQUFXLENBQUN6QyxPQUFaLENBQW9CM0IsVUFBcEIsR0FBaUMsQ0FBQy9ULEdBQUQsQ0FBakM7QUFDSCxhQUZNLE1BRUE7QUFDSDtBQUVBbkIsZUFBQyxDQUFDdUUsTUFBRixDQUFTK1UsV0FBVyxDQUFDekMsT0FBckIsRUFBOEIxVixHQUE5QjtBQUNIOztBQUVEOztBQUNKLGVBQUssU0FBTDtBQUNJbVksdUJBQVcsQ0FBQ21MLE9BQVosR0FBc0J0akIsR0FBdEI7QUFFQTs7QUFDSixlQUFLLFVBQUw7QUFDSW1ZLHVCQUFXLENBQUM5ZSxRQUFaLEdBQXVCMkcsR0FBdkI7QUFFQTtBQTlCUjtBQWdDSDs7QUFFRCxVQUFJbVksV0FBVyxDQUFDekMsT0FBWixDQUFvQjNCLFVBQXBCLENBQStCaHJCLE1BQW5DLEVBQTJDO0FBQ3ZDLGFBQUtELENBQUMsR0FBRyxDQUFULEVBQVlGLE1BQU0sR0FBR3NDLElBQUksQ0FBQ29vQixPQUFMLENBQWF4cUIsQ0FBYixDQUFyQixFQUFzQ0EsQ0FBQyxFQUF2QyxFQUEyQztBQUN2QyxjQUFJcXZCLFdBQVcsQ0FBQ3pDLE9BQVosQ0FBb0IzQixVQUFwQixDQUErQjFiLE9BQS9CLENBQXVDelAsTUFBTSxDQUFDZ3RCLEdBQVAsQ0FBV3plLEVBQWxELElBQXdELENBQUMsQ0FBN0QsRUFBZ0U7QUFDNURnaEIsdUJBQVcsQ0FBQ3pDLE9BQVosQ0FBb0JwQyxPQUFwQixDQUE0Qi9sQixJQUE1QixDQUFpQzNFLE1BQWpDO0FBQ0g7QUFDSjtBQUNKOztBQUVELFVBQUksQ0FBQ3V2QixXQUFXLENBQUN6QyxPQUFaLENBQW9CcEMsT0FBcEIsQ0FBNEJ2cUIsTUFBN0IsSUFBdUNtQyxJQUFJLENBQUMrVixNQUFMLENBQVllLEtBQVosQ0FBa0JDLFlBQTdELEVBQTJFO0FBQ3ZFbmEsZUFBTyxDQUFDRixJQUFSLENBQWFnWCxRQUFPLENBQUMrQyxRQUFSLENBQWlCa2lCLHVCQUFqQixFQUFiO0FBQ0g7O0FBRURobEIsT0FBQyxDQUFDa04sTUFBRixDQUFTb00sV0FBVDtBQUVBLGFBQU9BLFdBQVA7QUFDSCxLQXg1RUw7O0FBMDVFSTs7Ozs7OztBQVFBMkwsb0JBQWdCLEVBQUUsMEJBQVN6eUIsSUFBVCxFQUFlO0FBQzdCLFVBQUluRyxJQUFJLEdBQVUsSUFBbEI7QUFBQSxVQUNJaXRCLFdBQVcsR0FBRyxJQUFJdlosUUFBTyxDQUFDeWtCLGVBQVosRUFEbEI7QUFBQSxVQUVJcmpCLEdBQUcsR0FBVyxJQUZsQjtBQUFBLFVBR0lsWCxDQUFDLEdBQWEsQ0FBQyxDQUhuQjtBQUtBcXZCLGlCQUFXLENBQUNtTCxPQUFaLEdBQXNCcDRCLElBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0J6akIsTUFBNUM7QUFDQStvQixpQkFBVyxDQUFDekMsT0FBWixHQUFzQixJQUFJOVcsUUFBTyxDQUFDOFUsY0FBWixFQUF0Qjs7QUFFQSxXQUFLNXFCLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR3VJLElBQUksQ0FBQ3RJLE1BQXJCLEVBQTZCRCxDQUFDLEVBQTlCLEVBQWtDO0FBQzlCa1gsV0FBRyxHQUFHM08sSUFBSSxDQUFDdkksQ0FBRCxDQUFWO0FBRUEsWUFBSWtYLEdBQUcsS0FBSyxJQUFaLEVBQWtCOztBQUVsQix3QkFBZUEsR0FBZjtBQUNJLGVBQUssUUFBTDtBQUNJLGdCQUFJbFUsS0FBSyxDQUFDRCxPQUFOLENBQWNtVSxHQUFkLEtBQXNCLE9BQU9BLEdBQUcsQ0FBQ2pYLE1BQVgsS0FBc0IsUUFBaEQsRUFBMEQ7QUFDdERvdkIseUJBQVcsQ0FBQ3pDLE9BQVosQ0FBb0JsRCxPQUFwQixHQUE4QnhTLEdBQTlCO0FBQ0gsYUFGRCxNQUVPO0FBQ0g7QUFFQW5CLGVBQUMsQ0FBQ3VFLE1BQUYsQ0FBUytVLFdBQVcsQ0FBQ3pDLE9BQXJCLEVBQThCMVYsR0FBOUI7QUFDSDs7QUFFRDs7QUFDSixlQUFLLFNBQUw7QUFDSW1ZLHVCQUFXLENBQUNtTCxPQUFaLEdBQXNCdGpCLEdBQXRCO0FBRUE7O0FBQ0osZUFBSyxVQUFMO0FBQ0ltWSx1QkFBVyxDQUFDOWUsUUFBWixHQUF1QjJHLEdBQXZCO0FBRUE7QUFsQlI7QUFvQkg7O0FBRURuQixPQUFDLENBQUNrTixNQUFGLENBQVNvTSxXQUFUO0FBRUEsYUFBT0EsV0FBUDtBQUNILEtBejhFTDs7QUEyOEVJOzs7Ozs7O0FBUUFzTCx5QkFBcUIsRUFBRSwrQkFBU3B5QixJQUFULEVBQWU7QUFDbEMsVUFBSW5HLElBQUksR0FBVSxJQUFsQjtBQUFBLFVBQ0lpdEIsV0FBVyxHQUFHLElBQUl2WixRQUFPLENBQUN5a0IsZUFBWixFQURsQjtBQUFBLFVBRUlyakIsR0FBRyxHQUFXLElBRmxCO0FBQUEsVUFHSWxYLENBQUMsR0FBYSxDQUFDLENBSG5CO0FBS0FxdkIsaUJBQVcsQ0FBQ21MLE9BQVosR0FBc0JwNEIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQnpqQixNQUE1QztBQUNBK29CLGlCQUFXLENBQUN6QyxPQUFaLEdBQXNCLElBQUk5VyxRQUFPLENBQUM0VixtQkFBWixFQUF0Qjs7QUFFQSxXQUFLMXJCLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR3VJLElBQUksQ0FBQ3RJLE1BQXJCLEVBQTZCRCxDQUFDLEVBQTlCLEVBQWtDO0FBQzlCa1gsV0FBRyxHQUFHM08sSUFBSSxDQUFDdkksQ0FBRCxDQUFWO0FBRUEsWUFBSWtYLEdBQUcsS0FBSyxJQUFaLEVBQWtCOztBQUVsQix3QkFBZUEsR0FBZjtBQUNJLGVBQUssUUFBTDtBQUNJbVksdUJBQVcsQ0FBQ3pDLE9BQVosQ0FBb0J0RCxrQkFBcEIsR0FBeUNwUyxHQUF6QztBQUVBOztBQUNKLGVBQUssUUFBTDtBQUNJO0FBRUFuQixhQUFDLENBQUN1RSxNQUFGLENBQVMrVSxXQUFXLENBQUN6QyxPQUFyQixFQUE4QjFWLEdBQTlCO0FBRUE7O0FBQ0osZUFBSyxTQUFMO0FBQ0ltWSx1QkFBVyxDQUFDbUwsT0FBWixHQUFzQnRqQixHQUF0QjtBQUVBOztBQUNKLGVBQUssVUFBTDtBQUNJbVksdUJBQVcsQ0FBQzllLFFBQVosR0FBdUIyRyxHQUF2QjtBQUVBO0FBbEJSO0FBb0JIOztBQUVEbkIsT0FBQyxDQUFDa04sTUFBRixDQUFTb00sV0FBVDtBQUVBLGFBQU9BLFdBQVA7QUFDSCxLQTEvRUw7O0FBNC9FSTs7Ozs7OztBQVFBNEwsWUFBUSxFQUFFLGtCQUFTQyxTQUFULEVBQW9CO0FBQzFCLFVBQUk5NEIsSUFBSSxHQUFjLElBQXRCO0FBQUEsVUFDSXllLFFBQVEsR0FBVSxJQUR0QjtBQUFBLFVBRUlzUyxjQUFjLEdBQUksRUFGdEI7QUFJQS93QixVQUFJLENBQUNzWCxXQUFMLENBQWlCLGdCQUFqQixFQUFtQzdZLFNBQW5DO0FBRUFnZ0IsY0FBUSxHQUFHOUssQ0FBQyxDQUFDNkssS0FBRixDQUFROUssUUFBTyxDQUFDaUUsU0FBaEIsQ0FBWDs7QUFFQSxVQUFJM1gsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQi9DLEtBQXRCLElBQStCNWtCLElBQUksQ0FBQzRrQixLQUFMLENBQVcvbUIsTUFBWCxHQUFvQm1DLElBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0I5QyxVQUE3RSxFQUF5RjtBQUNyRmlVLGlCQUFTLENBQUNyYSxRQUFWLEdBQXFCQSxRQUFyQjtBQUVBemUsWUFBSSxDQUFDNGtCLEtBQUwsQ0FBV3ZpQixJQUFYLENBQWdCeTJCLFNBQWhCLEVBSHFGLENBS3JGOztBQUVBLFlBQUk5NEIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNUQsUUFBWixDQUFxQmpPLE1BQXpCLEVBQWlDO0FBQzdCLGNBQUlsRSxJQUFJLENBQUNtdEIsVUFBVCxFQUFxQjtBQUNqQm50QixnQkFBSSxDQUFDeXVCLGdCQUFMLENBQXNCcUssU0FBUyxDQUFDN0wsV0FBVixDQUFzQnpDLE9BQTVDO0FBRUF1RywwQkFBYyxHQUFHL3dCLElBQUksQ0FBQzZ3QixpQkFBTCxFQUFqQjtBQUVBN3dCLGdCQUFJLENBQUMwdUIsY0FBTCxDQUFvQjtBQUNoQmhtQixvQkFBTSxFQUFFO0FBQ0o5Rix3QkFBUSxFQUFFbXVCO0FBRE47QUFEUSxhQUFwQjtBQUtILFdBVkQsTUFVTztBQUNIL3dCLGdCQUFJLENBQUMwdUIsY0FBTCxDQUFvQm9LLFNBQVMsQ0FBQzdMLFdBQVYsQ0FBc0J6QyxPQUExQztBQUNIO0FBQ0o7QUFDSixPQXRCRCxNQXNCTztBQUNILFlBQUl4cUIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZZSxLQUFaLENBQWtCQyxZQUF0QixFQUFvQztBQUNoQ25hLGlCQUFPLENBQUNGLElBQVIsQ0FBYWdYLFFBQU8sQ0FBQytDLFFBQVIsQ0FBaUJzaUIsZ0NBQWpCLEVBQWI7QUFDSDs7QUFFRHRhLGdCQUFRLENBQUM1UixPQUFULENBQWlCN00sSUFBSSxDQUFDNnFCLEtBQXRCOztBQUVBblgsZ0JBQU8sQ0FBQzFTLE1BQVIsQ0FBZTRwQixJQUFmLENBQW9CLFNBQXBCLEVBQStCNXFCLElBQUksQ0FBQzBxQixHQUFMLENBQVM1VSxTQUF4QyxFQUFtRDtBQUMvQytVLGVBQUssRUFBRTdxQixJQUFJLENBQUM2cUIsS0FEbUM7QUFFL0N4dEIsa0JBQVEsRUFBRTJDO0FBRnFDLFNBQW5ELEVBR0dBLElBQUksQ0FBQzBxQixHQUFMLENBQVMzaEIsUUFIWjs7QUFLQSxZQUFJLE9BQU8vSSxJQUFJLENBQUMrVixNQUFMLENBQVk4UixTQUFaLENBQXNCcEMsU0FBN0IsS0FBMkMsVUFBL0MsRUFBMkQ7QUFDdkR6bEIsY0FBSSxDQUFDK1YsTUFBTCxDQUFZOFIsU0FBWixDQUFzQnBDLFNBQXRCLENBQWdDN21CLElBQWhDLENBQXFDb0IsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBUzVVLFNBQTlDLEVBQXlEOVYsSUFBSSxDQUFDNnFCLEtBQTlELEVBQXFFN3FCLElBQXJFO0FBQ0g7QUFDSjs7QUFFRCxhQUFPQSxJQUFJLENBQUN1aUIsV0FBTCxDQUFpQixpQkFBakIsRUFBb0M5RCxRQUFRLENBQUNNLE9BQTdDLEVBQXNEdGdCLFNBQXRELENBQVA7QUFDSCxLQXJqRkw7O0FBdWpGSTs7Ozs7OztBQVFBdTZCLG9CQUFnQixFQUFFLDBCQUFTN0osVUFBVCxFQUFxQjtBQUNuQyxVQUFJbnZCLElBQUksR0FBa0IsSUFBMUI7QUFBQSxVQUNJOHVCLFNBQVMsR0FBYSxJQUFJcGIsUUFBTyxDQUFDcWIsU0FBWixFQUQxQjtBQUFBLFVBRUlHLFlBQVksR0FBVSxFQUYxQjtBQUlBSixlQUFTLEdBQUc5dUIsSUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIsbUNBQWpCLEVBQXNEdU0sU0FBdEQsRUFBaUVyd0IsU0FBakUsQ0FBWjs7QUFFQSxVQUFJdUIsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3RDLE9BQVQsQ0FBaUJ2cUIsTUFBakIsSUFBMkIsQ0FBQyxDQUFDcXhCLFlBQVksR0FBSWx2QixJQUFJLENBQUM2cUIsS0FBTCxDQUFXdUUsYUFBWCxJQUE0QixFQUE3QyxFQUFrRHZ4QixNQUFsRixFQUEwRjtBQUN0RixjQUFNLElBQUkyWSxLQUFKLENBQVU5QyxRQUFPLENBQUMrQyxRQUFSLENBQWlCd2lCLGtCQUFqQixFQUFWLENBQU47QUFDSDs7QUFFRG5LLGVBQVMsQ0FBQ3hZLEVBQVYsR0FBMEIzQyxDQUFDLENBQUNpRCxTQUFGLEVBQTFCO0FBQ0FrWSxlQUFTLENBQUNxRixVQUFWLEdBQTBCbjBCLElBQUksQ0FBQzZxQixLQUEvQjtBQUNBaUUsZUFBUyxDQUFDSSxZQUFWLEdBQTBCQSxZQUExQjtBQUNBSixlQUFTLENBQUNLLFVBQVYsR0FBMEJBLFVBQVUsQ0FBQzFtQixLQUFYLEVBQTFCO0FBRUF6SSxVQUFJLENBQUNrNUIsWUFBTCxDQUFrQnBLLFNBQWxCO0FBRUFBLGVBQVMsQ0FBQ2lCLFVBQVYsR0FBdUIvdkIsSUFBSSxDQUFDb29CLE9BQTVCO0FBQ0EwRyxlQUFTLENBQUNnQixRQUFWLEdBQXFCaEIsU0FBUyxDQUFDUyxJQUEvQjs7QUFFQSxVQUFJdnZCLElBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0J6akIsTUFBMUIsRUFBa0M7QUFDOUJsRSxZQUFJLENBQUNnMUIsZUFBTCxDQUFxQmxHLFNBQXJCO0FBQ0E5dUIsWUFBSSxDQUFDbTJCLFFBQUwsQ0FBY3JILFNBQWQ7QUFFQUEsaUJBQVMsQ0FBQ3dGLFFBQVYsR0FBcUIzZ0IsQ0FBQyxDQUFDZ00sZ0JBQUYsQ0FBbUIzZixJQUFJLENBQUMwcUIsR0FBTCxDQUFTM2hCLFFBQTVCLENBQXJCO0FBRUEvSSxZQUFJLENBQUNvMkIsZUFBTCxDQUFxQnRILFNBQXJCO0FBQ0E5dUIsWUFBSSxDQUFDczJCLFFBQUwsQ0FBY3hILFNBQWQ7QUFDQTl1QixZQUFJLENBQUN1MkIsZUFBTCxDQUFxQnpILFNBQXJCO0FBRUE5dUIsWUFBSSxDQUFDNnVCLFlBQUw7QUFFQUMsaUJBQVMsQ0FBQzZJLFNBQVYsR0FBc0IzM0IsSUFBSSxDQUFDMjNCLFNBQUwsRUFBdEI7QUFFQTMzQixZQUFJLENBQUMyMkIsWUFBTCxDQUFrQjdILFNBQWxCO0FBQ0g7O0FBRUQ5dUIsVUFBSSxDQUFDb29CLE9BQUwsR0FBZTBHLFNBQVMsQ0FBQ1MsSUFBVixDQUFlOW1CLEtBQWYsRUFBZjtBQUVBcW1CLGVBQVMsQ0FBQ3NGLFFBQVYsR0FBcUJwMEIsSUFBSSxDQUFDb3dCLFVBQUwsQ0FBZ0J0QixTQUFoQixDQUFyQixDQXhDbUMsQ0EwQ25DO0FBQ0E7O0FBRUFsdUIsV0FBSyxDQUFDekQsU0FBTixDQUFnQmtGLElBQWhCLENBQXFCbUUsS0FBckIsQ0FBMkJ4RyxJQUFJLENBQUNvb0IsT0FBaEMsRUFBeUMwRyxTQUFTLENBQUNnRCxRQUFuRDtBQUVBaEQsZUFBUyxHQUFHOXVCLElBQUksQ0FBQ3VpQixXQUFMLENBQWlCLGlDQUFqQixFQUFvRHVNLFNBQXBELEVBQStEcndCLFNBQS9ELENBQVo7QUFFQSxhQUFPcXdCLFNBQVA7QUFDSCxLQWpuRkw7O0FBbW5GSTs7Ozs7OztBQVFBb0ssZ0JBQVksRUFBRSxzQkFBU3BLLFNBQVQsRUFBb0I7QUFDOUIsVUFBSTl1QixJQUFJLEdBQWtCLElBQTFCO0FBQUEsVUFDSW01QixrQkFBa0IsR0FBSSxFQUQxQjtBQUFBLFVBRUlDLGdCQUFnQixHQUFNLEVBRjFCO0FBQUEsVUFHSUMsZUFBZSxHQUFPLEVBSDFCO0FBQUEsVUFJSWhnQixJQUFJLEdBQWtCLElBSjFCO0FBQUEsVUFLSTNiLE1BQU0sR0FBZ0IsSUFMMUI7QUFBQSxVQU1JdU8sRUFBRSxHQUFvQixJQU4xQjtBQUFBLFVBT0k4TyxJQUFJLEdBQWtCLElBUDFCO0FBQUEsVUFRSXVlLE1BQU0sR0FBZ0IsSUFSMUI7QUFBQSxVQVNJQyxJQUFJLEdBQWtCLEVBVDFCO0FBQUEsVUFVSWpqQixFQUFFLEdBQW9CLEVBVjFCO0FBQUEsVUFXSTFZLENBQUMsR0FBcUIsQ0FBQyxDQVgzQjtBQWFBb0MsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixvQkFBakIsRUFBdUM3WSxTQUF2Qzs7QUFFQSxXQUFLYixDQUFDLEdBQUcsQ0FBVCxFQUFZeWIsSUFBSSxHQUFHeVYsU0FBUyxDQUFDSyxVQUFWLENBQXFCdnhCLENBQXJCLENBQW5CLEVBQTRDQSxDQUFDLEVBQTdDLEVBQWlEO0FBQzdDLFlBQUksUUFBUTBZLEVBQUUsR0FBRytDLElBQUksQ0FBQ3JaLElBQUksQ0FBQytWLE1BQUwsQ0FBWXNELElBQVosQ0FBaUJ1TixNQUFsQixDQUFqQixNQUFnRCxXQUFoRCxJQUErRHRRLEVBQUUsQ0FBQzFCLFFBQUgsR0FBYy9XLE1BQWQsR0FBdUIsQ0FBMUYsRUFBNkY7QUFDekYsZ0JBQU0sSUFBSU4sU0FBSixDQUFjbVcsUUFBTyxDQUFDK0MsUUFBUixDQUFpQitpQix5QkFBakIsQ0FBMkM7QUFDM0Q1UyxrQkFBTSxFQUFFNW1CLElBQUksQ0FBQytWLE1BQUwsQ0FBWXNELElBQVosQ0FBaUJ1TjtBQURrQyxXQUEzQyxDQUFkLENBQU47QUFHSDs7QUFFRCxZQUFJLENBQUMyUyxJQUFJLENBQUNqakIsRUFBRCxDQUFULEVBQWU7QUFDWGlqQixjQUFJLENBQUNqakIsRUFBRCxDQUFKLEdBQVcsSUFBWDtBQUNILFNBRkQsTUFFTztBQUNILGdCQUFNLElBQUlFLEtBQUosQ0FBVTlDLFFBQU8sQ0FBQytDLFFBQVIsQ0FBaUJnakIsd0JBQWpCLENBQTBDO0FBQ3REQyxlQUFHLEVBQUVwakI7QUFEaUQsV0FBMUMsQ0FBVixDQUFOO0FBR0g7O0FBRUQsWUFBSSxDQUFDNVksTUFBTSxHQUFHc0MsSUFBSSxDQUFDdXRCLEtBQUwsQ0FBV2pYLEVBQVgsQ0FBVixhQUFxQzVDLFFBQU8sQ0FBQzRjLE1BQWpELEVBQXlEO0FBQ3JEO0FBRUEsY0FBSXR3QixJQUFJLENBQUMrVixNQUFMLENBQVlzRCxJQUFaLENBQWlCd04sVUFBakIsSUFBK0IsQ0FBQ2xULENBQUMsQ0FBQzhILFVBQUYsQ0FBYXBDLElBQWIsRUFBbUIzYixNQUFNLENBQUMyYixJQUExQixDQUFwQyxFQUFxRTtBQUNqRTtBQUVBcE4sY0FBRSxHQUFHdk8sTUFBTSxDQUFDdXFCLE1BQVAsQ0FBYzVPLElBQWQsQ0FBTDtBQUVBM2Isa0JBQU0sQ0FBQzJiLElBQVAsR0FBY0EsSUFBZDs7QUFFQSxnQkFBSXBOLEVBQUUsS0FBS3ZPLE1BQU0sQ0FBQ2d0QixHQUFQLENBQVd6ZSxFQUF0QixFQUEwQjtBQUN0QjtBQUVBLGtCQUFJdk8sTUFBTSxDQUFDNnlCLE9BQVgsRUFBb0I7QUFDaEI3eUIsc0JBQU0sQ0FBQ2k4QixZQUFQO0FBRUEzNUIsb0JBQUksQ0FBQzBxQixHQUFMLENBQVNyckIsTUFBVCxDQUFnQnU2QixZQUFoQixDQUE2QjN0QixFQUE3QixFQUFpQ3ZPLE1BQU0sQ0FBQ2d0QixHQUFQLENBQVd6ZSxFQUE1QztBQUNIOztBQUVELGtCQUFJLENBQUN2TyxNQUFNLENBQUN5MEIsT0FBWixFQUFxQjtBQUNqQmxtQixrQkFBRSxDQUFDOUUsS0FBSCxDQUFTdXFCLE9BQVQsR0FBbUIsTUFBbkI7QUFDSDs7QUFFRGgwQixvQkFBTSxDQUFDZ3RCLEdBQVAsQ0FBV3plLEVBQVgsR0FBZ0JBLEVBQWhCOztBQUVBLGtCQUFJdk8sTUFBTSxDQUFDNnlCLE9BQVgsRUFBb0I7QUFDaEI3eUIsc0JBQU0sQ0FBQ204QixVQUFQO0FBQ0g7QUFDSjtBQUNKOztBQUVENXRCLFlBQUUsR0FBR3ZPLE1BQU0sQ0FBQ2d0QixHQUFQLENBQVd6ZSxFQUFoQjtBQUNILFNBaENELE1BZ0NPO0FBQ0g7QUFFQXZPLGdCQUFNLEdBQUcsSUFBSWdXLFFBQU8sQ0FBQzRjLE1BQVosRUFBVDtBQUVBNXlCLGdCQUFNLENBQUNxbUIsSUFBUCxDQUFZLElBQVosRUFBa0IvakIsSUFBbEIsRUFBd0JxWixJQUF4QjtBQUVBM2IsZ0JBQU0sQ0FBQzZ3QixJQUFQO0FBQ0g7O0FBRUQsWUFBSSxDQUFDN3dCLE1BQU0sQ0FBQzZ5QixPQUFaLEVBQXFCO0FBQ2pCO0FBRUEsY0FBSSxDQUFDeFYsSUFBTCxFQUFXO0FBQ1A7QUFFQUEsZ0JBQUksR0FBRy9hLElBQUksQ0FBQzBxQixHQUFMLENBQVMzaEIsUUFBVCxDQUFrQmtTLHNCQUFsQixFQUFQO0FBQ0g7O0FBRUQsY0FBSUYsSUFBSSxDQUFDK2UsZ0JBQVQsRUFBMkI7QUFDdkIvZSxnQkFBSSxDQUFDclAsV0FBTCxDQUFpQjFMLElBQUksQ0FBQzBxQixHQUFMLENBQVMzaEIsUUFBVCxDQUFrQjRvQixjQUFsQixDQUFpQyxHQUFqQyxDQUFqQjtBQUNIOztBQUVENVcsY0FBSSxDQUFDclAsV0FBTCxDQUFpQmhPLE1BQU0sQ0FBQ2d0QixHQUFQLENBQVd6ZSxFQUE1QjtBQUVBdk8sZ0JBQU0sQ0FBQzZ5QixPQUFQLEdBQWlCLElBQWpCO0FBRUE3eUIsZ0JBQU0sQ0FBQ2k4QixZQUFQO0FBQ0FqOEIsZ0JBQU0sQ0FBQ204QixVQUFQO0FBQ0FuOEIsZ0JBQU0sQ0FBQzZ3QixJQUFQO0FBRUFPLG1CQUFTLENBQUNpRCxNQUFWLENBQWlCMXZCLElBQWpCLENBQXNCM0UsTUFBdEI7QUFFQTI3Qix5QkFBZSxDQUFDaDNCLElBQWhCLENBQXFCM0UsTUFBckI7QUFDSCxTQXhCRCxNQXdCTztBQUNIO0FBRUE0N0IsZ0JBQU0sR0FBRzU3QixNQUFNLENBQUNndEIsR0FBUCxDQUFXemUsRUFBWCxDQUFjK0gsa0JBQXZCO0FBRUFvbEIsMEJBQWdCLENBQUMvMkIsSUFBakIsQ0FBc0JpVSxFQUF0Qjs7QUFFQSxjQUFJeUUsSUFBSixFQUFVO0FBQ047QUFFQSxnQkFBSUEsSUFBSSxDQUFDK2UsZ0JBQVQsRUFBMkI7QUFDdkIvZSxrQkFBSSxDQUFDclAsV0FBTCxDQUFpQjFMLElBQUksQ0FBQzBxQixHQUFMLENBQVMzaEIsUUFBVCxDQUFrQjRvQixjQUFsQixDQUFpQyxHQUFqQyxDQUFqQjtBQUNIOztBQUVEM3hCLGdCQUFJLENBQUMrNUIsaUJBQUwsQ0FBdUJoZixJQUF2QixFQUE2QnJkLE1BQU0sQ0FBQ2d0QixHQUFQLENBQVd6ZSxFQUF4QyxFQUE0Q290QixlQUE1QztBQUVBdGUsZ0JBQUksR0FBRyxJQUFQO0FBQ0g7QUFDSjs7QUFFRCtULGlCQUFTLENBQUNTLElBQVYsQ0FBZWx0QixJQUFmLENBQW9CM0UsTUFBcEI7QUFDSDs7QUFFRCxVQUFJcWQsSUFBSixFQUFVO0FBQ047QUFFQXVlLGNBQU0sR0FBR0EsTUFBTSxJQUFJdDVCLElBQUksQ0FBQytWLE1BQUwsQ0FBWStSLE1BQVosQ0FBbUJWLFlBQXRDOztBQUVBLFlBQUlrUyxNQUFKLEVBQVk7QUFDUnZlLGNBQUksQ0FBQ3JQLFdBQUwsQ0FBaUIxTCxJQUFJLENBQUMwcUIsR0FBTCxDQUFTM2hCLFFBQVQsQ0FBa0I0b0IsY0FBbEIsQ0FBaUMsR0FBakMsQ0FBakI7QUFDSDs7QUFFRDN4QixZQUFJLENBQUMrNUIsaUJBQUwsQ0FBdUJoZixJQUF2QixFQUE2QnVlLE1BQTdCLEVBQXFDRCxlQUFyQztBQUNIOztBQUVELFdBQUt6N0IsQ0FBQyxHQUFHLENBQVQsRUFBWXliLElBQUksR0FBR3lWLFNBQVMsQ0FBQ0ksWUFBVixDQUF1QnR4QixDQUF2QixDQUFuQixFQUE4Q0EsQ0FBQyxFQUEvQyxFQUFtRDtBQUMvQzBZLFVBQUUsR0FBRytDLElBQUksQ0FBQ3JaLElBQUksQ0FBQytWLE1BQUwsQ0FBWXNELElBQVosQ0FBaUJ1TixNQUFsQixDQUFUO0FBRUFscEIsY0FBTSxHQUFHc0MsSUFBSSxDQUFDdXRCLEtBQUwsQ0FBV2pYLEVBQVgsQ0FBVDs7QUFFQSxZQUFJd1ksU0FBUyxDQUFDUyxJQUFWLENBQWVwaUIsT0FBZixDQUF1QnpQLE1BQXZCLElBQWlDLENBQXJDLEVBQXdDO0FBQ3BDO0FBRUFveEIsbUJBQVMsQ0FBQ1AsSUFBVixDQUFlbHNCLElBQWYsQ0FBb0IzRSxNQUFwQjtBQUNBb3hCLG1CQUFTLENBQUNSLE1BQVYsQ0FBaUJqc0IsSUFBakIsQ0FBc0IzRSxNQUF0QjtBQUNBb3hCLG1CQUFTLENBQUNnRCxRQUFWLENBQW1CenZCLElBQW5CLENBQXdCM0UsTUFBeEI7QUFDSCxTQU5ELE1BTU87QUFDSHk3Qiw0QkFBa0IsQ0FBQzkyQixJQUFuQixDQUF3QmlVLEVBQXhCO0FBQ0g7QUFDSjs7QUFFRCxVQUFJLENBQUMzQyxDQUFDLENBQUMySCxZQUFGLENBQWU2ZCxrQkFBZixFQUFtQ0MsZ0JBQW5DLENBQUwsRUFBMkQ7QUFDdkR0SyxpQkFBUyxDQUFDd0QsUUFBVixHQUFxQixJQUFyQjtBQUNIOztBQUVEdHlCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsbUJBQWpCLEVBQXNDN1ksU0FBdEM7QUFDSCxLQXB4Rkw7O0FBc3hGSTs7Ozs7Ozs7O0FBVUFzN0IscUJBQWlCLEVBQUUsMkJBQVNoZixJQUFULEVBQWV1ZSxNQUFmLEVBQXVCbFIsT0FBdkIsRUFBZ0M7QUFDL0MsVUFBSXBvQixJQUFJLEdBQUcsSUFBWDtBQUNBLFVBQUlnNkIsUUFBUSxHQUFHVixNQUFNLEdBQUczbEIsQ0FBQyxDQUFDb0ksYUFBRixDQUFnQi9iLElBQUksQ0FBQzBxQixHQUFMLENBQVNyckIsTUFBVCxDQUFnQm9JLFFBQWhDLEVBQTBDMEYsT0FBMUMsQ0FBa0Rtc0IsTUFBbEQsQ0FBSCxHQUErRHQ1QixJQUFJLENBQUNvb0IsT0FBTCxDQUFhdnFCLE1BQWpHO0FBRUFtQyxVQUFJLENBQUMwcUIsR0FBTCxDQUFTcnJCLE1BQVQsQ0FBZ0J1TSxZQUFoQixDQUE2Qm1QLElBQTdCLEVBQW1DdWUsTUFBbkM7O0FBRUEsYUFBT2xSLE9BQU8sQ0FBQ3ZxQixNQUFmLEVBQXVCO0FBQ25CbUMsWUFBSSxDQUFDb29CLE9BQUwsQ0FBYThCLE1BQWIsQ0FBb0I4UCxRQUFwQixFQUE4QixDQUE5QixFQUFpQzVSLE9BQU8sQ0FBQ2dKLEtBQVIsRUFBakM7QUFFQTRJLGdCQUFRO0FBQ1g7QUFDSixLQTN5Rkw7O0FBNnlGSTs7Ozs7Ozs7QUFTQTFILFlBQVEsRUFBRSxrQkFBUzJILFlBQVQsRUFBdUJDLFlBQXZCLEVBQXFDO0FBQzNDLFVBQUlsNkIsSUFBSSxHQUFNLElBQWQ7QUFBQSxVQUNJb0csTUFBTSxHQUFJLEtBRGQ7O0FBR0EsVUFDSXBHLElBQUksQ0FBQytWLE1BQUwsQ0FBWTZSLFFBQVosQ0FBcUJ0QyxRQUFyQixJQUNBMlUsWUFBWSxDQUFDL1EsS0FBYixLQUE2QixRQUQ3QixJQUVBK1EsWUFBWSxDQUFDaFIsU0FBYixLQUE2QmlSLFlBQVksQ0FBQ2pSLFNBRjFDLElBR0FnUixZQUFZLENBQUMvUSxLQUFiLEtBQTZCZ1IsWUFBWSxDQUFDaFIsS0FIMUMsSUFJQStRLFlBQVksQ0FBQ3BSLFVBQWIsS0FBNkJxUixZQUFZLENBQUNyUixVQUoxQyxJQUtDb1IsWUFBWSxDQUFDOVEsSUFBYixLQUFzQixJQUF0QixJQUE4QitRLFlBQVksQ0FBQy9RLElBTDVDLElBTUM4USxZQUFZLENBQUM5USxJQUFiLElBQXFCK1EsWUFBWSxDQUFDL1EsSUFBYixLQUFzQixJQVBoRCxFQVFFO0FBQ0UvaUIsY0FBTSxHQUFHLElBQVQ7QUFDSCxPQVZELE1BVU8sSUFBSTZ6QixZQUFZLENBQUM5USxJQUFiLElBQXFCK1EsWUFBWSxDQUFDL1EsSUFBdEMsRUFBNEM7QUFDL0MvaUIsY0FBTSxHQUFHcEcsSUFBSSxDQUFDc3lCLFFBQUwsQ0FBYzJILFlBQVksQ0FBQzlRLElBQTNCLEVBQWlDK1EsWUFBWSxDQUFDL1EsSUFBOUMsQ0FBVDtBQUNILE9BRk0sTUFFQTtBQUNIL2lCLGNBQU0sR0FBRyxLQUFUO0FBQ0g7O0FBRUQsYUFBT3BHLElBQUksQ0FBQ3VpQixXQUFMLENBQWlCLGdCQUFqQixFQUFtQ25jLE1BQW5DLEVBQTJDM0gsU0FBM0MsQ0FBUDtBQUNILEtBMzBGTDs7QUE2MEZJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOHdCLFFBQUksRUFBRSxnQkFBVztBQUNiLFVBQUl2dkIsSUFBSSxHQUFHLElBQVg7QUFFQSxhQUFPQSxJQUFJLENBQUMwSSxNQUFMLENBQVksS0FBWixDQUFQO0FBQ0gsS0FyMkZMOztBQXUyRkk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBNmxCLFFBQUksRUFBRSxnQkFBVztBQUNiLFVBQUl2dUIsSUFBSSxHQUFHLElBQVg7QUFFQSxhQUFPQSxJQUFJLENBQUMwSSxNQUFMLENBQVksTUFBWixDQUFQO0FBQ0gsS0FoNEZMOztBQWs0Rkk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQXl4QixZQUFRLEVBQUUsb0JBQVc7QUFDakIsVUFBSW42QixJQUFJLEdBQUcsSUFBWDtBQUVBLGFBQU9BLElBQUksQ0FBQ290QixNQUFaO0FBQ0gsS0E1NUZMOztBQTg1Rkk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpRUExa0IsVUFBTSxFQUFFLGtCQUFXO0FBQ2YsVUFBSTFJLElBQUksR0FBVSxJQUFsQjtBQUFBLFVBQ0lpdEIsV0FBVyxHQUFHanRCLElBQUksQ0FBQ3d2QixlQUFMLENBQXFCL3dCLFNBQXJCLENBRGxCO0FBR0EsYUFBT3VCLElBQUksQ0FBQ2lyQixRQUFMLENBQWM7QUFDakJ2aUIsY0FBTSxFQUFFdWtCLFdBQVcsQ0FBQ3pDO0FBREgsT0FBZCxFQUVKeUMsV0FBVyxDQUFDbUwsT0FGUixFQUVpQm5MLFdBQVcsQ0FBQzllLFFBRjdCLENBQVA7QUFHSCxLQXQrRkw7O0FBdytGSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkE2YyxZQUFRLEVBQUUsb0JBQVc7QUFDakIsVUFBSWhyQixJQUFJLEdBQWMsSUFBdEI7QUFBQSxVQUNJaXRCLFdBQVcsR0FBT2p0QixJQUFJLENBQUN3dkIsZUFBTCxDQUFxQi93QixTQUFyQixDQUR0QjtBQUFBLFVBRUltRSxRQUFRLEdBQVVxcUIsV0FBVyxDQUFDekMsT0FBWixDQUFvQjVuQixRQUYxQztBQUFBLFVBR0ltdUIsY0FBYyxHQUFJLEVBSHRCO0FBS0Evd0IsVUFBSSxDQUFDbXRCLFVBQUwsR0FBa0IsSUFBbEI7O0FBRUEsVUFBSW50QixJQUFJLENBQUNrckIsV0FBTCxDQUFpQi9kLE9BQWpCLENBQXlCdkssUUFBekIsSUFBcUMsQ0FBekMsRUFBNEM7QUFDeEM1QyxZQUFJLENBQUNrckIsV0FBTCxDQUFpQjdvQixJQUFqQixDQUFzQk8sUUFBdEI7QUFDSDs7QUFFRG11QixvQkFBYyxHQUFHL3dCLElBQUksQ0FBQzZ3QixpQkFBTCxFQUFqQjtBQUVBLGFBQU83d0IsSUFBSSxDQUFDaXJCLFFBQUwsQ0FBYztBQUNqQnZpQixjQUFNLEVBQUVxb0I7QUFEUyxPQUFkLEVBRUo5RCxXQUFXLENBQUNtTCxPQUZSLEVBRWlCbkwsV0FBVyxDQUFDOWUsUUFGN0IsQ0FBUDtBQUdILEtBdmhHTDs7QUF5aEdJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBNGMsYUFBUyxFQUFFLHFCQUFXO0FBQ2xCLFVBQUkvcUIsSUFBSSxHQUFjLElBQXRCO0FBQUEsVUFDSWl0QixXQUFXLEdBQU9qdEIsSUFBSSxDQUFDd3ZCLGVBQUwsQ0FBcUIvd0IsU0FBckIsQ0FEdEI7QUFBQSxVQUVJbUUsUUFBUSxHQUFVcXFCLFdBQVcsQ0FBQ3pDLE9BQVosQ0FBb0I1bkIsUUFGMUM7QUFBQSxVQUdJdzNCLGFBQWEsR0FBS3A2QixJQUFJLENBQUNrckIsV0FBTCxDQUFpQi9kLE9BQWpCLENBQXlCdkssUUFBekIsQ0FIdEI7QUFBQSxVQUlJbXVCLGNBQWMsR0FBSSxFQUp0QjtBQU1BL3dCLFVBQUksQ0FBQ210QixVQUFMLEdBQWtCLElBQWxCOztBQUVBLFVBQUlpTixhQUFhLEdBQUcsQ0FBQyxDQUFyQixFQUF3QjtBQUNwQnA2QixZQUFJLENBQUNrckIsV0FBTCxDQUFpQmhCLE1BQWpCLENBQXdCa1EsYUFBeEIsRUFBdUMsQ0FBdkM7QUFDSDs7QUFFRHJKLG9CQUFjLEdBQUcvd0IsSUFBSSxDQUFDNndCLGlCQUFMLEVBQWpCO0FBRUEsYUFBTzd3QixJQUFJLENBQUNpckIsUUFBTCxDQUFjO0FBQ2pCdmlCLGNBQU0sRUFBRXFvQjtBQURTLE9BQWQsRUFFSjlELFdBQVcsQ0FBQ21MLE9BRlIsRUFFaUJuTCxXQUFXLENBQUM5ZSxRQUY3QixDQUFQO0FBR0gsS0F4a0dMOztBQTBrR0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEVBM00sUUFBSSxFQUFFLGdCQUFXO0FBQ2IsVUFBSXhCLElBQUksR0FBVSxJQUFsQjtBQUFBLFVBQ0lpdEIsV0FBVyxHQUFHanRCLElBQUksQ0FBQ3l2QixhQUFMLENBQW1CaHhCLFNBQW5CLENBRGxCO0FBR0EsYUFBT3VCLElBQUksQ0FBQ2lyQixRQUFMLENBQWM7QUFDakJ6cEIsWUFBSSxFQUFFeXJCLFdBQVcsQ0FBQ3pDO0FBREQsT0FBZCxFQUVKeUMsV0FBVyxDQUFDbUwsT0FGUixFQUVpQm5MLFdBQVcsQ0FBQzllLFFBRjdCLENBQVA7QUFHSCxLQS9wR0w7O0FBaXFHSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUNBd2EsZ0JBQVksRUFBRSx3QkFBVztBQUNyQixVQUFJM29CLElBQUksR0FBVSxJQUFsQjtBQUFBLFVBQ0lpdEIsV0FBVyxHQUFHanRCLElBQUksQ0FBQ3U0QixxQkFBTCxDQUEyQjk1QixTQUEzQixDQURsQjtBQUdBLGFBQU91QixJQUFJLENBQUNpckIsUUFBTCxDQUFjO0FBQ2pCdEMsb0JBQVksRUFBRXNFLFdBQVcsQ0FBQ3pDO0FBRFQsT0FBZCxFQUVKeUMsV0FBVyxDQUFDbUwsT0FGUixFQUVpQm5MLFdBQVcsQ0FBQzllLFFBRjdCLENBQVA7QUFHSCxLQTdzR0w7O0FBK3NHSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0VBbVosV0FBTyxFQUFFLG1CQUFXO0FBQ2hCLFVBQUl0bkIsSUFBSSxHQUFVLElBQWxCO0FBQUEsVUFDSWl0QixXQUFXLEdBQUdqdEIsSUFBSSxDQUFDNDRCLGdCQUFMLENBQXNCbjZCLFNBQXRCLENBRGxCO0FBQUEsVUFFSXF3QixTQUFTLEdBQUssSUFGbEI7QUFBQSxVQUdJZ0ssU0FBUyxHQUFLLElBSGxCO0FBQUEsVUFJSVYsT0FBTyxHQUFPLEtBSmxCO0FBTUFwNEIsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixlQUFqQixFQUFrQzdZLFNBQWxDOztBQUVBLFVBQUksQ0FBQ3VCLElBQUksQ0FBQ290QixNQUFWLEVBQWtCO0FBQ2QsWUFBSUgsV0FBVyxDQUFDOWUsUUFBaEIsRUFBMEJuTyxJQUFJLENBQUNndUIsWUFBTCxHQUFvQmYsV0FBVyxDQUFDOWUsUUFBaEM7QUFFMUJpcUIsZUFBTyxHQUFJbkwsV0FBVyxDQUFDbUwsT0FBWixHQUFzQnA0QixJQUFJLENBQUMrVixNQUFMLENBQVk0UixTQUFaLENBQXNCempCLE1BQTdDLEdBQXVEK29CLFdBQVcsQ0FBQ21MLE9BQW5FLEdBQTZFcDRCLElBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0J6akIsTUFBN0c7QUFFQTRxQixpQkFBUyxHQUFHOXVCLElBQUksQ0FBQ2c1QixnQkFBTCxDQUFzQi9MLFdBQVcsQ0FBQ3pDLE9BQVosQ0FBb0JsRCxPQUExQyxDQUFaO0FBRUEsZUFBT3RuQixJQUFJLENBQUNnMEIsS0FBTCxDQUFXb0UsT0FBWCxFQUFvQnRKLFNBQXBCLENBQVA7QUFDSCxPQVJELE1BUU87QUFDSGdLLGlCQUFTLEdBQUcsSUFBSXBsQixRQUFPLENBQUNzWixTQUFaLEVBQVo7QUFFQThMLGlCQUFTLENBQUMzeUIsSUFBVixHQUEwQjFILFNBQTFCO0FBQ0FxNkIsaUJBQVMsQ0FBQzdMLFdBQVYsR0FBMEJBLFdBQTFCO0FBRUEsZUFBT2p0QixJQUFJLENBQUM2NEIsUUFBTCxDQUFjQyxTQUFkLENBQVA7QUFDSDtBQUNKLEtBeHlHTDs7QUEweUdJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcURBN04sWUFBUSxFQUFFLG9CQUFXO0FBQ2pCLFVBQUlqckIsSUFBSSxHQUFVLElBQWxCO0FBQUEsVUFDSTh1QixTQUFTLEdBQUssSUFEbEI7QUFBQSxVQUVJc0osT0FBTyxHQUFPLEtBRmxCO0FBQUEsVUFHSVUsU0FBUyxHQUFLLElBSGxCO0FBQUEsVUFJSTdMLFdBQVcsR0FBR2p0QixJQUFJLENBQUNrNEIsaUJBQUwsQ0FBdUJ6NUIsU0FBdkIsQ0FKbEI7QUFNQXVCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsZ0JBQWpCLEVBQW1DN1ksU0FBbkM7O0FBRUEsVUFBSSxDQUFDdUIsSUFBSSxDQUFDb3RCLE1BQVYsRUFBa0I7QUFDZDBCLGlCQUFTLEdBQUc5dUIsSUFBSSxDQUFDcTZCLFlBQUwsQ0FBa0JwTixXQUFXLENBQUN6QyxPQUE5QixDQUFaOztBQUVBLFlBQUl4cUIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNUQsUUFBWixDQUFxQmpPLE1BQXpCLEVBQWlDO0FBQzdCO0FBRUEsY0FBSStvQixXQUFXLENBQUN6QyxPQUFaLENBQW9COWhCLE1BQXBCLElBQThCLENBQUMxSSxJQUFJLENBQUNtdEIsVUFBeEMsRUFBb0Q7QUFDaEQ7QUFDQTtBQUVBbnRCLGdCQUFJLENBQUNrckIsV0FBTCxDQUFpQnJ0QixNQUFqQixHQUEwQixDQUExQjtBQUNBbUMsZ0JBQUksQ0FBQ3l1QixnQkFBTCxDQUFzQkssU0FBUyxDQUFDdEUsT0FBaEM7QUFDSDs7QUFFRCxjQUFJeHFCLElBQUksQ0FBQzRrQixLQUFMLENBQVcvbUIsTUFBWCxHQUFvQixDQUF4QixFQUEyQjtBQUN2Qm1DLGdCQUFJLENBQUMwdUIsY0FBTCxDQUFvQkksU0FBUyxDQUFDdEUsT0FBOUI7QUFDSDtBQUNKOztBQUVELFlBQUl5QyxXQUFXLENBQUM5ZSxRQUFoQixFQUEwQm5PLElBQUksQ0FBQ2d1QixZQUFMLEdBQW9CZixXQUFXLENBQUM5ZSxRQUFoQyxDQW5CWixDQXFCZDs7QUFFQWlxQixlQUFPLEdBQUluTCxXQUFXLENBQUNtTCxPQUFaLEdBQXNCcDRCLElBQUksQ0FBQytWLE1BQUwsQ0FBWTRSLFNBQVosQ0FBc0J6akIsTUFBN0MsR0FDTitvQixXQUFXLENBQUNtTCxPQUROLEdBRU5wNEIsSUFBSSxDQUFDK1YsTUFBTCxDQUFZNFIsU0FBWixDQUFzQnpqQixNQUYxQjtBQUlBbEUsWUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIsbUJBQWpCLEVBQXNDdU0sU0FBdEMsRUFBaURyd0IsU0FBakQ7QUFFQSxlQUFPdUIsSUFBSSxDQUFDZzBCLEtBQUwsQ0FBV29FLE9BQVgsRUFBb0J0SixTQUFwQixDQUFQO0FBQ0gsT0E5QkQsTUE4Qk87QUFDSGdLLGlCQUFTLEdBQUcsSUFBSXBsQixRQUFPLENBQUNzWixTQUFaLEVBQVo7QUFFQThMLGlCQUFTLENBQUMzeUIsSUFBVixHQUEyQjFILFNBQTNCO0FBQ0FxNkIsaUJBQVMsQ0FBQzdMLFdBQVYsR0FBMkJBLFdBQTNCO0FBQ0E2TCxpQkFBUyxDQUFDNUwsY0FBVixHQUEyQmx0QixJQUFJLENBQUMycUIsV0FBaEM7QUFDQW1PLGlCQUFTLENBQUMzTCxVQUFWLEdBQTJCbnRCLElBQUksQ0FBQ210QixVQUFoQztBQUVBLGVBQU9udEIsSUFBSSxDQUFDNjRCLFFBQUwsQ0FBY0MsU0FBZCxDQUFQO0FBQ0g7QUFDSixLQWg1R0w7O0FBazVHSTs7Ozs7Ozs7O0FBVUF1QixnQkFBWSxFQUFFLHNCQUFTQyxlQUFULEVBQTBCO0FBQ3BDLFVBQUl0NkIsSUFBSSxHQUFrQixJQUExQjtBQUFBLFVBQ0l1NkIsV0FBVyxHQUFXRCxlQUFlLENBQUM5NEIsSUFEMUM7QUFBQSxVQUVJZzVCLGFBQWEsR0FBU0YsZUFBZSxDQUFDNXhCLE1BRjFDO0FBQUEsVUFHSSt4QixtQkFBbUIsR0FBR0gsZUFBZSxDQUFDM1IsWUFIMUM7QUFBQSxVQUlJK1IsYUFBYSxHQUFTSixlQUFlLENBQUNoNEIsTUFKMUM7QUFBQSxVQUtJcTRCLGFBQWEsR0FBU0wsZUFBZSxDQUFDNVIsTUFMMUM7QUFBQSxVQU1Jb0csU0FBUyxHQUFhLElBQUlwYixRQUFPLENBQUNxYixTQUFaLEVBTjFCO0FBUUFELGVBQVMsR0FBRzl1QixJQUFJLENBQUN1aUIsV0FBTCxDQUFpQiwrQkFBakIsRUFBa0R1TSxTQUFsRCxFQUE2RHJ3QixTQUE3RCxDQUFaO0FBRUFxd0IsZUFBUyxDQUFDeFksRUFBVixHQUE4QjNDLENBQUMsQ0FBQ2lELFNBQUYsRUFBOUI7QUFDQWtZLGVBQVMsQ0FBQ3RFLE9BQVYsR0FBOEI4UCxlQUE5QjtBQUNBeEwsZUFBUyxDQUFDcUYsVUFBVixHQUE4Qm4wQixJQUFJLENBQUM2cUIsS0FBbkM7QUFDQWlFLGVBQVMsQ0FBQzVCLGNBQVYsR0FBOEJsdEIsSUFBSSxDQUFDMnFCLFdBQW5DOztBQUVBLFVBQUkzcUIsSUFBSSxDQUFDb3RCLE1BQVQsRUFBaUI7QUFDYixZQUFJcHRCLElBQUksQ0FBQytWLE1BQUwsQ0FBWWUsS0FBWixDQUFrQkMsWUFBdEIsRUFBb0M7QUFDaENuYSxpQkFBTyxDQUFDRixJQUFSLENBQWFnWCxRQUFPLENBQUMrQyxRQUFSLENBQWlCbWtCLCtCQUFqQixFQUFiO0FBQ0g7O0FBRUQsZUFBTyxJQUFQO0FBQ0g7O0FBRUQsVUFBSUQsYUFBSixFQUFtQjtBQUNmMzZCLFlBQUksQ0FBQ3N4QixhQUFMLENBQW1CcUosYUFBbkIsRUFBa0M3TCxTQUFsQztBQUNIOztBQUVELFVBQUk0TCxhQUFKLEVBQW1CO0FBQ2Y1TCxpQkFBUyxDQUFDZ0QsUUFBVixHQUFxQjRJLGFBQWEsQ0FBQ3RTLE9BQW5DO0FBQ0g7O0FBRUQwRyxlQUFTLENBQUNvQixTQUFWLEdBQXNCcEIsU0FBUyxDQUFDYSxPQUFWLEdBQW9CYixTQUFTLENBQUNxRixVQUFWLENBQXFCdkYsVUFBL0Q7QUFDQUUsZUFBUyxDQUFDaUIsVUFBVixHQUF1QmpCLFNBQVMsQ0FBQ2dCLFFBQVYsR0FBcUI5dkIsSUFBSSxDQUFDb29CLE9BQWpEOztBQUVBLFVBQUltUyxXQUFKLEVBQWlCO0FBQ2J6TCxpQkFBUyxDQUFDb0IsU0FBVixHQUFzQnBCLFNBQVMsQ0FBQ3FGLFVBQVYsQ0FBcUJ2RixVQUEzQztBQUNBRSxpQkFBUyxDQUFDYSxPQUFWLEdBQXNCNEssV0FBdEI7QUFFQXpMLGlCQUFTLENBQUN3RCxRQUFWLEdBQXFCdHlCLElBQUksQ0FBQ3N5QixRQUFMLENBQWNpSSxXQUFkLEVBQTJCekwsU0FBUyxDQUFDcUYsVUFBVixDQUFxQnZGLFVBQWhELENBQXJCOztBQUVBLFlBQUlFLFNBQVMsQ0FBQ3dELFFBQWQsRUFBd0I7QUFDcEJ0eUIsY0FBSSxDQUFDNHZCLGFBQUwsQ0FBbUJkLFNBQW5CO0FBQ0g7QUFDSjs7QUFFREEsZUFBUyxDQUFDa0IsV0FBVixHQUF3QmxCLFNBQVMsQ0FBQ3FGLFVBQVYsQ0FBcUJ4RixZQUE3Qzs7QUFFQSxVQUFJNkwsYUFBSixFQUFtQjtBQUNmMUwsaUJBQVMsQ0FBQ21CLFNBQVYsR0FBc0J1SyxhQUF0QjtBQUNILE9BRkQsTUFFTztBQUNIMUwsaUJBQVMsQ0FBQ21CLFNBQVYsR0FBc0J0YyxDQUFDLENBQUN1RSxNQUFGLENBQVMsSUFBSXhFLFFBQU8sQ0FBQ2tWLGFBQVosRUFBVCxFQUFzQ2tHLFNBQVMsQ0FBQ2tCLFdBQWhELENBQXRCO0FBQ0g7O0FBRUQsVUFBSWxCLFNBQVMsQ0FBQ21CLFNBQVYsQ0FBb0JydEIsUUFBcEIsS0FBaUMsS0FBckMsRUFBNEM7QUFDeENrc0IsaUJBQVMsQ0FBQ21CLFNBQVYsQ0FBb0JydEIsUUFBcEIsR0FBK0I1QyxJQUFJLENBQUMrVixNQUFMLENBQVlpUyxTQUFaLENBQXNCdHFCLE1BQXJEO0FBQ0gsT0FGRCxNQUVPLElBQUlveEIsU0FBUyxDQUFDbUIsU0FBVixDQUFvQnJ0QixRQUFwQixLQUFpQyxNQUFyQyxFQUE2QztBQUNoRGtzQixpQkFBUyxDQUFDbUIsU0FBVixDQUFvQnJ0QixRQUFwQixHQUErQixFQUEvQjtBQUNIOztBQUVENUMsVUFBSSxDQUFDbXdCLGVBQUwsQ0FBcUJyQixTQUFyQjtBQUVBQSxlQUFTLENBQUNPLHVCQUFWLEdBQW9DUCxTQUFTLENBQUNxRixVQUFWLENBQXFCbkYsd0JBQXpEOztBQUVBLFVBQUl5TCxtQkFBSixFQUF5QjtBQUNyQjNMLGlCQUFTLENBQUNRLHFCQUFWLEdBQWtDbUwsbUJBQW1CLENBQUN2VCxrQkFBdEQ7O0FBRUEsWUFBSTRILFNBQVMsQ0FBQ1EscUJBQVYsS0FBb0NSLFNBQVMsQ0FBQ08sdUJBQWxELEVBQTJFO0FBQ3ZFUCxtQkFBUyxDQUFDb0YsZ0JBQVYsR0FBNkIsSUFBN0I7QUFDSDtBQUNKLE9BTkQsTUFNTztBQUNIcEYsaUJBQVMsQ0FBQ1EscUJBQVYsR0FBa0NSLFNBQVMsQ0FBQ08sdUJBQTVDO0FBQ0g7O0FBRUQsVUFBSXJ2QixJQUFJLENBQUMrVixNQUFMLENBQVk0UixTQUFaLENBQXNCempCLE1BQTFCLEVBQWtDO0FBQzlCO0FBRUFsRSxZQUFJLENBQUNnMUIsZUFBTCxDQUFxQmxHLFNBQXJCO0FBQ0E5dUIsWUFBSSxDQUFDbTJCLFFBQUwsQ0FBY3JILFNBQWQ7QUFFQUEsaUJBQVMsQ0FBQ3dGLFFBQVYsR0FBcUIzZ0IsQ0FBQyxDQUFDZ00sZ0JBQUYsQ0FBbUIzZixJQUFJLENBQUMwcUIsR0FBTCxDQUFTM2hCLFFBQTVCLENBQXJCO0FBRUEvSSxZQUFJLENBQUNvMkIsZUFBTCxDQUFxQnRILFNBQXJCO0FBQ0E5dUIsWUFBSSxDQUFDczJCLFFBQUwsQ0FBY3hILFNBQWQ7QUFDQTl1QixZQUFJLENBQUN1MkIsZUFBTCxDQUFxQnpILFNBQXJCO0FBRUE5dUIsWUFBSSxDQUFDNnVCLFlBQUw7QUFFQUMsaUJBQVMsQ0FBQzZJLFNBQVYsR0FBc0IzM0IsSUFBSSxDQUFDMjNCLFNBQUwsRUFBdEI7QUFFQTMzQixZQUFJLENBQUMyMkIsWUFBTCxDQUFrQjdILFNBQWxCO0FBQ0g7O0FBRUQsVUFBSUEsU0FBUyxDQUFDd0QsUUFBZCxFQUF3QjtBQUNwQnR5QixZQUFJLENBQUNvb0IsT0FBTCxHQUFlMEcsU0FBUyxDQUFDZ0IsUUFBekI7QUFDSDs7QUFFRGhCLGVBQVMsQ0FBQ3NGLFFBQVYsR0FBcUJwMEIsSUFBSSxDQUFDb3dCLFVBQUwsQ0FBZ0J0QixTQUFoQixDQUFyQjtBQUVBLGFBQU85dUIsSUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIsNkJBQWpCLEVBQWdEdU0sU0FBaEQsRUFBMkRyd0IsU0FBM0QsQ0FBUDtBQUNILEtBaGdITDs7QUFrZ0hJOzs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQW84QixTQUFLLEVBQUUsZUFBUy9MLFNBQVQsRUFBb0JnTSxVQUFwQixFQUFnQztBQUNuQyxVQUFJcDlCLE1BQU0sR0FBWSxJQUF0QjtBQUFBLFVBQ0lrNUIsT0FBTyxHQUFXLElBRHRCO0FBQUEsVUFFSW1FLFdBQVcsR0FBTyxDQUFDLENBRnZCO0FBQUEsVUFHSW45QixDQUFDLEdBQWlCLENBQUMsQ0FIdkI7QUFLQWs5QixnQkFBVSxHQUFHeDFCLElBQUksQ0FBQ0MsR0FBTCxDQUFTdTFCLFVBQVQsRUFBcUIsQ0FBckIsQ0FBYjtBQUNBQSxnQkFBVSxHQUFHeDFCLElBQUksQ0FBQ3lGLEdBQUwsQ0FBUyt2QixVQUFULEVBQXFCLENBQXJCLENBQWI7O0FBRUEsV0FBS2w5QixDQUFDLEdBQUcsQ0FBVCxFQUFZRixNQUFNLEdBQUdveEIsU0FBUyxDQUFDUyxJQUFWLENBQWUzeEIsQ0FBZixDQUFyQixFQUF3Q0EsQ0FBQyxFQUF6QyxFQUE2QztBQUN6Q2c1QixlQUFPLEdBQUc5SCxTQUFTLENBQUN3RyxXQUFWLENBQXNCMTNCLENBQXRCLENBQVY7QUFFQUYsY0FBTSxDQUFDczlCLFVBQVAsQ0FBa0JwRSxPQUFsQixFQUEyQmtFLFVBQTNCO0FBQ0g7O0FBRUQsV0FBS2w5QixDQUFDLEdBQUcsQ0FBVCxFQUFZRixNQUFNLEdBQUdveEIsU0FBUyxDQUFDUCxJQUFWLENBQWUzd0IsQ0FBZixDQUFyQixFQUF3Q0EsQ0FBQyxFQUF6QyxFQUE2QztBQUN6QyxZQUFJRixNQUFNLENBQUN5MEIsT0FBWCxFQUFvQjtBQUNoQnowQixnQkFBTSxDQUFDNndCLElBQVA7QUFDSDs7QUFFRCxZQUFJLENBQUN3TSxXQUFXLEdBQUdqTSxTQUFTLENBQUNSLE1BQVYsQ0FBaUJuaEIsT0FBakIsQ0FBeUJ6UCxNQUF6QixDQUFmLElBQW1ELENBQUMsQ0FBeEQsRUFBMkQ7QUFDdkRrNUIsaUJBQU8sR0FBRzlILFNBQVMsQ0FBQzBHLGFBQVYsQ0FBd0J1RixXQUF4QixDQUFWOztBQUVBLGNBQUksQ0FBQ3I5QixNQUFNLENBQUN5MEIsT0FBWixFQUFxQjtBQUNqQnowQixrQkFBTSxDQUFDNnhCLElBQVA7QUFDSDs7QUFFRDd4QixnQkFBTSxDQUFDczlCLFVBQVAsQ0FBa0JwRSxPQUFsQixFQUEyQmtFLFVBQTNCO0FBQ0g7QUFDSjtBQUNKLEtBbGpITDs7QUFvakhJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZGQXBTLFVBQU0sRUFBRSxrQkFBVztBQUNmLFVBQUkxb0IsSUFBSSxHQUFHLElBQVg7QUFBQSxVQUNJbUcsSUFBSSxHQUFHbkcsSUFBSSxDQUFDcTRCLGVBQUwsQ0FBcUI1NUIsU0FBckIsQ0FEWDtBQUdBLGFBQU91QixJQUFJLENBQUNpckIsUUFBTCxDQUFjO0FBQ2pCdkMsY0FBTSxFQUFFdmlCLElBQUksQ0FBQ3FrQjtBQURJLE9BQWQsRUFFSnJrQixJQUFJLENBQUNpeUIsT0FGRCxFQUVVanlCLElBQUksQ0FBQ2dJLFFBRmYsQ0FBUDtBQUdILEtBeHBITDs7QUEwcEhJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNENBdkMsZ0JBQVksRUFBRSx3QkFBVztBQUNyQixVQUFJNUwsSUFBSSxHQUFHLElBQVg7QUFBQSxVQUNJbUcsSUFBSSxHQUFHbkcsSUFBSSxDQUFDcTRCLGVBQUwsQ0FBcUI1NUIsU0FBckIsQ0FEWDtBQUdBLGFBQU91QixJQUFJLENBQUMwb0IsTUFBTCxDQUFZdmlCLElBQUksQ0FBQ3FrQixPQUFMLENBQWEzQixVQUF6QixFQUFxQyxRQUFyQyxFQUErQzFpQixJQUFJLENBQUNxa0IsT0FBTCxDQUFhbGdCLE9BQTVELEVBQXFFbkUsSUFBSSxDQUFDaXlCLE9BQTFFLEVBQW1GanlCLElBQUksQ0FBQ2dJLFFBQXhGLENBQVA7QUFDSCxLQTNzSEw7O0FBNnNISTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0NBOHNCLGVBQVcsRUFBRSx1QkFBVztBQUNwQixVQUFJajdCLElBQUksR0FBRyxJQUFYO0FBQUEsVUFDSW1HLElBQUksR0FBR25HLElBQUksQ0FBQ3E0QixlQUFMLENBQXFCNTVCLFNBQXJCLENBRFg7QUFHQSxhQUFPdUIsSUFBSSxDQUFDMG9CLE1BQUwsQ0FBWXZpQixJQUFJLENBQUNxa0IsT0FBTCxDQUFhM0IsVUFBekIsRUFBcUMsT0FBckMsRUFBOEMxaUIsSUFBSSxDQUFDcWtCLE9BQUwsQ0FBYWxnQixPQUEzRCxFQUFvRW5FLElBQUksQ0FBQ2l5QixPQUF6RSxFQUFrRmp5QixJQUFJLENBQUNnSSxRQUF2RixDQUFQO0FBQ0gsS0ExdkhMOztBQTR2SEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQTNDLFdBQU8sRUFBRSxtQkFBVztBQUNoQixVQUFJeEwsSUFBSSxHQUFHLElBQVg7QUFBQSxVQUNJbUcsSUFBSSxHQUFHbkcsSUFBSSxDQUFDcTRCLGVBQUwsQ0FBcUI1NUIsU0FBckIsQ0FEWDtBQUdBLGFBQU91QixJQUFJLENBQUMwb0IsTUFBTCxDQUFZLENBQVosRUFBZXZpQixJQUFJLENBQUNxa0IsT0FBTCxDQUFhM0IsVUFBNUIsRUFBd0MxaUIsSUFBSSxDQUFDaXlCLE9BQTdDLEVBQXNEanlCLElBQUksQ0FBQ2dJLFFBQTNELENBQVA7QUFDSCxLQW55SEw7O0FBcXlISTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBOUMsVUFBTSxFQUFFLGtCQUFXO0FBQ2YsVUFBSXJMLElBQUksR0FBRyxJQUFYO0FBQUEsVUFDSW1HLElBQUksR0FBR25HLElBQUksQ0FBQ3E0QixlQUFMLENBQXFCNTVCLFNBQXJCLENBRFg7QUFHQSxhQUFPdUIsSUFBSSxDQUFDMG9CLE1BQUwsQ0FBWTFvQixJQUFJLENBQUM2cUIsS0FBTCxDQUFXNkUsWUFBdkIsRUFBcUN2cEIsSUFBSSxDQUFDcWtCLE9BQUwsQ0FBYTNCLFVBQWxELEVBQThEMWlCLElBQUksQ0FBQ2l5QixPQUFuRSxFQUE0RWp5QixJQUFJLENBQUNnSSxRQUFqRixDQUFQO0FBQ0gsS0E1MEhMOztBQTgwSEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNERBN0wsVUFBTSxFQUFFLGtCQUFXO0FBQ2YsVUFBSXRDLElBQUksR0FBRyxJQUFYO0FBQUEsVUFDSW1HLElBQUksR0FBR25HLElBQUksQ0FBQ3M0QixlQUFMLENBQXFCNzVCLFNBQXJCLENBRFg7QUFHQSxhQUFPdUIsSUFBSSxDQUFDaXJCLFFBQUwsQ0FBYztBQUNqQjNvQixjQUFNLEVBQUU2RCxJQUFJLENBQUNxa0I7QUFESSxPQUFkLEVBRUpya0IsSUFBSSxDQUFDaXlCLE9BRkQsRUFFVWp5QixJQUFJLENBQUNnSSxRQUZmLENBQVA7QUFHSCxLQWo1SEw7O0FBbTVISTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkErc0IsYUFBUyxFQUFFLG1CQUFTblosU0FBVCxFQUFvQjtBQUMzQixVQUFJL2hCLElBQUksR0FBTSxJQUFkO0FBQUEsVUFDSVQsS0FBSyxHQUFLLElBRGQ7O0FBR0EsVUFBSSxDQUFDd2lCLFNBQUwsRUFBZ0I7QUFDWnhpQixhQUFLLEdBQUdTLElBQUksQ0FBQytWLE1BQWI7QUFDSCxPQUZELE1BRU87QUFDSHhXLGFBQUssR0FBR29VLENBQUMsQ0FBQ21PLFdBQUYsQ0FBYzloQixJQUFJLENBQUMrVixNQUFuQixFQUEyQmdNLFNBQTNCLENBQVI7QUFDSDs7QUFFRCxhQUFPL2hCLElBQUksQ0FBQ3VpQixXQUFMLENBQWlCLGdCQUFqQixFQUFtQ2hqQixLQUFuQyxFQUEwQ2QsU0FBMUMsQ0FBUDtBQUNILEtBejdITDs7QUEyN0hJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1EQTA4QixhQUFTLEVBQUUsbUJBQVNwbEIsTUFBVCxFQUFpQjtBQUN4QixVQUFJL1YsSUFBSSxHQUFHLElBQVg7QUFFQUEsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixpQkFBakIsRUFBb0M3WSxTQUFwQztBQUVBa1YsT0FBQyxDQUFDdUUsTUFBRixDQUFTbFksSUFBSSxDQUFDK1YsTUFBZCxFQUFzQkEsTUFBdEIsRUFBOEIsSUFBOUIsRUFBb0MsSUFBcEM7QUFFQS9WLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsZ0JBQWpCLEVBQW1DN1ksU0FBbkM7QUFDSCxLQXQvSEw7O0FBdy9ISTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTI4QixZQUFRLEVBQUUsb0JBQVc7QUFDakIsVUFBSXA3QixJQUFJLEdBQU0sSUFBZDtBQUFBLFVBQ0k2cUIsS0FBSyxHQUFLLElBRGQ7QUFHQUEsV0FBSyxHQUFHLElBQUluWCxRQUFPLENBQUNxWixLQUFaLEVBQVI7QUFFQXBaLE9BQUMsQ0FBQ3VFLE1BQUYsQ0FBUzJTLEtBQVQsRUFBZ0I3cUIsSUFBSSxDQUFDNnFCLEtBQXJCO0FBRUFsWCxPQUFDLENBQUNrTixNQUFGLENBQVNnSyxLQUFUO0FBRUEsYUFBTzdxQixJQUFJLENBQUN1aUIsV0FBTCxDQUFpQixlQUFqQixFQUFrQ3NJLEtBQWxDLEVBQXlDcHNCLFNBQXpDLENBQVA7QUFDSCxLQTFoSUw7O0FBNGhJSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDQTQ4QixnQkFBWSxFQUFFLHdCQUFXO0FBQ3JCLFVBQUlyN0IsSUFBSSxHQUFHLElBQVg7QUFFQUEsVUFBSSxDQUFDb3VCLFlBQUw7QUFDSCxLQXRrSUw7O0FBd2tJSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ0FrTixlQUFXLEVBQUUsdUJBQVc7QUFDcEIsVUFBSXQ3QixJQUFJLEdBQU0sSUFBZDtBQUFBLFVBQ0l0QyxNQUFNLEdBQUksSUFEZDtBQUFBLFVBRUl1TyxFQUFFLEdBQVEsSUFGZDtBQUFBLFVBR0lxSyxFQUFFLEdBQVEsRUFIZDs7QUFLQSxXQUFLQSxFQUFMLElBQVd0VyxJQUFJLENBQUN1dEIsS0FBaEIsRUFBdUI7QUFDbkI3dkIsY0FBTSxHQUFHc0MsSUFBSSxDQUFDdXRCLEtBQUwsQ0FBV2pYLEVBQVgsQ0FBVDtBQUVBckssVUFBRSxHQUFHdk8sTUFBTSxDQUFDdXFCLE1BQVAsQ0FBY3ZxQixNQUFNLENBQUMyYixJQUFyQixDQUFMOztBQUVBLFlBQUlwTixFQUFFLEtBQUt2TyxNQUFNLENBQUNndEIsR0FBUCxDQUFXemUsRUFBdEIsRUFBMEI7QUFDdEI7QUFFQSxjQUFJdk8sTUFBTSxDQUFDNnlCLE9BQVgsRUFBb0I7QUFDaEI3eUIsa0JBQU0sQ0FBQ2k4QixZQUFQO0FBRUEzNUIsZ0JBQUksQ0FBQzBxQixHQUFMLENBQVNyckIsTUFBVCxDQUFnQnU2QixZQUFoQixDQUE2QjN0QixFQUE3QixFQUFpQ3ZPLE1BQU0sQ0FBQ2d0QixHQUFQLENBQVd6ZSxFQUE1QztBQUNIOztBQUVELGNBQUksQ0FBQ3ZPLE1BQU0sQ0FBQ3kwQixPQUFaLEVBQXFCO0FBQ2pCbG1CLGNBQUUsQ0FBQzlFLEtBQUgsQ0FBU3VxQixPQUFULEdBQW1CLE1BQW5CO0FBQ0g7O0FBRURoMEIsZ0JBQU0sQ0FBQ2d0QixHQUFQLENBQVd6ZSxFQUFYLEdBQWdCQSxFQUFoQjs7QUFFQSxjQUFJdk8sTUFBTSxDQUFDNnlCLE9BQVgsRUFBb0I7QUFDaEI3eUIsa0JBQU0sQ0FBQ204QixVQUFQO0FBQ0g7QUFDSjtBQUNKOztBQUVENzVCLFVBQUksQ0FBQzZxQixLQUFMLEdBQWE3cUIsSUFBSSxDQUFDb3dCLFVBQUwsQ0FBZ0Jwd0IsSUFBSSxDQUFDK3RCLGFBQXJCLENBQWI7QUFDSCxLQTdvSUw7O0FBK29JSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkFqcUIsV0FBTyxFQUFFLGlCQUFTdXdCLE9BQVQsRUFBa0I7QUFDdkIsVUFBSXIwQixJQUFJLEdBQU0sSUFBZDtBQUFBLFVBQ0krZ0IsT0FBTyxHQUFHLElBRGQ7QUFBQSxVQUVJcmpCLE1BQU0sR0FBSSxJQUZkO0FBQUEsVUFHSUUsQ0FBQyxHQUFTLENBSGQ7QUFLQW9DLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsZUFBakIsRUFBa0M3WSxTQUFsQzs7QUFFQSxXQUFLYixDQUFDLEdBQUcsQ0FBVCxFQUFZbWpCLE9BQU8sR0FBRy9nQixJQUFJLENBQUNtUyxRQUFMLENBQWN2VSxDQUFkLENBQXRCLEVBQXdDQSxDQUFDLEVBQXpDLEVBQTZDO0FBQ3pDbWpCLGVBQU8sQ0FBQ2lKLGFBQVIsQ0FBc0JocUIsSUFBdEI7QUFDSDs7QUFFRCxXQUFLcEMsQ0FBQyxHQUFHLENBQVQsRUFBWUYsTUFBTSxHQUFHc0MsSUFBSSxDQUFDb29CLE9BQUwsQ0FBYXhxQixDQUFiLENBQXJCLEVBQXNDQSxDQUFDLEVBQXZDLEVBQTJDO0FBQ3ZDLFlBQUl5MkIsT0FBSixFQUFhO0FBQ1QzMkIsZ0JBQU0sQ0FBQzZ4QixJQUFQO0FBQ0g7O0FBRUQ3eEIsY0FBTSxDQUFDaThCLFlBQVA7QUFDSDs7QUFFRCxVQUFJMzVCLElBQUksQ0FBQzBxQixHQUFMLENBQVM1VSxTQUFULENBQW1CUSxFQUFuQixDQUFzQnBELEtBQXRCLENBQTRCLFVBQTVCLENBQUosRUFBNkM7QUFDekNsVCxZQUFJLENBQUMwcUIsR0FBTCxDQUFTNVUsU0FBVCxDQUFtQnBFLGVBQW5CLENBQW1DLElBQW5DO0FBQ0g7O0FBRUQsYUFBT2dDLFFBQU8sQ0FBQzJDLFNBQVIsQ0FBa0JyVyxJQUFJLENBQUNzVyxFQUF2QixDQUFQO0FBRUF0VyxVQUFJLENBQUNzWCxXQUFMLENBQWlCLGNBQWpCLEVBQWlDN1ksU0FBakM7QUFDSDtBQXJzSUwsR0FGQTtBQTBzSUE7Ozs7Ozs7QUFPQWlWLFVBQU8sQ0FBQ2drQixTQUFSLEdBQW9CLFlBQVc7QUFDM0Joa0IsWUFBTyxDQUFDMkQsSUFBUixDQUFhelksSUFBYixDQUFrQixJQUFsQjs7QUFFQSxTQUFLMFksV0FBTCxDQUFpQixpQkFBakI7QUFFQSxTQUFLNGYsS0FBTCxHQUFzQixJQUF0QjtBQUNBLFNBQUtDLE1BQUwsR0FBc0IsSUFBdEI7QUFDQSxTQUFLckksU0FBTCxHQUFzQixJQUF0QjtBQUNBLFNBQUszZ0IsUUFBTCxHQUFzQixJQUF0QjtBQUNBLFNBQUttcEIsWUFBTCxHQUFzQixFQUF0QjtBQUNBLFNBQUtycEIsUUFBTCxHQUFzQixDQUFDLENBQXZCO0FBQ0EsU0FBS3VwQixZQUFMLEdBQXNCLENBQUMsQ0FBdkI7QUFFQSxTQUFLbGdCLFdBQUwsQ0FBaUIsZ0JBQWpCO0FBRUEzRCxLQUFDLENBQUNpTixJQUFGLENBQU8sSUFBUDtBQUNILEdBaEJEOztBQWtCQWxOLFVBQU8sQ0FBQ2lQLFVBQVIsQ0FBbUIvakIsSUFBbkIsQ0FBd0I4VSxRQUFPLENBQUNna0IsU0FBaEM7O0FBRUFoa0IsVUFBTyxDQUFDZ2tCLFNBQVIsQ0FBa0J2NkIsU0FBbEIsR0FBOEJlLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYzhULFFBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQTNCLENBQTlCO0FBRUF1VyxVQUFPLENBQUNna0IsU0FBUixDQUFrQnY2QixTQUFsQixDQUE0QkQsV0FBNUIsR0FBMEN3VyxRQUFPLENBQUNna0IsU0FBbEQ7QUFFQTs7Ozs7OztBQU9BaGtCLFVBQU8sQ0FBQzZuQixTQUFSLEdBQW9CLFlBQVc7QUFDM0I3bkIsWUFBTyxDQUFDMkQsSUFBUixDQUFhelksSUFBYixDQUFrQixJQUFsQjs7QUFFQSxTQUFLMFksV0FBTCxDQUFpQixpQkFBakI7QUFFQSxTQUFLckwsRUFBTCxHQUFVLElBQVY7QUFFQSxTQUFLcUwsV0FBTCxDQUFpQixnQkFBakI7QUFFQTNELEtBQUMsQ0FBQ2lOLElBQUYsQ0FBTyxJQUFQO0FBQ0gsR0FWRDs7QUFZQWxOLFVBQU8sQ0FBQ2lQLFVBQVIsQ0FBbUIvakIsSUFBbkIsQ0FBd0I4VSxRQUFPLENBQUM2bkIsU0FBaEM7O0FBRUE3bkIsVUFBTyxDQUFDNm5CLFNBQVIsQ0FBa0JwK0IsU0FBbEIsR0FBOEJlLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYzhULFFBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQTNCLENBQTlCO0FBRUF1VyxVQUFPLENBQUM2bkIsU0FBUixDQUFrQnArQixTQUFsQixDQUE0QkQsV0FBNUIsR0FBMEN3VyxRQUFPLENBQUM2bkIsU0FBbEQ7QUFFQTs7Ozs7Ozs7QUFRQTduQixVQUFPLENBQUM0YyxNQUFSLEdBQWlCLFlBQVc7QUFDeEI1YyxZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBLFNBQUtoQixFQUFMLEdBQWtCLEVBQWxCO0FBQ0EsU0FBSzBTLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLYyxLQUFMLEdBQWtCLElBQWxCO0FBQ0EsU0FBSzNiLFFBQUwsR0FBa0IsSUFBbEI7QUFDQSxTQUFLZ2tCLE9BQUwsR0FBa0IsS0FBbEI7QUFDQSxTQUFLdEksT0FBTCxHQUFrQixLQUFsQjtBQUNBLFNBQUsyUixVQUFMLEdBQWtCLEtBQWxCO0FBQ0EsU0FBS2pMLE9BQUwsR0FBa0IsS0FBbEI7QUFDQSxTQUFLcHVCLE9BQUwsR0FBa0IsSUFBbEI7QUFDQSxTQUFLMnNCLFNBQUwsR0FBa0IsSUFBbEI7QUFDQSxTQUFLelYsSUFBTCxHQUFrQixJQUFsQjtBQUNBLFNBQUtxUixHQUFMLEdBQWtCLElBQUloWCxRQUFPLENBQUM2bkIsU0FBWixFQUFsQjtBQUVBLFNBQUtqa0IsV0FBTCxDQUFpQixnQkFBakI7QUFFQTNELEtBQUMsQ0FBQ2lOLElBQUYsQ0FBTyxJQUFQO0FBQ0gsR0FyQkQ7O0FBdUJBbE4sVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQzRjLE1BQWhDOztBQUVBNWMsVUFBTyxDQUFDNGMsTUFBUixDQUFlbnpCLFNBQWYsR0FBMkJlLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYzhULFFBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQTNCLENBQTNCO0FBRUF3VyxHQUFDLENBQUN1RSxNQUFGLENBQVN4RSxRQUFPLENBQUM0YyxNQUFSLENBQWVuekIsU0FBeEIsRUFBbUM7QUFDL0JELGVBQVcsRUFBRXdXLFFBQU8sQ0FBQzRjLE1BRFU7O0FBRy9COzs7Ozs7Ozs7OztBQVlBdk0sUUFBSSxFQUFFLGNBQVM5WCxFQUFULEVBQWE2ZCxLQUFiLEVBQW9CelEsSUFBcEIsRUFBMEI7QUFDNUIsVUFBSXJaLElBQUksR0FBRyxJQUFYO0FBQUEsVUFDSXNXLEVBQUUsR0FBSyxFQURYO0FBR0F0VyxVQUFJLENBQUNzWCxXQUFMLENBQWlCLFlBQWpCLEVBQStCN1ksU0FBL0I7QUFFQXVCLFVBQUksQ0FBQzhwQixLQUFMLEdBQWFBLEtBQWI7O0FBRUEsVUFBSSxDQUFDN2QsRUFBTCxFQUFTO0FBQ0w7QUFFQUEsVUFBRSxHQUFHak0sSUFBSSxDQUFDaW9CLE1BQUwsQ0FBWTVPLElBQVosQ0FBTDtBQUNIOztBQUVEclosVUFBSSxDQUFDbXVCLFFBQUwsQ0FBY2xpQixFQUFkO0FBRUFqTSxVQUFJLENBQUM2NUIsVUFBTDs7QUFFQSxVQUFJNzVCLElBQUksQ0FBQzBxQixHQUFMLENBQVN6ZSxFQUFULENBQVk5RSxLQUFaLENBQWtCdXFCLE9BQWxCLEtBQThCLE1BQWxDLEVBQTBDO0FBQ3RDMXhCLFlBQUksQ0FBQ215QixPQUFMLEdBQWUsSUFBZjtBQUNIOztBQUVELFVBQUk5WSxJQUFJLElBQUl5USxLQUFLLENBQUMvVCxNQUFOLENBQWFzRCxJQUFiLENBQWtCdU4sTUFBOUIsRUFBc0M7QUFDbEMsWUFBSSxRQUFRdFEsRUFBRSxHQUFHK0MsSUFBSSxDQUFDeVEsS0FBSyxDQUFDL1QsTUFBTixDQUFhc0QsSUFBYixDQUFrQnVOLE1BQW5CLENBQWpCLE1BQWlELFdBQWpELElBQWdFdFEsRUFBRSxDQUFDMUIsUUFBSCxHQUFjL1csTUFBZCxHQUF1QixDQUEzRixFQUE4RjtBQUMxRixnQkFBTSxJQUFJTixTQUFKLENBQWNtVyxRQUFPLENBQUMrQyxRQUFSLENBQWlCK2lCLHlCQUFqQixDQUEyQztBQUMzRDVTLGtCQUFNLEVBQUVrRCxLQUFLLENBQUMvVCxNQUFOLENBQWFzRCxJQUFiLENBQWtCdU47QUFEaUMsV0FBM0MsQ0FBZCxDQUFOO0FBR0g7O0FBRUQ1bUIsWUFBSSxDQUFDc1csRUFBTCxHQUFjQSxFQUFkO0FBQ0F0VyxZQUFJLENBQUNxWixJQUFMLEdBQWNBLElBQWQ7QUFFQXlRLGFBQUssQ0FBQ3lELEtBQU4sQ0FBWWpYLEVBQVosSUFBa0J0VyxJQUFsQjtBQUNIOztBQUVEQSxVQUFJLENBQUNzWCxXQUFMLENBQWlCLFdBQWpCLEVBQThCN1ksU0FBOUI7QUFDSCxLQW5EOEI7O0FBcUQvQjs7Ozs7Ozs7O0FBVUF3cEIsVUFBTSxFQUFFLGdCQUFTNU8sSUFBVCxFQUFlO0FBQ25CLFVBQUlyWixJQUFJLEdBQU0sSUFBZDtBQUFBLFVBQ0lpb0IsTUFBTSxHQUFJLElBRGQ7QUFBQSxVQUVJaGMsRUFBRSxHQUFRLElBRmQ7QUFBQSxVQUdJK08sSUFBSSxHQUFNLElBSGQ7QUFBQSxVQUlJNUUsTUFBTSxHQUFJLEVBSmQ7QUFNQXBXLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsY0FBakIsRUFBaUM3WSxTQUFqQztBQUVBd3BCLFlBQU0sR0FBR2pvQixJQUFJLENBQUN1aUIsV0FBTCxDQUFpQixjQUFqQixFQUFpQ3ZpQixJQUFJLENBQUM4cEIsS0FBTCxDQUFXL1QsTUFBWCxDQUFrQmtTLE1BQWxCLENBQXlCdnFCLE1BQTFELEVBQWtFZSxTQUFsRSxDQUFUOztBQUVBLFVBQUksT0FBT3dwQixNQUFQLEtBQWtCLFVBQXRCLEVBQWtDO0FBQzlCLGNBQU0sSUFBSTFxQixTQUFKLENBQWNtVyxRQUFPLENBQUMrQyxRQUFSLENBQWlCZ2xCLDBCQUFqQixFQUFkLENBQU47QUFDSDs7QUFFRHJsQixZQUFNLEdBQUc2UixNQUFNLENBQUM1TyxJQUFELENBQWY7O0FBRUEsVUFBSWpELE1BQU0sSUFBSSxRQUFPQSxNQUFQLE1BQWtCLFFBQTVCLElBQXdDekMsQ0FBQyxDQUFDNEMsU0FBRixDQUFZSCxNQUFaLENBQTVDLEVBQWlFO0FBQzdEbkssVUFBRSxHQUFHbUssTUFBTDtBQUNILE9BRkQsTUFFTyxJQUFJLE9BQU9BLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7QUFDbkM0RSxZQUFJLEdBQUdqUyxRQUFRLENBQUMrSyxhQUFULENBQXVCLEtBQXZCLENBQVA7QUFDQWtILFlBQUksQ0FBQ0UsU0FBTCxHQUFpQjlFLE1BQWpCO0FBRUFuSyxVQUFFLEdBQUcrTyxJQUFJLENBQUMwZ0IsaUJBQVY7QUFDSDs7QUFFRCxhQUFPMTdCLElBQUksQ0FBQ3VpQixXQUFMLENBQWlCLFVBQWpCLEVBQTZCdFcsRUFBN0IsRUFBaUN4TixTQUFqQyxDQUFQO0FBQ0gsS0ExRjhCOztBQTRGL0I7Ozs7Ozs7OztBQVVBMHZCLFlBQVEsRUFBRSxrQkFBU2xpQixFQUFULEVBQWE7QUFDbkIsVUFBSWpNLElBQUksR0FBRyxJQUFYO0FBRUFBLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsZ0JBQWpCLEVBQW1DN1ksU0FBbkM7QUFFQXVCLFVBQUksQ0FBQzBxQixHQUFMLENBQVN6ZSxFQUFULEdBQWNBLEVBQWQ7QUFFQWpNLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsZUFBakIsRUFBa0M3WSxTQUFsQztBQUNILEtBOUc4Qjs7QUFnSC9COzs7Ozs7O0FBUUFrOUIsaUJBQWEsRUFBRSx1QkFBU0MsYUFBVCxFQUF3QjtBQUNuQyxVQUFJNTdCLElBQUksR0FBTSxJQUFkO0FBQUEsVUFDSVQsS0FBSyxHQUFLUyxJQUFJLENBQUMwcUIsR0FBTCxDQUFTemUsRUFBVCxDQUFZd0YsWUFBWixDQUF5QixVQUFVbXFCLGFBQW5DLEtBQXFELEVBRG5FO0FBR0E1N0IsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixxQkFBakIsRUFBd0M3WSxTQUF4QztBQUVBYyxXQUFLLEdBQUdtekIsS0FBSyxDQUFDbnpCLEtBQUssR0FBRyxDQUFULENBQUwsR0FDSkEsS0FBSyxDQUFDZ2IsV0FBTixFQURJLEdBRUpoYixLQUFLLEdBQUcsQ0FGWjtBQUlBUyxVQUFJLENBQUNncEIsVUFBTCxHQUFrQnpwQixLQUFsQjtBQUVBUyxVQUFJLENBQUNzWCxXQUFMLENBQWlCLG9CQUFqQixFQUF1QzdZLFNBQXZDO0FBQ0gsS0FySThCOztBQXVJL0I7Ozs7OztBQU9BOHdCLFFBQUksRUFBRSxnQkFBVztBQUNiLFVBQUl2dkIsSUFBSSxHQUFHLElBQVg7QUFFQUEsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixZQUFqQixFQUErQjdZLFNBQS9COztBQUVBLFVBQUksQ0FBQ3VCLElBQUksQ0FBQ215QixPQUFWLEVBQW1CO0FBQ2ZueUIsWUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3plLEVBQVQsQ0FBWTlFLEtBQVosQ0FBa0J1cUIsT0FBbEIsR0FBNEIsRUFBNUI7QUFFQTF4QixZQUFJLENBQUNteUIsT0FBTCxHQUFlLElBQWY7QUFDSDs7QUFFRG55QixVQUFJLENBQUNzWCxXQUFMLENBQWlCLFdBQWpCLEVBQThCN1ksU0FBOUI7QUFDSCxLQTFKOEI7O0FBNEovQjs7Ozs7O0FBT0E4dkIsUUFBSSxFQUFFLGdCQUFXO0FBQ2IsVUFBSXZ1QixJQUFJLEdBQUcsSUFBWDtBQUVBQSxVQUFJLENBQUNzWCxXQUFMLENBQWlCLFlBQWpCLEVBQStCN1ksU0FBL0I7O0FBRUEsVUFBSXVCLElBQUksQ0FBQ215QixPQUFULEVBQWtCO0FBQ2RueUIsWUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3plLEVBQVQsQ0FBWTlFLEtBQVosQ0FBa0J1cUIsT0FBbEIsR0FBNEIsTUFBNUI7QUFFQTF4QixZQUFJLENBQUNteUIsT0FBTCxHQUFlLEtBQWY7QUFDSDs7QUFFRG55QixVQUFJLENBQUNzWCxXQUFMLENBQWlCLFdBQWpCLEVBQThCN1ksU0FBOUI7QUFDSCxLQS9LOEI7O0FBaUwvQjs7Ozs7OztBQVFBZ0YsUUFBSSxFQUFFLGNBQVM0ekIsUUFBVCxFQUFtQjtBQUNyQixVQUFJcjNCLElBQUksR0FBRyxJQUFYO0FBRUFBLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsWUFBakIsRUFBK0I3WSxTQUEvQjs7QUFFQSxVQUFJLENBQUN1QixJQUFJLENBQUN3N0IsVUFBVixFQUFzQjtBQUNsQng3QixZQUFJLENBQUM4cEIsS0FBTCxDQUFXMEQsWUFBWDtBQUNIOztBQUVEeHRCLFVBQUksQ0FBQzY3QixhQUFMLENBQW1CeEUsUUFBbkI7QUFFQXRqQiwyQkFBcUIsQ0FBQyxZQUFXO0FBQzdCL1QsWUFBSSxDQUFDODdCLGNBQUwsQ0FBb0J6RSxRQUFwQjtBQUNILE9BRm9CLENBQXJCO0FBSUFyM0IsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixXQUFqQixFQUE4QjdZLFNBQTlCO0FBQ0gsS0F6TThCOztBQTJNL0I7Ozs7Ozs7O0FBU0F1OEIsY0FBVSxFQUFFLG9CQUFTcEUsT0FBVCxFQUFrQmtFLFVBQWxCLEVBQThCO0FBQ3RDLFVBQUk5NkIsSUFBSSxHQUFzQixJQUE5QjtBQUFBLFVBQ0krN0IsWUFBWSxHQUFjLEVBRDlCO0FBQUEsVUFFSTNFLFNBQVMsR0FBaUIsSUFGOUI7QUFBQSxVQUdJRixLQUFLLEdBQXFCTixPQUFPLENBQUNNLEtBSHRDO0FBQUEsVUFJSThFLHNCQUFzQixHQUFJLEVBSjlCO0FBQUEsVUFLSUMsYUFBYSxHQUFhLElBQUl2b0IsUUFBTyxDQUFDOFgsU0FBWixFQUw5QjtBQUFBLFVBTUk1dEIsQ0FBQyxHQUF5QixDQUFDLENBTi9CO0FBUUFvQyxVQUFJLENBQUNzWCxXQUFMLENBQWlCLGtCQUFqQixFQUFxQzdZLFNBQXJDO0FBRUF3OUIsbUJBQWEsQ0FBQ3BmLENBQWQsR0FBc0JxYSxLQUFLLENBQUNyYSxDQUE1QjtBQUNBb2YsbUJBQWEsQ0FBQ25mLENBQWQsR0FBc0JvYSxLQUFLLENBQUNwYSxDQUE1Qjs7QUFFQSxVQUFJZ2UsVUFBVSxLQUFLLENBQW5CLEVBQXNCO0FBQ2xCOTZCLFlBQUksQ0FBQ3V1QixJQUFMO0FBQ0gsT0FGRCxNQUVPLElBQUksQ0FBQ3Z1QixJQUFJLENBQUNteUIsT0FBVixFQUFtQjtBQUN0Qm55QixZQUFJLENBQUN1dkIsSUFBTDtBQUNIOztBQUVELFdBQUszeEIsQ0FBQyxHQUFHLENBQVQsRUFBWW0rQixZQUFZLEdBQUdyb0IsUUFBTyxDQUFDa0wsUUFBUixDQUFpQmtGLFNBQWpCLENBQTJCbG1CLENBQTNCLENBQTNCLEVBQTBEQSxDQUFDLEVBQTNELEVBQStEO0FBQzNEdzVCLGlCQUFTLEdBQUdSLE9BQU8sQ0FBQ1EsU0FBUixDQUFrQjJFLFlBQWxCLENBQVo7O0FBRUEsWUFBSUEsWUFBWSxLQUFLLEdBQXJCLEVBQTBCO0FBQ3RCLGNBQUksQ0FBQzNFLFNBQUwsRUFBZ0I7QUFFaEI2RSx1QkFBYSxDQUFDcGYsQ0FBZCxHQUFrQnFhLEtBQUssQ0FBQ3JhLENBQU4sR0FBV3VhLFNBQVMsR0FBRzBELFVBQXpDO0FBQ0gsU0FKRCxNQUlPLElBQUlpQixZQUFZLEtBQUssR0FBckIsRUFBMEI7QUFDN0IsY0FBSSxDQUFDM0UsU0FBTCxFQUFnQjtBQUVoQjZFLHVCQUFhLENBQUNuZixDQUFkLEdBQWtCb2EsS0FBSyxDQUFDcGEsQ0FBTixHQUFXc2EsU0FBUyxHQUFHMEQsVUFBekM7QUFDSCxTQUpNLE1BSUEsSUFBSTFELFNBQVMsWUFBWTFqQixRQUFPLENBQUNtWSxhQUFqQyxFQUFnRDtBQUNuRCxjQUFJLENBQUN1TCxTQUFTLENBQUM3M0IsS0FBZixFQUFzQjtBQUV0QjA4Qix1QkFBYSxDQUFDRixZQUFELENBQWIsQ0FBNEJ4OEIsS0FBNUIsR0FDSTIzQixLQUFLLENBQUM2RSxZQUFELENBQUwsQ0FBb0J4OEIsS0FBcEIsR0FBNkI2M0IsU0FBUyxDQUFDNzNCLEtBQVYsR0FBa0J1N0IsVUFEbkQ7QUFHQW1CLHVCQUFhLENBQUNGLFlBQUQsQ0FBYixDQUE0QjNQLElBQTVCLEdBQW9DZ0wsU0FBUyxDQUFDaEwsSUFBOUM7QUFFQTRQLGdDQUFzQixDQUFDMzVCLElBQXZCLENBQ0kwNUIsWUFBWSxHQUFHLEdBQWYsR0FBcUJFLGFBQWEsQ0FBQ0YsWUFBRCxDQUFiLENBQTRCeDhCLEtBQWpELEdBQXlENjNCLFNBQVMsQ0FBQ2hMLElBQW5FLEdBQTBFLEdBRDlFO0FBR0gsU0FYTSxNQVdBO0FBQ0gsY0FBSSxDQUFDZ0wsU0FBTCxFQUFnQjtBQUVoQjZFLHVCQUFhLENBQUNGLFlBQUQsQ0FBYixHQUE4QjdFLEtBQUssQ0FBQzZFLFlBQUQsQ0FBTCxHQUF1QjNFLFNBQVMsR0FBRzBELFVBQWpFO0FBRUE5NkIsY0FBSSxDQUFDMHFCLEdBQUwsQ0FBU3plLEVBQVQsQ0FBWTlFLEtBQVosQ0FBa0I0MEIsWUFBbEIsSUFBa0NFLGFBQWEsQ0FBQ0YsWUFBRCxDQUEvQztBQUNIO0FBQ0o7O0FBRUQsVUFBSUUsYUFBYSxDQUFDcGYsQ0FBZCxJQUFtQm9mLGFBQWEsQ0FBQ25mLENBQXJDLEVBQXdDO0FBQ3BDa2YsOEJBQXNCLENBQUM1d0IsT0FBdkIsQ0FBK0IsZUFBZTZ3QixhQUFhLENBQUNwZixDQUE3QixHQUFpQyxNQUFqQyxHQUEwQ29mLGFBQWEsQ0FBQ25mLENBQXhELEdBQTRELEtBQTNGO0FBQ0g7O0FBRUQsVUFBSWtmLHNCQUFzQixDQUFDbitCLE1BQTNCLEVBQW1DO0FBQy9CbUMsWUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3plLEVBQVQsQ0FBWTlFLEtBQVosQ0FBa0J1TSxRQUFPLENBQUNrTCxRQUFSLENBQWlCdUUsYUFBbkMsSUFBb0Q2WSxzQkFBc0IsQ0FBQ2h2QixJQUF2QixDQUE0QixHQUE1QixDQUFwRDtBQUNIOztBQUVEaE4sVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixpQkFBakIsRUFBb0M3WSxTQUFwQztBQUNILEtBaFI4Qjs7QUFrUi9COzs7Ozs7Ozs7QUFVQW85QixpQkFBYSxFQUFFLHVCQUFTeEUsUUFBVCxFQUFtQjtBQUM5QixVQUFJcjNCLElBQUksR0FBYyxJQUF0QjtBQUFBLFVBQ0lrM0IsS0FBSyxHQUFhRyxRQUFRLENBQUNILEtBRC9CO0FBQUEsVUFFSWdGLFFBQVEsR0FBVWw4QixJQUFJLENBQUM4cEIsS0FBTCxDQUFXeEYsU0FBWCxDQUFxQjNELE9BQXJCLEtBQWlDLENBRnZEO0FBQUEsVUFHSXdiLGVBQWUsR0FBRyxFQUh0QjtBQUtBbjhCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIscUJBQWpCLEVBQXdDN1ksU0FBeEM7QUFFQTA5QixxQkFBZSxDQUFDOTVCLElBQWhCLENBQXFCLGVBQWU2MEIsS0FBSyxDQUFDcmEsQ0FBckIsR0FBeUIsTUFBekIsR0FBa0NxYSxLQUFLLENBQUNwYSxDQUF4QyxHQUE0QyxLQUFqRTs7QUFFQSxVQUFJOWMsSUFBSSxDQUFDOHBCLEtBQUwsQ0FBVy9ULE1BQVgsQ0FBa0I0UixTQUFsQixDQUE0QjVDLG9CQUFoQyxFQUFzRDtBQUNsRCxZQUFJc1MsUUFBUSxDQUFDQyxZQUFULEtBQTBCLE1BQTlCLEVBQXNDO0FBQ2xDO0FBRUF0M0IsY0FBSSxDQUFDMHFCLEdBQUwsQ0FBU3plLEVBQVQsQ0FBWTlFLEtBQVosQ0FBa0J1QyxLQUFsQixHQUEyQnd0QixLQUFLLENBQUN4dEIsS0FBTixHQUFjLElBQXpDO0FBQ0ExSixjQUFJLENBQUMwcUIsR0FBTCxDQUFTemUsRUFBVCxDQUFZOUUsS0FBWixDQUFrQnNXLE1BQWxCLEdBQTJCeVosS0FBSyxDQUFDelosTUFBTixHQUFlLElBQTFDO0FBQ0g7O0FBRUR6ZCxZQUFJLENBQUMwcUIsR0FBTCxDQUFTemUsRUFBVCxDQUFZOUUsS0FBWixDQUFrQkcsV0FBbEIsR0FBaUM0dkIsS0FBSyxDQUFDNXZCLFdBQU4sR0FBb0IsSUFBckQ7QUFDQXRILFlBQUksQ0FBQzBxQixHQUFMLENBQVN6ZSxFQUFULENBQVk5RSxLQUFaLENBQWtCd2tCLFlBQWxCLEdBQWlDdUwsS0FBSyxDQUFDdkwsWUFBTixHQUFxQixJQUF0RDtBQUNIOztBQUVEdVEsY0FBUSxLQUFLbDhCLElBQUksQ0FBQzBxQixHQUFMLENBQVN6ZSxFQUFULENBQVk5RSxLQUFaLENBQWtCd1osT0FBbEIsR0FBNEJ1VyxLQUFLLENBQUN2VyxPQUF2QyxDQUFSOztBQUVBLFVBQUkwVyxRQUFRLENBQUNDLFlBQVQsS0FBMEIsTUFBOUIsRUFBc0M7QUFDbEM2RSx1QkFBZSxHQUFHQSxlQUFlLENBQUN2dUIsTUFBaEIsQ0FBdUI1TixJQUFJLENBQUM4cEIsS0FBTCxDQUFXK0QsV0FBbEMsQ0FBbEI7QUFDSDs7QUFFRDd0QixVQUFJLENBQUMwcUIsR0FBTCxDQUFTemUsRUFBVCxDQUFZOUUsS0FBWixDQUFrQnVNLFFBQU8sQ0FBQ2tMLFFBQVIsQ0FBaUJ1RSxhQUFuQyxJQUFvRGdaLGVBQWUsQ0FBQ252QixJQUFoQixDQUFxQixHQUFyQixDQUFwRDtBQUVBaE4sVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixvQkFBakIsRUFBdUM3WSxTQUF2QztBQUNILEtBM1Q4Qjs7QUE2VC9COzs7Ozs7Ozs7QUFVQXE5QixrQkFBYyxFQUFFLHdCQUFTekUsUUFBVCxFQUFtQjtBQUMvQixVQUFJcjNCLElBQUksR0FBYyxJQUF0QjtBQUFBLFVBQ0lvOEIsZUFBZSxHQUFHLEVBRHRCO0FBQUEsVUFFSUQsZUFBZSxHQUFHLEVBRnRCO0FBQUEsVUFHSUUsVUFBVSxHQUFRcjhCLElBQUksQ0FBQzhwQixLQUFMLENBQVcvVCxNQUFYLENBQWtCNFIsU0FBbEIsQ0FBNEI1QyxvQkFIbEQ7QUFBQSxVQUlJbVgsUUFBUSxHQUFVLE9BQU9sOEIsSUFBSSxDQUFDOHBCLEtBQUwsQ0FBV3hGLFNBQVgsQ0FBcUIzRCxPQUE1QixLQUF3QyxXQUo5RDtBQU1BM2dCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsc0JBQWpCLEVBQXlDN1ksU0FBekMsRUFQK0IsQ0FTL0I7O0FBRUEyOUIscUJBQWUsQ0FBQy81QixJQUFoQixDQUFxQnJDLElBQUksQ0FBQ3M4QixtQkFBTCxDQUNqQjVvQixRQUFPLENBQUNrTCxRQUFSLENBQWlCd0UsYUFEQSxFQUVqQmlVLFFBQVEsQ0FBQ0csWUFGUSxDQUFyQjs7QUFLQSxVQUFJSCxRQUFRLENBQUNDLFlBQVQsS0FBMEIsTUFBOUIsRUFBc0M7QUFDbEM4RSx1QkFBZSxDQUFDLzVCLElBQWhCLENBQXFCckMsSUFBSSxDQUFDczhCLG1CQUFMLENBQ2pCLFNBRGlCLEVBRWpCakYsUUFBUSxDQUFDRyxZQUZRLEVBR2pCSCxRQUFRLENBQUNwcEIsUUFIUSxDQUFyQjtBQUtIOztBQUVELFVBQUlvdUIsVUFBSixFQUFnQjtBQUNaRCx1QkFBZSxDQUFDLzVCLElBQWhCLENBQXFCckMsSUFBSSxDQUFDczhCLG1CQUFMLENBQ2pCLE9BRGlCLEVBRWpCakYsUUFBUSxDQUFDRyxZQUZRLEVBR2pCSCxRQUFRLENBQUNwcEIsUUFIUSxDQUFyQjtBQU1BbXVCLHVCQUFlLENBQUMvNUIsSUFBaEIsQ0FBcUJyQyxJQUFJLENBQUNzOEIsbUJBQUwsQ0FDakIsUUFEaUIsRUFFakJqRixRQUFRLENBQUNHLFlBRlEsRUFHakJILFFBQVEsQ0FBQ3BwQixRQUhRLENBQXJCO0FBTUFtdUIsdUJBQWUsQ0FBQy81QixJQUFoQixDQUFxQnJDLElBQUksQ0FBQ3M4QixtQkFBTCxDQUNqQixRQURpQixFQUVqQmpGLFFBQVEsQ0FBQ0csWUFGUSxFQUdqQkgsUUFBUSxDQUFDcHBCLFFBSFEsQ0FBckI7QUFLSCxPQTFDOEIsQ0E0Qy9CO0FBQ0E7OztBQUVBLFVBQUksQ0FBQ29wQixRQUFRLENBQUNscEIsUUFBZCxFQUF3QjtBQUNwQm5PLFlBQUksQ0FBQzhwQixLQUFMLENBQVcyRCxnQkFBWDs7QUFFQSxZQUFJenRCLElBQUksQ0FBQzhwQixLQUFMLENBQVcwRCxZQUFYLEtBQTRCeHRCLElBQUksQ0FBQzhwQixLQUFMLENBQVcyRCxnQkFBM0MsRUFBNkQ7QUFDekQ7QUFDQTtBQUNBO0FBRUF6dEIsY0FBSSxDQUFDOHBCLEtBQUwsQ0FBV3VLLE9BQVgsQ0FBbUJnRCxRQUFRLENBQUN2SSxTQUE1QjtBQUNIOztBQUVEO0FBQ0gsT0EzRDhCLENBNkQvQjtBQUNBOzs7QUFFQTl1QixVQUFJLENBQUM4dUIsU0FBTCxHQUFpQnVJLFFBQVEsQ0FBQ3ZJLFNBQTFCO0FBQ0E5dUIsVUFBSSxDQUFDbU8sUUFBTCxHQUFnQmtwQixRQUFRLENBQUNscEIsUUFBekIsQ0FqRStCLENBbUUvQjtBQUNBOztBQUVBLE9BQUNuTyxJQUFJLENBQUN3N0IsVUFBTixJQUFvQng3QixJQUFJLENBQUM4cEIsS0FBTCxDQUFXNEQsWUFBWCxFQUFwQixDQXRFK0IsQ0F3RS9CO0FBQ0E7O0FBRUExdEIsVUFBSSxDQUFDNnBCLE9BQUwsR0FBZSxJQUFmLENBM0UrQixDQTZFL0I7O0FBRUE3cEIsVUFBSSxDQUFDdThCLGVBQUwsQ0FBcUJILGVBQXJCLEVBL0UrQixDQWlGL0I7O0FBRUEsVUFBSUMsVUFBVSxJQUFJaEYsUUFBUSxDQUFDRixNQUFULENBQWdCenRCLEtBQWhCLEdBQXdCLENBQXRDLElBQTJDMnRCLFFBQVEsQ0FBQ0YsTUFBVCxDQUFnQjFaLE1BQWhCLEdBQXlCLENBQXhFLEVBQTJFO0FBQ3ZFemQsWUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3plLEVBQVQsQ0FBWTlFLEtBQVosQ0FBa0J1QyxLQUFsQixHQUFpQzJ0QixRQUFRLENBQUNGLE1BQVQsQ0FBZ0J6dEIsS0FBaEIsR0FBd0IsSUFBekQ7QUFDQTFKLFlBQUksQ0FBQzBxQixHQUFMLENBQVN6ZSxFQUFULENBQVk5RSxLQUFaLENBQWtCc1csTUFBbEIsR0FBaUM0WixRQUFRLENBQUNGLE1BQVQsQ0FBZ0IxWixNQUFoQixHQUF5QixJQUExRDtBQUNBemQsWUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3plLEVBQVQsQ0FBWTlFLEtBQVosQ0FBa0JHLFdBQWxCLEdBQWlDK3ZCLFFBQVEsQ0FBQ0YsTUFBVCxDQUFnQjd2QixXQUFoQixHQUE4QixJQUEvRDtBQUNBdEgsWUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3plLEVBQVQsQ0FBWTlFLEtBQVosQ0FBa0J3a0IsWUFBbEIsR0FBaUMwTCxRQUFRLENBQUNGLE1BQVQsQ0FBZ0J4TCxZQUFoQixHQUErQixJQUFoRTtBQUNIOztBQUVELFVBQUksQ0FBQzNyQixJQUFJLENBQUM4cEIsS0FBTCxDQUFXL1QsTUFBWCxDQUFrQjRSLFNBQWxCLENBQTRCekMsS0FBN0IsSUFBc0NtUyxRQUFRLENBQUNDLFlBQVQsS0FBMEIsTUFBcEUsRUFBNEU7QUFDeEU7QUFDQTtBQUNBO0FBRUE2RSx1QkFBZSxDQUFDOTVCLElBQWhCLENBQXFCLGVBQWVnMUIsUUFBUSxDQUFDRixNQUFULENBQWdCdGEsQ0FBL0IsR0FBbUMsTUFBbkMsR0FBNEN3YSxRQUFRLENBQUNGLE1BQVQsQ0FBZ0JyYSxDQUE1RCxHQUFnRSxLQUFyRjtBQUNILE9BaEc4QixDQWtHL0I7OztBQUVBLGNBQVF1YSxRQUFRLENBQUNDLFlBQWpCO0FBQ0ksYUFBSyxNQUFMO0FBQ0k0RSxrQkFBUSxLQUFLbDhCLElBQUksQ0FBQzBxQixHQUFMLENBQVN6ZSxFQUFULENBQVk5RSxLQUFaLENBQWtCd1osT0FBbEIsR0FBNEIzZ0IsSUFBSSxDQUFDOHBCLEtBQUwsQ0FBV3ZGLFVBQVgsQ0FBc0I1RCxPQUF2RCxDQUFSO0FBRUF3Yix5QkFBZSxHQUFHQSxlQUFlLENBQUN2dUIsTUFBaEIsQ0FBdUI1TixJQUFJLENBQUM4cEIsS0FBTCxDQUFXZ0UsWUFBbEMsQ0FBbEI7QUFFQTs7QUFDSixhQUFLLE1BQUw7QUFDSW9PLGtCQUFRLEtBQUtsOEIsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3plLEVBQVQsQ0FBWTlFLEtBQVosQ0FBa0J3WixPQUFsQixHQUE0QixDQUFqQyxDQUFSO0FBUlI7O0FBV0EsVUFDSTNnQixJQUFJLENBQUM4cEIsS0FBTCxDQUFXL1QsTUFBWCxDQUFrQjRSLFNBQWxCLENBQTRCekMsS0FBNUIsSUFDQyxDQUFDbGxCLElBQUksQ0FBQzhwQixLQUFMLENBQVcvVCxNQUFYLENBQWtCNFIsU0FBbEIsQ0FBNEJ6QyxLQUE3QixJQUFzQ21TLFFBQVEsQ0FBQ0MsWUFBVCxLQUEwQixNQUZyRSxFQUdFO0FBQ0U7QUFDQTtBQUVBNkUsdUJBQWUsQ0FBQzk1QixJQUFoQixDQUFxQixlQUFlZzFCLFFBQVEsQ0FBQ0YsTUFBVCxDQUFnQnRhLENBQS9CLEdBQW1DLE1BQW5DLEdBQTRDd2EsUUFBUSxDQUFDRixNQUFULENBQWdCcmEsQ0FBNUQsR0FBZ0UsS0FBckY7QUFDSCxPQXZIOEIsQ0F5SC9COzs7QUFFQTljLFVBQUksQ0FBQzBxQixHQUFMLENBQVN6ZSxFQUFULENBQVk5RSxLQUFaLENBQWtCdU0sUUFBTyxDQUFDa0wsUUFBUixDQUFpQnVFLGFBQW5DLElBQW9EZ1osZUFBZSxDQUFDbnZCLElBQWhCLENBQXFCLEdBQXJCLENBQXBEO0FBRUFoTixVQUFJLENBQUNzWCxXQUFMLENBQWlCLHFCQUFqQixFQUF3QzdZLFNBQXhDO0FBQ0gsS0FyYzhCOztBQXVjL0I7Ozs7Ozs7Ozs7OztBQWFBNjlCLHVCQUFtQixFQUFFLDZCQUFTdjlCLFFBQVQsRUFBbUJ5NEIsWUFBbkIsRUFBaUN2cEIsUUFBakMsRUFBMkM7QUFDNUQsVUFBSWpPLElBQUksR0FBSSxJQUFaO0FBQUEsVUFDSXc4QixLQUFLLEdBQUd4OEIsSUFBSSxDQUFDeThCLFFBQUwsQ0FBY2pGLFlBQWQsQ0FEWjtBQUFBLFVBRUl0RSxJQUFJLEdBQUksRUFGWjtBQUlBQSxVQUFJLEdBQUduMEIsUUFBUSxHQUFHLEdBQVgsSUFDRmtQLFFBQVEsR0FBRyxDQUFYLEdBQWVBLFFBQWYsR0FBMEJqTyxJQUFJLENBQUM4cEIsS0FBTCxDQUFXL1QsTUFBWCxDQUFrQjRSLFNBQWxCLENBQTRCMVosUUFEcEQsSUFDZ0UsS0FEaEUsR0FFSHV1QixLQUZHLEdBRUssS0FGTCxJQUdGejlCLFFBQVEsS0FBSyxTQUFiLEdBQXlCLFFBQXpCLEdBQW9DaUIsSUFBSSxDQUFDOHBCLEtBQUwsQ0FBVy9ULE1BQVgsQ0FBa0I0UixTQUFsQixDQUE0Qm5ELE1BSDlELENBQVA7QUFLQSxhQUFPeGtCLElBQUksQ0FBQ3VpQixXQUFMLENBQWlCLHlCQUFqQixFQUE0QzJRLElBQTVDLEVBQWtEejBCLFNBQWxELENBQVA7QUFDSCxLQS9kOEI7O0FBaWUvQjs7Ozs7Ozs7Ozs7O0FBYUFnK0IsWUFBUSxFQUFFLGtCQUFTcjZCLEtBQVQsRUFBZ0I7QUFDdEIsVUFBSXBDLElBQUksR0FBTSxJQUFkO0FBQUEsVUFDSXc4QixLQUFLLEdBQUssQ0FBQyxDQURmOztBQUdBLFVBQUksT0FBT3g4QixJQUFJLENBQUM4cEIsS0FBTCxDQUFXL1QsTUFBWCxDQUFrQjRSLFNBQWxCLENBQTRCM0MsZUFBbkMsS0FBdUQsVUFBM0QsRUFBdUU7QUFDbkU1aUIsYUFBSyxHQUFHcEMsSUFBSSxDQUFDOHBCLEtBQUwsQ0FBVy9ULE1BQVgsQ0FBa0I0UixTQUFsQixDQUE0QjNDLGVBQTVCLENBQTRDcG1CLElBQTVDLENBQWlEb0IsSUFBakQsRUFBdURvQyxLQUF2RCxFQUE4RHBDLElBQUksQ0FBQzZxQixLQUFuRSxDQUFSO0FBQ0g7O0FBRUQyUixXQUFLLEdBQUcsQ0FBQyxDQUFDeDhCLElBQUksQ0FBQzhwQixLQUFMLENBQVc4RCxlQUFiLEdBQStCeHJCLEtBQUssR0FBR3BDLElBQUksQ0FBQzhwQixLQUFMLENBQVc4RCxlQUFsRCxHQUFvRSxDQUE1RTtBQUVBLGFBQU81dEIsSUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIsZUFBakIsRUFBa0NpYSxLQUFsQyxFQUF5Qy85QixTQUF6QyxDQUFQO0FBQ0gsS0F6ZjhCOztBQTJmL0I7Ozs7Ozs7QUFRQTg5QixtQkFBZSxFQUFFLHlCQUFTdEosS0FBVCxFQUFnQjtBQUM3QixVQUFJanpCLElBQUksR0FBa0IsSUFBMUI7QUFBQSxVQUNJMDhCLGdCQUFnQixHQUFNekosS0FBSyxDQUFDam1CLElBQU4sQ0FBVyxJQUFYLENBRDFCO0FBR0FoTixVQUFJLENBQUNzWCxXQUFMLENBQWlCLHVCQUFqQixFQUEwQzdZLFNBQTFDO0FBRUF1QixVQUFJLENBQUMwcUIsR0FBTCxDQUFTemUsRUFBVCxDQUFZOUUsS0FBWixDQUFrQnVNLFFBQU8sQ0FBQ2tMLFFBQVIsQ0FBaUJ5RSxjQUFuQyxJQUFxRHFaLGdCQUFyRDtBQUVBMThCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsc0JBQWpCLEVBQXlDN1ksU0FBekM7QUFDSCxLQTVnQjhCOztBQThnQi9COzs7Ozs7O0FBUUFrK0IsdUJBQW1CLEVBQUUsNkJBQVNydUIsQ0FBVCxFQUFZO0FBQzdCLFVBQUl0TyxJQUFJLEdBQVUsSUFBbEI7QUFBQSxVQUNJNDhCLFFBQVEsR0FBTXR1QixDQUFDLENBQUN5dEIsWUFEcEI7QUFBQSxVQUVJYyxTQUFTLEdBQUs3OEIsSUFBSSxDQUFDOHBCLEtBQUwsQ0FBVy9ULE1BQVgsQ0FBa0I0UixTQUFsQixDQUE0QjVDLG9CQUY5QztBQUlBL2tCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsMkJBQWpCLEVBQThDN1ksU0FBOUM7O0FBRUEsVUFDSXVCLElBQUksQ0FBQzZwQixPQUFMLElBQ0F2YixDQUFDLENBQUM1USxNQUFGLENBQVMyVixPQUFULENBQWlCclQsSUFBSSxDQUFDOHBCLEtBQUwsQ0FBVy9ULE1BQVgsQ0FBa0JpUyxTQUFsQixDQUE0QnRxQixNQUE3QyxDQURBLEtBR0lrL0IsUUFBUSxDQUFDenZCLE9BQVQsQ0FBaUIsV0FBakIsSUFBZ0MsQ0FBQyxDQUFqQyxJQUNBeXZCLFFBQVEsQ0FBQ3p2QixPQUFULENBQWlCLFNBQWpCLElBQThCLENBQUMsQ0FEL0IsSUFFQTB2QixTQUFTLElBQUlELFFBQVEsQ0FBQ3p2QixPQUFULENBQWlCLFFBQWpCLElBQTZCLENBQUMsQ0FGM0MsSUFHQTB2QixTQUFTLElBQUlELFFBQVEsQ0FBQ3p2QixPQUFULENBQWlCLE9BQWpCLElBQTRCLENBQUMsQ0FIMUMsSUFJQTB2QixTQUFTLElBQUlELFFBQVEsQ0FBQ3p2QixPQUFULENBQWlCLFFBQWpCLElBQTZCLENBQUMsQ0FQL0MsQ0FESixFQVVFO0FBQ0VuTixZQUFJLENBQUNtTyxRQUFMLENBQWN2UCxJQUFkLENBQW1Cb0IsSUFBbkIsRUFBeUJBLElBQUksQ0FBQzh1QixTQUE5QjtBQUVBOXVCLFlBQUksQ0FBQzZwQixPQUFMLEdBQWUsS0FBZjtBQUNBN3BCLFlBQUksQ0FBQ21PLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQW5PLFlBQUksQ0FBQzh1QixTQUFMLEdBQWlCLElBQWpCO0FBQ0g7O0FBRUQ5dUIsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQiwwQkFBakIsRUFBNkM3WSxTQUE3QztBQUNILEtBaGpCOEI7O0FBa2pCL0I7Ozs7Ozs7QUFRQXErQixZQUFRLEVBQUUsa0JBQVN4dUIsQ0FBVCxFQUFZO0FBQ2xCLFVBQUl0TyxJQUFJLEdBQUcsSUFBWDtBQUVBQSxVQUFJLENBQUNzWCxXQUFMLENBQWlCLGdCQUFqQixFQUFtQzdZLFNBQW5DOztBQUVBLGNBQVE2UCxDQUFDLENBQUM3VCxJQUFWO0FBQ0ksYUFBSyxxQkFBTDtBQUNBLGFBQUssZUFBTDtBQUNJdUYsY0FBSSxDQUFDMjhCLG1CQUFMLENBQXlCcnVCLENBQXpCO0FBSFI7O0FBTUF0TyxVQUFJLENBQUNzWCxXQUFMLENBQWlCLGVBQWpCLEVBQWtDN1ksU0FBbEM7QUFDSCxLQXRrQjhCOztBQXdrQi9COzs7Ozs7QUFPQWs3QixnQkFBWSxFQUFFLHdCQUFXO0FBQ3JCLFVBQUkzNUIsSUFBSSxHQUFHLElBQVg7QUFFQUEsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixvQkFBakIsRUFBdUM3WSxTQUF2QztBQUVBa1YsT0FBQyxDQUFDdEgsR0FBRixDQUFNck0sSUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3plLEVBQWYsRUFBbUIscUJBQW5CLEVBQTBDak0sSUFBSSxDQUFDbUMsT0FBL0M7QUFDQXdSLE9BQUMsQ0FBQ3RILEdBQUYsQ0FBTXJNLElBQUksQ0FBQzBxQixHQUFMLENBQVN6ZSxFQUFmLEVBQW1CLGVBQW5CLEVBQW9Dak0sSUFBSSxDQUFDbUMsT0FBekM7QUFFQW5DLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsbUJBQWpCLEVBQXNDN1ksU0FBdEM7QUFDSCxLQXhsQjhCOztBQTBsQi9COzs7Ozs7QUFPQW83QixjQUFVLEVBQUUsc0JBQVc7QUFDbkIsVUFBSTc1QixJQUFJLEdBQWtCLElBQTFCO0FBQUEsVUFDSSs4QixrQkFBa0IsR0FBSSxFQUQxQjtBQUdBLzhCLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsa0JBQWpCLEVBQXFDN1ksU0FBckM7QUFFQXMrQix3QkFBa0IsR0FBR3JwQixRQUFPLENBQUNrTCxRQUFSLENBQWlCc0UsZ0JBQWpCLEtBQXNDLFFBQXRDLEdBQWlELHFCQUFqRCxHQUF5RSxlQUE5Rjs7QUFFQWxqQixVQUFJLENBQUNtQyxPQUFMLEdBQWUsVUFBU21NLENBQVQsRUFBWTtBQUN2QixlQUFPdE8sSUFBSSxDQUFDODhCLFFBQUwsQ0FBY3h1QixDQUFkLENBQVA7QUFDSCxPQUZEOztBQUlBcUYsT0FBQyxDQUFDMVIsRUFBRixDQUFLakMsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3plLEVBQWQsRUFBa0I4d0Isa0JBQWxCLEVBQXNDLzhCLElBQUksQ0FBQ21DLE9BQTNDO0FBRUFuQyxVQUFJLENBQUNzWCxXQUFMLENBQWlCLGlCQUFqQixFQUFvQzdZLFNBQXBDO0FBQ0gsS0FobkI4Qjs7QUFrbkIvQjs7Ozs7OztBQVFBNDJCLGNBQVUsRUFBRSxvQkFBUzJILE1BQVQsRUFBaUI7QUFDekIsVUFBSWg5QixJQUFJLEdBQU0sSUFBZDtBQUFBLFVBQ0l3Z0IsTUFBTSxHQUFJLEVBRGQ7QUFBQSxVQUVJeWMsSUFBSSxHQUFNLElBRmQ7QUFBQSxVQUdJckcsT0FBTyxHQUFHLElBQUlsakIsUUFBTyxDQUFDOFgsU0FBWixFQUhkO0FBS0F4ckIsVUFBSSxDQUFDc1gsV0FBTCxDQUFpQixrQkFBakIsRUFBcUM3WSxTQUFyQztBQUVBbTRCLGFBQU8sQ0FBQy9aLENBQVIsR0FBWTdjLElBQUksQ0FBQzBxQixHQUFMLENBQVN6ZSxFQUFULENBQVkwUSxVQUF4QjtBQUNBaWEsYUFBTyxDQUFDOVosQ0FBUixHQUFZOWMsSUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3plLEVBQVQsQ0FBWTJRLFNBQXhCOztBQUVBLFVBQUk1YyxJQUFJLENBQUM4cEIsS0FBTCxDQUFXL1QsTUFBWCxDQUFrQjRSLFNBQWxCLENBQTRCNUMsb0JBQTVCLElBQW9EaVksTUFBeEQsRUFBZ0U7QUFDNURDLFlBQUksR0FBR2o5QixJQUFJLENBQUMwcUIsR0FBTCxDQUFTemUsRUFBVCxDQUFZa3BCLHFCQUFaLEVBQVA7QUFFQXlCLGVBQU8sQ0FBQzdZLEdBQVIsR0FBa0JrZixJQUFJLENBQUNsZixHQUF2QjtBQUNBNlksZUFBTyxDQUFDbkwsS0FBUixHQUFrQndSLElBQUksQ0FBQ3hSLEtBQXZCO0FBQ0FtTCxlQUFPLENBQUNsTCxNQUFSLEdBQWtCdVIsSUFBSSxDQUFDdlIsTUFBdkI7QUFDQWtMLGVBQU8sQ0FBQzlZLElBQVIsR0FBa0JtZixJQUFJLENBQUNuZixJQUF2QjtBQUVBOFksZUFBTyxDQUFDbHRCLEtBQVIsR0FBaUJ1ekIsSUFBSSxDQUFDdnpCLEtBQXRCO0FBQ0FrdEIsZUFBTyxDQUFDblosTUFBUixHQUFpQndmLElBQUksQ0FBQ3hmLE1BQXRCO0FBQ0g7O0FBRUQsVUFBSXpkLElBQUksQ0FBQzhwQixLQUFMLENBQVcvVCxNQUFYLENBQWtCNFIsU0FBbEIsQ0FBNEI1QyxvQkFBaEMsRUFBc0Q7QUFDbER2RSxjQUFNLEdBQUdyWSxNQUFNLENBQUNzWSxnQkFBUCxDQUF3QnpnQixJQUFJLENBQUMwcUIsR0FBTCxDQUFTemUsRUFBakMsQ0FBVDtBQUVBMnFCLGVBQU8sQ0FBQ2pMLFlBQVIsR0FBdUJ0ckIsVUFBVSxDQUFDbWdCLE1BQU0sQ0FBQ21MLFlBQVIsQ0FBakM7QUFDQWlMLGVBQU8sQ0FBQ3R2QixXQUFSLEdBQXVCakgsVUFBVSxDQUFDbWdCLE1BQU0sQ0FBQ2xaLFdBQVIsQ0FBakM7QUFDSDs7QUFFRCxhQUFPdEgsSUFBSSxDQUFDdWlCLFdBQUwsQ0FBaUIsbUJBQWpCLEVBQXNDcVUsT0FBdEMsRUFBK0NuNEIsU0FBL0MsQ0FBUDtBQUNILEtBenBCOEI7O0FBMnBCL0I7Ozs7OztBQU9BNDFCLFdBQU8sRUFBRSxtQkFBVztBQUNoQixVQUFJcjBCLElBQUksR0FBRyxJQUFYO0FBRUFBLFVBQUksQ0FBQ3NYLFdBQUwsQ0FBaUIsZUFBakIsRUFBa0M3WSxTQUFsQztBQUVBdUIsVUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3plLEVBQVQsQ0FBWTlFLEtBQVosQ0FBa0J1TSxRQUFPLENBQUNrTCxRQUFSLENBQWlCdUUsYUFBbkMsSUFBcUQsRUFBckQ7QUFDQW5qQixVQUFJLENBQUMwcUIsR0FBTCxDQUFTemUsRUFBVCxDQUFZOUUsS0FBWixDQUFrQnVNLFFBQU8sQ0FBQ2tMLFFBQVIsQ0FBaUJ5RSxjQUFuQyxJQUFxRCxFQUFyRDtBQUNBcmpCLFVBQUksQ0FBQzBxQixHQUFMLENBQVN6ZSxFQUFULENBQVk5RSxLQUFaLENBQWtCd1osT0FBbEIsR0FBcUQsRUFBckQ7O0FBRUEsVUFBSTNnQixJQUFJLENBQUM4cEIsS0FBTCxDQUFXL1QsTUFBWCxDQUFrQjRSLFNBQWxCLENBQTRCNUMsb0JBQWhDLEVBQXNEO0FBQ2xEL2tCLFlBQUksQ0FBQzBxQixHQUFMLENBQVN6ZSxFQUFULENBQVk5RSxLQUFaLENBQWtCdUMsS0FBbEIsR0FBaUMsRUFBakM7QUFDQTFKLFlBQUksQ0FBQzBxQixHQUFMLENBQVN6ZSxFQUFULENBQVk5RSxLQUFaLENBQWtCc1csTUFBbEIsR0FBaUMsRUFBakM7QUFDQXpkLFlBQUksQ0FBQzBxQixHQUFMLENBQVN6ZSxFQUFULENBQVk5RSxLQUFaLENBQWtCRyxXQUFsQixHQUFpQyxFQUFqQztBQUNBdEgsWUFBSSxDQUFDMHFCLEdBQUwsQ0FBU3plLEVBQVQsQ0FBWTlFLEtBQVosQ0FBa0J3a0IsWUFBbEIsR0FBaUMsRUFBakM7QUFDSDs7QUFFRDNyQixVQUFJLENBQUNzWCxXQUFMLENBQWlCLGNBQWpCLEVBQWlDN1ksU0FBakM7QUFDSDtBQW5yQjhCLEdBQW5DO0FBc3JCQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUFpVixVQUFPLENBQUN3RCxVQUFSLEdBQXFCLFVBQVNiLFNBQVQsRUFBb0I7QUFDckMsUUFBSWhaLFFBQVEsR0FBTSxJQUFsQjtBQUFBLFFBQ0lPLENBQUMsR0FBYSxDQUFDLENBRG5CO0FBR0EsU0FBSzBaLFdBQUwsQ0FBaUIsaUJBQWpCOztBQUVBLFNBQUsxWixDQUFDLEdBQUcsQ0FBVCxFQUFZUCxRQUFRLEdBQUdnWixTQUFTLENBQUN6WSxDQUFELENBQWhDLEVBQXFDQSxDQUFDLEVBQXRDLEVBQTBDO0FBQ3RDLFdBQUtBLENBQUwsSUFBVVAsUUFBVjtBQUNIOztBQUVELFNBQUtRLE1BQUwsR0FBY3dZLFNBQVMsQ0FBQ3hZLE1BQXhCO0FBRUEsU0FBS3laLFdBQUwsQ0FBaUIsZ0JBQWpCO0FBRUEzRCxLQUFDLENBQUNrTixNQUFGLENBQVMsSUFBVDtBQUNILEdBZkQ7O0FBaUJBbk4sVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQ3dELFVBQWhDOztBQUVBeEQsVUFBTyxDQUFDd0QsVUFBUixDQUFtQi9aLFNBQW5CLEdBQStCZSxNQUFNLENBQUMwQixNQUFQLENBQWM4VCxRQUFPLENBQUMyRCxJQUFSLENBQWFsYSxTQUEzQixDQUEvQjtBQUVBd1csR0FBQyxDQUFDdUUsTUFBRixDQUFTeEUsUUFBTyxDQUFDd0QsVUFBUixDQUFtQi9aLFNBQTVCO0FBQ0E7QUFDQTtBQUNJRCxlQUFXLEVBQUV3VyxRQUFPLENBQUN3RCxVQUR6Qjs7QUFHSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBeEQsV0FBTyxFQUFFLGlCQUFTd3BCLFVBQVQsRUFBcUI7QUFDMUIsVUFBSWw5QixJQUFJLEdBQVUsSUFBbEI7QUFBQSxVQUNJM0MsUUFBUSxHQUFNLElBRGxCO0FBQUEsVUFFSThJLElBQUksR0FBVXZGLEtBQUssQ0FBQ3pELFNBQU4sQ0FBZ0JzTCxLQUFoQixDQUFzQjdKLElBQXRCLENBQTJCSCxTQUEzQixDQUZsQjtBQUFBLFVBR0k0Z0IsS0FBSyxHQUFTLEVBSGxCO0FBQUEsVUFJSXpoQixDQUFDLEdBQWEsQ0FBQyxDQUpuQjtBQU1BLFdBQUswWixXQUFMLENBQWlCLGVBQWpCO0FBRUFuUixVQUFJLENBQUNpckIsS0FBTDs7QUFFQSxXQUFLeHpCLENBQUMsR0FBRyxDQUFULEVBQVlQLFFBQVEsR0FBRzJDLElBQUksQ0FBQ3BDLENBQUQsQ0FBM0IsRUFBZ0NBLENBQUMsRUFBakMsRUFBcUM7QUFDakN5aEIsYUFBSyxDQUFDaGQsSUFBTixDQUFXaEYsUUFBUSxDQUFDNi9CLFVBQUQsQ0FBUixDQUFxQjEyQixLQUFyQixDQUEyQm5KLFFBQTNCLEVBQXFDOEksSUFBckMsQ0FBWDtBQUNIOztBQUVELGFBQU9uRyxJQUFJLENBQUN1aUIsV0FBTCxDQUFpQixnQkFBakIsRUFBbUM1TyxDQUFDLENBQUN5TCxHQUFGLENBQU1DLEtBQU4sRUFBYTNMLFFBQU8sQ0FBQ2lFLFNBQXJCLENBQW5DLEVBQW9FbFosU0FBcEUsQ0FBUDtBQUNIO0FBNUNMLEdBRkE7QUFpREE7Ozs7Ozs7Ozs7OztBQVlBaVYsVUFBTyxDQUFDcWIsU0FBUixHQUFvQixZQUFXO0FBQzNCcmIsWUFBTyxDQUFDMkQsSUFBUixDQUFhelksSUFBYixDQUFrQixJQUFsQjs7QUFFQSxTQUFLMFksV0FBTCxDQUFpQixpQkFBakI7QUFFQSxTQUFLaEIsRUFBTCxHQUErQixFQUEvQjtBQUVBLFNBQUtuUSxJQUFMLEdBQStCLEVBQS9CO0FBQ0EsU0FBS3FrQixPQUFMLEdBQStCLElBQS9CO0FBQ0EsU0FBSzhLLFdBQUwsR0FBK0IsRUFBL0I7QUFDQSxTQUFLRSxhQUFMLEdBQStCLEVBQS9CO0FBRUEsU0FBS3JCLFVBQUwsR0FBK0IsSUFBL0I7QUFDQSxTQUFLQyxRQUFMLEdBQStCLElBQS9CO0FBQ0EsU0FBS0UsUUFBTCxHQUErQixJQUEvQjtBQUVBLFNBQUtoQyxRQUFMLEdBQStCLEtBQS9CO0FBQ0EsU0FBSzRCLGdCQUFMLEdBQStCLEtBQS9CO0FBQ0EsU0FBS3lELFNBQUwsR0FBK0IsS0FBL0I7QUFDQSxTQUFLMUYsU0FBTCxHQUErQixLQUEvQjtBQUVBLFNBQUsvRSxjQUFMLEdBQStCLElBQS9CO0FBRUEsU0FBS3FDLElBQUwsR0FBK0IsRUFBL0I7QUFDQSxTQUFLaEIsSUFBTCxHQUErQixFQUEvQjtBQUNBLFNBQUt5RCxRQUFMLEdBQStCLEVBQS9CO0FBQ0EsU0FBS0QsTUFBTCxHQUErQixFQUEvQjtBQUNBLFNBQUt6RCxNQUFMLEdBQStCLEVBQS9CO0FBQ0EsU0FBSzZPLE1BQUwsR0FBK0IsRUFBL0I7QUFDQSxTQUFLckwsUUFBTCxHQUErQixFQUEvQjtBQUNBLFNBQUsvQixVQUFMLEdBQStCLEVBQS9CO0FBQ0EsU0FBS0QsUUFBTCxHQUErQixFQUEvQjtBQUNBLFNBQUtJLFNBQUwsR0FBK0IsSUFBL0I7QUFDQSxTQUFLUCxPQUFMLEdBQStCLElBQS9CO0FBQ0EsU0FBS0ssV0FBTCxHQUErQixJQUEvQjtBQUNBLFNBQUtDLFNBQUwsR0FBK0IsSUFBL0I7QUFDQSxTQUFLZixZQUFMLEdBQStCLElBQS9CO0FBQ0EsU0FBS0MsVUFBTCxHQUErQixJQUEvQjtBQUNBLFNBQUswRixjQUFMLEdBQStCLENBQS9CO0FBQ0EsU0FBS0gsY0FBTCxHQUErQixDQUEvQjtBQUNBLFNBQUtlLE1BQUwsR0FBK0IsQ0FBL0I7QUFDQSxTQUFLQyxNQUFMLEdBQStCLENBQS9CO0FBQ0EsU0FBS2xCLFdBQUwsR0FBK0IsQ0FBL0I7QUFDQSxTQUFLRyxVQUFMLEdBQStCLENBQS9CO0FBQ0EsU0FBSzhCLElBQUwsR0FBK0IsQ0FBL0I7QUFDQSxTQUFLQyxJQUFMLEdBQStCLENBQS9CO0FBQ0EsU0FBS2pDLFNBQUwsR0FBK0IsQ0FBL0I7QUFDQSxTQUFLRyxRQUFMLEdBQStCLENBQS9CO0FBQ0EsU0FBS3ZGLHVCQUFMLEdBQStCLEVBQS9CO0FBQ0EsU0FBSytOLFlBQUwsR0FBK0IsRUFBL0I7QUFDQSxTQUFLOU4scUJBQUwsR0FBK0IsRUFBL0I7QUFDQSxTQUFLK04sVUFBTCxHQUErQixFQUEvQjtBQUVBLFNBQUsvbEIsV0FBTCxDQUFpQixnQkFBakI7QUFFQTNELEtBQUMsQ0FBQ2lOLElBQUYsQ0FBTyxJQUFQO0FBQ0gsR0F4REQ7O0FBMERBbE4sVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQ3FiLFNBQWhDOztBQUVBcmIsVUFBTyxDQUFDcWIsU0FBUixDQUFrQjV4QixTQUFsQixHQUE4QmUsTUFBTSxDQUFDMEIsTUFBUCxDQUFjOFQsUUFBTyxDQUFDMkQsSUFBUixDQUFhbGEsU0FBM0IsQ0FBOUI7QUFFQXVXLFVBQU8sQ0FBQ3FiLFNBQVIsQ0FBa0I1eEIsU0FBbEIsQ0FBNEJELFdBQTVCLEdBQTBDd1csUUFBTyxDQUFDcWIsU0FBbEQ7QUFFQTs7Ozs7Ozs7Ozs7OztBQWFBcmIsVUFBTyxDQUFDcVosS0FBUixHQUFnQixZQUFXO0FBQ3ZCclosWUFBTyxDQUFDMkQsSUFBUixDQUFhelksSUFBYixDQUFrQixJQUFsQjs7QUFFQSxTQUFLMFksV0FBTCxDQUFpQixpQkFBakI7QUFFQTs7Ozs7Ozs7OztBQVVBLFNBQUtoQixFQUFMLEdBQVUsRUFBVjtBQUVBOzs7Ozs7Ozs7O0FBVUEsU0FBS3FZLFlBQUwsR0FBb0IsSUFBcEI7QUFFQTs7Ozs7Ozs7OztBQVVBLFNBQUtDLFVBQUwsR0FBa0IsSUFBbEI7QUFFQTs7Ozs7Ozs7OztBQVVBLFNBQUtJLHdCQUFMLEdBQWdDLEVBQWhDO0FBRUE7Ozs7Ozs7Ozs7QUFVQSxTQUFLbFosU0FBTCxHQUFpQixJQUFqQjtBQUVBOzs7Ozs7Ozs7O0FBVUEsU0FBS3NTLE9BQUwsR0FBZSxFQUFmO0FBRUE7Ozs7Ozs7Ozs7QUFVQSxTQUFLbUcsSUFBTCxHQUFZLEVBQVo7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxTQUFLZ0IsSUFBTCxHQUFZLEVBQVo7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxTQUFLeUMsUUFBTCxHQUFnQixFQUFoQjtBQUVBOzs7Ozs7Ozs7OztBQVdBLFNBQUt0QyxZQUFMLEdBQW9CLENBQUMsQ0FBckI7QUFFQTs7Ozs7Ozs7Ozs7O0FBWUEsU0FBS21FLFNBQUwsR0FBaUIsQ0FBQyxDQUFsQjtBQUVBOzs7Ozs7Ozs7OztBQVdBLFNBQUtDLFNBQUwsR0FBaUIsQ0FBQyxDQUFsQjtBQUVBOzs7Ozs7Ozs7Ozs7QUFZQSxTQUFLQyxhQUFMLEdBQXFCLENBQUMsQ0FBdEI7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxTQUFLOUIsU0FBTCxHQUFpQixLQUFqQjtBQUVBOzs7Ozs7Ozs7OztBQVdBLFNBQUsvRSxjQUFMLEdBQXNCLElBQXRCO0FBRUE7Ozs7Ozs7Ozs7O0FBV0EsU0FBS2tDLGFBQUwsR0FBcUIsSUFBckI7QUFFQSxTQUFLOVgsV0FBTCxDQUFpQixnQkFBakI7QUFFQTNELEtBQUMsQ0FBQ2lOLElBQUYsQ0FBTyxJQUFQO0FBQ0gsR0FuTkQ7O0FBcU5BbE4sVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQ3FaLEtBQWhDOztBQUVBclosVUFBTyxDQUFDcVosS0FBUixDQUFjNXZCLFNBQWQsR0FBMEJlLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYzhULFFBQU8sQ0FBQzJELElBQVIsQ0FBYWxhLFNBQTNCLENBQTFCO0FBRUF1VyxVQUFPLENBQUNxWixLQUFSLENBQWM1dkIsU0FBZCxDQUF3QkQsV0FBeEIsR0FBc0N3VyxRQUFPLENBQUNxWixLQUE5QztBQUVBOzs7Ozs7O0FBT0FyWixVQUFPLENBQUN5a0IsZUFBUixHQUEwQixZQUFXO0FBQ2pDemtCLFlBQU8sQ0FBQzJELElBQVIsQ0FBYXpZLElBQWIsQ0FBa0IsSUFBbEI7O0FBRUEsU0FBSzBZLFdBQUwsQ0FBaUIsaUJBQWpCO0FBRUEsU0FBS2tULE9BQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLNE4sT0FBTCxHQUFrQixLQUFsQjtBQUNBLFNBQUtqcUIsUUFBTCxHQUFrQixJQUFsQjtBQUVBLFNBQUttSixXQUFMLENBQWlCLGdCQUFqQjtBQUVBM0QsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQVpEOztBQWNBbE4sVUFBTyxDQUFDaVAsVUFBUixDQUFtQi9qQixJQUFuQixDQUF3QjhVLFFBQU8sQ0FBQ3lrQixlQUFoQzs7QUFFQXprQixVQUFPLENBQUN5a0IsZUFBUixDQUF3Qmg3QixTQUF4QixHQUFvQ2UsTUFBTSxDQUFDMEIsTUFBUCxDQUFjOFQsUUFBTyxDQUFDMkQsSUFBUixDQUFhbGEsU0FBM0IsQ0FBcEM7QUFFQXVXLFVBQU8sQ0FBQ3lrQixlQUFSLENBQXdCaDdCLFNBQXhCLENBQWtDRCxXQUFsQyxHQUFnRHdXLFFBQU8sQ0FBQ3lrQixlQUF4RDtBQUVBOzs7Ozs7O0FBT0F6a0IsVUFBTyxDQUFDNHBCLFFBQVIsR0FBbUIsWUFBVztBQUMxQjVwQixZQUFPLENBQUMyRCxJQUFSLENBQWF6WSxJQUFiLENBQWtCLElBQWxCOztBQUVBLFNBQUswWSxXQUFMLENBQWlCLGlCQUFqQjtBQUVBOzs7QUFHQSxTQUFLaW1CLCtCQUFMLEdBQ0ksK0ZBREo7QUFHQSxTQUFLQyxpQ0FBTCxHQUNJLDhEQURKO0FBR0EsU0FBS0Msc0NBQUwsR0FDSSxpREFESjtBQUdBLFNBQUtDLG1DQUFMLEdBQ0ksOENBREo7QUFHQSxTQUFLQyw2QkFBTCxHQUNJLDZFQURKO0FBR0EsU0FBS0Msd0NBQUwsR0FDSSxvQ0FESjtBQUdBLFNBQUtDLGlDQUFMLEdBQ0ksbUZBREo7QUFHQSxTQUFLQyw2QkFBTCxHQUNJLHlGQURKO0FBR0EsU0FBS0MsMkJBQUwsR0FDSSx5RkFESjtBQUdBLFNBQUtDLDhCQUFMLEdBQ0kseUZBREo7QUFHQSxTQUFLQyxnQ0FBTCxHQUNJLHFFQURKO0FBR0EsU0FBS0MsOEJBQUwsR0FDSSxnRkFESjtBQUdBLFNBQUtDLHFCQUFMLEdBQ0ksaUhBREo7QUFHQSxTQUFLQyxrQ0FBTCxHQUNJLDhEQURKO0FBR0EsU0FBS0MsOEJBQUwsR0FDSSxvSEFESjtBQUdBLFNBQUtDLCtCQUFMLEdBQ0ksMkVBREo7QUFHQTs7O0FBR0EsU0FBS0Msb0NBQUwsR0FDSSwrSEFDQSx5RkFGSjtBQUlBLFNBQUtDLDBCQUFMLEdBQ0ksaUVBREo7QUFHQSxTQUFLQywwQkFBTCxHQUNJLGlFQURKO0FBR0EsU0FBS0Msb0NBQUwsR0FDSSw2SEFDQSx1Q0FGSjtBQUlBLFNBQUtDLG1DQUFMLEdBQ0kscUZBREo7QUFHQSxTQUFLQyxpQ0FBTCxHQUNJLDBIQUNBLDJCQUZKO0FBSUEsU0FBS0MsdUNBQUwsR0FDSSwwSEFDQSwyQ0FGSjtBQUlBLFNBQUt2bkIsV0FBTCxDQUFpQixnQkFBakI7QUFFQSxTQUFLd25CLGdCQUFMO0FBRUFuckIsS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQXpGRDs7QUEyRkFsTixVQUFPLENBQUNpUCxVQUFSLENBQW1CL2pCLElBQW5CLENBQXdCOFUsUUFBTyxDQUFDNHBCLFFBQWhDOztBQUVBNXBCLFVBQU8sQ0FBQzRwQixRQUFSLENBQWlCbmdDLFNBQWpCLEdBQTZCZSxNQUFNLENBQUMwQixNQUFQLENBQWM4VCxRQUFPLENBQUMyRCxJQUFSLENBQWFsYSxTQUEzQixDQUE3QjtBQUVBdVcsVUFBTyxDQUFDNHBCLFFBQVIsQ0FBaUJuZ0MsU0FBakIsQ0FBMkJELFdBQTNCLEdBQXlDd1csUUFBTyxDQUFDNHBCLFFBQWpEO0FBRUE7Ozs7QUFJQTVwQixVQUFPLENBQUM0cEIsUUFBUixDQUFpQm5nQyxTQUFqQixDQUEyQjJoQyxnQkFBM0IsR0FBOEMsWUFBVztBQUNyRCxRQUFJQyxRQUFRLEdBQVUsRUFBdEI7QUFDQSxRQUFJQyxZQUFZLEdBQU0sRUFBdEI7O0FBRUEsU0FBS0QsUUFBTCxJQUFpQixJQUFqQixFQUF1QjtBQUNuQixVQUFJLFFBQVFDLFlBQVksR0FBRyxLQUFLRCxRQUFMLENBQXZCLE1BQTJDLFFBQS9DLEVBQXlEO0FBRXpELFdBQUtwckIsQ0FBQyxDQUFDMkcsU0FBRixDQUFZeWtCLFFBQVosQ0FBTCxJQUE4QnByQixDQUFDLENBQUN1RixRQUFGLENBQVc4bEIsWUFBWCxDQUE5QjtBQUNIO0FBQ0osR0FURDs7QUFXQXRyQixVQUFPLENBQUMrQyxRQUFSLEdBQW1CLElBQUkvQyxRQUFPLENBQUM0cEIsUUFBWixFQUFuQjtBQUVBOzs7Ozs7OztBQVFBNXBCLFVBQU8sQ0FBQ3VELE1BQVIsR0FBaUIsU0FBU0osS0FBVCxDQUFlaVQsS0FBZixFQUFzQjtBQUNuQ3BXLFlBQU8sQ0FBQzJELElBQVIsQ0FBYXpZLElBQWIsQ0FBa0IsSUFBbEI7O0FBRUEsU0FBSzBZLFdBQUwsQ0FBaUIsaUJBQWpCLEVBQW9DN1ksU0FBcEM7QUFFQSxTQUFLMDhCLFNBQUwsR0FBMEJyUixLQUFLLENBQUNxUixTQUFOLENBQWdCMXVCLElBQWhCLENBQXFCcWQsS0FBckIsQ0FBMUI7QUFDQSxTQUFLeUYsSUFBTCxHQUEwQnpGLEtBQUssQ0FBQ3lGLElBQU4sQ0FBVzlpQixJQUFYLENBQWdCcWQsS0FBaEIsQ0FBMUI7QUFDQSxTQUFLeUUsSUFBTCxHQUEwQnpFLEtBQUssQ0FBQ3lFLElBQU4sQ0FBVzloQixJQUFYLENBQWdCcWQsS0FBaEIsQ0FBMUI7QUFDQSxTQUFLcGhCLE1BQUwsR0FBMEJvaEIsS0FBSyxDQUFDcGhCLE1BQU4sQ0FBYStELElBQWIsQ0FBa0JxZCxLQUFsQixDQUExQjtBQUNBLFNBQUtrQixRQUFMLEdBQTBCbEIsS0FBSyxDQUFDa0IsUUFBTixDQUFldmUsSUFBZixDQUFvQnFkLEtBQXBCLENBQTFCO0FBQ0EsU0FBS2lCLFNBQUwsR0FBMEJqQixLQUFLLENBQUNpQixTQUFOLENBQWdCdGUsSUFBaEIsQ0FBcUJxZCxLQUFyQixDQUExQjtBQUNBLFNBQUt0b0IsSUFBTCxHQUEwQnNvQixLQUFLLENBQUN0b0IsSUFBTixDQUFXaUwsSUFBWCxDQUFnQnFkLEtBQWhCLENBQTFCO0FBQ0EsU0FBS25CLFlBQUwsR0FBMEJtQixLQUFLLENBQUNuQixZQUFOLENBQW1CbGMsSUFBbkIsQ0FBd0JxZCxLQUF4QixDQUExQjtBQUNBLFNBQUttQixRQUFMLEdBQTBCbkIsS0FBSyxDQUFDbUIsUUFBTixDQUFleGUsSUFBZixDQUFvQnFkLEtBQXBCLENBQTFCO0FBQ0EsU0FBS3hDLE9BQUwsR0FBMEJ3QyxLQUFLLENBQUN4QyxPQUFOLENBQWM3YSxJQUFkLENBQW1CcWQsS0FBbkIsQ0FBMUI7QUFDQSxTQUFLK1EsS0FBTCxHQUEwQi9RLEtBQUssQ0FBQytRLEtBQU4sQ0FBWXB1QixJQUFaLENBQWlCcWQsS0FBakIsQ0FBMUI7QUFDQSxTQUFLcEIsTUFBTCxHQUEwQm9CLEtBQUssQ0FBQ3BCLE1BQU4sQ0FBYWpjLElBQWIsQ0FBa0JxZCxLQUFsQixDQUExQjtBQUNBLFNBQUtsZSxZQUFMLEdBQTBCa2UsS0FBSyxDQUFDbGUsWUFBTixDQUFtQmEsSUFBbkIsQ0FBd0JxZCxLQUF4QixDQUExQjtBQUNBLFNBQUttUixXQUFMLEdBQTBCblIsS0FBSyxDQUFDbVIsV0FBTixDQUFrQnh1QixJQUFsQixDQUF1QnFkLEtBQXZCLENBQTFCO0FBQ0EsU0FBS3RlLE9BQUwsR0FBMEJzZSxLQUFLLENBQUN0ZSxPQUFOLENBQWNpQixJQUFkLENBQW1CcWQsS0FBbkIsQ0FBMUI7QUFDQSxTQUFLemUsTUFBTCxHQUEwQnllLEtBQUssQ0FBQ3plLE1BQU4sQ0FBYW9CLElBQWIsQ0FBa0JxZCxLQUFsQixDQUExQjtBQUNBLFNBQUt4bkIsTUFBTCxHQUEwQnduQixLQUFLLENBQUN4bkIsTUFBTixDQUFhbUssSUFBYixDQUFrQnFkLEtBQWxCLENBQTFCO0FBQ0EsU0FBS2htQixPQUFMLEdBQTBCZ21CLEtBQUssQ0FBQ2htQixPQUFOLENBQWMySSxJQUFkLENBQW1CcWQsS0FBbkIsQ0FBMUI7QUFDQSxTQUFLdVIsWUFBTCxHQUEwQnZSLEtBQUssQ0FBQ3VSLFlBQU4sQ0FBbUI1dUIsSUFBbkIsQ0FBd0JxZCxLQUF4QixDQUExQjtBQUNBLFNBQUt3UixXQUFMLEdBQTBCeFIsS0FBSyxDQUFDd1IsV0FBTixDQUFrQjd1QixJQUFsQixDQUF1QnFkLEtBQXZCLENBQTFCO0FBQ0EsU0FBS3FRLFFBQUwsR0FBMEJyUSxLQUFLLENBQUNxUSxRQUFOLENBQWUxdEIsSUFBZixDQUFvQnFkLEtBQXBCLENBQTFCO0FBQ0EsU0FBS3VRLFlBQUwsR0FBMEJ2USxLQUFLLENBQUN1USxZQUFOLENBQW1CNXRCLElBQW5CLENBQXdCcWQsS0FBeEIsQ0FBMUI7QUFDQSxTQUFLb1IsU0FBTCxHQUEwQnBSLEtBQUssQ0FBQ29SLFNBQU4sQ0FBZ0J6dUIsSUFBaEIsQ0FBcUJxZCxLQUFyQixDQUExQjtBQUNBLFNBQUtzUixRQUFMLEdBQTBCdFIsS0FBSyxDQUFDc1IsUUFBTixDQUFlM3VCLElBQWYsQ0FBb0JxZCxLQUFwQixDQUExQjtBQUVBLFNBQUt4UyxXQUFMLENBQWlCLGdCQUFqQixFQUFtQzdZLFNBQW5DO0FBRUFrVixLQUFDLENBQUNrTixNQUFGLENBQVMsSUFBVDtBQUNBbE4sS0FBQyxDQUFDaU4sSUFBRixDQUFPLElBQVA7QUFDSCxHQWxDRDs7QUFvQ0FsTixVQUFPLENBQUNpUCxVQUFSLENBQW1CL2pCLElBQW5CLENBQXdCOFUsUUFBTyxDQUFDdUQsTUFBaEM7O0FBRUF2RCxVQUFPLENBQUN1RCxNQUFSLENBQWU5WixTQUFmLEdBQTJCZSxNQUFNLENBQUMwQixNQUFQLENBQWM4VCxRQUFPLENBQUMyRCxJQUFSLENBQWFsYSxTQUEzQixDQUEzQjtBQUVBdVcsVUFBTyxDQUFDdUQsTUFBUixDQUFlOVosU0FBZixDQUF5QkQsV0FBekIsR0FBdUN3VyxRQUFPLENBQUN1RCxNQUEvQzs7QUFFQSxNQUFJLDhCQUFPNWMsT0FBUCxPQUFtQixRQUFuQixJQUErQiw4QkFBT0MsTUFBUCxPQUFrQixRQUFyRCxFQUErRDtBQUMzREEsVUFBTSxDQUFDRCxPQUFQLEdBQWlCcVosUUFBakI7QUFDSCxHQUZELE1BRU8sSUFBSSxJQUFKLEVBQWdEO0FBQ25EblosdUNBQU8sWUFBVztBQUNkLGFBQU9tWixRQUFQO0FBQ0gsS0FGSztBQUFBLG9HQUFOO0FBR0gsR0FKTSxNQUlBLEVBRU47O0FBQ0RBLFVBQU8sQ0FBQ2lQLFVBQVIsQ0FBbUIvakIsSUFBbkIsQ0FBd0I4VSxRQUFPLENBQUN4VyxXQUFoQzs7QUFFQXdXLFVBQU8sQ0FBQzhELElBQVIsR0FBZSxTQUFmO0FBQ0E5RCxVQUFPLENBQUN1ckIsWUFBUixHQUF1QixPQUF2QjtBQUNILENBejZVRCxFQXk2VUc5MkIsTUF6NlVILEU7Ozs7Ozs7Ozs7OztBQ2hCQTdOLE1BQU0sQ0FBQ0QsT0FBUCxHQUFpQixVQUFTQyxNQUFULEVBQWlCO0FBQ2pDLE1BQUksQ0FBQ0EsTUFBTSxDQUFDNGtDLGVBQVosRUFBNkI7QUFDNUI1a0MsVUFBTSxDQUFDNmtDLFNBQVAsR0FBbUIsWUFBVyxDQUFFLENBQWhDOztBQUNBN2tDLFVBQU0sQ0FBQzhrQyxLQUFQLEdBQWUsRUFBZixDQUY0QixDQUc1Qjs7QUFDQSxRQUFJLENBQUM5a0MsTUFBTSxDQUFDbU4sUUFBWixFQUFzQm5OLE1BQU0sQ0FBQ21OLFFBQVAsR0FBa0IsRUFBbEI7QUFDdEJ2SixVQUFNLENBQUNDLGNBQVAsQ0FBc0I3RCxNQUF0QixFQUE4QixRQUE5QixFQUF3QztBQUN2Q3lELGdCQUFVLEVBQUUsSUFEMkI7QUFFdkNjLFNBQUcsRUFBRSxlQUFXO0FBQ2YsZUFBT3ZFLE1BQU0sQ0FBQytrQyxDQUFkO0FBQ0E7QUFKc0MsS0FBeEM7QUFNQW5oQyxVQUFNLENBQUNDLGNBQVAsQ0FBc0I3RCxNQUF0QixFQUE4QixJQUE5QixFQUFvQztBQUNuQ3lELGdCQUFVLEVBQUUsSUFEdUI7QUFFbkNjLFNBQUcsRUFBRSxlQUFXO0FBQ2YsZUFBT3ZFLE1BQU0sQ0FBQ3NELENBQWQ7QUFDQTtBQUprQyxLQUFwQztBQU1BdEQsVUFBTSxDQUFDNGtDLGVBQVAsR0FBeUIsQ0FBekI7QUFDQTs7QUFDRCxTQUFPNWtDLE1BQVA7QUFDQSxDQXJCRCxDOzs7Ozs7Ozs7Ozs7QUNBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBLElBQU1nbEMsY0FBYyxHQUFHdjJCLFFBQVEsQ0FBQ1AsYUFBVCxDQUF1QixlQUF2QixDQUF2QjtBQUVBLElBQUlzaEIsS0FBSyxHQUFHcFcsMkRBQU8sQ0FBQzRyQixjQUFELEVBQWlCO0FBQ2hDdFgsV0FBUyxFQUFFO0FBQ1B0cUIsVUFBTSxFQUFFO0FBREQsR0FEcUI7QUFJaENpcUIsV0FBUyxFQUFFO0FBQ1AxWixZQUFRLEVBQUU7QUFESDtBQUpxQixDQUFqQixDQUFuQjtBQVVBLElBQUluTixLQUFLLEdBQUcsSUFBSTZCLGdFQUFKLENBQVUsUUFBVixFQUFvQjtBQUM1QmxJLE1BQUksRUFBRSxVQURzQjtBQUU1QkUsU0FBTyxFQUFFLENBRm1CO0FBRzVCQyxTQUFPLEVBQUUsUUFIbUI7QUFJNUJFLFVBQVEsRUFBRTtBQUprQixDQUFwQixDQUFaO0FBTUFnRyxLQUFLLENBQUNELEtBQU47QUFHQSxJQUFJMCtCLEVBQUUsR0FBR3AzQixNQUFNLENBQUNnTCxVQUFQLENBQW1CLG9CQUFuQixDQUFUO0FBQ0EsSUFBSXFzQixFQUFFLEdBQUcsSUFBSUMsWUFBSixFQUFUO0FBRUE3aUMsT0FBTyxDQUFDOGlDLEdBQVIsQ0FBWUgsRUFBWjtBQUVBLElBQUlJLE9BQU8sR0FBRztBQUNWajhCLFVBQVEsRUFBRSxNQURBO0FBRVZrOEIsUUFBTSxFQUFFLFFBRkU7QUFHVmpmLFNBQU8sRUFBRSxFQUhDO0FBSVYxUyxVQUFRLEVBQUUsR0FKQTtBQUtWakssVUFBUSxFQUFFLEVBTEE7QUFNVnc0QixPQUFLLEVBQUM7QUFOSSxDQUFkO0FBUUEsSUFBSXFELFNBQVMsR0FBRztBQUNabjhCLFVBQVEsRUFBRSxNQURFO0FBRVprOEIsUUFBTSxFQUFFLE1BRkk7QUFHWjN4QixVQUFRLEVBQUUsR0FIRTtBQUladXVCLE9BQUssRUFBRSxHQUpLO0FBS1pzRCxRQUFNLEVBQUU7QUFMSSxDQUFoQjtBQU9BLElBQUlDLFFBQVEsR0FBRztBQUNYcjhCLFVBQVEsRUFBRSxNQURDO0FBRVhrOEIsUUFBTSxFQUFFLEtBRkc7QUFHWDN4QixVQUFRLEVBQUUsR0FIQztBQUlYdXVCLE9BQUssRUFBRTtBQUpJLENBQWY7QUFNQSxJQUFJd0QsVUFBVSxHQUFHO0FBQ2J0OEIsVUFBUSxFQUFFLE1BREc7QUFFYms4QixRQUFNLEVBQUUsT0FGSztBQUdiM3hCLFVBQVEsRUFBRSxHQUhHO0FBSWIwUyxTQUFPLEVBQUU7QUFKSSxDQUFqQjs7QUFNQSxJQUFHLENBQUM0ZSxFQUFFLENBQUNsc0IsT0FBUCxFQUFlO0FBQ1htc0IsSUFBRSxDQUFDUyxNQUFILENBQVUsZ0JBQVYsRUFBMkJOLE9BQTNCO0FBQ0FILElBQUUsQ0FBQ1MsTUFBSCxDQUFVLGdCQUFWLEVBQTJCSixTQUEzQjtBQUNBTCxJQUFFLENBQUNTLE1BQUgsQ0FBVSxXQUFWLEVBQXNCRixRQUF0QjtBQUNBUCxJQUFFLENBQUNTLE1BQUgsQ0FBVSxXQUFWLEVBQXNCSixTQUF0QjtBQUNBTCxJQUFFLENBQUNTLE1BQUgsQ0FBVSxrQkFBVixFQUE2QkQsVUFBN0I7QUFDSDs7QUFJRCxJQUFNRSxHQUFHLEdBQUduM0IsUUFBUSxDQUFDbzNCLGNBQVQsQ0FBd0IsS0FBeEIsQ0FBWjtBQUNBLElBQU1DLFFBQVEsR0FBR3IzQixRQUFRLENBQUNvM0IsY0FBVCxDQUF3QixVQUF4QixDQUFqQjtBQUNBLElBQU1FLFdBQVcsR0FBR3QzQixRQUFRLENBQUNxSSxnQkFBVCxDQUEwQixrQkFBMUIsQ0FBcEI7QUFDQSxJQUFNa3ZCLFFBQVEsR0FBR3YzQixRQUFRLENBQUNQLGFBQVQsQ0FBdUIsV0FBdkIsQ0FBakI7QUFDQSxJQUFNKzNCLFVBQVUsR0FBR3gzQixRQUFRLENBQUNQLGFBQVQsQ0FBdUIsYUFBdkIsQ0FBbkI7QUFDQSxJQUFNZzRCLFNBQVMsR0FBR3ozQixRQUFRLENBQUNxSSxnQkFBVCxDQUEwQixxQkFBMUIsQ0FBbEI7QUFDQSxJQUFJcXZCLGVBQUo7QUFDQSxJQUFJQyxlQUFKO0FBQ0EsSUFBSUMsYUFBYSxHQUFHLENBQXBCO0FBQ0EsSUFBSWo5QixRQUFRLEdBQUcsQ0FBZjtBQUNBLElBQUlrOUIsT0FBTyxHQUFHLEtBQWQ7QUFDQSxJQUFJQyxXQUFXLEdBQUc5M0IsUUFBUSxDQUFDUCxhQUFULENBQXVCLGFBQXZCLENBQWxCO0FBRUEsSUFBSTZRLElBQUksR0FBR3duQixXQUFXLENBQUMxTCxxQkFBWixFQUFYO0FBQ0EsSUFBTTJMLFNBQVMsR0FBRy8zQixRQUFRLENBQUNxSSxnQkFBVCxDQUEwQixZQUExQixDQUFsQjtBQUNBLElBQU0ydkIsT0FBTyxHQUFHaDRCLFFBQVEsQ0FBQ1AsYUFBVCxDQUF1QixjQUF2QixDQUFoQixDLENBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFFQXM0QixTQUFTLENBQUNyK0IsT0FBVixDQUFrQixVQUFDQyxJQUFELEVBQVE7QUFDdkJBLE1BQUksQ0FBQzBKLGdCQUFMLENBQXNCLE9BQXRCLEVBQThCLFVBQUNrQyxDQUFELEVBQUs7QUFDaEMxUixXQUFPLENBQUM4aUMsR0FBUixDQUFZcHhCLENBQUMsQ0FBQ2dFLGFBQUYsQ0FBZ0JrQyxhQUFoQixDQUE4QkEsYUFBMUM7QUFDQ2xHLEtBQUMsQ0FBQ2dFLGFBQUYsQ0FBZ0I3SyxRQUFoQixDQUF5QixDQUF6QixFQUE0QjRKLEtBQTVCO0FBQ0EvQyxLQUFDLENBQUNnRSxhQUFGLENBQWdCa0MsYUFBaEIsQ0FBOEJBLGFBQTlCLENBQTRDNUwsU0FBNUMsQ0FBc0R0RyxNQUF0RCxDQUE2RCxNQUE3RDtBQUNBeStCLFdBQU8sQ0FBQ240QixTQUFSLENBQWtCdEcsTUFBbEIsQ0FBeUIsUUFBekI7QUFDSCxHQUxEO0FBTUYsQ0FQRDs7QUFTQSxTQUFTMCtCLFlBQVQsR0FBd0I7QUFDcEIsTUFBSUMsQ0FBQyxHQUFHbDRCLFFBQVI7QUFDQSxTQUFPekQsSUFBSSxDQUFDeUYsR0FBTCxDQUNIazJCLENBQUMsQ0FBQy9pQixJQUFGLENBQU84QixZQURKLEVBQ2tCaWhCLENBQUMsQ0FBQ2xoQixlQUFGLENBQWtCQyxZQURwQyxFQUVIaWhCLENBQUMsQ0FBQy9pQixJQUFGLENBQU9nakIsWUFGSixFQUVrQkQsQ0FBQyxDQUFDbGhCLGVBQUYsQ0FBa0JtaEIsWUFGcEMsRUFHSEQsQ0FBQyxDQUFDL2lCLElBQUYsQ0FBT2tDLFlBSEosRUFHa0I2Z0IsQ0FBQyxDQUFDbGhCLGVBQUYsQ0FBa0JLLFlBSHBDLENBQVA7QUFLSDs7QUFFRCxJQUFJK2dCLFNBQVMsR0FBR0gsWUFBWSxFQUE1Qjs7QUFHQTc0QixNQUFNLENBQUNpNUIsUUFBUCxHQUFrQixZQUFZO0FBRzVCQyxXQUFTO0FBQ1RDLFdBQVMsR0FKbUIsQ0FPNUI7O0FBRUUsTUFBR0MsbUJBQW1CLENBQUNoQixVQUFELENBQW5CLElBQW1DSyxPQUFPLEtBQUssS0FBbEQsRUFBd0Q7QUFDcERKLGFBQVMsQ0FBQy85QixPQUFWLENBQWtCLFVBQUE2TCxDQUFDLEVBQUU7QUFDakIsVUFBSWt6QixHQUFHLEdBQUdsekIsQ0FBQyxDQUFDZ0ksRUFBWjtBQUNBLFVBQUl6RCxJQUFJLEdBQUcsQ0FBWDtBQUNBLFVBQUk0dUIsT0FBTyxHQUFHQyxhQUFhLFdBQUlGLEdBQUosRUFBM0I7QUFDQUcsZ0JBQVUsQ0FBQ3J6QixDQUFELEVBQUdtekIsT0FBSCxFQUFXNXVCLElBQVgsQ0FBVjtBQUNBK3RCLGFBQU8sR0FBRyxJQUFWO0FBQ0gsS0FORDtBQU9IO0FBSUosQ0FyQkQ7O0FBdUJBLFNBQVNXLG1CQUFULENBQTZCdDFCLEVBQTdCLEVBQWlDO0FBQzdCLE1BQUlneEIsSUFBSSxHQUFHaHhCLEVBQUUsQ0FBQ2twQixxQkFBSCxFQUFYO0FBRUEsU0FBTzhILElBQUksQ0FBQ3ZSLE1BQUwsR0FBYyxDQUFkLElBQ0h1UixJQUFJLENBQUN4UixLQUFMLEdBQWEsQ0FEVixJQUVId1IsSUFBSSxDQUFDbmYsSUFBTCxJQUFhM1YsTUFBTSxDQUFDeTVCLFVBQVAsSUFBcUI3NEIsUUFBUSxDQUFDZ1gsZUFBVCxDQUF5Qk8sV0FBM0Q7QUFBd0U7QUFGckUsS0FHSDJjLElBQUksQ0FBQ2xmLEdBQUwsSUFBWTVWLE1BQU0sQ0FBQzA1QixXQUFQLElBQXNCOTRCLFFBQVEsQ0FBQ2dYLGVBQVQsQ0FBeUJLLFlBQTNEO0FBQXlFO0FBSDdFO0FBSUg7O0FBRUQsU0FBUzBoQixVQUFULEdBQXNCO0FBQ2xCckIsaUJBQWUsR0FBR3Q0QixNQUFNLENBQUM0NUIsT0FBekI7QUFDQXJCLGlCQUFlLEdBQUd2NEIsTUFBTSxDQUFDNjVCLE9BQXpCO0FBQ0FDLGNBQVksQ0FBQyxDQUFELEVBQUl2QixlQUFlLEdBQUcsR0FBdEIsRUFBMkJKLFFBQTNCLENBQVo7QUFDQXZzQix1QkFBcUIsQ0FBQyt0QixVQUFELENBQXJCLENBSmtCLENBS2xCO0FBQ0g7O0FBR0QsU0FBU0csWUFBVCxDQUFzQkMsSUFBdEIsRUFBNEJDLElBQTVCLEVBQWtDbDJCLEVBQWxDLEVBQXNDO0FBQ2xDQSxJQUFFLENBQUM5RSxLQUFILENBQVM0RyxTQUFULHlCQUFvQ20wQixJQUFwQyxpQkFBK0NDLElBQS9DO0FBQ0g7O0FBQ0QsU0FBU0MsU0FBVCxDQUFtQkQsSUFBbkIsRUFBeUJsMkIsRUFBekIsRUFBNkI7QUFDekJBLElBQUUsQ0FBQzlFLEtBQUgsQ0FBU2s3QixtQkFBVCxHQUErQkYsSUFBSSxHQUFHLElBQXRDO0FBQ0gsQyxDQUNEOzs7QUFFQXA1QixRQUFRLENBQUNxSSxnQkFBVCxDQUEwQixjQUExQixFQUEwQzNPLE9BQTFDLENBQWtELFVBQUE2L0IsTUFBTSxFQUFJO0FBQ3hEQSxRQUFNLENBQUNsMkIsZ0JBQVAsQ0FBd0IsT0FBeEIsRUFBaUMsVUFBVWtDLENBQVYsRUFBYTtBQUMxQ0EsS0FBQyxDQUFDeUMsY0FBRjtBQUVBaEksWUFBUSxDQUFDUCxhQUFULENBQXVCLEtBQUtpSixZQUFMLENBQWtCLE1BQWxCLENBQXZCLEVBQWtEOHdCLGNBQWxELENBQWlFO0FBQzdEM2EsY0FBUSxFQUFFO0FBRG1ELEtBQWpFO0FBR0gsR0FORDtBQU9ILENBUkQ7QUFVQTdlLFFBQVEsQ0FBQ3FELGdCQUFULENBQTBCLGtCQUExQixFQUE4QyxZQUFXO0FBQ3JEbzJCLG1CQUFpQixHQURvQyxDQUVyRDtBQUNILENBSEQsRUFHRyxLQUhIOztBQUtBLElBQU1uQixTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFDMzNCLEtBQUQsRUFBVztBQUUzQixNQUFJWCxRQUFRLENBQUNtVixJQUFULENBQWN4QixTQUFkLEdBQTBCLEVBQTFCLElBQWdDM1QsUUFBUSxDQUFDZ1gsZUFBVCxDQUF5QnJELFNBQXpCLEdBQXFDLEVBQXpFLEVBQTZFO0FBQ3hFd2pCLE9BQUcsQ0FBQy80QixLQUFKLENBQVVzN0IsZUFBVixHQUE0QixpQkFBNUI7QUFDQXZDLE9BQUcsQ0FBQy80QixLQUFKLENBQVV1N0IsT0FBVixHQUFvQixNQUFwQjtBQUNBeEMsT0FBRyxDQUFDLzRCLEtBQUosQ0FBVWlWLFFBQVYsR0FBcUIsT0FBckI7QUFDQThqQixPQUFHLENBQUMvNEIsS0FBSixDQUFVc1csTUFBVixHQUFtQixNQUFuQjtBQUVKLEdBTkQsTUFNTztBQUNMeWlCLE9BQUcsQ0FBQy80QixLQUFKLENBQVVzN0IsZUFBVixHQUE0QixhQUE1QjtBQUNBdkMsT0FBRyxDQUFDLzRCLEtBQUosQ0FBVXU3QixPQUFWLEdBQW9CLGFBQXBCO0FBQ0F4QyxPQUFHLENBQUMvNEIsS0FBSixDQUFVaVYsUUFBVixHQUFxQixVQUFyQjtBQUNEO0FBQ0YsQ0FiRDs7QUFlQSxJQUFNa2xCLFNBQVMsR0FBRyxTQUFaQSxTQUFZLEdBQU07QUFDcEIsTUFBR3Y0QixRQUFRLENBQUNtVixJQUFULENBQWN4QixTQUFkLEdBQTBCLEdBQTFCLElBQWlDM1QsUUFBUSxDQUFDZ1gsZUFBVCxDQUF5QnJELFNBQXpCLEdBQXFDLEdBQXpFLEVBQTZFO0FBQ3pFMGpCLFlBQVEsQ0FBQ2o1QixLQUFULENBQWV3WixPQUFmLEdBQXlCLEdBQXpCO0FBQ0gsR0FGRCxNQUVPO0FBQ0h5ZixZQUFRLENBQUNqNUIsS0FBVCxDQUFld1osT0FBZixHQUF5QixHQUF6QjtBQUNIO0FBQ0osQ0FORCxDLENBU0E7OztBQUVBLElBQU1naUIsVUFBVSxHQUFHNTVCLFFBQVEsQ0FBQ3FJLGdCQUFULENBQTBCLGtCQUExQixDQUFuQjtBQUNBLElBQU13eEIsVUFBVSxHQUFHNzVCLFFBQVEsQ0FBQ3FJLGdCQUFULENBQTBCLGNBQTFCLENBQW5COztBQUtBLFNBQVNveEIsaUJBQVQsR0FBNEI7QUFDeEJJLFlBQVUsQ0FBQ25nQyxPQUFYLENBQW1CLFVBQUNvZ0MsR0FBRCxFQUFPO0FBQ3RCLFFBQUkzaEMsSUFBSSxHQUFHMmhDLEdBQUcsQ0FBQ3B4QixZQUFKLENBQWlCLEtBQWpCLEVBQXdCMUUsS0FBeEIsQ0FBOEIsR0FBOUIsRUFBbUMsQ0FBbkMsRUFBc0NBLEtBQXRDLENBQTRDLEdBQTVDLEVBQWlELENBQWpELENBQVgsQ0FEc0IsQ0FFdEI7O0FBRUE4MUIsT0FBRyxDQUFDcnhCLFlBQUosQ0FBaUIsV0FBakIsRUFBNkJ0USxJQUE3QjtBQUNILEdBTEQ7QUFNSCxDLENBRUQ7OztBQUNBLElBQUk0aEMsZUFBSjtBQUNBSCxVQUFVLENBQUNsZ0MsT0FBWCxDQUFtQixVQUFDNkwsQ0FBRCxFQUFLO0FBQ3JCQSxHQUFDLENBQUNsQyxnQkFBRixDQUFtQixPQUFuQixFQUEyQixVQUFDbEssS0FBRCxFQUFTO0FBQy9CLFFBQUdvTSxDQUFDLENBQUMxRixTQUFGLENBQVlDLFFBQVosQ0FBcUIsUUFBckIsQ0FBSCxFQUFrQztBQUM5QmpNLGFBQU8sQ0FBQzhpQyxHQUFSLENBQVksZUFBWjtBQUNBLGFBQU8sS0FBUDtBQUNILEtBSEQsTUFHTztBQUNIMzJCLGNBQVEsQ0FBQ1AsYUFBVCxDQUF1Qix5QkFBdkIsRUFBa0RJLFNBQWxELENBQTREdEcsTUFBNUQsQ0FBbUUsUUFBbkU7QUFDQWdNLE9BQUMsQ0FBQzFGLFNBQUYsQ0FBWXlCLEdBQVosQ0FBZ0IsUUFBaEI7QUFDSDs7QUFFRixRQUFJMUIsS0FBSyxHQUFHMkYsQ0FBQyxDQUFDZ0ksRUFBZDtBQUNBLFFBQUl1c0IsR0FBRyxHQUFHOTVCLFFBQVEsQ0FBQ3FJLGdCQUFULHVCQUF5Q3pJLEtBQXpDLFFBQVYsQ0FWZ0MsQ0FZaEM7O0FBRUEsUUFBR0ksUUFBUSxDQUFDUCxhQUFULENBQXVCLHFCQUF2QixDQUFILEVBQWlEO0FBQzdDTyxjQUFRLENBQUNQLGFBQVQsQ0FBdUIscUJBQXZCLEVBQThDSSxTQUE5QyxDQUF3RHRHLE1BQXhELENBQStELFFBQS9EO0FBQ0gsS0FoQitCLENBbUJoQzs7O0FBQ0EsUUFBSXlnQyxLQUFLLEdBQUdoNkIsUUFBUSxDQUFDUCxhQUFULENBQXVCLFVBQXZCLENBQVo7O0FBRUEsUUFBR3U2QixLQUFLLEtBQUssSUFBYixFQUFrQjtBQUNkQSxXQUFLLENBQUNuNkIsU0FBTixDQUFnQnRHLE1BQWhCLENBQXVCLFNBQXZCO0FBQ0FzRSxrQkFBWSxDQUFDazhCLGVBQUQsQ0FBWjtBQUNIOztBQUVBLFFBQUcsQ0FBQ0QsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFPajZCLFNBQVAsQ0FBaUJDLFFBQWpCLENBQTBCLFFBQTFCLENBQUQsSUFBd0MsQ0FBQ2c2QixHQUFHLENBQUMsQ0FBRCxDQUFILENBQU9qNkIsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEIsU0FBMUIsQ0FBNUMsRUFBaUY7QUFDN0VnNkIsU0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFPajZCLFNBQVAsQ0FBaUJ5QixHQUFqQixDQUFxQixTQUFyQixFQUQ2RSxDQUc3RTs7QUFDQSxVQUFJMjRCLHdCQUF3QixHQUFHNzZCLE1BQU0sQ0FBQ3NZLGdCQUFQLENBQXdCb2lCLEdBQUcsQ0FBQyxDQUFELENBQTNCLEVBQWdDLElBQWhDLEVBQXNDSSxnQkFBdEMsQ0FBdUQsb0JBQXZELENBQS9CLENBSjZFLENBTTdFOztBQUNBRCw4QkFBd0IsR0FBRzNpQyxVQUFVLENBQUMyaUMsd0JBQXdCLENBQUM3dEIsT0FBekIsQ0FBaUMsR0FBakMsRUFBcUMsRUFBckMsQ0FBRCxDQUFWLEdBQXVELElBQWxGLENBUDZFLENBVTdFOztBQUNBMnRCLHFCQUFlLEdBQUdoOEIsVUFBVSxDQUFDLFlBQUk7QUFDN0IrN0IsV0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFPajZCLFNBQVAsQ0FBaUJ0RyxNQUFqQixDQUF3QixTQUF4QjtBQUNBdWdDLFdBQUcsQ0FBQyxDQUFELENBQUgsQ0FBT2o2QixTQUFQLENBQWlCeUIsR0FBakIsQ0FBcUIsUUFBckI7QUFFSCxPQUoyQixFQUkxQjI0Qix3QkFKMEIsQ0FBNUI7QUFLSDtBQUVMLEdBN0NEO0FBOENGLENBL0NEO0FBa0RBRSxxQkFBcUIsRyxDQUVyQjs7QUFFQSxTQUFTQSxxQkFBVCxHQUFnQztBQUM1QixNQUFJQyxPQUFPLEdBQUdwNkIsUUFBUSxDQUFDUCxhQUFULENBQXVCLE1BQXZCLEVBQStCMnNCLHFCQUEvQixHQUF1RHRZLENBQXJFO0FBQ0EsTUFBSXVtQixZQUFZLEdBQUdyNkIsUUFBUSxDQUFDUCxhQUFULENBQXVCLFdBQXZCLEVBQW9DMnNCLHFCQUFwQyxHQUE0RHRZLENBQS9FO0FBQ0EsTUFBSTBpQixFQUFFLEdBQUdwM0IsTUFBTSxDQUFDZ0wsVUFBUCxDQUFtQixxQkFBbkIsQ0FBVDtBQUVBa3RCLGFBQVcsQ0FBQzU5QixPQUFaLENBQW9CLFVBQUN3SixFQUFELEVBQU07QUFDdEIsUUFBRyxDQUFDc3pCLEVBQUUsQ0FBQ2xzQixPQUFQLEVBQWU7QUFDWHBILFFBQUUsQ0FBQzlFLEtBQUgsQ0FBUzR1QixXQUFULEdBQXdCb04sT0FBTyxHQUFHQyxZQUFYLEdBQTJCLElBQWxEO0FBQ0g7QUFFSixHQUxEO0FBT0gsQyxDQUtEOzs7QUFFQSxJQUFNeDlCLE1BQU0sR0FBR21ELFFBQVEsQ0FBQ3FJLGdCQUFULENBQTBCLE1BQTFCLENBQWY7QUFFQXhMLE1BQU0sQ0FBQ25ELE9BQVAsQ0FBZSxVQUFBa0csS0FBSyxFQUFFO0FBQ2xCMDZCLGNBQVksQ0FBQzE2QixLQUFELENBQVo7QUFDSCxDQUZEOztBQUlBLFNBQVMwNkIsWUFBVCxDQUFzQkMsR0FBdEIsRUFBMEI7QUFDdEI7QUFDQSxNQUFJQyxVQUFVLEdBQUdELEdBQUcsQ0FBQzE2QixTQUFKLENBQWNySixLQUFkLENBQW9CNFYsT0FBcEIsQ0FBNEIsS0FBNUIsRUFBa0MsRUFBbEMsRUFBc0NELElBQXRDLEdBQTZDbkksS0FBN0MsQ0FBbUQsR0FBbkQsQ0FBakIsQ0FGc0IsQ0FHdEI7O0FBQ0EsTUFBSXkyQixPQUFPLEdBQUdGLEdBQUcsQ0FBQ3hKLGdCQUFKLENBQXFCcm9CLFlBQXJCLENBQWtDLEtBQWxDLEVBQXlDMUUsS0FBekMsQ0FBK0MsR0FBL0MsRUFBb0QsQ0FBcEQsRUFBdURBLEtBQXZELENBQTZELEdBQTdELEVBQWtFLENBQWxFLENBQWQ7QUFDQSxNQUFJK0ksU0FBUyxHQUFHL00sUUFBUSxDQUFDK0ssYUFBVCxDQUF1QixLQUF2QixDQUFoQjtBQUNBLE1BQUkydkIsS0FBSyxHQUFHMTZCLFFBQVEsQ0FBQytLLGFBQVQsQ0FBdUIsSUFBdkIsQ0FBWjtBQUNBZ0MsV0FBUyxDQUFDaUMsU0FBVixHQUFzQixZQUF0QjtBQUNBMHJCLE9BQUssQ0FBQ0MsV0FBTixHQUFvQkYsT0FBTyxDQUFDejJCLEtBQVIsQ0FBYyxHQUFkLEVBQW1CQyxJQUFuQixDQUF3QixHQUF4QixDQUFwQjtBQUNBOEksV0FBUyxDQUFDcEssV0FBVixDQUFzQiszQixLQUF0QjtBQUNBLE1BQUlFLGFBQWEsR0FBRzU2QixRQUFRLENBQUMrSyxhQUFULENBQXVCLEdBQXZCLENBQXBCO0FBQ0E2dkIsZUFBYSxDQUFDNXJCLFNBQWQsR0FBMEIsZUFBMUI7O0FBQ0ksT0FBSSxJQUFJbmEsQ0FBQyxHQUFHLENBQVosRUFBY0EsQ0FBQyxHQUFDMmxDLFVBQVUsQ0FBQzFsQyxNQUEzQixFQUFrQ0QsQ0FBQyxFQUFuQyxFQUFzQztBQUNsQyxRQUFJZ21DLGNBQWMsR0FBRzc2QixRQUFRLENBQUMrSyxhQUFULENBQXVCLE1BQXZCLENBQXJCO0FBQ0E4dkIsa0JBQWMsQ0FBQ0YsV0FBZixHQUE2QkgsVUFBVSxDQUFDM2xDLENBQUQsQ0FBdkM7QUFDQStsQyxpQkFBYSxDQUFDajRCLFdBQWQsQ0FBMEJrNEIsY0FBMUI7QUFDSDs7QUFDTDl0QixXQUFTLENBQUNwSyxXQUFWLENBQXNCaTRCLGFBQXRCO0FBQ0FMLEtBQUcsQ0FBQzUzQixXQUFKLENBQWdCb0ssU0FBaEI7QUFDSCxDLENBSUQ7OztBQUlBLElBQUk0ckIsYUFBYSxHQUFHO0FBQ2hCbUMsV0FBUyxFQUFDLElBRE07QUFFaEJDLFVBQVEsRUFBRSxHQUZNO0FBR2hCQyxZQUFVLEVBQUMsR0FISztBQUloQkMsV0FBUyxFQUFFLEdBSks7QUFLaEJDLGlCQUFlLEVBQUU7QUFMRCxDQUFwQjs7QUFVQSxTQUFTdEMsVUFBVCxDQUFvQjExQixFQUFwQixFQUF1QjFNLEtBQXZCLEVBQTZCc1QsSUFBN0IsRUFBbUM7QUFDL0IsTUFBSTdPLFFBQVEsR0FBR3pFLEtBQUssR0FBQ3NULElBQU4sR0FBVyxDQUExQjtBQUNBLE1BQUlrUixJQUFJLEdBQUcsQ0FBWDtBQUNBLE1BQUltZ0IsUUFBUSxHQUFHdnhCLFdBQVcsQ0FBQyxZQUFJO0FBQzNCb1IsUUFBSSxJQUFFL2YsUUFBTjs7QUFDQSxRQUFHaUksRUFBRSxDQUFDcUssRUFBSCxLQUFRLFVBQVgsRUFBc0I7QUFDbEJySyxRQUFFLENBQUN5M0IsV0FBSCxHQUFpQnArQixJQUFJLENBQUMwRixLQUFMLENBQVcrWSxJQUFYLElBQW1CLEdBQXBDO0FBQ0gsS0FGRCxNQUVNO0FBQ0Y5WCxRQUFFLENBQUN5M0IsV0FBSCxHQUFpQnArQixJQUFJLENBQUMwRixLQUFMLENBQVcrWSxJQUFYLENBQWpCO0FBQ0g7O0FBRUQsUUFBR0EsSUFBSSxJQUFJeGtCLEtBQVgsRUFBaUI7QUFDVHdrQixVQUFJLEdBQUd4a0IsS0FBUDtBQUNBdVQsbUJBQWEsQ0FBQ294QixRQUFELENBQWI7O0FBQ0osVUFBR2o0QixFQUFFLENBQUNxSyxFQUFILEtBQVEsVUFBWCxFQUFzQjtBQUNsQnJLLFVBQUUsQ0FBQ3kzQixXQUFILEdBQWlCcCtCLElBQUksQ0FBQzBGLEtBQUwsQ0FBVytZLElBQVgsSUFBbUIsR0FBcEM7QUFDSCxPQUZELE1BRU07QUFDRjlYLFVBQUUsQ0FBQ3kzQixXQUFILEdBQWlCcCtCLElBQUksQ0FBQzBGLEtBQUwsQ0FBVytZLElBQVgsQ0FBakI7QUFDSDs7QUFDRixhQUFPemUsSUFBSSxDQUFDMEYsS0FBTCxDQUFXK1ksSUFBWCxDQUFQO0FBQ0Y7QUFDSixHQWxCeUIsRUFrQnhCLEdBbEJ3QixDQUExQjtBQW1CSCxDLENBR0Q7OztBQUVBLElBQU1vZ0IsWUFBWSxHQUFHcDdCLFFBQVEsQ0FBQ3FJLGdCQUFULENBQTBCLGlCQUExQixDQUFyQjtBQUVBK3lCLFlBQVksQ0FBQzFoQyxPQUFiLENBQXFCLFVBQUEyaEMsSUFBSSxFQUFFO0FBQ3ZCQSxNQUFJLENBQUNoNEIsZ0JBQUwsQ0FBc0IsWUFBdEIsRUFBbUMsVUFBQ2tDLENBQUQsRUFBSztBQUNwQyxRQUFJKzFCLE9BQU8sR0FBRy8xQixDQUFDLENBQUM1USxNQUFGLENBQVM4VyxhQUFULENBQXVCQSxhQUF2QixDQUFxQy9NLFFBQXJDLENBQThDLENBQTlDLEVBQWlEQSxRQUFqRCxDQUEwRCxDQUExRCxDQUFkO0FBRUE0OEIsV0FBTyxDQUFDejdCLFNBQVIsQ0FBa0J5QixHQUFsQixDQUFzQixRQUF0QjtBQUNILEdBSkQ7QUFLQSs1QixNQUFJLENBQUNoNEIsZ0JBQUwsQ0FBc0IsVUFBdEIsRUFBaUMsVUFBQ2tDLENBQUQsRUFBSztBQUNsQyxRQUFJKzFCLE9BQU8sR0FBRy8xQixDQUFDLENBQUM1USxNQUFGLENBQVM4VyxhQUFULENBQXVCQSxhQUF2QixDQUFxQy9NLFFBQXJDLENBQThDLENBQTlDLEVBQWlEQSxRQUFqRCxDQUEwRCxDQUExRCxDQUFkO0FBRUE0OEIsV0FBTyxDQUFDejdCLFNBQVIsQ0FBa0J0RyxNQUFsQixDQUF5QixRQUF6QjtBQUNILEdBSkQ7QUFLSCxDQVhELEUsQ0FhQTs7QUFJQXkrQixPQUFPLENBQUMzMEIsZ0JBQVIsQ0FBeUIsT0FBekIsRUFBaUMsVUFBQ2tDLENBQUQsRUFBSztBQUNuQ0EsR0FBQyxDQUFDZ0UsYUFBRixDQUFnQjFKLFNBQWhCLENBQTBCMmlCLE1BQTFCLENBQWlDLFFBQWpDO0FBQ0EzdUIsU0FBTyxDQUFDOGlDLEdBQVIsQ0FBWXB4QixDQUFDLENBQUNnRSxhQUFGLENBQWdCMUssVUFBaEIsQ0FBMkJILFFBQTNCLENBQW9DLENBQXBDLEVBQXVDbUIsU0FBdkMsQ0FBaUQyaUIsTUFBakQsQ0FBd0QsTUFBeEQsQ0FBWjtBQUNGLENBSEQsRTs7Ozs7Ozs7Ozs7O0FDN1hBO0FBQUEiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbiIsIi8qIVxuICogR2xpZGUuanMgdjMuMy4wXG4gKiAoYykgMjAxMy0yMDE5IErEmWRyemVqIENoYcWCdWJlayA8amVkcnplai5jaGFsdWJla0BnbWFpbC5jb20+IChodHRwOi8vamVkcnplamNoYWx1YmVrLmNvbS8pXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsLkdsaWRlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIHRoZSBtb3ZlbWVudC5cbiAgICAgKlxuICAgICAqIEF2YWlsYWJsZSB0eXBlczpcbiAgICAgKiBgc2xpZGVyYCAtIFJld2luZHMgc2xpZGVyIHRvIHRoZSBzdGFydC9lbmQgd2hlbiBpdCByZWFjaGVzIHRoZSBmaXJzdCBvciBsYXN0IHNsaWRlLlxuICAgICAqIGBjYXJvdXNlbGAgLSBDaGFuZ2VzIHNsaWRlcyB3aXRob3V0IHN0YXJ0aW5nIG92ZXIgd2hlbiBpdCByZWFjaGVzIHRoZSBmaXJzdCBvciBsYXN0IHNsaWRlLlxuICAgICAqXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0eXBlOiAnc2xpZGVyJyxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGF0IHNwZWNpZmljIHNsaWRlIG51bWJlciBkZWZpbmVkIHdpdGggemVyby1iYXNlZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgc3RhcnRBdDogMCxcblxuICAgIC8qKlxuICAgICAqIEEgbnVtYmVyIG9mIHNsaWRlcyB2aXNpYmxlIG9uIHRoZSBzaW5nbGUgdmlld3BvcnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHBlclZpZXc6IDEsXG5cbiAgICAvKipcbiAgICAgKiBGb2N1cyBjdXJyZW50bHkgYWN0aXZlIHNsaWRlIGF0IGEgc3BlY2lmaWVkIHBvc2l0aW9uIGluIHRoZSB0cmFjay5cbiAgICAgKlxuICAgICAqIEF2YWlsYWJsZSBpbnB1dHM6XG4gICAgICogYGNlbnRlcmAgLSBDdXJyZW50IHNsaWRlIHdpbGwgYmUgYWx3YXlzIGZvY3VzZWQgYXQgdGhlIGNlbnRlciBvZiBhIHRyYWNrLlxuICAgICAqIGAwLDEsMiwzLi4uYCAtIEN1cnJlbnQgc2xpZGUgd2lsbCBiZSBmb2N1c2VkIG9uIHRoZSBzcGVjaWZpZWQgemVyby1iYXNlZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdHJpbmd8TnVtYmVyfVxuICAgICAqL1xuICAgIGZvY3VzQXQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBBIHNpemUgb2YgdGhlIGdhcCBhZGRlZCBiZXR3ZWVuIHNsaWRlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2FwOiAxMCxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBzbGlkZXMgYWZ0ZXIgYSBzcGVjaWZpZWQgaW50ZXJ2YWwuIFVzZSBgZmFsc2VgIGZvciB0dXJuaW5nIG9mZiBhdXRvcGxheS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ8Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBhdXRvcGxheTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGF1dG9wbGF5IG9uIG1vdXNlb3ZlciBldmVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhvdmVycGF1c2U6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBBbGxvdyBmb3IgY2hhbmdpbmcgc2xpZGVzIHdpdGggbGVmdCBhbmQgcmlnaHQga2V5Ym9hcmQgYXJyb3dzLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAga2V5Ym9hcmQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHJ1bm5pbmcgYHBlclZpZXdgIG51bWJlciBvZiBzbGlkZXMgZnJvbSB0aGUgZW5kLiBVc2UgdGhpc1xuICAgICAqIG9wdGlvbiBpZiB5b3UgZG9uJ3Qgd2FudCB0byBoYXZlIGFuIGVtcHR5IHNwYWNlIGFmdGVyXG4gICAgICogYSBzbGlkZXIuIFdvcmtzIG9ubHkgd2l0aCBgc2xpZGVyYCB0eXBlIGFuZCBhXG4gICAgICogbm9uLWNlbnRlcmVkIGBmb2N1c0F0YCBzZXR0aW5nLlxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgYm91bmQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogTWluaW1hbCBzd2lwZSBkaXN0YW5jZSBuZWVkZWQgdG8gY2hhbmdlIHRoZSBzbGlkZS4gVXNlIGBmYWxzZWAgZm9yIHR1cm5pbmcgb2ZmIGEgc3dpcGluZy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ8Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzd2lwZVRocmVzaG9sZDogODAsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbWFsIG1vdXNlIGRyYWcgZGlzdGFuY2UgbmVlZGVkIHRvIGNoYW5nZSB0aGUgc2xpZGUuIFVzZSBgZmFsc2VgIGZvciB0dXJuaW5nIG9mZiBhIGRyYWdnaW5nLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcnxCb29sZWFufVxuICAgICAqL1xuICAgIGRyYWdUaHJlc2hvbGQ6IDEyMCxcblxuICAgIC8qKlxuICAgICAqIEEgbWF4aW11bSBudW1iZXIgb2Ygc2xpZGVzIHRvIHdoaWNoIG1vdmVtZW50IHdpbGwgYmUgbWFkZSBvbiBzd2lwaW5nIG9yIGRyYWdnaW5nLiBVc2UgYGZhbHNlYCBmb3IgdW5saW1pdGVkLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcnxCb29sZWFufVxuICAgICAqL1xuICAgIHBlclRvdWNoOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIE1vdmluZyBkaXN0YW5jZSByYXRpbyBvZiB0aGUgc2xpZGVzIG9uIGEgc3dpcGluZyBhbmQgZHJhZ2dpbmcuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRvdWNoUmF0aW86IDAuNSxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIHJlcXVpcmVkIHRvIGFjdGl2YXRlIHNsaWRlcyBtb3Zpbmcgb24gc3dpcGluZyBvciBkcmFnZ2luZy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdG91Y2hBbmdsZTogNDUsXG5cbiAgICAvKipcbiAgICAgKiBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDQwMCxcblxuICAgIC8qKlxuICAgICAqIEFsbG93cyBsb29waW5nIHRoZSBgc2xpZGVyYCB0eXBlLiBTbGlkZXIgd2lsbCByZXdpbmQgdG8gdGhlIGZpcnN0L2xhc3Qgc2xpZGUgd2hlbiBpdCdzIGF0IHRoZSBzdGFydC9lbmQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICByZXdpbmQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBEdXJhdGlvbiBvZiB0aGUgcmV3aW5kaW5nIGFuaW1hdGlvbiBvZiB0aGUgYHNsaWRlcmAgdHlwZSBpbiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHJld2luZER1cmF0aW9uOiA4MDAsXG5cbiAgICAvKipcbiAgICAgKiBFYXNpbmcgZnVuY3Rpb24gZm9yIHRoZSBhbmltYXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGFuaW1hdGlvblRpbWluZ0Z1bmM6ICdjdWJpYy1iZXppZXIoLjE2NSwgLjg0MCwgLjQ0MCwgMSknLFxuXG4gICAgLyoqXG4gICAgICogVGhyb3R0bGUgY29zdGx5IGV2ZW50cyBhdCBtb3N0IG9uY2UgcGVyIGV2ZXJ5IHdhaXQgbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aHJvdHRsZTogMTAsXG5cbiAgICAvKipcbiAgICAgKiBNb3ZpbmcgZGlyZWN0aW9uIG1vZGUuXG4gICAgICpcbiAgICAgKiBBdmFpbGFibGUgaW5wdXRzOlxuICAgICAqIC0gJ2x0cicgLSBsZWZ0IHRvIHJpZ2h0IG1vdmVtZW50LFxuICAgICAqIC0gJ3J0bCcgLSByaWdodCB0byBsZWZ0IG1vdmVtZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBkaXJlY3Rpb246ICdsdHInLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIHZhbHVlIG9mIHRoZSBuZXh0IGFuZCBwcmV2aW91cyB2aWV3cG9ydHMgd2hpY2hcbiAgICAgKiBoYXZlIHRvIHBlZWsgaW4gdGhlIGN1cnJlbnQgdmlldy4gQWNjZXB0cyBudW1iZXIgYW5kXG4gICAgICogcGl4ZWxzIGFzIGEgc3RyaW5nLiBMZWZ0IGFuZCByaWdodCBwZWVraW5nIGNhbiBiZVxuICAgICAqIHNldCB1cCBzZXBhcmF0ZWx5IHdpdGggYSBkaXJlY3Rpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlOlxuICAgICAqIGAxMDBgIC0gUGVlayAxMDBweCBvbiB0aGUgYm90aCBzaWRlcy5cbiAgICAgKiB7IGJlZm9yZTogMTAwLCBhZnRlcjogNTAgfWAgLSBQZWVrIDEwMHB4IG9uIHRoZSBsZWZ0IHNpZGUgYW5kIDUwcHggb24gdGhlIHJpZ2h0IHNpZGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfFN0cmluZ3xPYmplY3R9XG4gICAgICovXG4gICAgcGVlazogMCxcblxuICAgIC8qKlxuICAgICAqIENvbGxlY3Rpb24gb2Ygb3B0aW9ucyBhcHBsaWVkIGF0IHNwZWNpZmllZCBtZWRpYSBicmVha3BvaW50cy5cbiAgICAgKiBGb3IgZXhhbXBsZTogZGlzcGxheSB0d28gc2xpZGVzIHBlciB2aWV3IHVuZGVyIDgwMHB4LlxuICAgICAqIGB7XG4gICAgICogICAnODAwcHgnOiB7XG4gICAgICogICAgIHBlclZpZXc6IDJcbiAgICAgKiAgIH1cbiAgICAgKiB9YFxuICAgICAqL1xuICAgIGJyZWFrcG9pbnRzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIENvbGxlY3Rpb24gb2YgaW50ZXJuYWxseSB1c2VkIEhUTUwgY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIEB0b2RvIFJlZmFjdG9yIGBzbGlkZXJgIGFuZCBgY2Fyb3VzZWxgIHByb3BlcnRpZXMgdG8gc2luZ2xlIGB0eXBlOiB7IHNsaWRlcjogJycsIGNhcm91c2VsOiAnJyB9YCBvYmplY3RcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGNsYXNzZXM6IHtcbiAgICAgIGRpcmVjdGlvbjoge1xuICAgICAgICBsdHI6ICdnbGlkZS0tbHRyJyxcbiAgICAgICAgcnRsOiAnZ2xpZGUtLXJ0bCdcbiAgICAgIH0sXG4gICAgICBzbGlkZXI6ICdnbGlkZS0tc2xpZGVyJyxcbiAgICAgIGNhcm91c2VsOiAnZ2xpZGUtLWNhcm91c2VsJyxcbiAgICAgIHN3aXBlYWJsZTogJ2dsaWRlLS1zd2lwZWFibGUnLFxuICAgICAgZHJhZ2dpbmc6ICdnbGlkZS0tZHJhZ2dpbmcnLFxuICAgICAgY2xvbmVTbGlkZTogJ2dsaWRlX19zbGlkZS0tY2xvbmUnLFxuICAgICAgYWN0aXZlTmF2OiAnZ2xpZGVfX2J1bGxldC0tYWN0aXZlJyxcbiAgICAgIGFjdGl2ZVNsaWRlOiAnZ2xpZGVfX3NsaWRlLS1hY3RpdmUnLFxuICAgICAgZGlzYWJsZWRBcnJvdzogJ2dsaWRlX19hcnJvdy0tZGlzYWJsZWQnXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBPdXRwdXRzIHdhcm5pbmcgbWVzc2FnZSB0byB0aGUgYm93c2VyIGNvbnNvbGUuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbXNnXG4gICAqIEByZXR1cm4ge1ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbR2xpZGUgd2Fybl06IFwiICsgbXNnKTtcbiAgfVxuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH07XG5cbiAgdmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICB2YXIgZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgICAgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICAgIH1cblxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbiAgfTtcblxuICB2YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gICAgaWYgKCFzZWxmKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHZhbHVlIGVudGVyZWQgYXMgbnVtYmVyXG4gICAqIG9yIHN0cmluZyB0byBpbnRlZ2VyIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIHRvSW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB2YWx1ZSBlbnRlcmVkIGFzIG51bWJlclxuICAgKiBvciBzdHJpbmcgdG8gZmxhdCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiB0b0Zsb2F0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSAgeyp9ICAgdmFsdWVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAgeyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSk7XG5cbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIXZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1peGVkLW9wZXJhdG9yc1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBudW1iZXIuXG4gICAqXG4gICAqIEBwYXJhbSAgeyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgdW5kZWZpbmVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0gIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgc3BlY2lmaWVkIGNvbGxlY3Rpb24gb2YgZXh0ZW5zaW9ucy5cbiAgICogRWFjaCBleHRlbnNpb24gcmVjZWl2ZXMgYWNjZXNzIHRvIGluc3RhbmNlIG9mIGdsaWRlIGFuZCByZXN0IG9mIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBnbGlkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgZnVuY3Rpb24gbW91bnQoZ2xpZGUsIGV4dGVuc2lvbnMsIGV2ZW50cykge1xuICAgIHZhciBjb21wb25lbnRzID0ge307XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGV4dGVuc2lvbnMpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGV4dGVuc2lvbnNbbmFtZV0pKSB7XG4gICAgICAgIGNvbXBvbmVudHNbbmFtZV0gPSBleHRlbnNpb25zW25hbWVdKGdsaWRlLCBjb21wb25lbnRzLCBldmVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybignRXh0ZW5zaW9uIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9uYW1lIGluIGNvbXBvbmVudHMpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbXBvbmVudHNbX25hbWVdLm1vdW50KSkge1xuICAgICAgICBjb21wb25lbnRzW19uYW1lXS5tb3VudCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgZ2V0dGVyIGFuZCBzZXR0ZXIgcHJvcGVydHkgb24gdGhlIHNwZWNpZmllZCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqICAgICAgICAgT2JqZWN0IHdoZXJlIHByb3BlcnR5IGhhcyB0byBiZSBkZWZpbmVkLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHByb3AgICAgICAgIE5hbWUgb2YgdGhlIGRlZmluZWQgcHJvcGVydHkuXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGVmaW5pdGlvbiAgR2V0IGFuZCBzZXQgZGVmaW5pdGlvbnMgZm9yIHRoZSBwcm9wZXJ0eS5cbiAgICogQHJldHVybiB7Vm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIHByb3AsIGRlZmluaXRpb24pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBkZWZpbml0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyBhcGhhYmV0aWNhbGx5IG9iamVjdCBrZXlzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiBzb3J0S2V5cyhvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uIChyLCBrKSB7XG4gICAgICByW2tdID0gb2JqW2tdO1xuXG4gICAgICByZXR1cm4gcltrXSwgcjtcbiAgICB9LCB7fSk7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2VzIHBhc3NlZCBzZXR0aW5ncyBvYmplY3Qgd2l0aCBkZWZhdWx0IG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGVmYXVsdHNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzZXR0aW5nc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZU9wdGlvbnMoZGVmYXVsdHMsIHNldHRpbmdzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdHMsIHNldHRpbmdzKTtcblxuICAgIC8vIGBPYmplY3QuYXNzaWduYCBkbyBub3QgZGVlcGx5IG1lcmdlIG9iamVjdHMsIHNvIHdlXG4gICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseSBmb3IgZXZlcnkgbmVzdGVkIG9iamVjdFxuICAgIC8vIGluIG9wdGlvbnMuIEFsdGhvdWdoIGl0IGRvZXMgbm90IGxvb2sgc21hcnQsXG4gICAgLy8gaXQncyBzbWFsbGVyIGFuZCBmYXN0ZXIgdGhhbiBzb21lIGZhbmN5XG4gICAgLy8gbWVyZ2luZyBkZWVwLW1lcmdlIGFsZ29yaXRobSBzY3JpcHQuXG4gICAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdjbGFzc2VzJykpIHtcbiAgICAgIG9wdGlvbnMuY2xhc3NlcyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0cy5jbGFzc2VzLCBzZXR0aW5ncy5jbGFzc2VzKTtcblxuICAgICAgaWYgKHNldHRpbmdzLmNsYXNzZXMuaGFzT3duUHJvcGVydHkoJ2RpcmVjdGlvbicpKSB7XG4gICAgICAgIG9wdGlvbnMuY2xhc3Nlcy5kaXJlY3Rpb24gPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdHMuY2xhc3Nlcy5kaXJlY3Rpb24sIHNldHRpbmdzLmNsYXNzZXMuZGlyZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2JyZWFrcG9pbnRzJykpIHtcbiAgICAgIG9wdGlvbnMuYnJlYWtwb2ludHMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdHMuYnJlYWtwb2ludHMsIHNldHRpbmdzLmJyZWFrcG9pbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIHZhciBFdmVudHNCdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgRXZlbnRCdXMgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXZlbnRzQnVzKCkge1xuICAgICAgdmFyIGV2ZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudHNCdXMpO1xuXG4gICAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICAgIHRoaXMuaG9wID0gZXZlbnRzLmhhc093blByb3BlcnR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgbGlzdGVuZXIgdG8gdGhlIHNwZWNpZmVkIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqL1xuXG5cbiAgICBjcmVhdGVDbGFzcyhFdmVudHNCdXMsIFt7XG4gICAgICBrZXk6ICdvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5vbihldmVudFtpXSwgaGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBldmVudCdzIG9iamVjdCBpZiBub3QgeWV0IGNyZWF0ZWRcbiAgICAgICAgaWYgKCF0aGlzLmhvcC5jYWxsKHRoaXMuZXZlbnRzLCBldmVudCkpIHtcbiAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudF0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgaGFuZGxlciB0byBxdWV1ZVxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmV2ZW50c1tldmVudF0ucHVzaChoYW5kbGVyKSAtIDE7XG5cbiAgICAgICAgLy8gUHJvdmlkZSBoYW5kbGUgYmFjayBmb3IgcmVtb3ZhbCBvZiBldmVudFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzW2V2ZW50XVtpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJ1bnMgcmVnaXN0ZXJlZCBoYW5kbGVycyBmb3Igc3BlY2lmaWVkIGV2ZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBldmVudFxuICAgICAgICogQHBhcmFtIHtPYmplY3Q9fSBjb250ZXh0XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2VtaXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50W2ldLCBjb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgZXZlbnQgZG9lc24ndCBleGlzdCwgb3IgdGhlcmUncyBubyBoYW5kbGVycyBpbiBxdWV1ZSwganVzdCBsZWF2ZVxuICAgICAgICBpZiAoIXRoaXMuaG9wLmNhbGwodGhpcy5ldmVudHMsIGV2ZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEN5Y2xlIHRocm91Z2ggZXZlbnRzIHF1ZXVlLCBmaXJlIVxuICAgICAgICB0aGlzLmV2ZW50c1tldmVudF0uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIGl0ZW0oY29udGV4dCB8fCB7fSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gRXZlbnRzQnVzO1xuICB9KCk7XG5cbiAgdmFyIEdsaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0IGdsaWRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gc2VsZWN0b3JcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICovXG4gICAgZnVuY3Rpb24gR2xpZGUoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEdsaWRlKTtcblxuICAgICAgdGhpcy5fYyA9IHt9O1xuICAgICAgdGhpcy5fdCA9IFtdO1xuICAgICAgdGhpcy5fZSA9IG5ldyBFdmVudHNCdXMoKTtcblxuICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IG1lcmdlT3B0aW9ucyhkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmluZGV4ID0gdGhpcy5zZXR0aW5ncy5zdGFydEF0O1xuICAgIH1cblxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgZ2xpZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgQ29sbGVjdGlvbiBvZiBleHRlbnNpb25zIHRvIGluaXRpYWxpemUuXHJcbiAgICAgKiBAcmV0dXJuIHtHbGlkZX1cclxuICAgICAqL1xuXG5cbiAgICBjcmVhdGVDbGFzcyhHbGlkZSwgW3tcbiAgICAgIGtleTogJ21vdW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VudCQkMSgpIHtcbiAgICAgICAgdmFyIGV4dGVuc2lvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgIHRoaXMuX2UuZW1pdCgnbW91bnQuYmVmb3JlJyk7XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KGV4dGVuc2lvbnMpKSB7XG4gICAgICAgICAgdGhpcy5fYyA9IG1vdW50KHRoaXMsIGV4dGVuc2lvbnMsIHRoaXMuX2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oJ1lvdSBuZWVkIHRvIHByb3ZpZGUgYSBvYmplY3Qgb24gYG1vdW50KClgJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lLmVtaXQoJ21vdW50LmFmdGVyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgKiBDb2xsZWN0cyBhbiBpbnN0YW5jZSBgdHJhbnNsYXRlYCB0cmFuc2Zvcm1lcnMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSAge0FycmF5fSB0cmFuc2Zvcm1lcnMgQ29sbGVjdGlvbiBvZiB0cmFuc2Zvcm1lcnMuXHJcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbXV0YXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtdXRhdGUoKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuXG4gICAgICAgIGlmIChpc0FycmF5KHRyYW5zZm9ybWVycykpIHtcbiAgICAgICAgICB0aGlzLl90ID0gdHJhbnNmb3JtZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oJ1lvdSBuZWVkIHRvIHByb3ZpZGUgYSBhcnJheSBvbiBgbXV0YXRlKClgJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAqIFVwZGF0ZXMgZ2xpZGUgd2l0aCBzcGVjaWZpZWQgc2V0dGluZ3MuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICAgKiBAcmV0dXJuIHtHbGlkZX1cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cGRhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICB0aGlzLnNldHRpbmdzID0gbWVyZ2VPcHRpb25zKHRoaXMuc2V0dGluZ3MsIHNldHRpbmdzKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ3N0YXJ0QXQnKSkge1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBzZXR0aW5ncy5zdGFydEF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZS5lbWl0KCd1cGRhdGUnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAqIENoYW5nZSBzbGlkZSB3aXRoIHNwZWNpZmllZCBwYXR0ZXJuLiBBIHBhdHRlcm4gbXVzdCBiZSBpbiB0aGUgc3BlY2lhbCBmb3JtYXQ6XHJcbiAgICAgICAqIGA+YCAtIE1vdmUgb25lIGZvcndhcmRcclxuICAgICAgICogYDxgIC0gTW92ZSBvbmUgYmFja3dhcmRcclxuICAgICAgICogYD17aX1gIC0gR28gdG8ge2l9IHplcm8tYmFzZWQgc2xpZGUgKGVxLiAnPTEnLCB3aWxsIGdvIHRvIHNlY29uZCBzbGlkZSlcclxuICAgICAgICogYD4+YCAtIFJld2luZHMgdG8gZW5kIChsYXN0IHNsaWRlKVxyXG4gICAgICAgKiBgPDxgIC0gUmV3aW5kcyB0byBzdGFydCAoZmlyc3Qgc2xpZGUpXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuXHJcbiAgICAgICAqIEByZXR1cm4ge0dsaWRlfVxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dvJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnbyhwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMuX2MuUnVuLm1ha2UocGF0dGVybik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgKiBNb3ZlIHRyYWNrIGJ5IHNwZWNpZmllZCBkaXN0YW5jZS5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGRpc3RhbmNlXHJcbiAgICAgICAqIEByZXR1cm4ge0dsaWRlfVxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ21vdmUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmUoZGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fYy5UcmFuc2l0aW9uLmRpc2FibGUoKTtcbiAgICAgICAgdGhpcy5fYy5Nb3ZlLm1ha2UoZGlzdGFuY2UpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICogRGVzdHJveSBpbnN0YW5jZSBhbmQgcmV2ZXJ0IGFsbCBjaGFuZ2VzIGRvbmUgYnkgdGhpcy5fYy5cclxuICAgICAgICpcclxuICAgICAgICogQHJldHVybiB7R2xpZGV9XHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZS5lbWl0KCdkZXN0cm95Jyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgKiBTdGFydCBpbnN0YW5jZSBhdXRvcGxheWluZy5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtCb29sZWFufE51bWJlcn0gaW50ZXJ2YWwgUnVuIGF1dG9wbGF5aW5nIHdpdGggcGFzc2VkIGludGVydmFsIHJlZ2FyZGxlc3Mgb2YgYGF1dG9wbGF5YCBzZXR0aW5nc1xyXG4gICAgICAgKiBAcmV0dXJuIHtHbGlkZX1cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdwbGF5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICAgIGlmIChpbnRlcnZhbCkge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MuYXV0b3BsYXkgPSBpbnRlcnZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2UuZW1pdCgncGxheScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICogU3RvcCBpbnN0YW5jZSBhdXRvcGxheWluZy5cclxuICAgICAgICpcclxuICAgICAgICogQHJldHVybiB7R2xpZGV9XHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncGF1c2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgICB0aGlzLl9lLmVtaXQoJ3BhdXNlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgKiBTZXRzIGdsaWRlIGludG8gYSBpZGxlIHN0YXR1cy5cclxuICAgICAgICpcclxuICAgICAgICogQHJldHVybiB7R2xpZGV9XHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGlzYWJsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgKiBTZXRzIGdsaWRlIGludG8gYSBhY3RpdmUgc3RhdHVzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJuIHtHbGlkZX1cclxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdlbmFibGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICogQWRkcyBjdXV0b20gZXZlbnQgbGlzdGVuZXIgd2l0aCBoYW5kbGVyLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl9IGV2ZW50XHJcbiAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBoYW5kbGVyXHJcbiAgICAgICAqIEByZXR1cm4ge0dsaWRlfVxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9lLm9uKGV2ZW50LCBoYW5kbGVyKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAqIENoZWNrcyBpZiBnbGlkZSBpcyBhIHByZWNpc2VkIHR5cGUuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxyXG4gICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2lzVHlwZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNUeXBlKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MudHlwZSA9PT0gbmFtZTtcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAqIEdldHMgdmFsdWUgb2YgdGhlIGNvcmUgb3B0aW9ucy5cclxuICAgICAgICpcclxuICAgICAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NldHRpbmdzJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbztcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAqIFNldHMgdmFsdWUgb2YgdGhlIGNvcmUgb3B0aW9ucy5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvXHJcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XHJcbiAgICAgICAqL1xuICAgICAgLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEobykge1xuICAgICAgICBpZiAoaXNPYmplY3QobykpIHtcbiAgICAgICAgICB0aGlzLl9vID0gbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKCdPcHRpb25zIG11c3QgYmUgYW4gYG9iamVjdGAgaW5zdGFuY2UuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAqIEdldHMgY3VycmVudCBpbmRleCBvZiB0aGUgc2xpZGVyLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnaW5kZXgnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICogU2V0cyBjdXJyZW50IGluZGV4IGEgc2xpZGVyLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICAgICAqL1xuICAgICAgLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoaSkge1xuICAgICAgICB0aGlzLl9pID0gdG9JbnQoaSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxyXG4gICAgICAgKiBHZXRzIHR5cGUgbmFtZSBvZiB0aGUgc2xpZGVyLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndHlwZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MudHlwZTtcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAqIEdldHMgdmFsdWUgb2YgdGhlIGlkbGUgc3RhdHVzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rpc2FibGVkJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZDtcbiAgICAgIH1cblxuICAgICAgLyoqXHJcbiAgICAgICAqIFNldHMgdmFsdWUgb2YgdGhlIGlkbGUgc3RhdHVzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICAgKi9cbiAgICAgICxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHN0YXR1cykge1xuICAgICAgICB0aGlzLl9kID0gISFzdGF0dXM7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBHbGlkZTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIFJ1biAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICAgIHZhciBSdW4gPSB7XG4gICAgICAvKipcbiAgICAgICAqIEluaXRpYWxpemVzIGF1dG9ydW5uaW5nIG9mIHRoZSBnbGlkZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICAgIHRoaXMuX28gPSBmYWxzZTtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBNYWtlcyBnbGlkZXMgcnVubmluZyBiYXNlZCBvbiB0aGUgcGFzc2VkIG1vdmluZyBzY2hlbWEuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1vdmVcbiAgICAgICAqL1xuICAgICAgbWFrZTogZnVuY3Rpb24gbWFrZShtb3ZlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFHbGlkZS5kaXNhYmxlZCkge1xuICAgICAgICAgIEdsaWRlLmRpc2FibGUoKTtcblxuICAgICAgICAgIHRoaXMubW92ZSA9IG1vdmU7XG5cbiAgICAgICAgICBFdmVudHMuZW1pdCgncnVuLmJlZm9yZScsIHRoaXMubW92ZSk7XG5cbiAgICAgICAgICB0aGlzLmNhbGN1bGF0ZSgpO1xuXG4gICAgICAgICAgRXZlbnRzLmVtaXQoJ3J1bicsIHRoaXMubW92ZSk7XG5cbiAgICAgICAgICBDb21wb25lbnRzLlRyYW5zaXRpb24uYWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzU3RhcnQoKSkge1xuICAgICAgICAgICAgICBFdmVudHMuZW1pdCgncnVuLnN0YXJ0JywgX3RoaXMubW92ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0VuZCgpKSB7XG4gICAgICAgICAgICAgIEV2ZW50cy5lbWl0KCdydW4uZW5kJywgX3RoaXMubW92ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfdGhpcy5pc09mZnNldCgnPCcpIHx8IF90aGlzLmlzT2Zmc2V0KCc+JykpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX28gPSBmYWxzZTtcblxuICAgICAgICAgICAgICBFdmVudHMuZW1pdCgncnVuLm9mZnNldCcsIF90aGlzLm1vdmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBFdmVudHMuZW1pdCgncnVuLmFmdGVyJywgX3RoaXMubW92ZSk7XG5cbiAgICAgICAgICAgIEdsaWRlLmVuYWJsZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsY3VsYXRlcyBjdXJyZW50IGluZGV4IGJhc2VkIG9uIGRlZmluZWQgbW92ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBjYWxjdWxhdGU6IGZ1bmN0aW9uIGNhbGN1bGF0ZSgpIHtcbiAgICAgICAgdmFyIG1vdmUgPSB0aGlzLm1vdmUsXG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgdmFyIHN0ZXBzID0gbW92ZS5zdGVwcyxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG1vdmUuZGlyZWN0aW9uO1xuXG5cbiAgICAgICAgdmFyIGNvdW50YWJsZVN0ZXBzID0gaXNOdW1iZXIodG9JbnQoc3RlcHMpKSAmJiB0b0ludChzdGVwcykgIT09IDA7XG5cbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIGlmIChzdGVwcyA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgIEdsaWRlLmluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRW5kKCkpIHtcbiAgICAgICAgICAgICAgaWYgKCEoR2xpZGUuaXNUeXBlKCdzbGlkZXInKSAmJiAhR2xpZGUuc2V0dGluZ3MucmV3aW5kKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX28gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgR2xpZGUuaW5kZXggPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50YWJsZVN0ZXBzKSB7XG4gICAgICAgICAgICAgIEdsaWRlLmluZGV4ICs9IE1hdGgubWluKGxlbmd0aCAtIEdsaWRlLmluZGV4LCAtdG9JbnQoc3RlcHMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEdsaWRlLmluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgaWYgKHN0ZXBzID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgR2xpZGUuaW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU3RhcnQoKSkge1xuICAgICAgICAgICAgICBpZiAoIShHbGlkZS5pc1R5cGUoJ3NsaWRlcicpICYmICFHbGlkZS5zZXR0aW5ncy5yZXdpbmQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBHbGlkZS5pbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb3VudGFibGVTdGVwcykge1xuICAgICAgICAgICAgICBHbGlkZS5pbmRleCAtPSBNYXRoLm1pbihHbGlkZS5pbmRleCwgdG9JbnQoc3RlcHMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEdsaWRlLmluZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgR2xpZGUuaW5kZXggPSBzdGVwcztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgZGlyZWN0aW9uIHBhdHRlcm4gWycgKyBkaXJlY3Rpb24gKyBzdGVwcyArICddIGhhcyBiZWVuIHVzZWQnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2tzIGlmIHdlIGFyZSBvbiB0aGUgZmlyc3Qgc2xpZGUuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgaXNTdGFydDogZnVuY3Rpb24gaXNTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIEdsaWRlLmluZGV4ID09PSAwO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrcyBpZiB3ZSBhcmUgb24gdGhlIGxhc3Qgc2xpZGUuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgaXNFbmQ6IGZ1bmN0aW9uIGlzRW5kKCkge1xuICAgICAgICByZXR1cm4gR2xpZGUuaW5kZXggPT09IHRoaXMubGVuZ3RoO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrcyBpZiB3ZSBhcmUgbWFraW5nIGEgb2Zmc2V0IHJ1bi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uXG4gICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBpc09mZnNldDogZnVuY3Rpb24gaXNPZmZzZXQoZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vICYmIHRoaXMubW92ZS5kaXJlY3Rpb24gPT09IGRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZGVmaW5lKFJ1biwgJ21vdmUnLCB7XG4gICAgICAvKipcbiAgICAgICAqIEdldHMgdmFsdWUgb2YgdGhlIG1vdmUgc2NoZW1hLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbTtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIHZhbHVlIG9mIHRoZSBtb3ZlIHNjaGVtYS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB2YXIgc3RlcCA9IHZhbHVlLnN1YnN0cigxKTtcblxuICAgICAgICB0aGlzLl9tID0ge1xuICAgICAgICAgIGRpcmVjdGlvbjogdmFsdWUuc3Vic3RyKDAsIDEpLFxuICAgICAgICAgIHN0ZXBzOiBzdGVwID8gdG9JbnQoc3RlcCkgPyB0b0ludChzdGVwKSA6IHN0ZXAgOiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkZWZpbmUoUnVuLCAnbGVuZ3RoJywge1xuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIHZhbHVlIG9mIHRoZSBydW5uaW5nIGRpc3RhbmNlIGJhc2VkXG4gICAgICAgKiBvbiB6ZXJvLWluZGV4aW5nIG51bWJlciBvZiBzbGlkZXMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gR2xpZGUuc2V0dGluZ3M7XG4gICAgICAgIHZhciBsZW5ndGggPSBDb21wb25lbnRzLkh0bWwuc2xpZGVzLmxlbmd0aDtcblxuICAgICAgICAvLyBJZiB0aGUgYGJvdW5kYCBvcHRpb24gaXMgYWNpdHZlLCBhIG1heGltdW0gcnVubmluZyBkaXN0YW5jZSBzaG91bGQgYmVcbiAgICAgICAgLy8gcmVkdWNlZCBieSBgcGVyVmlld2AgYW5kIGBmb2N1c0F0YCBzZXR0aW5ncy4gUnVubmluZyBkaXN0YW5jZVxuICAgICAgICAvLyBzaG91bGQgZW5kIGJlZm9yZSBjcmVhdGluZyBhbiBlbXB0eSBzcGFjZSBhZnRlciBpbnN0YW5jZS5cblxuICAgICAgICBpZiAoR2xpZGUuaXNUeXBlKCdzbGlkZXInKSAmJiBzZXR0aW5ncy5mb2N1c0F0ICE9PSAnY2VudGVyJyAmJiBzZXR0aW5ncy5ib3VuZCkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGggLSAxIC0gKHRvSW50KHNldHRpbmdzLnBlclZpZXcpIC0gMSkgKyB0b0ludChzZXR0aW5ncy5mb2N1c0F0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGVmaW5lKFJ1biwgJ29mZnNldCcsIHtcbiAgICAgIC8qKlxuICAgICAgICogR2V0cyBzdGF0dXMgb2YgdGhlIG9mZnNldHRpbmcgZmxhZy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX287XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUnVuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjdXJyZW50IHRpbWUuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWRcbiAgICogYXQgbW9zdCBvbmNlIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0XG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICpcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmVcbiAgICovXG4gIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGltZW91dCA9IHZvaWQgMCxcbiAgICAgICAgY29udGV4dCA9IHZvaWQgMCxcbiAgICAgICAgYXJncyA9IHZvaWQgMCxcbiAgICAgICAgcmVzdWx0ID0gdm9pZCAwO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBub3coKTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgdGhyb3R0bGVkID0gZnVuY3Rpb24gdGhyb3R0bGVkKCkge1xuICAgICAgdmFyIGF0ID0gbm93KCk7XG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gYXQ7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChhdCAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gYXQ7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHRocm90dGxlZC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBwcmV2aW91cyA9IDA7XG4gICAgICB0aW1lb3V0ID0gY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhyb3R0bGVkO1xuICB9XG5cbiAgdmFyIE1BUkdJTl9UWVBFID0ge1xuICAgIGx0cjogWydtYXJnaW5MZWZ0JywgJ21hcmdpblJpZ2h0J10sXG4gICAgcnRsOiBbJ21hcmdpblJpZ2h0JywgJ21hcmdpbkxlZnQnXVxuICB9O1xuXG4gIGZ1bmN0aW9uIEdhcHMgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgICB2YXIgR2FwcyA9IHtcbiAgICAgIC8qKlxuICAgICAgICogQXBwbGllcyBnYXBzIGJldHdlZW4gc2xpZGVzLiBGaXJzdCBhbmQgbGFzdFxuICAgICAgICogc2xpZGVzIGRvIG5vdCByZWNlaXZlIGl0J3MgZWRnZSBtYXJnaW5zLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTENvbGxlY3Rpb259IHNsaWRlc1xuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHNsaWRlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2xpZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0eWxlID0gc2xpZGVzW2ldLnN0eWxlO1xuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBDb21wb25lbnRzLkRpcmVjdGlvbi52YWx1ZTtcblxuICAgICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICBzdHlsZVtNQVJHSU5fVFlQRVtkaXJlY3Rpb25dWzBdXSA9IHRoaXMudmFsdWUgLyAyICsgJ3B4JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVbTUFSR0lOX1RZUEVbZGlyZWN0aW9uXVswXV0gPSAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSAhPT0gc2xpZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHN0eWxlW01BUkdJTl9UWVBFW2RpcmVjdGlvbl1bMV1dID0gdGhpcy52YWx1ZSAvIDIgKyAncHgnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZVtNQVJHSU5fVFlQRVtkaXJlY3Rpb25dWzFdXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgZ2FwcyBmcm9tIHRoZSBzbGlkZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MQ29sbGVjdGlvbn0gc2xpZGVzXG4gICAgICAgKiBAcmV0dXJucyB7Vm9pZH1cbiAgICAgICovXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShzbGlkZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNsaWRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBzdHlsZSA9IHNsaWRlc1tpXS5zdHlsZTtcblxuICAgICAgICAgIHN0eWxlLm1hcmdpbkxlZnQgPSAnJztcbiAgICAgICAgICBzdHlsZS5tYXJnaW5SaWdodCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZShHYXBzLCAndmFsdWUnLCB7XG4gICAgICAvKipcbiAgICAgICAqIEdldHMgdmFsdWUgb2YgdGhlIGdhcC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50KEdsaWRlLnNldHRpbmdzLmdhcCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkZWZpbmUoR2FwcywgJ2dyb3cnLCB7XG4gICAgICAvKipcbiAgICAgICAqIEdldHMgYWRkaXRpb25hbCBkaW1lbnRpb25zIHZhbHVlIGNhdXNlZCBieSBnYXBzLlxuICAgICAgICogVXNlZCB0byBpbmNyZWFzZSB3aWR0aCBvZiB0aGUgc2xpZGVzIHdyYXBwZXIuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBHYXBzLnZhbHVlICogKENvbXBvbmVudHMuU2l6ZXMubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkZWZpbmUoR2FwcywgJ3JlZHVjdG9yJywge1xuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIHJlZHVjdGlvbiB2YWx1ZSBjYXVzZWQgYnkgZ2Fwcy5cbiAgICAgICAqIFVzZWQgdG8gc3VidHJhY3Qgd2lkdGggb2YgdGhlIHNsaWRlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHBlclZpZXcgPSBHbGlkZS5zZXR0aW5ncy5wZXJWaWV3O1xuXG4gICAgICAgIHJldHVybiBHYXBzLnZhbHVlICogKHBlclZpZXcgLSAxKSAvIHBlclZpZXc7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBjYWxjdWxhdGVkIGdhcHM6XG4gICAgICogLSBhZnRlciBidWlsZGluZywgc28gc2xpZGVzIChpbmNsdWRpbmcgY2xvbmVzKSB3aWxsIHJlY2VpdmUgcHJvcGVyIG1hcmdpbnNcbiAgICAgKiAtIG9uIHVwZGF0aW5nIHZpYSBBUEksIHRvIHJlY2FsY3VsYXRlIGdhcHMgd2l0aCBuZXcgb3B0aW9uc1xuICAgICAqL1xuICAgIEV2ZW50cy5vbihbJ2J1aWxkLmFmdGVyJywgJ3VwZGF0ZSddLCB0aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgICBHYXBzLmFwcGx5KENvbXBvbmVudHMuSHRtbC53cmFwcGVyLmNoaWxkcmVuKTtcbiAgICB9LCAzMCkpO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGdhcHM6XG4gICAgICogLSBvbiBkZXN0cm95aW5nIHRvIGJyaW5nIG1hcmt1cCB0byBpdHMgaW5pdGFsIHN0YXRlXG4gICAgICovXG4gICAgRXZlbnRzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgR2Fwcy5yZW1vdmUoQ29tcG9uZW50cy5IdG1sLndyYXBwZXIuY2hpbGRyZW4pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIEdhcHM7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgc2libGluZ3Mgbm9kZXMgb2YgdGhlIHBhc3NlZCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtFbGVtZW50fSBub2RlXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gc2libGluZ3Mobm9kZSkge1xuICAgIGlmIChub2RlICYmIG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIG4gPSBub2RlLnBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIHZhciBtYXRjaGVkID0gW107XG5cbiAgICAgIGZvciAoOyBuOyBuID0gbi5uZXh0U2libGluZykge1xuICAgICAgICBpZiAobi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBub2RlKSB7XG4gICAgICAgICAgbWF0Y2hlZC5wdXNoKG4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcGFzc2VkIG5vZGUgZXhpc3QgYW5kIGlzIGEgdmFsaWQgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtICB7RWxlbWVudH0gbm9kZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpc3Qobm9kZSkge1xuICAgIGlmIChub2RlICYmIG5vZGUgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBUUkFDS19TRUxFQ1RPUiA9ICdbZGF0YS1nbGlkZS1lbD1cInRyYWNrXCJdJztcblxuICBmdW5jdGlvbiBIdG1sIChHbGlkZSwgQ29tcG9uZW50cykge1xuICAgIHZhciBIdG1sID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cCBzbGlkZXIgSFRNTCBub2Rlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0dsaWRlfSBnbGlkZVxuICAgICAgICovXG4gICAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IEdsaWRlLnNlbGVjdG9yO1xuICAgICAgICB0aGlzLnRyYWNrID0gdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3IoVFJBQ0tfU0VMRUNUT1IpO1xuICAgICAgICB0aGlzLnNsaWRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMud3JhcHBlci5jaGlsZHJlbikuZmlsdGVyKGZ1bmN0aW9uIChzbGlkZSkge1xuICAgICAgICAgIHJldHVybiAhc2xpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKEdsaWRlLnNldHRpbmdzLmNsYXNzZXMuY2xvbmVTbGlkZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBkZWZpbmUoSHRtbCwgJ3Jvb3QnLCB7XG4gICAgICAvKipcbiAgICAgICAqIEdldHMgbm9kZSBvZiB0aGUgZ2xpZGUgbWFpbiBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBIdG1sLl9yO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgbm9kZSBvZiB0aGUgZ2xpZGUgbWFpbiBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQocikge1xuICAgICAgICBpZiAoaXNTdHJpbmcocikpIHtcbiAgICAgICAgICByID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleGlzdChyKSkge1xuICAgICAgICAgIEh0bWwuX3IgPSByO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oJ1Jvb3QgZWxlbWVudCBtdXN0IGJlIGEgZXhpc3RpbmcgSHRtbCBub2RlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRlZmluZShIdG1sLCAndHJhY2snLCB7XG4gICAgICAvKipcbiAgICAgICAqIEdldHMgbm9kZSBvZiB0aGUgZ2xpZGUgdHJhY2sgd2l0aCBzbGlkZXMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIEh0bWwuX3Q7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyBub2RlIG9mIHRoZSBnbGlkZSB0cmFjayB3aXRoIHNsaWRlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHQpIHtcbiAgICAgICAgaWYgKGV4aXN0KHQpKSB7XG4gICAgICAgICAgSHRtbC5fdCA9IHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybignQ291bGQgbm90IGZpbmQgdHJhY2sgZWxlbWVudC4gUGxlYXNlIHVzZSAnICsgVFJBQ0tfU0VMRUNUT1IgKyAnIGF0dHJpYnV0ZS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGVmaW5lKEh0bWwsICd3cmFwcGVyJywge1xuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIG5vZGUgb2YgdGhlIHNsaWRlcyB3cmFwcGVyLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBIdG1sLnRyYWNrLmNoaWxkcmVuWzBdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEh0bWw7XG4gIH1cblxuICBmdW5jdGlvbiBQZWVrIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gICAgdmFyIFBlZWsgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFNldHVwcyBob3cgbXVjaCB0byBwZWVrIGJhc2VkIG9uIHNldHRpbmdzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IEdsaWRlLnNldHRpbmdzLnBlZWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZShQZWVrLCAndmFsdWUnLCB7XG4gICAgICAvKipcbiAgICAgICAqIEdldHMgdmFsdWUgb2YgdGhlIHBlZWsuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge051bWJlcnxPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gUGVlay5fdjtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIHZhbHVlIG9mIHRoZSBwZWVrLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gdmFsdWVcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZS5iZWZvcmUgPSB0b0ludCh2YWx1ZS5iZWZvcmUpO1xuICAgICAgICAgIHZhbHVlLmFmdGVyID0gdG9JbnQodmFsdWUuYWZ0ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgUGVlay5fdiA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGVmaW5lKFBlZWssICdyZWR1Y3RvcicsIHtcbiAgICAgIC8qKlxuICAgICAgICogR2V0cyByZWR1Y3Rpb24gdmFsdWUgY2F1c2VkIGJ5IHBlZWsuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IFBlZWsudmFsdWU7XG4gICAgICAgIHZhciBwZXJWaWV3ID0gR2xpZGUuc2V0dGluZ3MucGVyVmlldztcblxuICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmJlZm9yZSAvIHBlclZpZXcgKyB2YWx1ZS5hZnRlciAvIHBlclZpZXc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUgKiAyIC8gcGVyVmlldztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlY2FsY3VsYXRlIHBlZWtpbmcgc2l6ZXMgb246XG4gICAgICogLSB3aGVuIHJlc2l6aW5nIHdpbmRvdyB0byB1cGRhdGUgdG8gcHJvcGVyIHBlcmNlbnRzXG4gICAgICovXG4gICAgRXZlbnRzLm9uKFsncmVzaXplJywgJ3VwZGF0ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgICBQZWVrLm1vdW50KCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUGVlaztcbiAgfVxuXG4gIGZ1bmN0aW9uIE1vdmUgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgICB2YXIgTW92ZSA9IHtcbiAgICAgIC8qKlxuICAgICAgICogQ29uc3RydWN0cyBtb3ZlIGNvbXBvbmVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgICB0aGlzLl9vID0gMDtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxjdWxhdGVzIGEgbW92ZW1lbnQgdmFsdWUgYmFzZWQgb24gcGFzc2VkIG9mZnNldCBhbmQgY3VycmVudGx5IGFjdGl2ZSBpbmRleC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG9mZnNldFxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgbWFrZTogZnVuY3Rpb24gbWFrZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgICAgIEV2ZW50cy5lbWl0KCdtb3ZlJywge1xuICAgICAgICAgIG1vdmVtZW50OiB0aGlzLnZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNpdGlvbi5hZnRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgRXZlbnRzLmVtaXQoJ21vdmUuYWZ0ZXInLCB7XG4gICAgICAgICAgICBtb3ZlbWVudDogX3RoaXMudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZShNb3ZlLCAnb2Zmc2V0Jywge1xuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIGFuIG9mZnNldCB2YWx1ZSB1c2VkIHRvIG1vZGlmeSBjdXJyZW50IHRyYW5zbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gTW92ZS5fbztcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIGFuIG9mZnNldCB2YWx1ZSB1c2VkIHRvIG1vZGlmeSBjdXJyZW50IHRyYW5zbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIE1vdmUuX28gPSAhaXNVbmRlZmluZWQodmFsdWUpID8gdG9JbnQodmFsdWUpIDogMDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRlZmluZShNb3ZlLCAndHJhbnNsYXRlJywge1xuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIGEgcmF3IG1vdmVtZW50IHZhbHVlLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnRzLlNpemVzLnNsaWRlV2lkdGggKiBHbGlkZS5pbmRleDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRlZmluZShNb3ZlLCAndmFsdWUnLCB7XG4gICAgICAvKipcbiAgICAgICAqIEdldHMgYW4gYWN0dWFsIG1vdmVtZW50IHZhbHVlIGNvcnJlY3RlZCBieSBvZmZzZXQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICB2YXIgdHJhbnNsYXRlID0gdGhpcy50cmFuc2xhdGU7XG5cbiAgICAgICAgaWYgKENvbXBvbmVudHMuRGlyZWN0aW9uLmlzKCdydGwnKSkge1xuICAgICAgICAgIHJldHVybiB0cmFuc2xhdGUgKyBvZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJhbnNsYXRlIC0gb2Zmc2V0O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogTWFrZSBtb3ZlbWVudCB0byBwcm9wZXIgc2xpZGUgb246XG4gICAgICogLSBiZWZvcmUgYnVpbGQsIHNvIGdsaWRlIHdpbGwgc3RhcnQgYXQgYHN0YXJ0QXRgIGluZGV4XG4gICAgICogLSBvbiBlYWNoIHN0YW5kYXJkIHJ1biB0byBtb3ZlIHRvIG5ld2x5IGNhbGN1bGF0ZWQgaW5kZXhcbiAgICAgKi9cbiAgICBFdmVudHMub24oWydidWlsZC5iZWZvcmUnLCAncnVuJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIE1vdmUubWFrZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIE1vdmU7XG4gIH1cblxuICBmdW5jdGlvbiBTaXplcyAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICAgIHZhciBTaXplcyA9IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0dXBzIGRpbWVudGlvbnMgb2Ygc2xpZGVzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIHNldHVwU2xpZGVzOiBmdW5jdGlvbiBzZXR1cFNsaWRlcygpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5zbGlkZVdpZHRoICsgJ3B4JztcbiAgICAgICAgdmFyIHNsaWRlcyA9IENvbXBvbmVudHMuSHRtbC5zbGlkZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzbGlkZXNbaV0uc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHVwcyBkaW1lbnRpb25zIG9mIHNsaWRlcyB3cmFwcGVyLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIHNldHVwV3JhcHBlcjogZnVuY3Rpb24gc2V0dXBXcmFwcGVyKGRpbWVudGlvbikge1xuICAgICAgICBDb21wb25lbnRzLkh0bWwud3JhcHBlci5zdHlsZS53aWR0aCA9IHRoaXMud3JhcHBlclNpemUgKyAncHgnO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgYXBwbGllZCBzdHlsZXMgZnJvbSBIVE1MIGVsZW1lbnRzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtWb2lkfVxuICAgICAgICovXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgdmFyIHNsaWRlcyA9IENvbXBvbmVudHMuSHRtbC5zbGlkZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzbGlkZXNbaV0uc3R5bGUud2lkdGggPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLnN0eWxlLndpZHRoID0gJyc7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZShTaXplcywgJ2xlbmd0aCcsIHtcbiAgICAgIC8qKlxuICAgICAgICogR2V0cyBjb3VudCBudW1iZXIgb2YgdGhlIHNsaWRlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50cy5IdG1sLnNsaWRlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkZWZpbmUoU2l6ZXMsICd3aWR0aCcsIHtcbiAgICAgIC8qKlxuICAgICAgICogR2V0cyB3aWR0aCB2YWx1ZSBvZiB0aGUgZ2xpZGUuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudHMuSHRtbC5yb290Lm9mZnNldFdpZHRoO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGVmaW5lKFNpemVzLCAnd3JhcHBlclNpemUnLCB7XG4gICAgICAvKipcbiAgICAgICAqIEdldHMgc2l6ZSBvZiB0aGUgc2xpZGVzIHdyYXBwZXIuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFNpemVzLnNsaWRlV2lkdGggKiBTaXplcy5sZW5ndGggKyBDb21wb25lbnRzLkdhcHMuZ3JvdyArIENvbXBvbmVudHMuQ2xvbmVzLmdyb3c7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkZWZpbmUoU2l6ZXMsICdzbGlkZVdpZHRoJywge1xuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIHdpZHRoIHZhbHVlIG9mIHRoZSBzaW5nbGUgc2xpZGUuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFNpemVzLndpZHRoIC8gR2xpZGUuc2V0dGluZ3MucGVyVmlldyAtIENvbXBvbmVudHMuUGVlay5yZWR1Y3RvciAtIENvbXBvbmVudHMuR2Fwcy5yZWR1Y3RvcjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGNhbGN1bGF0ZWQgZ2xpZGUncyBkaW1lbnNpb25zOlxuICAgICAqIC0gYmVmb3JlIGJ1aWxkaW5nLCBzbyBvdGhlciBkaW1lbnRpb25zIChlLmcuIHRyYW5zbGF0ZSkgd2lsbCBiZSBjYWxjdWxhdGVkIHByb3BlcnRseVxuICAgICAqIC0gd2hlbiByZXNpemluZyB3aW5kb3cgdG8gcmVjYWxjdWxhdGUgc2lsZGVzIGRpbWVuc2lvbnNcbiAgICAgKiAtIG9uIHVwZGF0aW5nIHZpYSBBUEksIHRvIGNhbGN1bGF0ZSBkaW1lbnNpb25zIGJhc2VkIG9uIG5ldyBvcHRpb25zXG4gICAgICovXG4gICAgRXZlbnRzLm9uKFsnYnVpbGQuYmVmb3JlJywgJ3Jlc2l6ZScsICd1cGRhdGUnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgU2l6ZXMuc2V0dXBTbGlkZXMoKTtcbiAgICAgIFNpemVzLnNldHVwV3JhcHBlcigpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGNhbGN1bGF0ZWQgZ2xpZGUncyBkaW1lbnNpb25zOlxuICAgICAqIC0gb24gZGVzdG90aW5nIHRvIGJyaW5nIG1hcmt1cCB0byBpdHMgaW5pdGFsIHN0YXRlXG4gICAgICovXG4gICAgRXZlbnRzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgU2l6ZXMucmVtb3ZlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gU2l6ZXM7XG4gIH1cblxuICBmdW5jdGlvbiBCdWlsZCAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICAgIHZhciBCdWlsZCA9IHtcbiAgICAgIC8qKlxuICAgICAgICogSW5pdCBnbGlkZSBidWlsZGluZy4gQWRkcyBjbGFzc2VzLCBzZXRzXG4gICAgICAgKiBkaW1lbnNpb25zIGFuZCBzZXR1cHMgaW5pdGlhbCBzdGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICAgIEV2ZW50cy5lbWl0KCdidWlsZC5iZWZvcmUnKTtcblxuICAgICAgICB0aGlzLnR5cGVDbGFzcygpO1xuICAgICAgICB0aGlzLmFjdGl2ZUNsYXNzKCk7XG5cbiAgICAgICAgRXZlbnRzLmVtaXQoJ2J1aWxkLmFmdGVyJyk7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBgdHlwZWAgY2xhc3MgdG8gdGhlIGdsaWRlIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgdHlwZUNsYXNzOiBmdW5jdGlvbiB0eXBlQ2xhc3MoKSB7XG4gICAgICAgIENvbXBvbmVudHMuSHRtbC5yb290LmNsYXNzTGlzdC5hZGQoR2xpZGUuc2V0dGluZ3MuY2xhc3Nlc1tHbGlkZS5zZXR0aW5ncy50eXBlXSk7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyBhY3RpdmUgY2xhc3MgdG8gY3VycmVudCBzbGlkZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBhY3RpdmVDbGFzczogZnVuY3Rpb24gYWN0aXZlQ2xhc3MoKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gR2xpZGUuc2V0dGluZ3MuY2xhc3NlcztcbiAgICAgICAgdmFyIHNsaWRlID0gQ29tcG9uZW50cy5IdG1sLnNsaWRlc1tHbGlkZS5pbmRleF07XG5cbiAgICAgICAgaWYgKHNsaWRlKSB7XG4gICAgICAgICAgc2xpZGUuY2xhc3NMaXN0LmFkZChjbGFzc2VzLmFjdGl2ZVNsaWRlKTtcblxuICAgICAgICAgIHNpYmxpbmdzKHNsaWRlKS5mb3JFYWNoKGZ1bmN0aW9uIChzaWJsaW5nKSB7XG4gICAgICAgICAgICBzaWJsaW5nLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3Nlcy5hY3RpdmVTbGlkZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIEhUTUwgY2xhc3NlcyBhcHBsaWVkIGF0IGJ1aWxkaW5nLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIHJlbW92ZUNsYXNzZXM6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMoKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gR2xpZGUuc2V0dGluZ3MuY2xhc3NlcztcblxuICAgICAgICBDb21wb25lbnRzLkh0bWwucm9vdC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzZXNbR2xpZGUuc2V0dGluZ3MudHlwZV0pO1xuXG4gICAgICAgIENvbXBvbmVudHMuSHRtbC5zbGlkZXMuZm9yRWFjaChmdW5jdGlvbiAoc2libGluZykge1xuICAgICAgICAgIHNpYmxpbmcuY2xhc3NMaXN0LnJlbW92ZShjbGFzc2VzLmFjdGl2ZVNsaWRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIGJ1aWxkaW5nIGNsYXNzZXM6XG4gICAgICogLSBvbiBkZXN0cm95aW5nIHRvIGJyaW5nIEhUTUwgdG8gaXRzIGluaXRpYWwgc3RhdGVcbiAgICAgKiAtIG9uIHVwZGF0aW5nIHRvIHJlbW92ZSBjbGFzc2VzIGJlZm9yZSByZW1vdW50aW5nIGNvbXBvbmVudFxuICAgICAqL1xuICAgIEV2ZW50cy5vbihbJ2Rlc3Ryb3knLCAndXBkYXRlJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIEJ1aWxkLnJlbW92ZUNsYXNzZXMoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW91bnQgY29tcG9uZW50OlxuICAgICAqIC0gb24gcmVzaXppbmcgb2YgdGhlIHdpbmRvdyB0byBjYWxjdWxhdGUgbmV3IGRpbWVudGlvbnNcbiAgICAgKiAtIG9uIHVwZGF0aW5nIHNldHRpbmdzIHZpYSBBUElcbiAgICAgKi9cbiAgICBFdmVudHMub24oWydyZXNpemUnLCAndXBkYXRlJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIEJ1aWxkLm1vdW50KCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTd2FwIGFjdGl2ZSBjbGFzcyBvZiBjdXJyZW50IHNsaWRlOlxuICAgICAqIC0gYWZ0ZXIgZWFjaCBtb3ZlIHRvIHRoZSBuZXcgaW5kZXhcbiAgICAgKi9cbiAgICBFdmVudHMub24oJ21vdmUuYWZ0ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICBCdWlsZC5hY3RpdmVDbGFzcygpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIEJ1aWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ2xvbmVzIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gICAgdmFyIENsb25lcyA9IHtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIHBhdHRlcm4gbWFwIGFuZCBjb2xsZWN0IHNsaWRlcyB0byBiZSBjbG9uZWQuXG4gICAgICAgKi9cbiAgICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuXG4gICAgICAgIGlmIChHbGlkZS5pc1R5cGUoJ2Nhcm91c2VsJykpIHtcbiAgICAgICAgICB0aGlzLml0ZW1zID0gdGhpcy5jb2xsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBDb2xsZWN0IGNsb25lcyB3aXRoIHBhdHRlcm4uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgY29sbGVjdDogZnVuY3Rpb24gY29sbGVjdCgpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICAgICAgdmFyIHNsaWRlcyA9IENvbXBvbmVudHMuSHRtbC5zbGlkZXM7XG4gICAgICAgIHZhciBfR2xpZGUkc2V0dGluZ3MgPSBHbGlkZS5zZXR0aW5ncyxcbiAgICAgICAgICAgIHBlclZpZXcgPSBfR2xpZGUkc2V0dGluZ3MucGVyVmlldyxcbiAgICAgICAgICAgIGNsYXNzZXMgPSBfR2xpZGUkc2V0dGluZ3MuY2xhc3NlcztcblxuXG4gICAgICAgIHZhciBwZWVrSW5jcmVtZW50ZXIgPSArISFHbGlkZS5zZXR0aW5ncy5wZWVrO1xuICAgICAgICB2YXIgcGFydCA9IHBlclZpZXcgKyBwZWVrSW5jcmVtZW50ZXI7XG4gICAgICAgIHZhciBzdGFydCA9IHNsaWRlcy5zbGljZSgwLCBwYXJ0KTtcbiAgICAgICAgdmFyIGVuZCA9IHNsaWRlcy5zbGljZSgtcGFydCk7XG5cbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHBlclZpZXcgLyBzbGlkZXMubGVuZ3RoKSk7IHIrKykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IHN0YXJ0W2ldLmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICAgICAgY2xvbmUuY2xhc3NMaXN0LmFkZChjbGFzc2VzLmNsb25lU2xpZGUpO1xuXG4gICAgICAgICAgICBpdGVtcy5wdXNoKGNsb25lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZW5kLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF9jbG9uZSA9IGVuZFtfaV0uY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgICAgICBfY2xvbmUuY2xhc3NMaXN0LmFkZChjbGFzc2VzLmNsb25lU2xpZGUpO1xuXG4gICAgICAgICAgICBpdGVtcy51bnNoaWZ0KF9jbG9uZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEFwcGVuZCBjbG9uZWQgc2xpZGVzIHdpdGggZ2VuZXJhdGVkIHBhdHRlcm4uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgYXBwZW5kOiBmdW5jdGlvbiBhcHBlbmQoKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIHZhciBfQ29tcG9uZW50cyRIdG1sID0gQ29tcG9uZW50cy5IdG1sLFxuICAgICAgICAgICAgd3JhcHBlciA9IF9Db21wb25lbnRzJEh0bWwud3JhcHBlcixcbiAgICAgICAgICAgIHNsaWRlcyA9IF9Db21wb25lbnRzJEh0bWwuc2xpZGVzO1xuXG5cbiAgICAgICAgdmFyIGhhbGYgPSBNYXRoLmZsb29yKGl0ZW1zLmxlbmd0aCAvIDIpO1xuICAgICAgICB2YXIgcHJlcGVuZCA9IGl0ZW1zLnNsaWNlKDAsIGhhbGYpLnJldmVyc2UoKTtcbiAgICAgICAgdmFyIGFwcGVuZCA9IGl0ZW1zLnNsaWNlKGhhbGYsIGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIHZhciB3aWR0aCA9IENvbXBvbmVudHMuU2l6ZXMuc2xpZGVXaWR0aCArICdweCc7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcHBlbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGFwcGVuZFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwcmVwZW5kLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB3cmFwcGVyLmluc2VydEJlZm9yZShwcmVwZW5kW19pMl0sIHNsaWRlc1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBpdGVtcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgaXRlbXNbX2kzXS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIGFsbCBjbG9uZWQgc2xpZGVzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLml0ZW1zO1xuXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLnJlbW92ZUNoaWxkKGl0ZW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBkZWZpbmUoQ2xvbmVzLCAnZ3JvdycsIHtcbiAgICAgIC8qKlxuICAgICAgICogR2V0cyBhZGRpdGlvbmFsIGRpbWVudGlvbnMgdmFsdWUgY2F1c2VkIGJ5IGNsb25lcy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gKENvbXBvbmVudHMuU2l6ZXMuc2xpZGVXaWR0aCArIENvbXBvbmVudHMuR2Fwcy52YWx1ZSkgKiBDbG9uZXMuaXRlbXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQXBwZW5kIGFkZGl0aW9uYWwgc2xpZGUncyBjbG9uZXM6XG4gICAgICogLSB3aGlsZSBnbGlkZSdzIHR5cGUgaXMgYGNhcm91c2VsYFxuICAgICAqL1xuICAgIEV2ZW50cy5vbigndXBkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgQ2xvbmVzLnJlbW92ZSgpO1xuICAgICAgQ2xvbmVzLm1vdW50KCk7XG4gICAgICBDbG9uZXMuYXBwZW5kKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYWRkaXRpb25hbCBzbGlkZSdzIGNsb25lczpcbiAgICAgKiAtIHdoaWxlIGdsaWRlJ3MgdHlwZSBpcyBgY2Fyb3VzZWxgXG4gICAgICovXG4gICAgRXZlbnRzLm9uKCdidWlsZC5iZWZvcmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoR2xpZGUuaXNUeXBlKCdjYXJvdXNlbCcpKSB7XG4gICAgICAgIENsb25lcy5hcHBlbmQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBjbG9uZXMgSFRNTEVsZW1lbnRzOlxuICAgICAqIC0gb24gZGVzdHJveWluZywgdG8gYnJpbmcgSFRNTCB0byBpdHMgaW5pdGlhbCBzdGF0ZVxuICAgICAqL1xuICAgIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIENsb25lcy5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBDbG9uZXM7XG4gIH1cblxuICB2YXIgRXZlbnRzQmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIEV2ZW50c0JpbmRlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFdmVudHNCaW5kZXIoKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50c0JpbmRlcik7XG5cbiAgICAgIHRoaXMubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgZXZlbnRzIGxpc3RlbmVycyB0byBhcnJvd3MgSFRNTCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gZXZlbnRzXG4gICAgICogQHBhcmFtICB7RWxlbWVudHxXaW5kb3d8RG9jdW1lbnR9IGVsXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNsb3N1cmVcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufE9iamVjdH0gY2FwdHVyZVxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG5cblxuICAgIGNyZWF0ZUNsYXNzKEV2ZW50c0JpbmRlciwgW3tcbiAgICAgIGtleTogJ29uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudHMsIGVsLCBjbG9zdXJlKSB7XG4gICAgICAgIHZhciBjYXB0dXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAgICAgICBpZiAoaXNTdHJpbmcoZXZlbnRzKSkge1xuICAgICAgICAgIGV2ZW50cyA9IFtldmVudHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudHNbaV1dID0gY2xvc3VyZTtcblxuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzW2ldLCB0aGlzLmxpc3RlbmVyc1tldmVudHNbaV1dLCBjYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIGZyb20gYXJyb3dzIEhUTUwgZWxlbWVudHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBldmVudHNcbiAgICAgICAqIEBwYXJhbSAge0VsZW1lbnR8V2luZG93fERvY3VtZW50fSBlbFxuICAgICAgICogQHBhcmFtICB7Qm9vbGVhbnxPYmplY3R9IGNhcHR1cmVcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29mZicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKGV2ZW50cywgZWwpIHtcbiAgICAgICAgdmFyIGNhcHR1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICAgIGlmIChpc1N0cmluZyhldmVudHMpKSB7XG4gICAgICAgICAgZXZlbnRzID0gW2V2ZW50c107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRzW2ldLCB0aGlzLmxpc3RlbmVyc1tldmVudHNbaV1dLCBjYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlc3Ryb3kgY29sbGVjdGVkIGxpc3RlbmVycy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7Vm9pZH1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gRXZlbnRzQmluZGVyO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gUmVzaXplIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gICAgLyoqXG4gICAgICogSW5zdGFuY2Ugb2YgdGhlIGJpbmRlciBmb3IgRE9NIEV2ZW50cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtFdmVudHNCaW5kZXJ9XG4gICAgICovXG4gICAgdmFyIEJpbmRlciA9IG5ldyBFdmVudHNCaW5kZXIoKTtcblxuICAgIHZhciBSZXNpemUgPSB7XG4gICAgICAvKipcbiAgICAgICAqIEluaXRpYWxpemVzIHdpbmRvdyBiaW5kaW5ncy5cbiAgICAgICAqL1xuICAgICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgICB0aGlzLmJpbmQoKTtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBCaW5kcyBgcmV6c2l6ZWAgbGlzdGVuZXIgdG8gdGhlIHdpbmRvdy5cbiAgICAgICAqIEl0J3MgYSBjb3N0bHkgZXZlbnQsIHNvIHdlIGFyZSBkZWJvdW5jaW5nIGl0LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgICAgIEJpbmRlci5vbigncmVzaXplJywgd2luZG93LCB0aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgRXZlbnRzLmVtaXQoJ3Jlc2l6ZScpO1xuICAgICAgICB9LCBHbGlkZS5zZXR0aW5ncy50aHJvdHRsZSkpO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFVuYmluZHMgbGlzdGVuZXJzIGZyb20gdGhlIHdpbmRvdy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgICAgQmluZGVyLm9mZigncmVzaXplJywgd2luZG93KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGJpbmRpbmdzIGZyb20gd2luZG93OlxuICAgICAqIC0gb24gZGVzdHJveWluZywgdG8gcmVtb3ZlIGFkZGVkIEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBFdmVudHMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICBSZXNpemUudW5iaW5kKCk7XG4gICAgICBCaW5kZXIuZGVzdHJveSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFJlc2l6ZTtcbiAgfVxuXG4gIHZhciBWQUxJRF9ESVJFQ1RJT05TID0gWydsdHInLCAncnRsJ107XG4gIHZhciBGTElQRURfTU9WRU1FTlRTID0ge1xuICAgICc+JzogJzwnLFxuICAgICc8JzogJz4nLFxuICAgICc9JzogJz0nXG4gIH07XG5cbiAgZnVuY3Rpb24gRGlyZWN0aW9uIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gICAgdmFyIERpcmVjdGlvbiA9IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0dXBzIGdhcCB2YWx1ZSBiYXNlZCBvbiBzZXR0aW5ncy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBHbGlkZS5zZXR0aW5ncy5kaXJlY3Rpb247XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVzb2x2ZXMgcGF0dGVybiBiYXNlZCBvbiBkaXJlY3Rpb24gdmFsdWVcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVyblxuICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAqL1xuICAgICAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShwYXR0ZXJuKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHBhdHRlcm4uc2xpY2UoMCwgMSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXMoJ3J0bCcpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQodG9rZW4pLmpvaW4oRkxJUEVEX01PVkVNRU5UU1t0b2tlbl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2tzIHZhbHVlIG9mIGRpcmVjdGlvbiBtb2RlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb25cbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICBpczogZnVuY3Rpb24gaXMoZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBkaXJlY3Rpb247XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogQXBwbGllcyBkaXJlY3Rpb24gY2xhc3MgdG8gdGhlIHJvb3QgSFRNTCBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcygpIHtcbiAgICAgICAgQ29tcG9uZW50cy5IdG1sLnJvb3QuY2xhc3NMaXN0LmFkZChHbGlkZS5zZXR0aW5ncy5jbGFzc2VzLmRpcmVjdGlvblt0aGlzLnZhbHVlXSk7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBkaXJlY3Rpb24gY2xhc3MgZnJvbSB0aGUgcm9vdCBIVE1MIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKCkge1xuICAgICAgICBDb21wb25lbnRzLkh0bWwucm9vdC5jbGFzc0xpc3QucmVtb3ZlKEdsaWRlLnNldHRpbmdzLmNsYXNzZXMuZGlyZWN0aW9uW3RoaXMudmFsdWVdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZGVmaW5lKERpcmVjdGlvbiwgJ3ZhbHVlJywge1xuICAgICAgLyoqXG4gICAgICAgKiBHZXRzIHZhbHVlIG9mIHRoZSBkaXJlY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEaXJlY3Rpb24uX3Y7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyB2YWx1ZSBvZiB0aGUgZGlyZWN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKFZBTElEX0RJUkVDVElPTlMuaW5kZXhPZih2YWx1ZSkgPiAtMSkge1xuICAgICAgICAgIERpcmVjdGlvbi5fdiA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oJ0RpcmVjdGlvbiB2YWx1ZSBtdXN0IGJlIGBsdHJgIG9yIGBydGxgJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIGRpcmVjdGlvbiBjbGFzczpcbiAgICAgKiAtIG9uIGRlc3Ryb3kgdG8gYnJpbmcgSFRNTCB0byBpdHMgaW5pdGlhbCBzdGF0ZVxuICAgICAqIC0gb24gdXBkYXRlIHRvIHJlbW92ZSBjbGFzcyBiZWZvcmUgcmVhcHBsaW5nIGJlbGxvd1xuICAgICAqL1xuICAgIEV2ZW50cy5vbihbJ2Rlc3Ryb3knLCAndXBkYXRlJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIERpcmVjdGlvbi5yZW1vdmVDbGFzcygpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3VudCBjb21wb25lbnQ6XG4gICAgICogLSBvbiB1cGRhdGUgdG8gcmVmbGVjdCBjaGFuZ2VzIGluIGRpcmVjdGlvbiB2YWx1ZVxuICAgICAqL1xuICAgIEV2ZW50cy5vbigndXBkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgRGlyZWN0aW9uLm1vdW50KCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBkaXJlY3Rpb24gY2xhc3M6XG4gICAgICogLSBiZWZvcmUgYnVpbGRpbmcgdG8gYXBwbHkgY2xhc3MgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICogLSBvbiB1cGRhdGluZyB0byByZWFwcGx5IGRpcmVjdGlvbiBjbGFzcyB0aGF0IG1heSBjaGFuZ2VkXG4gICAgICovXG4gICAgRXZlbnRzLm9uKFsnYnVpbGQuYmVmb3JlJywgJ3VwZGF0ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgICBEaXJlY3Rpb24uYWRkQ2xhc3MoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBEaXJlY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVmbGVjdHMgdmFsdWUgb2YgZ2xpZGUgbW92ZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gR2xpZGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBDb21wb25lbnRzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIFJ0bCAoR2xpZGUsIENvbXBvbmVudHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBOZWdhdGVzIHRoZSBwYXNzZWQgdHJhbnNsYXRlIGlmIGdsaWRlIGlzIGluIFJUTCBvcHRpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtICB7TnVtYmVyfSB0cmFuc2xhdGVcbiAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgbW9kaWZ5OiBmdW5jdGlvbiBtb2RpZnkodHJhbnNsYXRlKSB7XG4gICAgICAgIGlmIChDb21wb25lbnRzLkRpcmVjdGlvbi5pcygncnRsJykpIHtcbiAgICAgICAgICByZXR1cm4gLXRyYW5zbGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFuc2xhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGdsaWRlIG1vdmVtZW50IHdpdGggYSBgZ2FwYCBzZXR0aW5ncy5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBHbGlkZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IENvbXBvbmVudHNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZnVuY3Rpb24gR2FwIChHbGlkZSwgQ29tcG9uZW50cykge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIE1vZGlmaWVzIHBhc3NlZCB0cmFuc2xhdGUgdmFsdWUgd2l0aCBudW1iZXIgaW4gdGhlIGBnYXBgIHNldHRpbmdzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSAge051bWJlcn0gdHJhbnNsYXRlXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIG1vZGlmeTogZnVuY3Rpb24gbW9kaWZ5KHRyYW5zbGF0ZSkge1xuICAgICAgICByZXR1cm4gdHJhbnNsYXRlICsgQ29tcG9uZW50cy5HYXBzLnZhbHVlICogR2xpZGUuaW5kZXg7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGdsaWRlIG1vdmVtZW50IHdpdGggd2lkdGggb2YgYWRkaXRpb25hbCBjbG9uZXMgd2lkdGguXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gR2xpZGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBDb21wb25lbnRzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIEdyb3cgKEdsaWRlLCBDb21wb25lbnRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogQWRkcyB0byB0aGUgcGFzc2VkIHRyYW5zbGF0ZSB3aWR0aCBvZiB0aGUgaGFsZiBvZiBjbG9uZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtICB7TnVtYmVyfSB0cmFuc2xhdGVcbiAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgbW9kaWZ5OiBmdW5jdGlvbiBtb2RpZnkodHJhbnNsYXRlKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2xhdGUgKyBDb21wb25lbnRzLkNsb25lcy5ncm93IC8gMjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgZ2xpZGUgbW92ZW1lbnQgd2l0aCBhIGBwZWVrYCBzZXR0aW5ncy5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBHbGlkZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IENvbXBvbmVudHNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZnVuY3Rpb24gUGVla2luZyAoR2xpZGUsIENvbXBvbmVudHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBNb2RpZmllcyBwYXNzZWQgdHJhbnNsYXRlIHZhbHVlIHdpdGggYSBgcGVla2Agc2V0dGluZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRyYW5zbGF0ZVxuICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBtb2RpZnk6IGZ1bmN0aW9uIG1vZGlmeSh0cmFuc2xhdGUpIHtcbiAgICAgICAgaWYgKEdsaWRlLnNldHRpbmdzLmZvY3VzQXQgPj0gMCkge1xuICAgICAgICAgIHZhciBwZWVrID0gQ29tcG9uZW50cy5QZWVrLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHBlZWspKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRlIC0gcGVlay5iZWZvcmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZSAtIHBlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJhbnNsYXRlO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBnbGlkZSBtb3ZlbWVudCB3aXRoIGEgYGZvY3VzQXRgIHNldHRpbmdzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IEdsaWRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gQ29tcG9uZW50c1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiBGb2N1c2luZyAoR2xpZGUsIENvbXBvbmVudHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBNb2RpZmllcyBwYXNzZWQgdHJhbnNsYXRlIHZhbHVlIHdpdGggaW5kZXggaW4gdGhlIGBmb2N1c0F0YCBzZXR0aW5nLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSAge051bWJlcn0gdHJhbnNsYXRlXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIG1vZGlmeTogZnVuY3Rpb24gbW9kaWZ5KHRyYW5zbGF0ZSkge1xuICAgICAgICB2YXIgZ2FwID0gQ29tcG9uZW50cy5HYXBzLnZhbHVlO1xuICAgICAgICB2YXIgd2lkdGggPSBDb21wb25lbnRzLlNpemVzLndpZHRoO1xuICAgICAgICB2YXIgZm9jdXNBdCA9IEdsaWRlLnNldHRpbmdzLmZvY3VzQXQ7XG4gICAgICAgIHZhciBzbGlkZVdpZHRoID0gQ29tcG9uZW50cy5TaXplcy5zbGlkZVdpZHRoO1xuXG4gICAgICAgIGlmIChmb2N1c0F0ID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHJldHVybiB0cmFuc2xhdGUgLSAod2lkdGggLyAyIC0gc2xpZGVXaWR0aCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZSAtIHNsaWRlV2lkdGggKiBmb2N1c0F0IC0gZ2FwICogZm9jdXNBdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgZGlmZnJlbnQgdHJhbnNmb3JtZXJzIG9uIHRyYW5zbGF0ZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBHbGlkZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IENvbXBvbmVudHNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZnVuY3Rpb24gbXV0YXRvciAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICAgIC8qKlxuICAgICAqIE1lcmdlIGluc3RhbmNlIHRyYW5zZm9ybWVycyB3aXRoIGNvbGxlY3Rpb24gb2YgZGVmYXVsdCB0cmFuc2Zvcm1lcnMuXG4gICAgICogSXQncyBpbXBvcnRhbnQgdGhhdCB0aGUgUnRsIGNvbXBvbmVudCBiZSBsYXN0IG9uIHRoZSBsaXN0LFxuICAgICAqIHNvIGl0IHJlZmxlY3RzIGFsbCBwcmV2aW91cyB0cmFuc2Zvcm1hdGlvbnMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdmFyIFRSQU5TRk9STUVSUyA9IFtHYXAsIEdyb3csIFBlZWtpbmcsIEZvY3VzaW5nXS5jb25jYXQoR2xpZGUuX3QsIFtSdGxdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIFBpcGxpbmVzIHRyYW5zbGF0ZSB2YWx1ZSB3aXRoIHJlZ2lzdGVyZWQgdHJhbnNmb3JtZXJzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSAge051bWJlcn0gdHJhbnNsYXRlXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKHRyYW5zbGF0ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFRSQU5TRk9STUVSUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm1lciA9IFRSQU5TRk9STUVSU1tpXTtcblxuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRyYW5zZm9ybWVyKSAmJiBpc0Z1bmN0aW9uKHRyYW5zZm9ybWVyKCkubW9kaWZ5KSkge1xuICAgICAgICAgICAgdHJhbnNsYXRlID0gdHJhbnNmb3JtZXIoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykubW9kaWZ5KHRyYW5zbGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4oJ1RyYW5zZm9ybWVyIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgbW9kaWZ5KClgIG1ldGhvZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFuc2xhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFRyYW5zbGF0ZSAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICAgIHZhciBUcmFuc2xhdGUgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFNldHMgdmFsdWUgb2YgdHJhbnNsYXRlIG9uIEhUTUwgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBtdXRhdG9yKEdsaWRlLCBDb21wb25lbnRzKS5tdXRhdGUodmFsdWUpO1xuXG4gICAgICAgIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgLTEgKiB0cmFuc2Zvcm0gKyAncHgsIDBweCwgMHB4KSc7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyB2YWx1ZSBvZiB0cmFuc2xhdGUgZnJvbSBIVE1MIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgbmV3IHRyYW5zbGF0ZSB2YWx1ZTpcbiAgICAgKiAtIG9uIG1vdmUgdG8gcmVmbGVjdCBpbmRleCBjaGFuZ2VcbiAgICAgKiAtIG9uIHVwZGF0aW5nIHZpYSBBUEkgdG8gcmVmbGVjdCBwb3NzaWJsZSBjaGFuZ2VzIGluIG9wdGlvbnNcbiAgICAgKi9cbiAgICBFdmVudHMub24oJ21vdmUnLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgdmFyIGdhcCA9IENvbXBvbmVudHMuR2Fwcy52YWx1ZTtcbiAgICAgIHZhciBsZW5ndGggPSBDb21wb25lbnRzLlNpemVzLmxlbmd0aDtcbiAgICAgIHZhciB3aWR0aCA9IENvbXBvbmVudHMuU2l6ZXMuc2xpZGVXaWR0aDtcblxuICAgICAgaWYgKEdsaWRlLmlzVHlwZSgnY2Fyb3VzZWwnKSAmJiBDb21wb25lbnRzLlJ1bi5pc09mZnNldCgnPCcpKSB7XG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNpdGlvbi5hZnRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgRXZlbnRzLmVtaXQoJ3RyYW5zbGF0ZS5qdW1wJyk7XG5cbiAgICAgICAgICBUcmFuc2xhdGUuc2V0KHdpZHRoICogKGxlbmd0aCAtIDEpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFRyYW5zbGF0ZS5zZXQoLXdpZHRoIC0gZ2FwICogbGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEdsaWRlLmlzVHlwZSgnY2Fyb3VzZWwnKSAmJiBDb21wb25lbnRzLlJ1bi5pc09mZnNldCgnPicpKSB7XG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNpdGlvbi5hZnRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgRXZlbnRzLmVtaXQoJ3RyYW5zbGF0ZS5qdW1wJyk7XG5cbiAgICAgICAgICBUcmFuc2xhdGUuc2V0KDApO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gVHJhbnNsYXRlLnNldCh3aWR0aCAqIGxlbmd0aCArIGdhcCAqIGxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBUcmFuc2xhdGUuc2V0KGNvbnRleHQubW92ZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRyYW5zbGF0ZTpcbiAgICAgKiAtIG9uIGRlc3Ryb3lpbmcgdG8gYnJpbmcgbWFya3VwIHRvIGl0cyBpbml0YWwgc3RhdGVcbiAgICAgKi9cbiAgICBFdmVudHMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICBUcmFuc2xhdGUucmVtb3ZlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gVHJhbnNsYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gVHJhbnNpdGlvbiAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICAgIC8qKlxuICAgICAqIEhvbGRzIGluYWN0aXZpdHkgc3RhdHVzIG9mIHRyYW5zaXRpb24uXG4gICAgICogV2hlbiB0cnVlIHRyYW5zaXRpb24gaXMgbm90IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIHZhciBUcmFuc2l0aW9uID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBDb21wb3NlcyBzdHJpbmcgb2YgdGhlIENTUyB0cmFuc2l0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBjb21wb3NlOiBmdW5jdGlvbiBjb21wb3NlKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IEdsaWRlLnNldHRpbmdzO1xuXG4gICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcGVydHkgKyAnICcgKyB0aGlzLmR1cmF0aW9uICsgJ21zICcgKyBzZXR0aW5ncy5hbmltYXRpb25UaW1pbmdGdW5jO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3BlcnR5ICsgJyAwbXMgJyArIHNldHRpbmdzLmFuaW1hdGlvblRpbWluZ0Z1bmM7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyB2YWx1ZSBvZiB0cmFuc2l0aW9uIG9uIEhUTUwgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZz19IHByb3BlcnR5XG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAndHJhbnNmb3JtJztcblxuICAgICAgICBDb21wb25lbnRzLkh0bWwud3JhcHBlci5zdHlsZS50cmFuc2l0aW9uID0gdGhpcy5jb21wb3NlKHByb3BlcnR5KTtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIHZhbHVlIG9mIHRyYW5zaXRpb24gZnJvbSBIVE1MIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBSdW5zIGNhbGxiYWNrIGFmdGVyIGFuaW1hdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGFmdGVyOiBmdW5jdGlvbiBhZnRlcihjYWxsYmFjaykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9LCB0aGlzLmR1cmF0aW9uKTtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBFbmFibGUgdHJhbnNpdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnNldCgpO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIERpc2FibGUgdHJhbnNpdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5zZXQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZGVmaW5lKFRyYW5zaXRpb24sICdkdXJhdGlvbicsIHtcbiAgICAgIC8qKlxuICAgICAgICogR2V0cyBkdXJhdGlvbiBvZiB0aGUgdHJhbnNpdGlvbiBiYXNlZFxuICAgICAgICogb24gY3VycmVudGx5IHJ1bm5pbmcgYW5pbWF0aW9uIHR5cGUuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gR2xpZGUuc2V0dGluZ3M7XG5cbiAgICAgICAgaWYgKEdsaWRlLmlzVHlwZSgnc2xpZGVyJykgJiYgQ29tcG9uZW50cy5SdW4ub2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRpbmdzLnJld2luZER1cmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLmFuaW1hdGlvbkR1cmF0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRyYW5zaXRpb24gYHN0eWxlYCB2YWx1ZTpcbiAgICAgKiAtIG9uIGVhY2ggbW92aW5nLCBiZWNhdXNlIGl0IG1heSBiZSBjbGVhcmVkIGJ5IG9mZnNldCBtb3ZlXG4gICAgICovXG4gICAgRXZlbnRzLm9uKCdtb3ZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgVHJhbnNpdGlvbi5zZXQoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdHJhbnNpdGlvbjpcbiAgICAgKiAtIGJlZm9yZSBpbml0aWFsIGJ1aWxkIHRvIGF2b2lkIHRyYW5zaXRpb25pbmcgZnJvbSBgMGAgdG8gYHN0YXJ0QXRgIGluZGV4XG4gICAgICogLSB3aGlsZSByZXNpemluZyB3aW5kb3cgYW5kIHJlY2FsY3VsYXRpbmcgZGltZW50aW9uc1xuICAgICAqIC0gb24ganVtcGluZyBmcm9tIG9mZnNldCB0cmFuc2l0aW9uIGF0IHN0YXJ0IGFuZCBlbmQgZWRnZXMgaW4gYGNhcm91c2VsYCB0eXBlXG4gICAgICovXG4gICAgRXZlbnRzLm9uKFsnYnVpbGQuYmVmb3JlJywgJ3Jlc2l6ZScsICd0cmFuc2xhdGUuanVtcCddLCBmdW5jdGlvbiAoKSB7XG4gICAgICBUcmFuc2l0aW9uLmRpc2FibGUoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0cmFuc2l0aW9uOlxuICAgICAqIC0gb24gZWFjaCBydW5uaW5nLCBiZWNhdXNlIGl0IG1heSBiZSBkaXNhYmxlZCBieSBvZmZzZXQgbW92ZVxuICAgICAqL1xuICAgIEV2ZW50cy5vbigncnVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgVHJhbnNpdGlvbi5lbmFibGUoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0cmFuc2l0aW9uOlxuICAgICAqIC0gb24gZGVzdHJveWluZyB0byBicmluZyBtYXJrdXAgdG8gaXRzIGluaXRhbCBzdGF0ZVxuICAgICAqL1xuICAgIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFRyYW5zaXRpb24ucmVtb3ZlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gVHJhbnNpdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IHZpYSBhIGdldHRlciBpbiB0aGUgb3B0aW9ucyBvYmplY3QgdG8gc2VlXG4gICAqIGlmIHRoZSBwYXNzaXZlIHByb3BlcnR5IGlzIGFjY2Vzc2VkLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0V2ZW50TGlzdGVuZXJPcHRpb25zL2Jsb2IvZ2gtcGFnZXMvZXhwbGFpbmVyLm1kI2ZlYXR1cmUtZGV0ZWN0aW9uXG4gICAqL1xuXG4gIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHN1cHBvcnRzUGFzc2l2ZSQxID0gc3VwcG9ydHNQYXNzaXZlO1xuXG4gIHZhciBTVEFSVF9FVkVOVFMgPSBbJ3RvdWNoc3RhcnQnLCAnbW91c2Vkb3duJ107XG4gIHZhciBNT1ZFX0VWRU5UUyA9IFsndG91Y2htb3ZlJywgJ21vdXNlbW92ZSddO1xuICB2YXIgRU5EX0VWRU5UUyA9IFsndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnLCAnbW91c2V1cCcsICdtb3VzZWxlYXZlJ107XG4gIHZhciBNT1VTRV9FVkVOVFMgPSBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcsICdtb3VzZWxlYXZlJ107XG5cbiAgZnVuY3Rpb24gU3dpcGUgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW5jZSBvZiB0aGUgYmluZGVyIGZvciBET00gRXZlbnRzLlxuICAgICAqXG4gICAgICogQHR5cGUge0V2ZW50c0JpbmRlcn1cbiAgICAgKi9cbiAgICB2YXIgQmluZGVyID0gbmV3IEV2ZW50c0JpbmRlcigpO1xuXG4gICAgdmFyIHN3aXBlU2luID0gMDtcbiAgICB2YXIgc3dpcGVTdGFydFggPSAwO1xuICAgIHZhciBzd2lwZVN0YXJ0WSA9IDA7XG4gICAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG4gICAgdmFyIGNhcHR1cmUgPSBzdXBwb3J0c1Bhc3NpdmUkMSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogZmFsc2U7XG5cbiAgICB2YXIgU3dpcGUgPSB7XG4gICAgICAvKipcbiAgICAgICAqIEluaXRpYWxpemVzIHN3aXBlIGJpbmRpbmdzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgICAgdGhpcy5iaW5kU3dpcGVTdGFydCgpO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZXIgZm9yIGBzd2lwZXN0YXJ0YCBldmVudC4gQ2FsY3VsYXRlcyBlbnRyeSBwb2ludHMgb2YgdGhlIHVzZXIncyB0YXAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFkaXNhYmxlZCAmJiAhR2xpZGUuZGlzYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLmRpc2FibGUoKTtcblxuICAgICAgICAgIHZhciBzd2lwZSA9IHRoaXMudG91Y2hlcyhldmVudCk7XG5cbiAgICAgICAgICBzd2lwZVNpbiA9IG51bGw7XG4gICAgICAgICAgc3dpcGVTdGFydFggPSB0b0ludChzd2lwZS5wYWdlWCk7XG4gICAgICAgICAgc3dpcGVTdGFydFkgPSB0b0ludChzd2lwZS5wYWdlWSk7XG5cbiAgICAgICAgICB0aGlzLmJpbmRTd2lwZU1vdmUoKTtcbiAgICAgICAgICB0aGlzLmJpbmRTd2lwZUVuZCgpO1xuXG4gICAgICAgICAgRXZlbnRzLmVtaXQoJ3N3aXBlLnN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGVyIGZvciBgc3dpcGVtb3ZlYCBldmVudC4gQ2FsY3VsYXRlcyB1c2VyJ3MgdGFwIGFuZ2xlIGFuZCBkaXN0YW5jZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgbW92ZTogZnVuY3Rpb24gbW92ZShldmVudCkge1xuICAgICAgICBpZiAoIUdsaWRlLmRpc2FibGVkKSB7XG4gICAgICAgICAgdmFyIF9HbGlkZSRzZXR0aW5ncyA9IEdsaWRlLnNldHRpbmdzLFxuICAgICAgICAgICAgICB0b3VjaEFuZ2xlID0gX0dsaWRlJHNldHRpbmdzLnRvdWNoQW5nbGUsXG4gICAgICAgICAgICAgIHRvdWNoUmF0aW8gPSBfR2xpZGUkc2V0dGluZ3MudG91Y2hSYXRpbyxcbiAgICAgICAgICAgICAgY2xhc3NlcyA9IF9HbGlkZSRzZXR0aW5ncy5jbGFzc2VzO1xuXG5cbiAgICAgICAgICB2YXIgc3dpcGUgPSB0aGlzLnRvdWNoZXMoZXZlbnQpO1xuXG4gICAgICAgICAgdmFyIHN1YkV4U3ggPSB0b0ludChzd2lwZS5wYWdlWCkgLSBzd2lwZVN0YXJ0WDtcbiAgICAgICAgICB2YXIgc3ViRXlTeSA9IHRvSW50KHN3aXBlLnBhZ2VZKSAtIHN3aXBlU3RhcnRZO1xuICAgICAgICAgIHZhciBwb3dFWCA9IE1hdGguYWJzKHN1YkV4U3ggPDwgMik7XG4gICAgICAgICAgdmFyIHBvd0VZID0gTWF0aC5hYnMoc3ViRXlTeSA8PCAyKTtcbiAgICAgICAgICB2YXIgc3dpcGVIeXBvdGVudXNlID0gTWF0aC5zcXJ0KHBvd0VYICsgcG93RVkpO1xuICAgICAgICAgIHZhciBzd2lwZUNhdGhldHVzID0gTWF0aC5zcXJ0KHBvd0VZKTtcblxuICAgICAgICAgIHN3aXBlU2luID0gTWF0aC5hc2luKHN3aXBlQ2F0aGV0dXMgLyBzd2lwZUh5cG90ZW51c2UpO1xuXG4gICAgICAgICAgaWYgKHN3aXBlU2luICogMTgwIC8gTWF0aC5QSSA8IHRvdWNoQW5nbGUpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICBDb21wb25lbnRzLk1vdmUubWFrZShzdWJFeFN4ICogdG9GbG9hdCh0b3VjaFJhdGlvKSk7XG5cbiAgICAgICAgICAgIENvbXBvbmVudHMuSHRtbC5yb290LmNsYXNzTGlzdC5hZGQoY2xhc3Nlcy5kcmFnZ2luZyk7XG5cbiAgICAgICAgICAgIEV2ZW50cy5lbWl0KCdzd2lwZS5tb3ZlJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGVyIGZvciBgc3dpcGVlbmRgIGV2ZW50LiBGaW5pdGlhbGl6ZXMgdXNlcidzIHRhcCBhbmQgZGVjaWRlcyBhYm91dCBnbGlkZSBtb3ZlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgZW5kOiBmdW5jdGlvbiBlbmQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFHbGlkZS5kaXNhYmxlZCkge1xuICAgICAgICAgIHZhciBzZXR0aW5ncyA9IEdsaWRlLnNldHRpbmdzO1xuXG4gICAgICAgICAgdmFyIHN3aXBlID0gdGhpcy50b3VjaGVzKGV2ZW50KTtcbiAgICAgICAgICB2YXIgdGhyZXNob2xkID0gdGhpcy50aHJlc2hvbGQoZXZlbnQpO1xuXG4gICAgICAgICAgdmFyIHN3aXBlRGlzdGFuY2UgPSBzd2lwZS5wYWdlWCAtIHN3aXBlU3RhcnRYO1xuICAgICAgICAgIHZhciBzd2lwZURlZyA9IHN3aXBlU2luICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgICB2YXIgc3RlcHMgPSBNYXRoLnJvdW5kKHN3aXBlRGlzdGFuY2UgLyBDb21wb25lbnRzLlNpemVzLnNsaWRlV2lkdGgpO1xuXG4gICAgICAgICAgdGhpcy5lbmFibGUoKTtcblxuICAgICAgICAgIGlmIChzd2lwZURpc3RhbmNlID4gdGhyZXNob2xkICYmIHN3aXBlRGVnIDwgc2V0dGluZ3MudG91Y2hBbmdsZSkge1xuICAgICAgICAgICAgLy8gV2hpbGUgc3dpcGUgaXMgcG9zaXRpdmUgYW5kIGdyZWF0ZXIgdGhhbiB0aHJlc2hvbGQgbW92ZSBiYWNrd2FyZC5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5wZXJUb3VjaCkge1xuICAgICAgICAgICAgICBzdGVwcyA9IE1hdGgubWluKHN0ZXBzLCB0b0ludChzZXR0aW5ncy5wZXJUb3VjaCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoQ29tcG9uZW50cy5EaXJlY3Rpb24uaXMoJ3J0bCcpKSB7XG4gICAgICAgICAgICAgIHN0ZXBzID0gLXN0ZXBzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBDb21wb25lbnRzLlJ1bi5tYWtlKENvbXBvbmVudHMuRGlyZWN0aW9uLnJlc29sdmUoJzwnICsgc3RlcHMpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN3aXBlRGlzdGFuY2UgPCAtdGhyZXNob2xkICYmIHN3aXBlRGVnIDwgc2V0dGluZ3MudG91Y2hBbmdsZSkge1xuICAgICAgICAgICAgLy8gV2hpbGUgc3dpcGUgaXMgbmVnYXRpdmUgYW5kIGxvd2VyIHRoYW4gbmVnYXRpdmUgdGhyZXNob2xkIG1vdmUgZm9yd2FyZC5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5wZXJUb3VjaCkge1xuICAgICAgICAgICAgICBzdGVwcyA9IE1hdGgubWF4KHN0ZXBzLCAtdG9JbnQoc2V0dGluZ3MucGVyVG91Y2gpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKENvbXBvbmVudHMuRGlyZWN0aW9uLmlzKCdydGwnKSkge1xuICAgICAgICAgICAgICBzdGVwcyA9IC1zdGVwcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQ29tcG9uZW50cy5SdW4ubWFrZShDb21wb25lbnRzLkRpcmVjdGlvbi5yZXNvbHZlKCc+JyArIHN0ZXBzKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoaWxlIHN3aXBlIGRvbid0IHJlYWNoIGRpc3RhbmNlIGFwcGx5IHByZXZpb3VzIHRyYW5zZm9ybS5cbiAgICAgICAgICAgIENvbXBvbmVudHMuTW92ZS5tYWtlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQ29tcG9uZW50cy5IdG1sLnJvb3QuY2xhc3NMaXN0LnJlbW92ZShzZXR0aW5ncy5jbGFzc2VzLmRyYWdnaW5nKTtcblxuICAgICAgICAgIHRoaXMudW5iaW5kU3dpcGVNb3ZlKCk7XG4gICAgICAgICAgdGhpcy51bmJpbmRTd2lwZUVuZCgpO1xuXG4gICAgICAgICAgRXZlbnRzLmVtaXQoJ3N3aXBlLmVuZCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogQmluZHMgc3dpcGUncyBzdGFydGluZyBldmVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBiaW5kU3dpcGVTdGFydDogZnVuY3Rpb24gYmluZFN3aXBlU3RhcnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHNldHRpbmdzID0gR2xpZGUuc2V0dGluZ3M7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLnN3aXBlVGhyZXNob2xkKSB7XG4gICAgICAgICAgQmluZGVyLm9uKFNUQVJUX0VWRU5UU1swXSwgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMuc3RhcnQoZXZlbnQpO1xuICAgICAgICAgIH0sIGNhcHR1cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmRyYWdUaHJlc2hvbGQpIHtcbiAgICAgICAgICBCaW5kZXIub24oU1RBUlRfRVZFTlRTWzFdLCBDb21wb25lbnRzLkh0bWwud3JhcHBlciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5zdGFydChldmVudCk7XG4gICAgICAgICAgfSwgY2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBVbmJpbmRzIHN3aXBlJ3Mgc3RhcnRpbmcgZXZlbnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgdW5iaW5kU3dpcGVTdGFydDogZnVuY3Rpb24gdW5iaW5kU3dpcGVTdGFydCgpIHtcbiAgICAgICAgQmluZGVyLm9mZihTVEFSVF9FVkVOVFNbMF0sIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLCBjYXB0dXJlKTtcbiAgICAgICAgQmluZGVyLm9mZihTVEFSVF9FVkVOVFNbMV0sIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLCBjYXB0dXJlKTtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBCaW5kcyBzd2lwZSdzIG1vdmluZyBldmVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBiaW5kU3dpcGVNb3ZlOiBmdW5jdGlvbiBiaW5kU3dpcGVNb3ZlKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBCaW5kZXIub24oTU9WRV9FVkVOVFMsIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLCB0aHJvdHRsZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBfdGhpczIubW92ZShldmVudCk7XG4gICAgICAgIH0sIEdsaWRlLnNldHRpbmdzLnRocm90dGxlKSwgY2FwdHVyZSk7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVW5iaW5kcyBzd2lwZSdzIG1vdmluZyBldmVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICB1bmJpbmRTd2lwZU1vdmU6IGZ1bmN0aW9uIHVuYmluZFN3aXBlTW92ZSgpIHtcbiAgICAgICAgQmluZGVyLm9mZihNT1ZFX0VWRU5UUywgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIsIGNhcHR1cmUpO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEJpbmRzIHN3aXBlJ3MgZW5kaW5nIGV2ZW50LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGJpbmRTd2lwZUVuZDogZnVuY3Rpb24gYmluZFN3aXBlRW5kKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBCaW5kZXIub24oRU5EX0VWRU5UUywgQ29tcG9uZW50cy5IdG1sLndyYXBwZXIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzMy5lbmQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBVbmJpbmRzIHN3aXBlJ3MgZW5kaW5nIGV2ZW50LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIHVuYmluZFN3aXBlRW5kOiBmdW5jdGlvbiB1bmJpbmRTd2lwZUVuZCgpIHtcbiAgICAgICAgQmluZGVyLm9mZihFTkRfRVZFTlRTLCBDb21wb25lbnRzLkh0bWwud3JhcHBlcik7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogTm9ybWFsaXplcyBldmVudCB0b3VjaGVzIHBvaW50cyBhY2NvcnRpbmcgdG8gZGlmZmVyZW50IHR5cGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICovXG4gICAgICB0b3VjaGVzOiBmdW5jdGlvbiB0b3VjaGVzKGV2ZW50KSB7XG4gICAgICAgIGlmIChNT1VTRV9FVkVOVFMuaW5kZXhPZihldmVudC50eXBlKSA+IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50LnRvdWNoZXNbMF0gfHwgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyB2YWx1ZSBvZiBtaW5pbXVtIHN3aXBlIGRpc3RhbmNlIHNldHRpbmdzIGJhc2VkIG9uIGV2ZW50IHR5cGUuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICB0aHJlc2hvbGQ6IGZ1bmN0aW9uIHRocmVzaG9sZChldmVudCkge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBHbGlkZS5zZXR0aW5ncztcblxuICAgICAgICBpZiAoTU9VU0VfRVZFTlRTLmluZGV4T2YoZXZlbnQudHlwZSkgPiAtMSkge1xuICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5kcmFnVGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLnN3aXBlVGhyZXNob2xkO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEVuYWJsZXMgc3dpcGUgZXZlbnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7c2VsZn1cbiAgICAgICAqL1xuICAgICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICAgIGRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2l0aW9uLmVuYWJsZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIERpc2FibGVzIHN3aXBlIGV2ZW50LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge3NlbGZ9XG4gICAgICAgKi9cbiAgICAgIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcblxuICAgICAgICBDb21wb25lbnRzLlRyYW5zaXRpb24uZGlzYWJsZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29tcG9uZW50IGNsYXNzOlxuICAgICAqIC0gYWZ0ZXIgaW5pdGlhbCBidWlsZGluZ1xuICAgICAqL1xuICAgIEV2ZW50cy5vbignYnVpbGQuYWZ0ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICBDb21wb25lbnRzLkh0bWwucm9vdC5jbGFzc0xpc3QuYWRkKEdsaWRlLnNldHRpbmdzLmNsYXNzZXMuc3dpcGVhYmxlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBzd2lwaW5nIGJpbmRpbmdzOlxuICAgICAqIC0gb24gZGVzdHJveWluZywgdG8gcmVtb3ZlIGFkZGVkIEV2ZW50TGlzdGVuZXJzXG4gICAgICovXG4gICAgRXZlbnRzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgU3dpcGUudW5iaW5kU3dpcGVTdGFydCgpO1xuICAgICAgU3dpcGUudW5iaW5kU3dpcGVNb3ZlKCk7XG4gICAgICBTd2lwZS51bmJpbmRTd2lwZUVuZCgpO1xuICAgICAgQmluZGVyLmRlc3Ryb3koKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBTd2lwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEltYWdlcyAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICAgIC8qKlxuICAgICAqIEluc3RhbmNlIG9mIHRoZSBiaW5kZXIgZm9yIERPTSBFdmVudHMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RXZlbnRzQmluZGVyfVxuICAgICAqL1xuICAgIHZhciBCaW5kZXIgPSBuZXcgRXZlbnRzQmluZGVyKCk7XG5cbiAgICB2YXIgSW1hZ2VzID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBCaW5kcyBsaXN0ZW5lciB0byBnbGlkZSB3cmFwcGVyLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogQmluZHMgYGRyYWdzdGFydGAgZXZlbnQgb24gd3JhcHBlciB0byBwcmV2ZW50IGRyYWdnaW5nIGltYWdlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgICBCaW5kZXIub24oJ2RyYWdzdGFydCcsIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLCB0aGlzLmRyYWdzdGFydCk7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVW5iaW5kcyBgZHJhZ3N0YXJ0YCBldmVudCBvbiB3cmFwcGVyLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgICAgICBCaW5kZXIub2ZmKCdkcmFnc3RhcnQnLCBDb21wb25lbnRzLkh0bWwud3JhcHBlcik7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogRXZlbnQgaGFuZGxlci4gUHJldmVudHMgZHJhZ2dpbmcuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgZHJhZ3N0YXJ0OiBmdW5jdGlvbiBkcmFnc3RhcnQoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGJpbmRpbmdzIGZyb20gaW1hZ2VzOlxuICAgICAqIC0gb24gZGVzdHJveWluZywgdG8gcmVtb3ZlIGFkZGVkIEV2ZW50TGlzdGVuZXJzXG4gICAgICovXG4gICAgRXZlbnRzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgSW1hZ2VzLnVuYmluZCgpO1xuICAgICAgQmluZGVyLmRlc3Ryb3koKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBJbWFnZXM7XG4gIH1cblxuICBmdW5jdGlvbiBBbmNob3JzIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gICAgLyoqXG4gICAgICogSW5zdGFuY2Ugb2YgdGhlIGJpbmRlciBmb3IgRE9NIEV2ZW50cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtFdmVudHNCaW5kZXJ9XG4gICAgICovXG4gICAgdmFyIEJpbmRlciA9IG5ldyBFdmVudHNCaW5kZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIGRldGFjaGluZyBzdGF0dXMgb2YgYW5jaG9ycy5cbiAgICAgKiBQcmV2ZW50cyBkZXRhY2hpbmcgb2YgYWxyZWFkeSBkZXRhY2hlZCBhbmNob3JzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB2YXIgZGV0YWNoZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHByZXZlbnRpbmcgc3RhdHVzIG9mIGFuY2hvcnMuXG4gICAgICogSWYgYHRydWVgIHJlZGlyZWN0aW9uIGFmdGVyIGNsaWNrIHdpbGwgYmUgZGlzYWJsZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHZhciBwcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIHZhciBBbmNob3JzID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXR1cHMgYSBpbml0aWFsIHN0YXRlIG9mIGFuY2hvcnMgY29tcG9uZW50LlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtWb2lkfVxuICAgICAgICovXG4gICAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb2xkcyBjb2xsZWN0aW9uIG9mIGFuY2hvcnMgZWxlbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtIVE1MQ29sbGVjdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2EgPSBDb21wb25lbnRzLkh0bWwud3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCdhJyk7XG5cbiAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogQmluZHMgZXZlbnRzIHRvIGFuY2hvcnMgaW5zaWRlIGEgdHJhY2suXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgICAgQmluZGVyLm9uKCdjbGljaycsIENvbXBvbmVudHMuSHRtbC53cmFwcGVyLCB0aGlzLmNsaWNrKTtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBVbmJpbmRzIGV2ZW50cyBhdHRhY2hlZCB0byBhbmNob3JzIGluc2lkZSBhIHRyYWNrLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgICAgICBCaW5kZXIub2ZmKCdjbGljaycsIENvbXBvbmVudHMuSHRtbC53cmFwcGVyKTtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGVyIGZvciBjbGljayBldmVudC4gUHJldmVudHMgY2xpY2tzIHdoZW4gZ2xpZGUgaXMgaW4gYHByZXZlbnRgIHN0YXR1cy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGV2ZW50XG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soZXZlbnQpIHtcbiAgICAgICAgaWYgKHByZXZlbnRlZCkge1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBEZXRhY2hlcyBhbmNob3JzIGNsaWNrIGV2ZW50IGluc2lkZSBnbGlkZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtzZWxmfVxuICAgICAgICovXG4gICAgICBkZXRhY2g6IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgICAgcHJldmVudGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWRldGFjaGVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldLmRyYWdnYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldLnNldEF0dHJpYnV0ZSgnZGF0YS1ocmVmJywgdGhpcy5pdGVtc1tpXS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSk7XG5cbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0ucmVtb3ZlQXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGV0YWNoZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogQXR0YWNoZXMgYW5jaG9ycyBjbGljayBldmVudHMgaW5zaWRlIGdsaWRlLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge3NlbGZ9XG4gICAgICAgKi9cbiAgICAgIGF0dGFjaDogZnVuY3Rpb24gYXR0YWNoKCkge1xuICAgICAgICBwcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZGV0YWNoZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0uZHJhZ2dhYmxlID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5pdGVtc1tpXS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB0aGlzLml0ZW1zW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1ocmVmJykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRldGFjaGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZGVmaW5lKEFuY2hvcnMsICdpdGVtcycsIHtcbiAgICAgIC8qKlxuICAgICAgICogR2V0cyBjb2xsZWN0aW9uIG9mIHRoZSBhcnJvd3MgSFRNTCBlbGVtZW50cy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudFtdfVxuICAgICAgICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIEFuY2hvcnMuX2E7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggYW5jaG9ycyBpbnNpZGUgc2xpZGVzOlxuICAgICAqIC0gb24gc3dpcGluZywgc28gdGhleSB3b24ndCByZWRpcmVjdCB0byBpdHMgYGhyZWZgIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBFdmVudHMub24oJ3N3aXBlLm1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBBbmNob3JzLmRldGFjaCgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGFuY2hvcnMgaW5zaWRlIHNsaWRlczpcbiAgICAgKiAtIGFmdGVyIHN3aXBpbmcgYW5kIHRyYW5zaXRpb25zIGVuZHMsIHNvIHRoZXkgY2FuIHJlZGlyZWN0IGFmdGVyIGNsaWNrIGFnYWluXG4gICAgICovXG4gICAgRXZlbnRzLm9uKCdzd2lwZS5lbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBDb21wb25lbnRzLlRyYW5zaXRpb24uYWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBBbmNob3JzLmF0dGFjaCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmQgYW5jaG9ycyBpbnNpZGUgc2xpZGVzOlxuICAgICAqIC0gb24gZGVzdHJveWluZywgdG8gYnJpbmcgYW5jaG9ycyB0byBpdHMgaW5pdGlhbCBzdGF0ZVxuICAgICAqL1xuICAgIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIEFuY2hvcnMuYXR0YWNoKCk7XG4gICAgICBBbmNob3JzLnVuYmluZCgpO1xuICAgICAgQmluZGVyLmRlc3Ryb3koKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBBbmNob3JzO1xuICB9XG5cbiAgdmFyIE5BVl9TRUxFQ1RPUiA9ICdbZGF0YS1nbGlkZS1lbD1cImNvbnRyb2xzW25hdl1cIl0nO1xuICB2YXIgQ09OVFJPTFNfU0VMRUNUT1IgPSAnW2RhdGEtZ2xpZGUtZWxePVwiY29udHJvbHNcIl0nO1xuXG4gIGZ1bmN0aW9uIENvbnRyb2xzIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gICAgLyoqXG4gICAgICogSW5zdGFuY2Ugb2YgdGhlIGJpbmRlciBmb3IgRE9NIEV2ZW50cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtFdmVudHNCaW5kZXJ9XG4gICAgICovXG4gICAgdmFyIEJpbmRlciA9IG5ldyBFdmVudHNCaW5kZXIoKTtcblxuICAgIHZhciBjYXB0dXJlID0gc3VwcG9ydHNQYXNzaXZlJDEgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlO1xuXG4gICAgdmFyIENvbnRyb2xzID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBJbml0cyBhcnJvd3MuIEJpbmRzIGV2ZW50cyBsaXN0ZW5lcnNcbiAgICAgICAqIHRvIHRoZSBhcnJvd3MgSFRNTCBlbGVtZW50cy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIG5hdmlnYXRpb24gSFRNTCBlbGVtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0hUTUxDb2xsZWN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbiA9IENvbXBvbmVudHMuSHRtbC5yb290LnF1ZXJ5U2VsZWN0b3JBbGwoTkFWX1NFTEVDVE9SKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiBjb250cm9scyBIVE1MIGVsZW1lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7SFRNTENvbGxlY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jID0gQ29tcG9uZW50cy5IdG1sLnJvb3QucXVlcnlTZWxlY3RvckFsbChDT05UUk9MU19TRUxFQ1RPUik7XG5cbiAgICAgICAgdGhpcy5hZGRCaW5kaW5ncygpO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgYWN0aXZlIGNsYXNzIHRvIGN1cnJlbnQgc2xpZGUuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgc2V0QWN0aXZlOiBmdW5jdGlvbiBzZXRBY3RpdmUoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYWRkQ2xhc3ModGhpcy5fbltpXS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFjdGl2ZSBjbGFzcyB0byBjdXJyZW50IHNsaWRlLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIHJlbW92ZUFjdGl2ZTogZnVuY3Rpb24gcmVtb3ZlQWN0aXZlKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKHRoaXMuX25baV0uY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlcyBhY3RpdmUgY2xhc3Mgb24gaXRlbXMgaW5zaWRlIG5hdmlnYXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGNvbnRyb2xzXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoY29udHJvbHMpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gR2xpZGUuc2V0dGluZ3M7XG4gICAgICAgIHZhciBpdGVtID0gY29udHJvbHNbR2xpZGUuaW5kZXhdO1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKHNldHRpbmdzLmNsYXNzZXMuYWN0aXZlTmF2KTtcblxuICAgICAgICAgIHNpYmxpbmdzKGl0ZW0pLmZvckVhY2goZnVuY3Rpb24gKHNpYmxpbmcpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuY2xhc3NMaXN0LnJlbW92ZShzZXR0aW5ncy5jbGFzc2VzLmFjdGl2ZU5hdik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFjdGl2ZSBjbGFzcyBmcm9tIGFjdGl2ZSBjb250cm9sLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBjb250cm9sc1xuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNvbnRyb2xzKSB7XG4gICAgICAgIHZhciBpdGVtID0gY29udHJvbHNbR2xpZGUuaW5kZXhdO1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKEdsaWRlLnNldHRpbmdzLmNsYXNzZXMuYWN0aXZlTmF2KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgaGFuZGxlcyB0byB0aGUgZWFjaCBncm91cCBvZiBjb250cm9scy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBhZGRCaW5kaW5nczogZnVuY3Rpb24gYWRkQmluZGluZ3MoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYmluZCh0aGlzLl9jW2ldLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgaGFuZGxlcyBmcm9tIHRoZSBlYWNoIGdyb3VwIG9mIGNvbnRyb2xzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIHJlbW92ZUJpbmRpbmdzOiBmdW5jdGlvbiByZW1vdmVCaW5kaW5ncygpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy51bmJpbmQodGhpcy5fY1tpXS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBCaW5kcyBldmVudHMgdG8gYXJyb3dzIEhUTUwgZWxlbWVudHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MQ29sbGVjdGlvbn0gZWxlbWVudHNcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoZWxlbWVudHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIEJpbmRlci5vbignY2xpY2snLCBlbGVtZW50c1tpXSwgdGhpcy5jbGljayk7XG4gICAgICAgICAgQmluZGVyLm9uKCd0b3VjaHN0YXJ0JywgZWxlbWVudHNbaV0sIHRoaXMuY2xpY2ssIGNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogVW5iaW5kcyBldmVudHMgYmluZGVkIHRvIHRoZSBhcnJvd3MgSFRNTCBlbGVtZW50cy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxDb2xsZWN0aW9ufSBlbGVtZW50c1xuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoZWxlbWVudHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIEJpbmRlci5vZmYoWydjbGljaycsICd0b3VjaHN0YXJ0J10sIGVsZW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZXMgYGNsaWNrYCBldmVudCBvbiB0aGUgYXJyb3dzIEhUTUwgZWxlbWVudHMuXG4gICAgICAgKiBNb3ZlcyBzbGlkZXIgaW4gZHJpZWN0aW9uIHByZWNpc2VkIGluXG4gICAgICAgKiBgZGF0YS1nbGlkZS1kaXJgIGF0dHJpYnV0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljayhldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIENvbXBvbmVudHMuUnVuLm1ha2UoQ29tcG9uZW50cy5EaXJlY3Rpb24ucmVzb2x2ZShldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1nbGlkZS1kaXInKSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBkZWZpbmUoQ29udHJvbHMsICdpdGVtcycsIHtcbiAgICAgIC8qKlxuICAgICAgICogR2V0cyBjb2xsZWN0aW9uIG9mIHRoZSBjb250cm9scyBIVE1MIGVsZW1lbnRzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XG4gICAgICAgKi9cbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gQ29udHJvbHMuX2M7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTd2FwIGFjdGl2ZSBjbGFzcyBvZiBjdXJyZW50IG5hdmlnYXRpb24gaXRlbTpcbiAgICAgKiAtIGFmdGVyIG1vdW50aW5nIHRvIHNldCBpdCB0byBpbml0aWFsIGluZGV4XG4gICAgICogLSBhZnRlciBlYWNoIG1vdmUgdG8gdGhlIG5ldyBpbmRleFxuICAgICAqL1xuICAgIEV2ZW50cy5vbihbJ21vdW50LmFmdGVyJywgJ21vdmUuYWZ0ZXInXSwgZnVuY3Rpb24gKCkge1xuICAgICAgQ29udHJvbHMuc2V0QWN0aXZlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYmluZGluZ3MgYW5kIEhUTUwgQ2xhc3NlczpcbiAgICAgKiAtIG9uIGRlc3Ryb3lpbmcsIHRvIGJyaW5nIG1hcmt1cCB0byBpdHMgaW5pdGlhbCBzdGF0ZVxuICAgICAqL1xuICAgIEV2ZW50cy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIENvbnRyb2xzLnJlbW92ZUJpbmRpbmdzKCk7XG4gICAgICBDb250cm9scy5yZW1vdmVBY3RpdmUoKTtcbiAgICAgIEJpbmRlci5kZXN0cm95KCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQ29udHJvbHM7XG4gIH1cblxuICBmdW5jdGlvbiBLZXlib2FyZCAoR2xpZGUsIENvbXBvbmVudHMsIEV2ZW50cykge1xuICAgIC8qKlxuICAgICAqIEluc3RhbmNlIG9mIHRoZSBiaW5kZXIgZm9yIERPTSBFdmVudHMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RXZlbnRzQmluZGVyfVxuICAgICAqL1xuICAgIHZhciBCaW5kZXIgPSBuZXcgRXZlbnRzQmluZGVyKCk7XG5cbiAgICB2YXIgS2V5Ym9hcmQgPSB7XG4gICAgICAvKipcbiAgICAgICAqIEJpbmRzIGtleWJvYXJkIGV2ZW50cyBvbiBjb21wb25lbnQgbW91bnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgICBpZiAoR2xpZGUuc2V0dGluZ3Mua2V5Ym9hcmQpIHtcbiAgICAgICAgICB0aGlzLmJpbmQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMga2V5Ym9hcmQgcHJlc3MgZXZlbnRzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgICAgIEJpbmRlci5vbigna2V5dXAnLCBkb2N1bWVudCwgdGhpcy5wcmVzcyk7XG4gICAgICB9LFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBrZXlib2FyZCBwcmVzcyBldmVudHMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgICAqL1xuICAgICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICAgIEJpbmRlci5vZmYoJ2tleXVwJywgZG9jdW1lbnQpO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZXMga2V5Ym9hcmQncyBhcnJvd3MgcHJlc3MgYW5kIG1vdmluZyBnbGlkZSBmb3dhcmQgYW5kIGJhY2t3YXJkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnRcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIHByZXNzOiBmdW5jdGlvbiBwcmVzcyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMzkpIHtcbiAgICAgICAgICBDb21wb25lbnRzLlJ1bi5tYWtlKENvbXBvbmVudHMuRGlyZWN0aW9uLnJlc29sdmUoJz4nKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMzcpIHtcbiAgICAgICAgICBDb21wb25lbnRzLlJ1bi5tYWtlKENvbXBvbmVudHMuRGlyZWN0aW9uLnJlc29sdmUoJzwnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGJpbmRpbmdzIGZyb20ga2V5Ym9hcmQ6XG4gICAgICogLSBvbiBkZXN0cm95aW5nIHRvIHJlbW92ZSBhZGRlZCBldmVudHNcbiAgICAgKiAtIG9uIHVwZGF0aW5nIHRvIHJlbW92ZSBldmVudHMgYmVmb3JlIHJlbW91bnRpbmdcbiAgICAgKi9cbiAgICBFdmVudHMub24oWydkZXN0cm95JywgJ3VwZGF0ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgICBLZXlib2FyZC51bmJpbmQoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW91bnQgY29tcG9uZW50XG4gICAgICogLSBvbiB1cGRhdGluZyB0byByZWZsZWN0IHBvdGVudGlhbCBjaGFuZ2VzIGluIHNldHRpbmdzXG4gICAgICovXG4gICAgRXZlbnRzLm9uKCd1cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBLZXlib2FyZC5tb3VudCgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveSBiaW5kZXI6XG4gICAgICogLSBvbiBkZXN0cm95aW5nIHRvIHJlbW92ZSBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBFdmVudHMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICBCaW5kZXIuZGVzdHJveSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIEtleWJvYXJkO1xuICB9XG5cbiAgZnVuY3Rpb24gQXV0b3BsYXkgKEdsaWRlLCBDb21wb25lbnRzLCBFdmVudHMpIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW5jZSBvZiB0aGUgYmluZGVyIGZvciBET00gRXZlbnRzLlxuICAgICAqXG4gICAgICogQHR5cGUge0V2ZW50c0JpbmRlcn1cbiAgICAgKi9cbiAgICB2YXIgQmluZGVyID0gbmV3IEV2ZW50c0JpbmRlcigpO1xuXG4gICAgdmFyIEF1dG9wbGF5ID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBJbml0aWFsaXplcyBhdXRvcGxheWluZyBhbmQgZXZlbnRzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICAgKi9cbiAgICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuXG4gICAgICAgIGlmIChHbGlkZS5zZXR0aW5ncy5ob3ZlcnBhdXNlKSB7XG4gICAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBTdGFydHMgYXV0b3BsYXlpbmcgaW4gY29uZmlndXJlZCBpbnRlcnZhbC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW58TnVtYmVyfSBmb3JjZSBSdW4gYXV0b3BsYXlpbmcgd2l0aCBwYXNzZWQgaW50ZXJ2YWwgcmVnYXJkbGVzcyBvZiBgYXV0b3BsYXlgIHNldHRpbmdzXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKEdsaWRlLnNldHRpbmdzLmF1dG9wbGF5KSB7XG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuX2kpKSB7XG4gICAgICAgICAgICB0aGlzLl9pID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgICAgICAgQ29tcG9uZW50cy5SdW4ubWFrZSgnPicpO1xuXG4gICAgICAgICAgICAgIF90aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgICB9LCB0aGlzLnRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFN0b3BzIGF1dG9ydW5uaW5nIG9mIHRoZSBnbGlkZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICB0aGlzLl9pID0gY2xlYXJJbnRlcnZhbCh0aGlzLl9pKTtcbiAgICAgIH0sXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBTdG9wcyBhdXRvcGxheWluZyB3aGlsZSBtb3VzZSBpcyBvdmVyIGdsaWRlJ3MgYXJlYS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICovXG4gICAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBCaW5kZXIub24oJ21vdXNlb3ZlcicsIENvbXBvbmVudHMuSHRtbC5yb290LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnN0b3AoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgQmluZGVyLm9uKCdtb3VzZW91dCcsIENvbXBvbmVudHMuSHRtbC5yb290LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnN0YXJ0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFVuYmluZCBtb3VzZW92ZXIgZXZlbnRzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtWb2lkfVxuICAgICAgICovXG4gICAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgICAgQmluZGVyLm9mZihbJ21vdXNlb3ZlcicsICdtb3VzZW91dCddLCBDb21wb25lbnRzLkh0bWwucm9vdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZShBdXRvcGxheSwgJ3RpbWUnLCB7XG4gICAgICAvKipcbiAgICAgICAqIEdldHMgdGltZSBwZXJpb2QgdmFsdWUgZm9yIHRoZSBhdXRvcGxheSBpbnRlcnZhbC4gUHJpb3JpdGl6ZXNcbiAgICAgICAqIHRpbWVzIGluIGBkYXRhLWdsaWRlLWF1dG9wbGF5YCBhdHRydWJ1dGVzIG92ZXIgb3B0aW9ucy5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgYXV0b3BsYXkgPSBDb21wb25lbnRzLkh0bWwuc2xpZGVzW0dsaWRlLmluZGV4XS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZ2xpZGUtYXV0b3BsYXknKTtcblxuICAgICAgICBpZiAoYXV0b3BsYXkpIHtcbiAgICAgICAgICByZXR1cm4gdG9JbnQoYXV0b3BsYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvSW50KEdsaWRlLnNldHRpbmdzLmF1dG9wbGF5KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFN0b3AgYXV0b3BsYXlpbmcgYW5kIHVuYmluZCBldmVudHM6XG4gICAgICogLSBvbiBkZXN0cm95aW5nLCB0byBjbGVhciBkZWZpbmVkIGludGVydmFsXG4gICAgICogLSBvbiB1cGRhdGluZyB2aWEgQVBJIHRvIHJlc2V0IGludGVydmFsIHRoYXQgbWF5IGNoYW5nZWRcbiAgICAgKi9cbiAgICBFdmVudHMub24oWydkZXN0cm95JywgJ3VwZGF0ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgICBBdXRvcGxheS51bmJpbmQoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFN0b3AgYXV0b3BsYXlpbmc6XG4gICAgICogLSBiZWZvcmUgZWFjaCBydW4sIHRvIHJlc3RhcnQgYXV0b3BsYXlpbmdcbiAgICAgKiAtIG9uIHBhdXNpbmcgdmlhIEFQSVxuICAgICAqIC0gb24gZGVzdHJveWluZywgdG8gY2xlYXIgZGVmaW5lZCBpbnRlcnZhbFxuICAgICAqIC0gd2hpbGUgc3RhcnRpbmcgYSBzd2lwZVxuICAgICAqIC0gb24gdXBkYXRpbmcgdmlhIEFQSSB0byByZXNldCBpbnRlcnZhbCB0aGF0IG1heSBjaGFuZ2VkXG4gICAgICovXG4gICAgRXZlbnRzLm9uKFsncnVuLmJlZm9yZScsICdwYXVzZScsICdkZXN0cm95JywgJ3N3aXBlLnN0YXJ0JywgJ3VwZGF0ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgICBBdXRvcGxheS5zdG9wKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBhdXRvcGxheWluZzpcbiAgICAgKiAtIGFmdGVyIGVhY2ggcnVuLCB0byByZXN0YXJ0IGF1dG9wbGF5aW5nXG4gICAgICogLSBvbiBwbGF5aW5nIHZpYSBBUElcbiAgICAgKiAtIHdoaWxlIGVuZGluZyBhIHN3aXBlXG4gICAgICovXG4gICAgRXZlbnRzLm9uKFsncnVuLmFmdGVyJywgJ3BsYXknLCAnc3dpcGUuZW5kJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIEF1dG9wbGF5LnN0YXJ0KCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdW50IGF1dG9wbGF5aW5nOlxuICAgICAqIC0gb24gdXBkYXRpbmcgdmlhIEFQSSB0byByZXNldCBpbnRlcnZhbCB0aGF0IG1heSBjaGFuZ2VkXG4gICAgICovXG4gICAgRXZlbnRzLm9uKCd1cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBBdXRvcGxheS5tb3VudCgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveSBhIGJpbmRlcjpcbiAgICAgKiAtIG9uIGRlc3Ryb3lpbmcgZ2xpZGUgaW5zdGFuY2UgdG8gY2xlYXJ1cCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBFdmVudHMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICBCaW5kZXIuZGVzdHJveSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIEF1dG9wbGF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFNvcnRzIGtleXMgb2YgYnJlYWtwb2ludCBvYmplY3Qgc28gdGhleSB3aWxsIGJlIG9yZGVyZWQgZnJvbSBsb3dlciB0byBiaWdnZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludHNcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIHNvcnRCcmVha3BvaW50cyhwb2ludHMpIHtcbiAgICBpZiAoaXNPYmplY3QocG9pbnRzKSkge1xuICAgICAgcmV0dXJuIHNvcnRLZXlzKHBvaW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oJ0JyZWFrcG9pbnRzIG9wdGlvbiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJyZWFrcG9pbnRzIChHbGlkZSwgQ29tcG9uZW50cywgRXZlbnRzKSB7XG4gICAgLyoqXG4gICAgICogSW5zdGFuY2Ugb2YgdGhlIGJpbmRlciBmb3IgRE9NIEV2ZW50cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtFdmVudHNCaW5kZXJ9XG4gICAgICovXG4gICAgdmFyIEJpbmRlciA9IG5ldyBFdmVudHNCaW5kZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIHJlZmVyZW5jZSB0byBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIHNldHRpbmdzID0gR2xpZGUuc2V0dGluZ3M7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyByZWZlcmVuY2UgdG8gYnJlYWtwb2ludHMgb2JqZWN0IGluIHNldHRpbmdzLiBTb3J0cyBicmVha3BvaW50c1xuICAgICAqIGZyb20gc21hbGxlciB0byBsYXJnZXIuIEl0IGlzIHJlcXVpcmVkIGluIG9yZGVyIHRvIHByb3BlclxuICAgICAqIG1hdGNoaW5nIGN1cnJlbnRseSBhY3RpdmUgYnJlYWtwb2ludCBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIHBvaW50cyA9IHNvcnRCcmVha3BvaW50cyhzZXR0aW5ncy5icmVha3BvaW50cyk7XG5cbiAgICAvKipcbiAgICAgKiBDYWNoZSBpbml0aWFsIHNldHRpbmdzIGJlZm9yZSBvdmVyd3JpdHRpbmcuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0cyA9IF9leHRlbmRzKHt9LCBzZXR0aW5ncyk7XG5cbiAgICB2YXIgQnJlYWtwb2ludHMgPSB7XG4gICAgICAvKipcbiAgICAgICAqIE1hdGNoZXMgc2V0dGluZ3MgZm9yIGN1cnJlY3RseSBtYXRjaGluZyBtZWRpYSBicmVha3BvaW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludHNcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIG1hdGNoOiBmdW5jdGlvbiBtYXRjaChwb2ludHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cubWF0Y2hNZWRpYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBwb2ludCBpbiBwb2ludHMpIHtcbiAgICAgICAgICAgIGlmIChwb2ludHMuaGFzT3duUHJvcGVydHkocG9pbnQpKSB7XG4gICAgICAgICAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYSgnKG1heC13aWR0aDogJyArIHBvaW50ICsgJ3B4KScpLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRzW3BvaW50XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogT3ZlcndyaXRlIGluc3RhbmNlIHNldHRpbmdzIHdpdGggY3VycmVudGx5IG1hdGNoaW5nIGJyZWFrcG9pbnQgc2V0dGluZ3MuXG4gICAgICogVGhpcyBoYXBwZW5zIHJpZ2h0IGFmdGVyIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgKi9cbiAgICBfZXh0ZW5kcyhzZXR0aW5ncywgQnJlYWtwb2ludHMubWF0Y2gocG9pbnRzKSk7XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZ2xpZGUgd2l0aCBzZXR0aW5ncyBvZiBtYXRjaGVkIGJyZWtwb2ludDpcbiAgICAgKiAtIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIHNsaWRlclxuICAgICAqL1xuICAgIEJpbmRlci5vbigncmVzaXplJywgd2luZG93LCB0aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgICBHbGlkZS5zZXR0aW5ncyA9IG1lcmdlT3B0aW9ucyhzZXR0aW5ncywgQnJlYWtwb2ludHMubWF0Y2gocG9pbnRzKSk7XG4gICAgfSwgR2xpZGUuc2V0dGluZ3MudGhyb3R0bGUpKTtcblxuICAgIC8qKlxuICAgICAqIFJlc29ydCBhbmQgdXBkYXRlIGRlZmF1bHQgc2V0dGluZ3M6XG4gICAgICogLSBvbiByZWluaXQgdmlhIEFQSSwgc28gYnJlYWtwb2ludCBtYXRjaGluZyB3aWxsIGJlIHBlcmZvcm1lZCB3aXRoIG9wdGlvbnNcbiAgICAgKi9cbiAgICBFdmVudHMub24oJ3VwZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHBvaW50cyA9IHNvcnRCcmVha3BvaW50cyhwb2ludHMpO1xuXG4gICAgICBkZWZhdWx0cyA9IF9leHRlbmRzKHt9LCBzZXR0aW5ncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmQgcmVzaXplIGxpc3RlbmVyOlxuICAgICAqIC0gb24gZGVzdHJveWluZywgdG8gYnJpbmcgbWFya3VwIHRvIGl0cyBpbml0aWFsIHN0YXRlXG4gICAgICovXG4gICAgRXZlbnRzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgQmluZGVyLm9mZigncmVzaXplJywgd2luZG93KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBCcmVha3BvaW50cztcbiAgfVxuXG4gIHZhciBDT01QT05FTlRTID0ge1xuICAgIC8vIFJlcXVpcmVkXG4gICAgSHRtbDogSHRtbCxcbiAgICBUcmFuc2xhdGU6IFRyYW5zbGF0ZSxcbiAgICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICAgIERpcmVjdGlvbjogRGlyZWN0aW9uLFxuICAgIFBlZWs6IFBlZWssXG4gICAgU2l6ZXM6IFNpemVzLFxuICAgIEdhcHM6IEdhcHMsXG4gICAgTW92ZTogTW92ZSxcbiAgICBDbG9uZXM6IENsb25lcyxcbiAgICBSZXNpemU6IFJlc2l6ZSxcbiAgICBCdWlsZDogQnVpbGQsXG4gICAgUnVuOiBSdW4sXG5cbiAgICAvLyBPcHRpb25hbFxuICAgIFN3aXBlOiBTd2lwZSxcbiAgICBJbWFnZXM6IEltYWdlcyxcbiAgICBBbmNob3JzOiBBbmNob3JzLFxuICAgIENvbnRyb2xzOiBDb250cm9scyxcbiAgICBLZXlib2FyZDogS2V5Ym9hcmQsXG4gICAgQXV0b3BsYXk6IEF1dG9wbGF5LFxuICAgIEJyZWFrcG9pbnRzOiBCcmVha3BvaW50c1xuICB9O1xuXG4gIHZhciBHbGlkZSQxID0gZnVuY3Rpb24gKF9Db3JlKSB7XG4gICAgaW5oZXJpdHMoR2xpZGUkJDEsIF9Db3JlKTtcblxuICAgIGZ1bmN0aW9uIEdsaWRlJCQxKCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgR2xpZGUkJDEpO1xuICAgICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEdsaWRlJCQxLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR2xpZGUkJDEpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBjcmVhdGVDbGFzcyhHbGlkZSQkMSwgW3tcbiAgICAgIGtleTogJ21vdW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgICAgdmFyIGV4dGVuc2lvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgIHJldHVybiBnZXQoR2xpZGUkJDEucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR2xpZGUkJDEucHJvdG90eXBlKSwgJ21vdW50JywgdGhpcykuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7fSwgQ09NUE9ORU5UUywgZXh0ZW5zaW9ucykpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gR2xpZGUkJDE7XG4gIH0oR2xpZGUpO1xuXG4gIHJldHVybiBHbGlkZSQxO1xuXG59KSkpO1xuIiwiLyoqIVxuICogTWl4SXRVcCB2My4zLjFcbiAqIEEgaGlnaC1wZXJmb3JtYW5jZSwgZGVwZW5kZW5jeS1mcmVlIGxpYnJhcnkgZm9yIGFuaW1hdGVkIGZpbHRlcmluZywgc29ydGluZyBhbmQgbW9yZVxuICogQnVpbGQgOTRlMGZiZjYtY2QwYi00OTg3LWIzYzAtMTRiNTliNjdiOGEwXG4gKlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgMjAxNC0yMDE4IEt1bmthTGFicyBMaW1pdGVkLlxuICogQGF1dGhvciAgICBLdW5rYUxhYnMgTGltaXRlZC5cbiAqIEBsaW5rICAgICAgaHR0cHM6Ly93d3cua3Vua2FsYWJzLmNvbS9taXhpdHVwL1xuICpcbiAqIEBsaWNlbnNlICAgQ29tbWVyY2lhbCB1c2UgcmVxdWlyZXMgYSBjb21tZXJjaWFsIGxpY2Vuc2UuXG4gKiAgICAgICAgICAgIGh0dHBzOi8vd3d3Lmt1bmthbGFicy5jb20vbWl4aXR1cC9saWNlbnNlcy9cbiAqXG4gKiAgICAgICAgICAgIE5vbi1jb21tZXJjaWFsIHVzZSBwZXJtaXR0ZWQgdW5kZXIgc2FtZSB0ZXJtcyBhcyBDQyBCWS1OQyAzLjAgbGljZW5zZS5cbiAqICAgICAgICAgICAgaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICovXG5cbihmdW5jdGlvbih3aW5kb3cpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbWl4aXR1cCA9IG51bGwsXG4gICAgICAgIGggICAgICAgPSBudWxsO1xuXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgVkVORE9SUyA9IFsnd2Via2l0JywgJ21veicsICdvJywgJ21zJ10sXG4gICAgICAgICAgICBjYW5hcnkgID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgaSAgICAgICA9IC0xO1xuXG4gICAgICAgIC8vIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgVkVORE9SUy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7IGkrKykge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1tWRU5ET1JTW2ldICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmdcblxuICAgICAgICBpZiAodHlwZW9mIGNhbmFyeS5uZXh0RWxlbWVudFNpYmxpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LkVsZW1lbnQucHJvdG90eXBlLCAnbmV4dEVsZW1lbnRTaWJsaW5nJywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZWwubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVsZW1lbnQubWF0Y2hlc1xuXG4gICAgICAgIChmdW5jdGlvbihFbGVtZW50UHJvdG90eXBlKSB7XG4gICAgICAgICAgICBFbGVtZW50UHJvdG90eXBlLm1hdGNoZXMgPVxuICAgICAgICAgICAgICAgIEVsZW1lbnRQcm90b3R5cGUubWF0Y2hlcyB8fFxuICAgICAgICAgICAgICAgIEVsZW1lbnRQcm90b3R5cGUubWFjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICBFbGVtZW50UHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgIEVsZW1lbnRQcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICBFbGVtZW50UHJvdG90eXBlLm9NYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICBFbGVtZW50UHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksIHRoaXMpID4gLTE7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfSkod2luZG93LkVsZW1lbnQucHJvdG90eXBlKTtcblxuICAgICAgICAvLyBPYmplY3Qua2V5c1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qva2V5c1xuXG4gICAgICAgIGlmICghT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSAgICAgID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgaGFzRG9udEVudW1CdWcgICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkb250RW51bXMgICAgICAgICAgID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGRvbnRFbnVtc0xlbmd0aCAgICAgPSAtMTtcblxuICAgICAgICAgICAgICAgIGhhc0RvbnRFbnVtQnVnID0gISh7XG4gICAgICAgICAgICAgICAgICAgIHRvU3RyaW5nOiBudWxsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuXG4gICAgICAgICAgICAgICAgZG9udEVudW1zID0gW1xuICAgICAgICAgICAgICAgICAgICAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAndG9Mb2NhbGVTdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAndmFsdWVPZicsXG4gICAgICAgICAgICAgICAgICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgICAgICdpc1Byb3RvdHlwZU9mJyxcbiAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NvbnN0cnVjdG9yJ1xuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ICA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCAgICA9ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiAodHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmogPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gbm9uLW9iamVjdCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZG9udEVudW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGRvbnRFbnVtc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZG9udEVudW1zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXJyYXkuaXNBcnJheVxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9iamVjdC5jcmVhdGVcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZVxuXG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZSA9IChmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgVGVtcCA9IGZ1bmN0aW9uKCkge307XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydGllc09iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvdG90eXBlICE9PSBPYmplY3QocHJvdG90eXBlKSAmJiBwcm90b3R5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QsIG9yIG51bGwnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIFRlbXAucHJvdG90eXBlID0gcHJvdG90eXBlIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgVGVtcCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIFRlbXAucHJvdG90eXBlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc09iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhyZXN1bHQsIHByb3BlcnRpZXNPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Ll9fcHJvdG9fXyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0cmluZy5wcm90b3R5b2UudHJpbVxuXG4gICAgICAgIGlmICghU3RyaW5nLnByb3RvdHlwZS50cmltKSB7XG4gICAgICAgICAgICBTdHJpbmcucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFycmF5LnByb3RvdHlwZS5pbmRleE9mXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2ZcblxuICAgICAgICBpZiAoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uKHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiwgaywgdCwgbGVuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHQgPSBPYmplY3QodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAgICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG4gPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBOdW1iZXIoYXJndW1lbnRzWzFdKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobiAhPT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSBJbmZpbml0eSAmJiBuICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobiA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoayA9IG4gPj0gMCA/IG4gOiBNYXRoLm1heChsZW4gLSBNYXRoLmFicyhuKSwgMCk7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoayBpbiB0ICYmIHRba10gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9vYmplY3RzL0Z1bmN0aW9uL2JpbmRcblxuICAgICAgICBpZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKG9UaGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFBcmdzLCBzZWxmLCBGTk9QLCBmQm91bmQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgRk5PUCA9IGZ1bmN0aW9uKCkge307XG5cbiAgICAgICAgICAgICAgICBmQm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuYXBwbHkodGhpcyBpbnN0YW5jZW9mIEZOT1AgPyB0aGlzIDogb1RoaXMsIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBGTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgRk5PUCgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZCb3VuZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50XG5cbiAgICAgICAgaWYgKCF3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCkge1xuICAgICAgICAgICAgd2luZG93LkVsZW1lbnQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcmVFdmVudCgnb24nICsgZXZlbnQudHlwZSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBtaXhpdHVwKClgIFwiZmFjdG9yeVwiIGZ1bmN0aW9uIGNyZWF0ZXMgYW5kIHJldHVybnMgaW5kaXZpZHVhbCBpbnN0YW5jZXNcbiAgICAgKiBvZiBNaXhJdFVwLCBrbm93biBhcyBcIm1peGVyc1wiLCBvbiB3aGljaCBBUEkgbWV0aG9kcyBjYW4gYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogV2hlbiBsb2FkaW5nIE1peEl0VXAgdmlhIGEgc2NyaXB0IHRhZywgdGhlIGZhY3RvcnkgZnVuY3Rpb24gaXMgYWNjZXNzZWRcbiAgICAgKiB2aWEgdGhlIGdsb2JhbCB2YXJpYWJsZSBgbWl4aXR1cGAuIFdoZW4gdXNpbmcgYSBtb2R1bGUgbG9hZGluZ1xuICAgICAqIHN5c3RlbSAoZS5nLiBFUzIwMTUsIENvbW1vbkpTLCBSZXF1aXJlSlMpLCB0aGUgZmFjdG9yeSBmdW5jdGlvbiBpc1xuICAgICAqIGV4cG9ydGVkIGludG8geW91ciBtb2R1bGUgd2hlbiB5b3UgcmVxdWlyZSB0aGUgTWl4SXRVcCBsaWJyYXJ5LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtaXhpdHVwKGNvbnRhaW5lciBbLGNvbmZpZ10gWyxmb3JlaWduRG9jXSlcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogQ3JlYXRpbmcgYSBtaXhlciBpbnN0YW5jZSB3aXRoIGFuIGVsZW1lbnQgcmVmZXJlbmNlPC9jYXB0aW9uPlxuICAgICAqIHZhciBjb250YWluZXJFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250YWluZXInKTtcbiAgICAgKlxuICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAyOiBDcmVhdGluZyBhIG1peGVyIGluc3RhbmNlIHdpdGggYSBzZWxlY3RvciBzdHJpbmc8L2NhcHRpb24+XG4gICAgICogdmFyIG1peGVyID0gbWl4aXR1cCgnLmNvbnRhaW5lcicpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAzOiBQYXNzaW5nIGEgY29uZmlndXJhdGlvbiBvYmplY3Q8L2NhcHRpb24+XG4gICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgKiAgICAgICAgIGVmZmVjdHM6ICdmYWRlIHNjYWxlKDAuNSknXG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgNDogUGFzc2luZyBhbiBpZnJhbWUgcmVmZXJlbmNlPC9jYXB0aW9uPlxuICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIGNvbmZpZywgZm9yZWlnbkRvY3VtZW50KTtcbiAgICAgKlxuICAgICAqIEBnbG9iYWxcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBraW5kICAgICAgICBmdW5jdGlvblxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqIEBwYXJhbSAgICAgICB7KEVsZW1lbnR8c3RyaW5nKX0gIGNvbnRhaW5lclxuICAgICAqICAgICAgQSBET00gZWxlbWVudCBvciBzZWxlY3RvciBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb250YWluZXIocykgb24gd2hpY2ggdG8gaW5zdGFudGlhdGUgTWl4SXRVcC5cbiAgICAgKiBAcGFyYW0gICAgICAge29iamVjdH0gICAgICAgICAgICBbY29uZmlnXVxuICAgICAqICAgICAgQW4gb3B0aW9uYWwgXCJjb25maWd1cmF0aW9uIG9iamVjdFwiIHVzZWQgdG8gY3VzdG9taXplIHRoZSBiZWhhdmlvciBvZiB0aGUgTWl4SXRVcCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gICAgICAge29iamVjdH0gICAgICAgICAgICBbZm9yZWlnbkRvY11cbiAgICAgKiAgICAgIEFuIG9wdGlvbmFsIHJlZmVyZW5jZSB0byBhIGBkb2N1bWVudGAsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgYSBNaXhJdFVwIGluc3RhbmNlIGluIGFuIGlmcmFtZS5cbiAgICAgKiBAcmV0dXJuICAgICAge21peGl0dXAuTWl4ZXJ9XG4gICAgICogICAgICBBIFwibWl4ZXJcIiBvYmplY3QgaG9sZGluZyB0aGUgTWl4SXRVcCBpbnN0YW5jZS5cbiAgICAgKi9cblxuICAgIG1peGl0dXAgPSBmdW5jdGlvbihjb250YWluZXIsIGNvbmZpZywgZm9yZWlnbkRvYykge1xuICAgICAgICB2YXIgZWwgICAgICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICByZXR1cm5Db2xsZWN0aW9uICAgID0gZmFsc2UsXG4gICAgICAgICAgICBpbnN0YW5jZSAgICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgIGZhY2FkZSAgICAgICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgZG9jICAgICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICBvdXRwdXQgICAgICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgIGluc3RhbmNlcyAgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGlkICAgICAgICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICAgIGVsZW1lbnRzICAgICAgICAgICAgPSBbXSxcbiAgICAgICAgICAgIGkgICAgICAgICAgICAgICAgICAgPSAtMTtcblxuICAgICAgICBkb2MgPSBmb3JlaWduRG9jIHx8IHdpbmRvdy5kb2N1bWVudDtcblxuICAgICAgICBpZiAocmV0dXJuQ29sbGVjdGlvbiA9IGFyZ3VtZW50c1szXSkge1xuICAgICAgICAgICAgLy8gQSBub24tZG9jdW1lbnRlZCA0dGggcGFyYW1hdGVyIGVuYWJsaW5nIGNvbnRyb2wgb2YgbXVsdGlwbGUgaW5zdGFuY2VzXG5cbiAgICAgICAgICAgIHJldHVybkNvbGxlY3Rpb24gPSB0eXBlb2YgcmV0dXJuQ29sbGVjdGlvbiA9PT0gJ2Jvb2xlYW4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb250YWluZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbGVtZW50cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKGNvbnRhaW5lcik7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyICYmIHR5cGVvZiBjb250YWluZXIgPT09ICdvYmplY3QnICYmIGguaXNFbGVtZW50KGNvbnRhaW5lciwgZG9jKSkge1xuICAgICAgICAgICAgZWxlbWVudHMgPSBbY29udGFpbmVyXTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250YWluZXIgJiYgdHlwZW9mIGNvbnRhaW5lciA9PT0gJ29iamVjdCcgJiYgY29udGFpbmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gQWx0aG91Z2ggbm90IGRvY3VtZW50ZWQsIHRoZSBjb250YWluZXIgbWF5IGFsc28gYmUgYW4gYXJyYXktbGlrZSBsaXN0IG9mXG4gICAgICAgICAgICAvLyBlbGVtZW50cyBzdWNoIGFzIGEgTm9kZUxpc3Qgb3IgalF1ZXJ5IGNvbGxlY3Rpb24sIGlzIHJldHVybkNvbGxlY3Rpb24gaXMgdHJ1ZVxuXG4gICAgICAgICAgICBlbGVtZW50cyA9IGNvbnRhaW5lcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtaXhpdHVwLm1lc3NhZ2VzLmVycm9yRmFjdG9yeUludmFsaWRDb250YWluZXIoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1peGl0dXAubWVzc2FnZXMuZXJyb3JGYWN0b3J5Q29udGFpbmVyTm90Rm91bmQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBlbCA9IGVsZW1lbnRzW2ldOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID4gMCAmJiAhcmV0dXJuQ29sbGVjdGlvbikgYnJlYWs7XG5cbiAgICAgICAgICAgIGlmICghZWwuaWQpIHtcbiAgICAgICAgICAgICAgICBpZCA9ICdNaXhJdFVwJyArIGgucmFuZG9tSGV4KCk7XG5cbiAgICAgICAgICAgICAgICBlbC5pZCA9IGlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZCA9IGVsLmlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWl4aXR1cC5pbnN0YW5jZXNbaWRdIGluc3RhbmNlb2YgbWl4aXR1cC5NaXhlcikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gbWl4aXR1cC5pbnN0YW5jZXNbaWRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb25maWcgfHwgKGNvbmZpZyAmJiBjb25maWcuZGVidWcgJiYgY29uZmlnLmRlYnVnLnNob3dXYXJuaW5ncyAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihtaXhpdHVwLm1lc3NhZ2VzLndhcm5pbmdGYWN0b3J5UHJlZXhpc3RpbmdJbnN0YW5jZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gbmV3IG1peGl0dXAuTWl4ZXIoKTtcblxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmF0dGFjaChlbCwgZG9jLCBpZCwgY29uZmlnKTtcblxuICAgICAgICAgICAgICAgIG1peGl0dXAuaW5zdGFuY2VzW2lkXSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmYWNhZGUgPSBuZXcgbWl4aXR1cC5GYWNhZGUoaW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5kZWJ1ZyAmJiBjb25maWcuZGVidWcuZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXMucHVzaChmYWNhZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldHVybkNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG5ldyBtaXhpdHVwLkNvbGxlY3Rpb24oaW5zdGFuY2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgZmlyc3QgaW5zdGFuY2UgcmVnYXJkbGVzc1xuXG4gICAgICAgICAgICBvdXRwdXQgPSBpbnN0YW5jZXNbMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYC51c2UoKWAgc3RhdGljIG1ldGhvZCBpcyB1c2VkIHRvIGV4dGVuZCB0aGUgZnVuY3Rpb25hbGl0eSBvZiBtaXhpdHVwIHdpdGggY29tcGF0aWJsZVxuICAgICAqIGV4dGVuc2lvbnMgYW5kIGxpYnJhcmllcyBpbiBhbiBlbnZpcm9ubWVudCB3aXRoIG1vZHVsYXIgc2NvcGluZyBlLmcuIEVTMjAxNSwgQ29tbW9uSlMsIG9yIFJlcXVpcmVKUy5cbiAgICAgKlxuICAgICAqIFlvdSBuZWVkIG9ubHkgY2FsbCB0aGUgYC51c2UoKWAgZnVuY3Rpb24gb25jZSBwZXIgcHJvamVjdCwgcGVyIGV4dGVuc2lvbiwgYXMgbW9kdWxlIGxvYWRlcnNcbiAgICAgKiB3aWxsIGNhY2hlIGEgc2luZ2xlIHJlZmVyZW5jZSB0byBNaXhJdFVwIGluY2x1c2l2ZSBvZiBhbGwgY2hhbmdlcyBtYWRlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtaXhpdHVwLnVzZShleHRlbnNpb24pXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IEV4dGVuZGluZyBNaXhJdFVwIHdpdGggdGhlIFBhZ2luYXRpb24gRXh0ZW5zaW9uPC9jYXB0aW9uPlxuICAgICAqXG4gICAgICogaW1wb3J0IG1peGl0dXAgZnJvbSAnbWl4aXR1cCc7XG4gICAgICogaW1wb3J0IG1peGl0dXBQYWdpbmF0aW9uIGZyb20gJ21peGl0dXAtcGFnaW5hdGlvbic7XG4gICAgICpcbiAgICAgKiBtaXhpdHVwLnVzZShtaXhpdHVwUGFnaW5hdGlvbik7XG4gICAgICpcbiAgICAgKiAvLyBBbGwgbWl4ZXJzIGNyZWF0ZWQgYnkgdGhlIGZhY3RvcnkgZnVuY3Rpb24gaW4gYWxsIG1vZHVsZXMgd2lsbCBub3dcbiAgICAgKiAvLyBoYXZlIHBhZ2luYXRpb24gZnVuY3Rpb25hbGl0eVxuICAgICAqXG4gICAgICogdmFyIG1peGVyID0gbWl4aXR1cCgnLmNvbnRhaW5lcicpO1xuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBuYW1lICAgICB1c2VcbiAgICAgKiBAbWVtYmVyb2YgbWl4aXR1cFxuICAgICAqIEBraW5kICAgICBmdW5jdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgICAgMy4wLjBcbiAgICAgKiBAcGFyYW0gICAgeyp9ICBleHRlbnNpb24gICBBIHJlZmVyZW5jZSB0byB0aGUgZXh0ZW5zaW9uIG9yIGxpYnJhcnkgdG8gYmUgdXNlZC5cbiAgICAgKiBAcmV0dXJuICAge3ZvaWR9XG4gICAgICovXG5cbiAgICBtaXhpdHVwLnVzZSA9IGZ1bmN0aW9uKGV4dGVuc2lvbikge1xuICAgICAgICBtaXhpdHVwLkJhc2UucHJvdG90eXBlLmNhbGxBY3Rpb25zLmNhbGwobWl4aXR1cCwgJ2JlZm9yZVVzZScsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgZXh0ZW5zaW9uJ3MgZmFjdG9yeSBmdW5jdGlvbiwgcGFzc2luZ1xuICAgICAgICAvLyB0aGUgbWl4aXR1cCBmYWN0b3J5IGFzIGEgcGFyYW1hdGVyXG5cbiAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicgJiYgZXh0ZW5zaW9uLlRZUEUgPT09ICdtaXhpdHVwLWV4dGVuc2lvbicpIHtcbiAgICAgICAgICAgIC8vIE1peGl0dXAgZXh0ZW5zaW9uXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWl4aXR1cC5leHRlbnNpb25zW2V4dGVuc2lvbi5OQU1FXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24obWl4aXR1cCk7XG5cbiAgICAgICAgICAgICAgICBtaXhpdHVwLmV4dGVuc2lvbnNbZXh0ZW5zaW9uLk5BTUVdID0gZXh0ZW5zaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV4dGVuc2lvbi5mbiAmJiBleHRlbnNpb24uZm4uanF1ZXJ5KSB7XG4gICAgICAgICAgICAvLyBqUXVlcnlcblxuICAgICAgICAgICAgbWl4aXR1cC5saWJyYXJpZXMuJCA9IGV4dGVuc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1peGl0dXAuQmFzZS5wcm90b3R5cGUuY2FsbEFjdGlvbnMuY2FsbChtaXhpdHVwLCAnYWZ0ZXJVc2UnLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLmluc3RhbmNlcyAgID0ge307XG4gICAgbWl4aXR1cC5leHRlbnNpb25zICA9IHt9O1xuICAgIG1peGl0dXAubGlicmFyaWVzICAgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICBoID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgZWxcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgIGNsc1xuICAgICAgICAgKiBAcmV0dXJuICB7Ym9vbGVhbn1cbiAgICAgICAgICovXG5cbiAgICAgICAgaGFzQ2xhc3M6IGZ1bmN0aW9uKGVsLCBjbHMpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWVsLmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKCcoXFxcXHN8XiknICsgY2xzICsgJyhcXFxcc3wkKScpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgIGVsXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgICBjbHNcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGFkZENsYXNzOiBmdW5jdGlvbihlbCwgY2xzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzQ2xhc3MoZWwsIGNscykpIGVsLmNsYXNzTmFtZSArPSBlbC5jbGFzc05hbWUgPyAnICcgKyBjbHMgOiBjbHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gICBlbFxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICAgICAgY2xzXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWwsIGNscykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQ2xhc3MoZWwsIGNscykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cCgnKFxcXFxzfF4pJyArIGNscyArICcoXFxcXHN8JCknKTtcblxuICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKHJlZywgJyAnKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdCBvbnRvIHRoZVxuICAgICAgICAgKiB0YXJnZXQgb2JqZWN0LiBBbHRlcnMgdGhlIHRhcmdldCBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgIGRlc3RpbmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgIHNvdXJjZVxuICAgICAgICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gICBbZGVlcD1mYWxzZV1cbiAgICAgICAgICogQHBhcmFtICAge2Jvb2xlYW59ICAgW2hhbmRsZUVycm9ycz1mYWxzZV1cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGV4dGVuZDogZnVuY3Rpb24oZGVzdGluYXRpb24sIHNvdXJjZSwgZGVlcCwgaGFuZGxlRXJyb3JzKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlS2V5cyAgPSBbXSxcbiAgICAgICAgICAgICAgICBrZXkgICAgICAgICA9ICcnLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIGRlZXAgPSBkZWVwIHx8IGZhbHNlO1xuICAgICAgICAgICAgaGFuZGxlRXJyb3JzID0gaGFuZGxlRXJyb3JzIHx8IGZhbHNlO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlS2V5cy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlZXAgfHwgdHlwZW9mIHNvdXJjZVtrZXldICE9PSAnb2JqZWN0JyB8fCB0aGlzLmlzRWxlbWVudChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBub24tb2JqZWN0IHByb3BlcnRpZXMsIG9yIGFsbCBwcm9wZXJ0aWVzIGlmIHNoYWxsb3cgZXh0ZW5kXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXlzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVzdGluYXRpb25ba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRlbmQoZGVzdGluYXRpb25ba2V5XSwgc291cmNlW2tleV0sIGRlZXAsIGhhbmRsZUVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPYmplY3RzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVzdGluYXRpb25ba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRlbmQoZGVzdGluYXRpb25ba2V5XSwgc291cmNlW2tleV0sIGRlZXAsIGhhbmRsZUVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFeHRlbmRFcnJvcihlcnIsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtFcnJvcn0gIGVyclxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSBkZXN0aW5hdGlvblxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgaGFuZGxlRXh0ZW5kRXJyb3I6IGZ1bmN0aW9uKGVyciwgZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgIHZhciByZSAgICAgICAgICAgICAgICAgID0gL3Byb3BlcnR5IFwiPyhcXHcqKVwiP1ssOl0gb2JqZWN0L2ksXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb25lb3VzICAgICAgICAgICA9ICcnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICAgICAgICBzdWdnZXN0aW9uICAgICAgICAgID0gJycsXG4gICAgICAgICAgICAgICAgcHJvYmFibGVNYXRjaCAgICAgICA9ICcnLFxuICAgICAgICAgICAgICAgIGtleSAgICAgICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICAgICAgICBtb3N0TWF0Y2hpbmdDaGFycyAgID0gLTEsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIChtYXRjaGVzID0gcmUuZXhlYyhlcnIubWVzc2FnZSkpKSB7XG4gICAgICAgICAgICAgICAgZXJyb25lb3VzID0gbWF0Y2hlc1sxXTtcblxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgZXJyb25lb3VzLmxlbmd0aCAmJiBlcnJvbmVvdXMuY2hhckF0KGkpID09PSBrZXkuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IG1vc3RNYXRjaGluZ0NoYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3N0TWF0Y2hpbmdDaGFycyA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9iYWJsZU1hdGNoID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1vc3RNYXRjaGluZ0NoYXJzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uID0gbWl4aXR1cC5tZXNzYWdlcy5lcnJvckNvbmZpZ0ludmFsaWRQcm9wZXJ0eVN1Z2dlc3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvYmFibGVNYXRjaDogcHJvYmFibGVNYXRjaFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWl4aXR1cC5tZXNzYWdlcy5lcnJvckNvbmZpZ0ludmFsaWRQcm9wZXJ0eSh7XG4gICAgICAgICAgICAgICAgICAgIGVycm9uZW91czogZXJyb25lb3VzLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uOiBzdWdnZXN0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9IHN0clxuICAgICAgICAgKiBAcmV0dXJuICB7ZnVuY3Rpb259XG4gICAgICAgICAqL1xuXG4gICAgICAgIHRlbXBsYXRlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciByZSAgICAgICAgICA9IC9cXCR7KFtcXHddKil9L2csXG4gICAgICAgICAgICAgICAgZHluYW1pY3MgICAgPSB7fSxcbiAgICAgICAgICAgICAgICBtYXRjaGVzICAgICA9IG51bGw7XG5cbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2hlcyA9IHJlLmV4ZWMoc3RyKSkpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljc1ttYXRjaGVzWzFdXSA9IG5ldyBSZWdFeHAoJ1xcXFwkeycgKyBtYXRjaGVzWzFdICsgJ30nLCAnZycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgICAgID0gJycsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCAgPSBzdHI7XG5cbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGR5bmFtaWNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKGR5bmFtaWNzW2tleV0sIHR5cGVvZiBkYXRhW2tleV0gIT09ICd1bmRlZmluZWQnID8gZGF0YVtrZXldIDogJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgZWxcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgIHR5cGVcbiAgICAgICAgICogQHBhcmFtICAge2Z1bmN0aW9ufSAgICAgIGZuXG4gICAgICAgICAqIEBwYXJhbSAgIHtib29sZWFufSAgICAgICB1c2VDYXB0dXJlXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBvbjogZnVuY3Rpb24oZWwsIHR5cGUsIGZuLCB1c2VDYXB0dXJlKSB7XG4gICAgICAgICAgICBpZiAoIWVsKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgdXNlQ2FwdHVyZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZWxbJ2UnICsgdHlwZSArIGZuXSA9IGZuO1xuXG4gICAgICAgICAgICAgICAgZWxbdHlwZSArIGZuXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBlbFsnZScgKyB0eXBlICsgZm5dKHdpbmRvdy5ldmVudCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBlbFt0eXBlICsgZm5dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgIGVsXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgICB0eXBlXG4gICAgICAgICAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gICAgICBmblxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgb2ZmOiBmdW5jdGlvbihlbCwgdHlwZSwgZm4pIHtcbiAgICAgICAgICAgIGlmICghZWwpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsLmRldGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGVsW3R5cGUgKyBmbl0pO1xuICAgICAgICAgICAgICAgIGVsW3R5cGUgKyBmbl0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICAgIGV2ZW50VHlwZVxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICAgIGRldGFpbFxuICAgICAgICAgKiBAcGFyYW0gICB7RG9jdW1lbnR9ICAgIFtkb2NdXG4gICAgICAgICAqIEByZXR1cm4gIHtDdXN0b21FdmVudH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0Q3VzdG9tRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZGV0YWlsLCBkb2MpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IG51bGw7XG5cbiAgICAgICAgICAgIGRvYyA9IGRvYyB8fCB3aW5kb3cuZG9jdW1lbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGRldGFpbCxcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jLmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBkb2MuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50VHlwZSwgdHJ1ZSwgdHJ1ZSwgZGV0YWlsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBkb2MuY3JlYXRlRXZlbnRPYmplY3QoKSxcbiAgICAgICAgICAgICAgICBldmVudC50eXBlID0gZXZlbnRUeXBlO1xuXG4gICAgICAgICAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBldmVudC5kZXRhaWwgPSBkZXRhaWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge0V2ZW50fSBlXG4gICAgICAgICAqIEByZXR1cm4gIHtFdmVudH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0T3JpZ2luYWxFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudG91Y2hlc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5jaGFuZ2VkVG91Y2hlcyAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgIGVsXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgICBzZWxlY3RvclxuICAgICAgICAgKiBAcmV0dXJuICB7TnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgICAgICBpbmRleDogZnVuY3Rpb24oZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlICgoZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0b3IgfHwgZWwubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGEgZGFzaCBvciBzbmFrZS1jYXNlIHN0cmluZyB0byBjYW1lbCBjYXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICBzdHJcbiAgICAgICAgICogQHBhcmFtICAge2Jvb2xlYW59ICAgW2lzUGFzY2FsXVxuICAgICAgICAgKiBAcmV0dXJuICB7c3RyaW5nfVxuICAgICAgICAgKi9cblxuICAgICAgICBjYW1lbENhc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyhbXy1dW2Etel0pL2csIGZ1bmN0aW9uKCQxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvW18tXS8sICcnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhIGRhc2ggb3Igc25ha2UtY2FzZSBzdHJpbmcgdG8gcGFzY2FsIGNhc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIHN0clxuICAgICAgICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gICBbaXNQYXNjYWxdXG4gICAgICAgICAqIEByZXR1cm4gIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHBhc2NhbENhc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIChzdHIgPSB0aGlzLmNhbWVsQ2FzZShzdHIpKS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgYSBjYW1lbCBvciBwYXNjYWwtY2FzZSBzdHJpbmcgdG8gZGFzaCBjYXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICBzdHJcbiAgICAgICAgICogQHJldHVybiAge3N0cmluZ31cbiAgICAgICAgICovXG5cbiAgICAgICAgZGFzaENhc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS5yZXBsYWNlKC9eLS8sICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgICAgIGVsXG4gICAgICAgICAqIEBwYXJhbSAgIHtIVE1MSHRtbEVsZW1lbnR9ICAgW2RvY11cbiAgICAgICAgICogQHJldHVybiAge2Jvb2xlYW59XG4gICAgICAgICAqL1xuXG4gICAgICAgIGlzRWxlbWVudDogZnVuY3Rpb24oZWwsIGRvYykge1xuICAgICAgICAgICAgZG9jID0gZG9jIHx8IHdpbmRvdy5kb2N1bWVudDtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHdpbmRvdy5IVE1MRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIGVsIGluc3RhbmNlb2Ygd2luZG93LkhUTUxFbGVtZW50XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgZG9jLmRlZmF1bHRWaWV3ICYmXG4gICAgICAgICAgICAgICAgZG9jLmRlZmF1bHRWaWV3LkhUTUxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgZWwgaW5zdGFuY2VvZiBkb2MuZGVmYXVsdFZpZXcuSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICBlbCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBlbC5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZWwubm9kZU5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgICAgICBodG1sU3RyaW5nXG4gICAgICAgICAqIEBwYXJhbSAgIHtIVE1MSHRtbEVsZW1lbnR9ICAgW2RvY11cbiAgICAgICAgICogQHJldHVybiAge0RvY3VtZW50RnJhZ21lbnR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGh0bWxTdHJpbmcsIGRvYykge1xuICAgICAgICAgICAgdmFyIGZyYWcgPSBudWxsLFxuICAgICAgICAgICAgICAgIHRlbXAgPSBudWxsO1xuXG4gICAgICAgICAgICBkb2MgPSBkb2MgfHwgd2luZG93LmRvY3VtZW50O1xuXG4gICAgICAgICAgICBmcmFnID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIHRlbXAgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgIHRlbXAuaW5uZXJIVE1MID0gaHRtbFN0cmluZy50cmltKCk7XG5cbiAgICAgICAgICAgIHdoaWxlICh0ZW1wLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKHRlbXAuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmcmFnO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7Tm9kZX0gbm9kZVxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgcmVtb3ZlV2hpdGVzcGFjZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdmFyIGRlbGV0aW5nO1xuXG4gICAgICAgICAgICB3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVOYW1lID09PSAnI3RleHQnKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRpbmcgPSBub2RlO1xuXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgZGVsZXRpbmcucGFyZW50RWxlbWVudCAmJiBkZWxldGluZy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGRlbGV0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge0FycmF5PCo+fSAgYVxuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXk8Kj59ICBiXG4gICAgICAgICAqIEByZXR1cm4gIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICBpc0VxdWFsQXJyYXk6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBpID0gYS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChpICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICBhXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICBiXG4gICAgICAgICAqIEByZXR1cm4gIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICBkZWVwRXF1YWxzOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmIGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KGtleSkgfHwgIXRoaXMuZGVlcEVxdWFscyhhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXk8Kj59ICBvbGRBcnJheVxuICAgICAgICAgKiBAcmV0dXJuICB7QXJyYXk8Kj59XG4gICAgICAgICAqL1xuXG4gICAgICAgIGFycmF5U2h1ZmZsZTogZnVuY3Rpb24ob2xkQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBuZXdBcnJheSAgICA9IG9sZEFycmF5LnNsaWNlKCksXG4gICAgICAgICAgICAgICAgbGVuICAgICAgICAgPSBuZXdBcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgPSBsZW4sXG4gICAgICAgICAgICAgICAgcCAgICAgICAgICAgPSAtMSxcbiAgICAgICAgICAgICAgICB0ICAgICAgICAgICA9IFtdO1xuXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgcCA9IH5+KE1hdGgucmFuZG9tKCkgKiBsZW4pO1xuICAgICAgICAgICAgICAgIHQgPSBuZXdBcnJheVtpXTtcblxuICAgICAgICAgICAgICAgIG5ld0FycmF5W2ldID0gbmV3QXJyYXlbcF07XG4gICAgICAgICAgICAgICAgbmV3QXJyYXlbcF0gPSB0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3QXJyYXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgIGxpc3RcbiAgICAgICAgICovXG5cbiAgICAgICAgYXJyYXlGcm9tTGlzdDogZnVuY3Rpb24obGlzdCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCwgaTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCk7XG4gICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gobGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge2Z1bmN0aW9ufSAgZnVuY1xuICAgICAgICAgKiBAcGFyYW0gICB7TnVtYmVyfSAgICB3YWl0XG4gICAgICAgICAqIEBwYXJhbSAgIHtib29sZWFufSAgIGltbWVkaWF0ZVxuICAgICAgICAgKiBAcmV0dXJuICB7ZnVuY3Rpb259XG4gICAgICAgICAqL1xuXG4gICAgICAgIGRlYm91bmNlOiBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0O1xuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYXJncyAgICAgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxOb3cgID0gaW1tZWRpYXRlICYmICF0aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICBsYXRlciAgICA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ICA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxOb3cpIGZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgZWxlbWVudFxuICAgICAgICAgKiBAcmV0dXJuICB7b2JqZWN0fVxuICAgICAgICAgKi9cblxuICAgICAgICBwb3NpdGlvbjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHhQb3NpdGlvbiAgICAgICA9IDAsXG4gICAgICAgICAgICAgICAgeVBvc2l0aW9uICAgICAgID0gMCxcbiAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgICAgPSBlbGVtZW50O1xuXG4gICAgICAgICAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHhQb3NpdGlvbiAtPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgeVBvc2l0aW9uIC09IGVsZW1lbnQuc2Nyb2xsVG9wO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IG9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB4UG9zaXRpb24gKz0gZWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB5UG9zaXRpb24gKz0gZWxlbWVudC5vZmZzZXRUb3A7XG5cbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgeTogeVBvc2l0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICBub2RlMVxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICBub2RlMlxuICAgICAgICAgKiBAcmV0dXJuICB7TnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXRIeXBvdGVudXNlOiBmdW5jdGlvbihub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZVggPSBub2RlMS54IC0gbm9kZTIueCxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZVkgPSBub2RlMS55IC0gbm9kZTIueTtcblxuICAgICAgICAgICAgZGlzdGFuY2VYID0gZGlzdGFuY2VYIDwgMCA/IGRpc3RhbmNlWCAqIC0xIDogZGlzdGFuY2VYLFxuICAgICAgICAgICAgZGlzdGFuY2VZID0gZGlzdGFuY2VZIDwgMCA/IGRpc3RhbmNlWSAqIC0xIDogZGlzdGFuY2VZO1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRpc3RhbmNlWCwgMikgKyBNYXRoLnBvdyhkaXN0YW5jZVksIDIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VhdGVzIHRoZSBhcmVhIG9mIGludGVyc2VjdGlvbiBiZXR3ZWVuIHR3byByZWN0YW5nbGVzIGFuZCBleHByZXNzZXMgaXQgYXNcbiAgICAgICAgICogYSByYXRpbyBpbiBjb21wYXJpc29uIHRvIHRoZSBhcmVhIG9mIHRoZSBmaXJzdCByZWN0YW5nbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtSZWN0fSAgYm94MVxuICAgICAgICAgKiBAcGFyYW0gICB7UmVjdH0gIGJveDJcbiAgICAgICAgICogQHJldHVybiAge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0SW50ZXJzZWN0aW9uUmF0aW86IGZ1bmN0aW9uKGJveDEsIGJveDIpIHtcbiAgICAgICAgICAgIHZhciBjb250cm9sQXJlYSAgICAgICAgID0gYm94MS53aWR0aCAqIGJveDEuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblggICAgICAgPSAtMSxcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25ZICAgICAgID0gLTEsXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uQXJlYSAgICA9IC0xLFxuICAgICAgICAgICAgICAgIHJhdGlvICAgICAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uWCA9XG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgTWF0aC5taW4oYm94MS5sZWZ0ICsgYm94MS53aWR0aCwgYm94Mi5sZWZ0ICsgYm94Mi53aWR0aCkgLSBNYXRoLm1heChib3gxLmxlZnQsIGJveDIubGVmdCkpO1xuXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25ZID1cbiAgICAgICAgICAgICAgICBNYXRoLm1heCgwLCBNYXRoLm1pbihib3gxLnRvcCArIGJveDEuaGVpZ2h0LCBib3gyLnRvcCArIGJveDIuaGVpZ2h0KSAtIE1hdGgubWF4KGJveDEudG9wLCBib3gyLnRvcCkpO1xuXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25BcmVhID0gaW50ZXJzZWN0aW9uWSAqIGludGVyc2VjdGlvblg7XG5cbiAgICAgICAgICAgIHJhdGlvID0gaW50ZXJzZWN0aW9uQXJlYSAvIGNvbnRyb2xBcmVhO1xuXG4gICAgICAgICAgICByZXR1cm4gcmF0aW87XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgICAgICAgICAgZWxcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgICAgICBzZWxlY3RvclxuICAgICAgICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gICAgICAgICAgIFtpbmNsdWRlU2VsZl1cbiAgICAgICAgICogQHBhcmFtICAge0hUTUxIdG1sRWxlbWVudH0gICBbZG9jXVxuICAgICAgICAgKiBAcmV0dXJuICB7RWxlbWVudHxudWxsfVxuICAgICAgICAgKi9cblxuICAgICAgICBjbG9zZXN0UGFyZW50OiBmdW5jdGlvbihlbCwgc2VsZWN0b3IsIGluY2x1ZGVTZWxmLCBkb2MpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgID0gZWwucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgZG9jID0gZG9jIHx8IHdpbmRvdy5kb2N1bWVudDtcblxuICAgICAgICAgICAgaWYgKGluY2x1ZGVTZWxmICYmIGVsLm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudCAhPSBkb2MuYm9keSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQubWF0Y2hlcyAmJiBwYXJlbnQubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gICAgICAgZWxcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgICAgICBzZWxlY3RvclxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEh0bWxFbGVtZW50fSAgIFtkb2NdXG4gICAgICAgICAqIEByZXR1cm4gIHtOb2RlTGlzdH1cbiAgICAgICAgICovXG5cbiAgICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uKGVsLCBzZWxlY3RvciwgZG9jKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gICAgPSBbXSxcbiAgICAgICAgICAgICAgICB0ZW1wSWQgICAgICA9ICcnO1xuXG4gICAgICAgICAgICBkb2MgPSBkb2MgfHwgd2luZG93LmRvYztcblxuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbC5pZCkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wSWQgPSAnVGVtcCcgKyB0aGlzLnJhbmRvbUhleEtleSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGVsLmlkID0gdGVtcElkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoJyMnICsgZWwuaWQgKyAnID4gJyArIHNlbGVjdG9yKTtcblxuICAgICAgICAgICAgICAgIGlmICh0ZW1wSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYSBwcm92aWRlZCBhcnJheSwgd2l0aCBhbnkgZW1wdHkgc3RyaW5ncyByZW1vdmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXk8Kj59IG9yaWdpbmFsQXJyYXlcbiAgICAgICAgICogQHJldHVybiAge0FycmF5PCo+fVxuICAgICAgICAgKi9cblxuICAgICAgICBjbGVhbjogZnVuY3Rpb24ob3JpZ2luYWxBcnJheSkge1xuICAgICAgICAgICAgdmFyIGNsZWFuQXJyYXkgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gLTE7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcmlnaW5hbEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsQXJyYXlbaV0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuQXJyYXkucHVzaChvcmlnaW5hbEFycmF5W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjbGVhbkFycmF5O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBYnN0cmFjdHMgYW4gRVM2IHByb21pc2UgaW50byBhIHEtbGlrZSBkZWZlcnJlZCBpbnRlcmZhY2UgZm9yIHN0b3JhZ2UgYW5kIGRlZmVycmVkIHJlc29sdXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAge29iamVjdH0gbGlicmFyaWVzXG4gICAgICAgICAqIEByZXR1cm4ge2guRGVmZXJyZWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGRlZmVyOiBmdW5jdGlvbihsaWJyYXJpZXMpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgcHJvbWlzZVdyYXBwZXIgPSBudWxsLFxuICAgICAgICAgICAgICAgICQgICAgICAgICAgICAgID0gbnVsbDtcblxuICAgICAgICAgICAgcHJvbWlzZVdyYXBwZXIgPSBuZXcgdGhpcy5EZWZlcnJlZCgpO1xuXG4gICAgICAgICAgICBpZiAobWl4aXR1cC5mZWF0dXJlcy5oYXMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBFUzYgbmF0aXZlIHByb21pc2Ugb3IgcG9seWZpbGxcblxuICAgICAgICAgICAgICAgIHByb21pc2VXcmFwcGVyLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVdyYXBwZXIucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VXcmFwcGVyLnJlamVjdCAgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgkID0gKHdpbmRvdy5qUXVlcnkgfHwgbGlicmFyaWVzLiQpKSAmJiB0eXBlb2YgJC5EZWZlcnJlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIGpRdWVyeVxuXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XG5cbiAgICAgICAgICAgICAgICBwcm9taXNlV3JhcHBlci5wcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHByb21pc2VXcmFwcGVyLnJlc29sdmUgPSBkZWZlcnJlZC5yZXNvbHZlO1xuICAgICAgICAgICAgICAgIHByb21pc2VXcmFwcGVyLnJlamVjdCAgPSBkZWZlcnJlZC5yZWplY3Q7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gaW1wbGVtZW50YXRpb25cblxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihtaXhpdHVwLm1lc3NhZ2VzLndhcm5pbmdOb1Byb21pc2VJbXBsZW1lbnRhdGlvbigpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VXcmFwcGVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXk8UHJvbWlzZT59ICAgIHRhc2tzXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgICAgICAgICAgbGlicmFyaWVzXG4gICAgICAgICAqIEByZXR1cm4gIHtQcm9taXNlPEFycmF5Pn1cbiAgICAgICAgICovXG5cbiAgICAgICAgYWxsOiBmdW5jdGlvbih0YXNrcywgbGlicmFyaWVzKSB7XG4gICAgICAgICAgICB2YXIgJCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChtaXhpdHVwLmZlYXR1cmVzLmhhcy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0YXNrcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgkID0gKHdpbmRvdy5qUXVlcnkgfHwgbGlicmFyaWVzLiQpKSAmJiB0eXBlb2YgJC53aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQud2hlbi5hcHBseSgkLCB0YXNrcylcbiAgICAgICAgICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqUXVlcnkgd2hlbiByZXR1cm5zIHNwcmVhZCBhcmd1bWVudHMgcmF0aGVyIHRoYW4gYW4gYXJyYXkgb3IgcmVzb2x1dGlvbnNcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vIGltcGxlbWVudGF0aW9uXG5cbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihtaXhpdHVwLm1lc3NhZ2VzLndhcm5pbmdOb1Byb21pc2VJbXBsZW1lbnRhdGlvbigpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgZWxcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgIHByb3BlcnR5XG4gICAgICAgICAqIEBwYXJhbSAgIHtBcnJheTxzdHJpbmc+fSB2ZW5kb3JzXG4gICAgICAgICAqIEByZXR1cm4gIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGdldFByZWZpeDogZnVuY3Rpb24oZWwsIHByb3BlcnR5LCB2ZW5kb3JzKSB7XG4gICAgICAgICAgICB2YXIgaSAgICAgICA9IC0xLFxuICAgICAgICAgICAgICAgIHByZWZpeCAgPSAnJztcblxuICAgICAgICAgICAgaWYgKGguZGFzaENhc2UocHJvcGVydHkpIGluIGVsLnN0eWxlKSByZXR1cm4gJyc7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHByZWZpeCA9IHZlbmRvcnNbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggKyBwcm9wZXJ0eSBpbiBlbC5zdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJ3Vuc3VwcG9ydGVkJztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHJldHVybiAge3N0cmluZ31cbiAgICAgICAgICovXG5cbiAgICAgICAgcmFuZG9tSGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAoJzAwMDAwJyArIChNYXRoLnJhbmRvbSgpICogMTY3NzcyMTYgPDwgMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtIVE1MRG9jdW1lbnR9ICBbZG9jXVxuICAgICAgICAgKiBAcmV0dXJuICB7b2JqZWN0fVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXREb2N1bWVudFN0YXRlOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICAgIGRvYyA9IHR5cGVvZiBkb2MuYm9keSA9PT0gJ29iamVjdCcgPyBkb2MgOiB3aW5kb3cuZG9jdW1lbnQ7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsTGVmdDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGRvY0hlaWdodDogZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsXG4gICAgICAgICAgICAgICAgZG9jV2lkdGg6IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGgsXG4gICAgICAgICAgICAgICAgdmlld3BvcnRIZWlnaHQ6IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0V2lkdGg6IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgIG9ialxuICAgICAgICAgKiBAcGFyYW0gICB7ZnVuY3Rpb259ICBmblxuICAgICAgICAgKiBAcmV0dXJuICB7ZnVuY3Rpb259XG4gICAgICAgICAqL1xuXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uKG9iaiwgZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgIGVsXG4gICAgICAgICAqIEByZXR1cm4gIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICBpc1Zpc2libGU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVzID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKGVsLm9mZnNldFBhcmVudCkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0eWxlcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyAmJlxuICAgICAgICAgICAgICAgIHN0eWxlcy52aXNpYmlsaXR5ICE9PSAnaGlkZGVuJyAmJlxuICAgICAgICAgICAgICAgIHN0eWxlcy5vcGFjaXR5ICE9PSAnMCdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIEZpeGVkIGVsZW1lbnRzIHJlcG9ydCBubyBvZmZzZXRQYXJlbnQsXG4gICAgICAgICAgICAgICAgLy8gYnV0IG1heSBzdGlsbCBiZSBpbnZpc2libGVcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgIG9ialxuICAgICAgICAgKi9cblxuICAgICAgICBzZWFsOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LnNlYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Quc2VhbChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICBvYmpcbiAgICAgICAgICovXG5cbiAgICAgICAgZnJlZXplOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmZyZWV6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgY29udHJvbFxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICBzcGVjaW1lblxuICAgICAgICAgKiBAcmV0dXJuICB7Ym9vbGVhbn1cbiAgICAgICAgICovXG5cbiAgICAgICAgY29tcGFyZVZlcnNpb25zOiBmdW5jdGlvbihjb250cm9sLCBzcGVjaW1lbikge1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xQYXJ0cyAgICA9IGNvbnRyb2wuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICBzcGVjaW1lblBhcnRzICAgPSBzcGVjaW1lbi5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xQYXJ0ICAgICA9IC0xLFxuICAgICAgICAgICAgICAgIHNwZWNpbWVuUGFydCAgICA9IC0xLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29udHJvbFBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbFBhcnQgICAgID0gcGFyc2VJbnQoY29udHJvbFBhcnRzW2ldLnJlcGxhY2UoL1teXFxkLl0vZywgJycpKTtcbiAgICAgICAgICAgICAgICBzcGVjaW1lblBhcnQgICAgPSBwYXJzZUludChzcGVjaW1lblBhcnRzW2ldLnJlcGxhY2UoL1teXFxkLl0vZywgJycpIHx8IDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpbWVuUGFydCA8IGNvbnRyb2xQYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNpbWVuUGFydCA+IGNvbnRyb2xQYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKi9cblxuICAgICAgICBEZWZlcnJlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnByb21pc2UgICAgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlICAgID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ICAgICA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmlkICAgICAgICAgPSBoLnJhbmRvbUhleCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgb2JqXG4gICAgICAgICAqIEByZXR1cm4gIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSAnJztcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gICB7bWl4aXR1cC5Db25maWcuQ2xhc3NOYW1lc30gICBjbGFzc05hbWVzXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnROYW1lXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgIFttb2RpZmllcl1cbiAgICAgICAgICogQHJldHVybiAge3N0cmluZ31cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0Q2xhc3NuYW1lOiBmdW5jdGlvbihjbGFzc05hbWVzLCBlbGVtZW50TmFtZSwgbW9kaWZpZXIpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc25hbWUgPSAnJztcblxuICAgICAgICAgICAgY2xhc3NuYW1lICs9IGNsYXNzTmFtZXMuYmxvY2s7XG5cbiAgICAgICAgICAgIGlmIChjbGFzc25hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NuYW1lICs9IGNsYXNzTmFtZXMuZGVsaW5lYXRvckVsZW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsYXNzbmFtZSArPSBjbGFzc05hbWVzWydlbGVtZW50JyArIHRoaXMucGFzY2FsQ2FzZShlbGVtZW50TmFtZSldO1xuXG4gICAgICAgICAgICBpZiAoIW1vZGlmaWVyKSByZXR1cm4gY2xhc3NuYW1lO1xuXG4gICAgICAgICAgICBpZiAoY2xhc3NuYW1lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNsYXNzbmFtZSArPSBjbGFzc05hbWVzLmRlbGluZWF0b3JNb2RpZmllcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xhc3NuYW1lICs9IG1vZGlmaWVyO1xuXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NuYW1lO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IG9uIGEgZ2l2ZW4gb2JqZWN0IHZpYSBpdHMgc3RyaW5nIGtleS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAge29iamVjdH0gICAgb2JqXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIHN0cmluZ0tleVxuICAgICAgICAgKiBAcmV0dXJuICB7Kn0gdmFsdWVcbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0UHJvcGVydHk6IGZ1bmN0aW9uKG9iaiwgc3RyaW5nS2V5KSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgICAgICAgICAgID0gc3RyaW5nS2V5LnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAgcmV0dXJuQ3VycmVudCAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBjdXJyZW50ICAgICAgICAgPSAnJyxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAwO1xuXG4gICAgICAgICAgICBpZiAoIXN0cmluZ0tleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybkN1cnJlbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2N1cnJlbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHdoaWxlIChpIDwgcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHBhcnRzW2ldO1xuXG4gICAgICAgICAgICAgICAgb2JqID0gcmV0dXJuQ3VycmVudChvYmopO1xuXG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtaXhpdHVwLmggPSBoO1xuXG4gICAgLyoqXG4gICAgICogVGhlIEJhc2UgY2xhc3MgYWRkcyBpbnN0YW5jZSBtZXRob2RzIHRvIGFsbCBvdGhlciBleHRlbnNpYmxlIE1peEl0VXAgY2xhc3NlcyxcbiAgICAgKiBlbmFibGluZyB0aGUgY2FsbGluZyBvZiBhbnkgcmVnaXN0ZXJlZCBob29rcy5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkJhc2UgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgbWl4aXR1cC5CYXNlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IG1peGl0dXAuQmFzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbHMgYW55IHJlZ2lzdGVyZWQgaG9va3MgZm9yIHRoZSBwcm92aWRlZCBhY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkJhc2VcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgICAgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgYWN0aW9uTmFtZVxuICAgICAgICAgKiBAcGFyYW0gICAgICAge0FycmF5PCo+fSAgYXJnc1xuICAgICAgICAgKiBAcmV0dXJuICAgICAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGNhbGxBY3Rpb25zOiBmdW5jdGlvbihhY3Rpb25OYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBob29rcyAgICAgICAgICAgPSBzZWxmLmNvbnN0cnVjdG9yLmFjdGlvbnNbYWN0aW9uTmFtZV0sXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uTmFtZSAgID0gJyc7XG5cbiAgICAgICAgICAgIGlmICghaG9va3MgfHwgaC5pc0VtcHR5T2JqZWN0KGhvb2tzKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBmb3IgKGV4dGVuc2lvbk5hbWUgaW4gaG9va3MpIHtcbiAgICAgICAgICAgICAgICBob29rc1tleHRlbnNpb25OYW1lXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbHMgYW55IHJlZ2lzdGVyZWQgaG9va3MgZm9yIHRoZSBwcm92aWRlZCBmaWx0ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkJhc2VcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgICAgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgZmlsdGVyTmFtZVxuICAgICAgICAgKiBAcGFyYW0gICAgICAgeyp9ICAgICAgICAgaW5wdXRcbiAgICAgICAgICogQHBhcmFtICAgICAgIHtBcnJheTwqPn0gIGFyZ3NcbiAgICAgICAgICogQHJldHVybiAgICAgIHsqfVxuICAgICAgICAgKi9cblxuICAgICAgICBjYWxsRmlsdGVyczogZnVuY3Rpb24oZmlsdGVyTmFtZSwgaW5wdXQsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGhvb2tzICAgICAgICAgICA9IHNlbGYuY29uc3RydWN0b3IuZmlsdGVyc1tmaWx0ZXJOYW1lXSxcbiAgICAgICAgICAgICAgICBvdXRwdXQgICAgICAgICAgPSBpbnB1dCxcbiAgICAgICAgICAgICAgICBleHRlbnNpb25OYW1lICAgPSAnJztcblxuICAgICAgICAgICAgaWYgKCFob29rcyB8fCBoLmlzRW1wdHlPYmplY3QoaG9va3MpKSByZXR1cm4gb3V0cHV0O1xuXG4gICAgICAgICAgICBhcmdzID0gYXJncyB8fCBbXTtcblxuICAgICAgICAgICAgZm9yIChleHRlbnNpb25OYW1lIGluIGhvb2tzKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IGguYXJyYXlGcm9tTGlzdChhcmdzKTtcblxuICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChvdXRwdXQpO1xuXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gaG9va3NbZXh0ZW5zaW9uTmFtZV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIEJhc2VTdGF0aWMgY2xhc3MgaG9sZHMgYSBzZXQgb2Ygc3RhdGljIG1ldGhvZHMgd2hpY2ggYXJlIHRoZW4gYWRkZWQgdG8gYWxsIG90aGVyXG4gICAgICogZXh0ZW5zaWJsZSBNaXhJdFVwIGNsYXNzZXMgYXMgYSBtZWFucyBvZiBpbnRlZ3JhdGluZyBleHRlbnNpb25zIHZpYSB0aGUgYWRkaXRpb24gb2YgbmV3XG4gICAgICogbWV0aG9kcyBhbmQvb3IgYWN0aW9ucyBhbmQgaG9va3MuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgYSBzaGFsbG93IGV4dGVuZCBvbiB0aGUgY2xhc3MncyBwcm90b3R5cGUsIGFkZGluZyBvbmUgb3IgbW9yZSBuZXcgbWVtYmVycyB0b1xuICAgICAgICAgKiB0aGUgY2xhc3MgaW4gYSBzaW5nbGUgb3BlcmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5CYXNlU3RhdGljXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAc2luY2UgICAgICAgMi4xLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHtvYmplY3R9IGV4dGVuc2lvblxuICAgICAgICAgKiBAcmV0dXJuICAgICAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuZXh0ZW5kID0gZnVuY3Rpb24oZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBoLmV4dGVuZCh0aGlzLnByb3RvdHlwZSwgZXh0ZW5zaW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXJzIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIHRoZSBhY3Rpb24gaG9vayBvZiB0aGUgcHJvdmlkZWQgbmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQmFzZVN0YXRpY1xuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHNpbmNlICAgICAgIDIuMS4wXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICBob29rTmFtZVxuICAgICAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgZXh0ZW5zaW9uTmFtZVxuICAgICAgICAgKiBAcGFyYW0gICAgICAge2Z1bmN0aW9ufSAgZnVuY1xuICAgICAgICAgKiBAcmV0dXJuICAgICAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJBY3Rpb24gPSBmdW5jdGlvbihob29rTmFtZSwgZXh0ZW5zaW9uTmFtZSwgZnVuYykge1xuICAgICAgICAgICAgKHRoaXMuYWN0aW9uc1tob29rTmFtZV0gPSB0aGlzLmFjdGlvbnNbaG9va05hbWVdIHx8IHt9KVtleHRlbnNpb25OYW1lXSA9IGZ1bmM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVycyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiB0aGUgZmlsdGVyIG9mIHRoZSBwcm92aWRlZCBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5CYXNlU3RhdGljXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAc2luY2UgICAgICAgMi4xLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgIGhvb2tOYW1lXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICBleHRlbnNpb25OYW1lXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7ZnVuY3Rpb259ICBmdW5jXG4gICAgICAgICAqIEByZXR1cm4gICAgICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5yZWdpc3RlckZpbHRlciA9IGZ1bmN0aW9uKGhvb2tOYW1lLCBleHRlbnNpb25OYW1lLCBmdW5jKSB7XG4gICAgICAgICAgICAodGhpcy5maWx0ZXJzW2hvb2tOYW1lXSA9IHRoaXMuZmlsdGVyc1tob29rTmFtZV0gfHwge30pW2V4dGVuc2lvbk5hbWVdID0gZnVuYztcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBtaXhpdHVwLkZlYXR1cmVzYCBjbGFzcyBwZXJmb3JtcyBhbGwgZmVhdHVyZSBhbmQgQ1NTIHByZWZpeCBkZXRlY3Rpb25cbiAgICAgKiBuZWNjZXNzYXJ5IGZvciBNaXhJdFVwIHRvIGZ1bmN0aW9uIGNvcnJlY3RseSwgYXMgd2VsbCBhcyBzdG9yaW5nIHZhcmlvdXNcbiAgICAgKiBzdHJpbmcgYW5kIGFycmF5IGNvbnN0YW50cy4gQWxsIGZlYXR1cmUgZGVjZWN0aW9uIGlzIG9uIGV2YWx1YXRpb24gb2YgdGhlXG4gICAgICogbGlicmFyeSBhbmQgc3RvcmVkIGluIGEgc2luZ2xldG9uIGluc3RhbmNlIGZvciB1c2UgYnkgb3RoZXIgaW50ZXJuYWwgY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkZlYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1peGl0dXAuQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbnN0cnVjdCcpO1xuXG4gICAgICAgIHRoaXMuYm94U2l6aW5nUHJlZml4ICAgICAgICAgICAgPSAnJztcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1QcmVmaXggICAgICAgICAgICA9ICcnO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25QcmVmaXggICAgICAgICAgID0gJyc7XG5cbiAgICAgICAgdGhpcy5ib3hTaXppbmdQcmVmaXggICAgICAgICAgICA9ICcnO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybVByb3AgICAgICAgICAgICAgID0gJyc7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtUnVsZSAgICAgICAgICAgICAgPSAnJztcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uUHJvcCAgICAgICAgICAgICA9ICcnO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlUHJvcCAgICAgICAgICAgID0gJyc7XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVPcmlnaW5Qcm9wICAgICAgPSAnJztcblxuICAgICAgICB0aGlzLmhhcyAgICAgICAgICAgICAgICAgICAgICAgID0gbmV3IG1peGl0dXAuSGFzKCk7XG5cbiAgICAgICAgdGhpcy5jYW5hcnkgICAgICAgICAgICAgICAgICAgICA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5CT1hfU0laSU5HX1BST1AgICAgICAgICAgICA9ICdib3hTaXppbmcnO1xuICAgICAgICB0aGlzLlRSQU5TSVRJT05fUFJPUCAgICAgICAgICAgID0gJ3RyYW5zaXRpb24nO1xuICAgICAgICB0aGlzLlRSQU5TRk9STV9QUk9QICAgICAgICAgICAgID0gJ3RyYW5zZm9ybSc7XG4gICAgICAgIHRoaXMuUEVSU1BFQ1RJVkVfUFJPUCAgICAgICAgICAgPSAncGVyc3BlY3RpdmUnO1xuICAgICAgICB0aGlzLlBFUlNQRUNUSVZFX09SSUdJTl9QUk9QICAgID0gJ3BlcnNwZWN0aXZlT3JpZ2luJztcbiAgICAgICAgdGhpcy5WRU5ET1JTICAgICAgICAgICAgICAgICAgICA9IFsnV2Via2l0JywgJ21veicsICdPJywgJ21zJ107XG5cbiAgICAgICAgdGhpcy5UV0VFTkFCTEUgPSBbXG4gICAgICAgICAgICAnb3BhY2l0eScsXG4gICAgICAgICAgICAnd2lkdGgnLCAnaGVpZ2h0JyxcbiAgICAgICAgICAgICdtYXJnaW5SaWdodCcsICdtYXJnaW5Cb3R0b20nLFxuICAgICAgICAgICAgJ3gnLCAneScsXG4gICAgICAgICAgICAnc2NhbGUnLFxuICAgICAgICAgICAgJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICd0cmFuc2xhdGVaJyxcbiAgICAgICAgICAgICdyb3RhdGVYJywgJ3JvdGF0ZVknLCAncm90YXRlWidcbiAgICAgICAgXTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkZlYXR1cmVzKTtcblxuICAgIG1peGl0dXAuRmVhdHVyZXMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIGguZXh0ZW5kKG1peGl0dXAuRmVhdHVyZXMucHJvdG90eXBlLFxuICAgIC8qKiBAbGVuZHMgbWl4aXR1cC5GZWF0dXJlcyAqL1xuICAgIHtcbiAgICAgICAgY29uc3RydWN0b3I6IG1peGl0dXAuRmVhdHVyZXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlSW5pdCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYuY2FuYXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgIHNlbGYuc2V0UHJlZml4ZXMoKTtcbiAgICAgICAgICAgIHNlbGYucnVuVGVzdHMoKTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlSW5pdCcsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBydW5UZXN0czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVJ1blRlc3RzJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5oYXMucHJvbWlzZXMgICAgICAgPSB0eXBlb2Ygd2luZG93LlByb21pc2UgPT09ICdmdW5jdGlvbic7XG4gICAgICAgICAgICBzZWxmLmhhcy50cmFuc2l0aW9ucyAgICA9IHNlbGYudHJhbnNpdGlvblByZWZpeCAhPT0gJ3Vuc3VwcG9ydGVkJztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJSdW5UZXN0cycsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGguZnJlZXplKHNlbGYuaGFzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHNldFByZWZpeGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlU2V0UHJlZml4ZXMnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBzZWxmLnRyYW5zaXRpb25QcmVmaXggICA9IGguZ2V0UHJlZml4KHNlbGYuY2FuYXJ5LCAnVHJhbnNpdGlvbicsIHNlbGYuVkVORE9SUyk7XG4gICAgICAgICAgICBzZWxmLnRyYW5zZm9ybVByZWZpeCAgICA9IGguZ2V0UHJlZml4KHNlbGYuY2FuYXJ5LCAnVHJhbnNmb3JtJywgc2VsZi5WRU5ET1JTKTtcbiAgICAgICAgICAgIHNlbGYuYm94U2l6aW5nUHJlZml4ICAgID0gaC5nZXRQcmVmaXgoc2VsZi5jYW5hcnksICdCb3hTaXppbmcnLCBzZWxmLlZFTkRPUlMpO1xuXG4gICAgICAgICAgICBzZWxmLmJveFNpemluZ1Byb3AgPSBzZWxmLmJveFNpemluZ1ByZWZpeCA/XG4gICAgICAgICAgICAgICAgc2VsZi5ib3hTaXppbmdQcmVmaXggKyBoLnBhc2NhbENhc2Uoc2VsZi5CT1hfU0laSU5HX1BST1ApIDogc2VsZi5CT1hfU0laSU5HX1BST1A7XG5cbiAgICAgICAgICAgIHNlbGYudHJhbnNpdGlvblByb3AgPSBzZWxmLnRyYW5zaXRpb25QcmVmaXggP1xuICAgICAgICAgICAgICAgIHNlbGYudHJhbnNpdGlvblByZWZpeCArIGgucGFzY2FsQ2FzZShzZWxmLlRSQU5TSVRJT05fUFJPUCkgOiBzZWxmLlRSQU5TSVRJT05fUFJPUDtcblxuICAgICAgICAgICAgc2VsZi50cmFuc2Zvcm1Qcm9wID0gc2VsZi50cmFuc2Zvcm1QcmVmaXggP1xuICAgICAgICAgICAgICAgIHNlbGYudHJhbnNmb3JtUHJlZml4ICsgaC5wYXNjYWxDYXNlKHNlbGYuVFJBTlNGT1JNX1BST1ApIDogc2VsZi5UUkFOU0ZPUk1fUFJPUDtcblxuICAgICAgICAgICAgc2VsZi50cmFuc2Zvcm1SdWxlID0gc2VsZi50cmFuc2Zvcm1QcmVmaXggP1xuICAgICAgICAgICAgICAgICctJyArIHNlbGYudHJhbnNmb3JtUHJlZml4ICsgJy0nICsgc2VsZi5UUkFOU0ZPUk1fUFJPUCA6IHNlbGYuVFJBTlNGT1JNX1BST1A7XG5cbiAgICAgICAgICAgIHNlbGYucGVyc3BlY3RpdmVQcm9wID0gc2VsZi50cmFuc2Zvcm1QcmVmaXggP1xuICAgICAgICAgICAgICAgIHNlbGYudHJhbnNmb3JtUHJlZml4ICsgaC5wYXNjYWxDYXNlKHNlbGYuUEVSU1BFQ1RJVkVfUFJPUCkgOiBzZWxmLlBFUlNQRUNUSVZFX1BST1A7XG5cbiAgICAgICAgICAgIHNlbGYucGVyc3BlY3RpdmVPcmlnaW5Qcm9wID0gc2VsZi50cmFuc2Zvcm1QcmVmaXggP1xuICAgICAgICAgICAgICAgIHNlbGYudHJhbnNmb3JtUHJlZml4ICsgaC5wYXNjYWxDYXNlKHNlbGYuUEVSU1BFQ1RJVkVfT1JJR0lOX1BST1ApIDpcbiAgICAgICAgICAgICAgICBzZWxmLlBFUlNQRUNUSVZFX09SSUdJTl9QUk9QO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlclNldFByZWZpeGVzJywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5IYXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9ucyAgICA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb21pc2VzICAgICAgID0gZmFsc2U7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICAvLyBBc3NpZ24gYSBzaW5nbGV0b24gaW5zdGFuY2UgdG8gYG1peGl0dXAuZmVhdHVyZXNgIGFuZCBpbml0aWFsaXNlOlxuXG4gICAgbWl4aXR1cC5mZWF0dXJlcyA9IG5ldyBtaXhpdHVwLkZlYXR1cmVzKCk7XG5cbiAgICBtaXhpdHVwLmZlYXR1cmVzLmluaXQoKTtcblxuICAgIC8qKlxuICAgICAqIEEgZ3JvdXAgb2YgcHJvcGVydGllcyBkZWZpbmluZyB0aGUgbWl4ZXIncyBhbmltYXRpb24gYW5kIGVmZmVjdHMgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWdcbiAgICAgKiBAbmFtZSAgICAgICAgYW5pbWF0aW9uXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAc2luY2UgICAgICAgMi4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1peGl0dXAuQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbnN0cnVjdCcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgb3Igbm90IGFuaW1hdGlvbiBzaG91bGQgYmUgZW5hYmxlZCBmb3IgdGhlIE1peEl0VXAgaW5zdGFuY2UuXG4gICAgICAgICAqIElmIGBmYWxzZWAsIGFsbCBvcGVyYXRpb25zIHdpbGwgb2NjdXIgaW5zdGFudGx5IGFuZCBzeW5jcm9ub3VzbHksIGFsdGhvdWdoIGNhbGxiYWNrXG4gICAgICAgICAqIGZ1bmN0aW9ucyBhbmQgYW55IHJldHVybmVkIHByb21pc2VzIHdpbGwgc3RpbGwgYmUgZnVsZmlsbGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBDcmVhdGUgYSBtaXhlciB3aXRoIGFsbCBhbmltYXRpb25zIGRpc2FibGVkPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBlbmFibGU6IGZhbHNlXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgZW5hYmxlXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIHRydWVcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5lbmFibGUgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN0cmluZyBvZiBvbmUgb3IgbW9yZSBzcGFjZS1zZXBlcmF0ZWQgcHJvcGVydGllcyB0byB3aGljaCB0cmFuc2l0aW9ucyB3aWxsIGJlXG4gICAgICAgICAqIGFwcGxpZWQgZm9yIGFsbCBmaWx0ZXJpbmcgYW5pbWF0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogUHJvcGVydGllcyBjYW4gYmUgbGlzdGVkIGFueSBvcmRlciBvciBjb21iaW5hdGlvbiwgYWx0aG91Z2ggdGhleSB3aWxsIGJlIGFwcGxpZWQgaW4gYSBzcGVjaWZpY1xuICAgICAgICAgKiBwcmVkZWZpbmVkIG9yZGVyIHRvIHByb2R1Y2UgY29uc2lzdGVudCByZXN1bHRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyBsZWFybiBtb3JlIGFib3V0IGF2YWlsYWJsZSBlZmZlY3RzLCBleHBlcmltZW50IHdpdGggb3VyIDxhIGhyZWY9XCJodHRwczovL3d3dy5rdW5rYWxhYnMuY29tL21peGl0dXAvXCI+XG4gICAgICAgICAqIHNhbmRib3ggZGVtbzwvYT4gYW5kIHRyeSBvdXQgdGhlIFwiRXhwb3J0IGNvbmZpZ1wiIGJ1dHRvbiBpbiB0aGUgQW5pbWF0aW9uIG9wdGlvbnMgZHJvcCBkb3duLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBBcHBseSBcImZhZGVcIiBhbmQgXCJ0cmFuc2xhdGVaXCIgZWZmZWN0cyB0byBhbGwgYW5pbWF0aW9uczwvY2FwdGlvbj5cbiAgICAgICAgICogLy8gQXMgdGFyZ2V0cyBhcmUgZmlsdGVyZWQgaW4gYW5kIG91dCwgdGhleSB3aWxsIGZhZGUgYmV0d2VlblxuICAgICAgICAgKiAvLyBvcGFjaXR5IDEgYW5kIDAgYW5kIHRyYW5zZm9ybSBiZXR3ZWVuIHRyYW5zbGF0ZVooLTEwMHB4KSBhbmRcbiAgICAgICAgICogLy8gdHJhbnNsYXRlWigwKS5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgZWZmZWN0czogJ2ZhZGUgdHJhbnNsYXRlWigtMTAwcHgpJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGVmZmVjdHNcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmFuaW1hdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICAnZmFkZSBzY2FsZSdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5lZmZlY3RzID0gJ2ZhZGUgc2NhbGUnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN0cmluZyBvZiBvbmUgb3IgbW9yZSBzcGFjZS1zZXBlcmF0ZWQgZWZmZWN0cyB0byBiZSBhcHBsaWVkIG9ubHkgdG8gZmlsdGVyLWluXG4gICAgICAgICAqIGFuaW1hdGlvbnMsIG92ZXJyaWRpbmcgYGNvbmZpZy5hbmltYXRpb24uZWZmZWN0c2AgaWYgc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBBcHBseSBkb3dud2FyZHMgdmVydGljYWwgdHJhbnNsYXRlIHRvIHRhcmdldHMgYmVpbmcgZmlsdGVyZWQgaW48L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgKiAgICAgICAgIGVmZmVjdHNJbjogJ2ZhZGUgdHJhbnNsYXRlWSgtMTAwJSknXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgZWZmZWN0c0luXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJydcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5lZmZlY3RzSW4gPSAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgb2Ygb25lIG9yIG1vcmUgc3BhY2Utc2VwZXJhdGVkIGVmZmVjdHMgdG8gYmUgYXBwbGllZCBvbmx5IHRvIGZpbHRlci1vdXRcbiAgICAgICAgICogYW5pbWF0aW9ucywgb3ZlcnJpZGluZyBgY29uZmlnLmFuaW1hdGlvbi5lZmZlY3RzYCBpZiBzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IEFwcGx5IHVwd2FyZHMgdmVydGljYWwgdHJhbnNsYXRlIHRvIHRhcmdldHMgYmVpbmcgZmlsdGVyZWQgb3V0PC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBlZmZlY3RzT3V0OiAnZmFkZSB0cmFuc2xhdGVZKC0xMDAlKSdcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBlZmZlY3RzT3V0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJydcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5lZmZlY3RzT3V0ID0gJyc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVnZXIgZGljdGF0aW5nIHRoZSBkdXJhdGlvbiBvZiBhbGwgTWl4SXRVcCBhbmltYXRpb25zIGluIG1pbGxpc2Vjb25kcywgbm90XG4gICAgICAgICAqIGluY2x1ZGluZyBhbnkgYWRkaXRpb25hbCBkZWxheSBhcGxsaWVkIHZpYSB0aGUgYCdzdGFnZ2VyJ2AgZWZmZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBBcHBseSBhbiBhbmltYXRpb24gZHVyYXRpb24gb2YgMjAwbXMgdG8gYWxsIG1peGl0dXAgYW5pbWF0aW9uczwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGR1cmF0aW9uXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgNjAwXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSA2MDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdmFsaWQgQ1NTMyB0cmFuc2l0aW9uLXRpbWluZyBmdW5jdGlvbiBvciBzaG9ydGhhbmQuIEZvciBhIGZ1bGwgbGlzdCBvZiBhY2NlcHRlZFxuICAgICAgICAgKiB2YWx1ZXMsIHZpc2l0IDxhIGhyZWY9XCJodHRwOi8vZWFzaW5ncy5uZXRcIiB0YXJnZXQ9XCJfYmxhbmtcIj5lYXNpbmdzLm5ldDwvYT4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogQXBwbHkgXCJlYXNlLWluLW91dFwiIGVhc2luZyB0byBhbGwgYW5pbWF0aW9uczwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgZWFzaW5nOiAnZWFzZS1pbi1vdXQnXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDI6IEFwcGx5IGEgY3VzdG9tIFwiY3ViaWMtYmV6aWVyXCIgZWFzaW5nIGZ1bmN0aW9uIHRvIGFsbCBhbmltYXRpb25zPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBlYXNpbmc6ICdjdWJpYy1iZXppZXIoMC42NDUsIDAuMDQ1LCAwLjM1NSwgMSknXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgZWFzaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJ2Vhc2UnXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuZWFzaW5nID0gJ2Vhc2UnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgb3Igbm90IHRvIGFwcGx5IHBlcnNwZWN0aXZlIHRvIHRoZSBNaXhJdFVwIGNvbnRhaW5lclxuICAgICAgICAgKiBkdXJpbmcgYW5pbWF0aW9ucy4gQnkgZGVmYXVsdCwgcGVyc3BlY3RpdmUgaXMgYWx3YXlzIGFwcGxpZWQgYW5kIGNyZWF0ZXMgdGhlXG4gICAgICAgICAqIGlsbHVzaW9uIG9mIHRocmVlLWRpbWVuc2lvbmFsIHNwYWNlIGZvciBlZmZlY3RzIHN1Y2ggYXMgYHRyYW5zbGF0ZVpgLCBgcm90YXRlWGAsXG4gICAgICAgICAqIGFuZCBgcm90YXRlWWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBtYXkgd2lzaCB0byBkaXNhYmxlIHRoaXMgYW5kIGRlZmluZSB5b3VyIG93biBwZXJzcGVjdGl2ZSBzZXR0aW5ncyB2aWEgQ1NTLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBQcmV2ZW50IHBlcnNwZWN0aXZlIGZyb20gYmVpbmcgYXBwbGllZCB0byBhbnkgM0QgdHJhbnNmb3JtczwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgYXBwbHlQZXJzcGVjdGl2ZTogZmFsc2VcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBhcHBseVBlcnNwZWN0aXZlXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7Ym9sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgdHJ1ZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmFwcGx5UGVyc3BlY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGVyc3BlY3RpdmUgZGlzdGFuY2UgdmFsdWUgdG8gYmUgYXBwbGllZCB0byB0aGUgY29udGFpbmVyIGR1cmluZyBhbmltYXRpb25zLFxuICAgICAgICAgKiBhZmZlY3RpbmcgYW55IDNELXRyYW5zZm9ybS1iYXNlZCBlZmZlY3RzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBTZXQgYSBwZXJzcGVjdGl2ZSBkaXN0YW5jZSBvZiAyMDAwcHg8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgKiAgICAgICAgIGVmZmVjdHM6ICdyb3RhdGVZKC0yNWRlZyknLFxuICAgICAgICAgKiAgICAgICAgIHBlcnNwZWN0aXZlRGlzdGFuY2U6ICcyMDAwcHgnXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgcGVyc3BlY3RpdmVEaXN0YW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuYW5pbWF0aW9uXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICczMDAwcHgnXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVEaXN0YW5jZSA9ICczMDAwcHgnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGVyc3BlY3RpdmUtb3JpZ2luIHZhbHVlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGNvbnRhaW5lciBkdXJpbmcgYW5pbWF0aW9ucyxcbiAgICAgICAgICogYWZmZWN0aW5nIGFueSAzRC10cmFuc2Zvcm0tYmFzZWQgZWZmZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogU2V0IGEgcGVyc3BlY3RpdmUgb3JpZ2luIGluIHRoZSB0b3AtcmlnaHQgb2YgdGhlIGNvbnRhaW5lcjwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgZWZmZWN0czogJ3RyYW5zYXRlWigtMjAwcHgpJyxcbiAgICAgICAgICogICAgICAgICBwZXJzcGVjdGl2ZU9yaWdpbjogJzEwMCUgMCdcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBwZXJzcGVjdGl2ZU9yaWdpblxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuYW5pbWF0aW9uXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICc1MCUgNTAlJ1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlT3JpZ2luID0gJzUwJSA1MCUnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgb3Igbm90IHRvIGVuYWJsZSB0aGUgcXVldWluZyBvZiBvcGVyYXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgdHJ1ZWAgKGRlZmF1bHQpLCBhbmQgYSBjb250cm9sIGlzIGNsaWNrZWQgb3IgYW4gQVBJIGNhbGwgaXMgbWFkZSB3aGlsZSBhbm90aGVyXG4gICAgICAgICAqIG9wZXJhdGlvbiBpcyBwcm9ncmVzcywgdGhlIG9wZXJhdGlvbiB3aWxsIGdvIGludG8gdGhlIHF1ZXVlIGFuZCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZXhlY3R1dGVkXG4gICAgICAgICAqIHdoZW4gdGhlIHByZXZpb3VzIG9wZXJhaXRvbnMgaXMgZmluaXNoZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBmYWxzZWAsIGFueSByZXF1ZXN0ZWQgb3BlcmF0aW9ucyB3aWxsIGJlIGlnbm9yZWQsIGFuZCB0aGUgYG9uTWl4QnVzeWAgY2FsbGJhY2sgYW5kIGBtaXhCdXN5YFxuICAgICAgICAgKiBldmVudCB3aWxsIGJlIGZpcmVkLiBJZiBgZGVidWcuc2hvd1dhcm5pbmdzYCBpcyBlbmFibGVkLCBhIGNvbnNvbGUgd2FybmluZyB3aWxsIGFsc28gb2NjdXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IERpc2FibGUgcXVldWluZzwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgcXVldWU6IGZhbHNlXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgcXVldWVcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmFuaW1hdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgdHJ1ZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLnF1ZXVlID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZWdlciBkaWN0YWN0aW5nIHRoZSBtYXhpbXVtIG51bWJlciBvZiBvcGVyYXRpb25zIGFsbG93ZWQgaW4gdGhlIHF1ZXVlIGF0XG4gICAgICAgICAqIGFueSB0aW1lLCB3aGVuIHF1ZXVpbmcgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogQWxsb3cgYSBtYXhpbXVtIG9mIDUgb3BlcmF0aW9ucyBpbiB0aGUgcXVldWUgYXQgYW55IHRpbWU8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgKiAgICAgICAgIHF1ZXVlTGltaXQ6IDVcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBxdWV1ZUxpbWl0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgM1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLnF1ZXVlTGltaXQgPSAzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgb3Igbm90IHRvIHRyYW5zaXRpb24gdGhlIGhlaWdodCBhbmQgd2lkdGggb2YgdGhlXG4gICAgICAgICAqIGNvbnRhaW5lciBhcyBlbGVtZW50cyBhcmUgZmlsdGVyZWQgaW4gYW5kIG91dC4gSWYgZGlzYWJsZWQsIHRoZSBjb250YWluZXIgaGVpZ2h0XG4gICAgICAgICAqIHdpbGwgY2hhbmdlIGFicnVwdGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCBtYXkgYmUgZGVzaXJhYmxlIHRvIGRpc2FibGUgdGhpcyBvbiBtb2JpbGUgZGV2aWNlcyBhcyB0aGUgQ1NTIGBoZWlnaHRgIGFuZFxuICAgICAgICAgKiBgd2lkdGhgIHByb3BlcnRpZXMgZG8gbm90IHJlY2VpdmUgR1BVLWFjY2VsZXJhdGlvbiBhbmQgY2FuIHRoZXJlZm9yZSBjYXVzZSBzdHV0dGVyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IERpc2FibGUgdGhlIHRyYW5zaXRpb25pbmcgb2YgdGhlIGNvbnRhaW5lciBoZWlnaHQgYW5kL29yIHdpZHRoPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBhbmltYXRlUmVzaXplQ29udGFpbmVyOiBmYWxzZVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAyOiBEaXNhYmxlIHRoZSB0cmFuc2l0aW9uaW5nIG9mIHRoZSBjb250YWluZXIgaGVpZ2h0IGFuZC9vciB3aWR0aCBmb3IgbW9iaWxlIGRldmljZXMgb25seTwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgYW5pbWF0ZVJlc2l6ZUNvbnRhaW5lcjogbXlGZWF0dXJlVGVzdHMuaXNNb2JpbGUgPyBmYWxzZSA6IHRydWVcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBhbmltYXRlUmVzaXplQ29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIHRydWVcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5hbmltYXRlUmVzaXplQ29udGFpbmVyID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uIHRoZSBoZWlnaHQgYW5kIHdpZHRoIG9mIHRhcmdldFxuICAgICAgICAgKiBlbGVtZW50cyBhcyB0aGV5IGNoYW5nZSB0aHJvdWdob3V0IHRoZSBjb3Vyc2Ugb2YgYW4gYW5pbWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIG9mdGVuIGEgbXVzdCBmb3IgZmxleC1ib3ggZ3JpZCBsYXlvdXRzIHdoZXJlIHRoZSBzaXplIG9mIHRhcmdldCBlbGVtZW50cyBtYXkgY2hhbmdlXG4gICAgICAgICAqIGRlcGVuZGluZyBvbiBmaW5hbCB0aGVpciBwb3NpdGlvbiBpbiByZWxhdGlvbiB0byB0aGVpciBzaWJsaW5ncywgb3IgZm9yIGAuY2hhbmdlTGF5b3V0KClgXG4gICAgICAgICAqIG9wZXJhdGlvbnMgd2hlcmUgdGhlIHNpemUgb2YgdGFyZ2V0cyBjaGFuZ2UgYmV0d2VlbiBsYXlvdXRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOQjogVGhpcyBmZWF0dXJlIHJlcXVpcmVzIGFkZGl0aW9uYWwgY2FsY3VsYXRpb25zIGFuZCBtYW5pcHVsYXRpb24gdG8gbm9uLWhhcmR3YXJlLWFjY2VsZXJhdGVkXG4gICAgICAgICAqIHByb3BlcnRpZXMgd2hpY2ggbWF5IGFkdmVyc2VseSBhZmZlY3QgcGVyZm9ybWFuY2Ugb24gc2xvd2VyIGRldmljZXMsIGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgICogZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogRW5hYmxlIHRoZSB0cmFuc2l0aW9uaW5nIG9mIHRhcmdldCB3aWR0aHMgYW5kIGhlaWdodHM8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgKiAgICAgICAgIGFuaW1hdGVSZXNpemVUYXJnZXRzOiB0cnVlXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgYW5pbWF0ZVJlc2l6ZVRhcmdldHNcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmFuaW1hdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgZmFsc2VcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5hbmltYXRlUmVzaXplVGFyZ2V0cyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGN1c3RvbSBmdW5jdGlvbiB1c2VkIHRvIG1hbmlwdWxhdGUgdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBzdGFnZ2VyIGRlbGF5IGlzXG4gICAgICAgICAqIGluY3JlbWVudGVkIHdoZW4gdXNpbmcgdGhlIOKAmHN0YWdnZXLigJkgZWZmZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHVzaW5nIHRoZSAnc3RhZ2dlcicgZWZmZWN0LCB0aGUgZGVsYXkgYXBwbGllZCB0byBlYWNoIHRhcmdldCBlbGVtZW50IGlzIGluY3JlbWVudGVkXG4gICAgICAgICAqIGJhc2VkIG9uIGl0cyBpbmRleC4gWW91IG1heSBjcmVhdGUgYSBjdXN0b20gZnVuY3Rpb24gdG8gbWFuaXB1bGF0ZSB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlXG4gICAgICAgICAqIGRlbGF5IGlzIGluY3JlbWVudGVkIGFuZCBjcmVhdGUgZW5nYWdpbmcgbm9uLWxpbmVhciBzdGFnZ2VyIGVmZmVjdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgaW5kZXggb2YgdGhlIHRhcmdldCBlbGVtZW50IGFzIGEgcGFyYW1ldGVyLCBhbmQgbXVzdFxuICAgICAgICAgKiByZXR1cm4gYW4gaW50ZWdlciB3aGljaCBzZXJ2ZXMgYXMgdGhlIG11bHRpcGxpZXIgZm9yIHRoZSBzdGFnZ2VyIGRlbGF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IFN0YWdnZXIgdGFyZ2V0IGVsZW1lbnRzIGJ5IGNvbHVtbiBpbiBhIDMtY29sdW1uIGdyaWQ8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgKiAgICAgICAgIGVmZmVjdHM6ICdmYWRlIHN0YWdnZXIoMTAwbXMpJyxcbiAgICAgICAgICogICAgICAgICBzdGFnZ2VyU2VxdWVuY2U6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICogICAgICAgICAgICAgcmV0dXJuIGkgJSAzO1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogVXNpbmcgYW4gYWxnb3JpdGhtIHRvIHByb2R1Y2UgYSBtb3JlIGNvbXBsZXggc2VxdWVuY2U8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgKiAgICAgICAgIGVmZmVjdHM6ICdmYWRlIHN0YWdnZXIoMTAwbXMpJyxcbiAgICAgICAgICogICAgICAgICBzdGFnZ2VyU2VxdWVuY2U6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICogICAgICAgICAgICAgcmV0dXJuICgyKmkpIC0gKDUqKChpLzMpIC0gKCgxLzMpICogKGklMykpKSk7XG4gICAgICAgICAqICAgICAgICAgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIHN0YWdnZXJTZXF1ZW5jZVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuYW5pbWF0aW9uXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge2Z1bmN0aW9ufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgbnVsbFxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLnN0YWdnZXJTZXF1ZW5jZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYm9vbGVhbiBkaWN0YXRpbmcgd2hldGhlciBvciBub3QgdG8gcmV2ZXJzZSB0aGUgZGlyZWN0aW9uIG9mIGB0cmFuc2xhdGVgXG4gICAgICAgICAqIGFuZCBgcm90YXRlYCB0cmFuc2Zvcm1zIGZvciBlbGVtZW50cyBiZWluZyBmaWx0ZXJlZCBvdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBjYXJvdXNlbC1saWtlIGFuaW1hdGlvbnMgd2hlcmUgZWxlbWVudHMgZW50ZXIgYW5kIGV4aXRcbiAgICAgICAgICogZnJvbSBvcHBvc2l0ZSBkaXJlY3Rpb25zLiBJZiBlbmFibGVkLCB0aGUgZWZmZWN0IGB0cmFuc2xhdGVYKC0xMDAlKWAgZm9yIGVsZW1lbnRzXG4gICAgICAgICAqIGJlaW5nIGZpbHRlcmVkIGluIHdvdWxkIGJlY29tZSBgdHJhbnNsYXRlWCgxMDAlKWAgZm9yIHRhcmdldHMgYmVpbmcgZmlsdGVyZWQgb3V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uYWxpdHkgY2FuIGFsc28gYmUgYWNoaWV2ZWQgYnkgcHJvdmlkaW5nIHNlcGVyYXRlIGVmZmVjdHNcbiAgICAgICAgICogc3RyaW5ncyBmb3IgYGNvbmZpZy5hbmltYXRpb24uZWZmZWN0c0luYCBhbmQgYGNvbmZpZy5hbmltYXRpb24uZWZmZWN0c091dGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IFJldmVyc2UgdGhlIGRlc2lyZWQgZGlyZWN0aW9uIG9uIGFueSB0cmFuc2xhdGUvcm90YXRlIGVmZmVjdCBmb3IgdGFyZ2V0cyBiZWluZyBmaWx0ZXJlZCBvdXQ8L2NhcHRpb24+XG4gICAgICAgICAqIC8vIEVsZW1lbnRzIGJlaW5nIGZpbHRlcmVkIGluIHdpbGwgYmUgdHJhbnNsYXRlZCBmcm9tICcxMDAlJyB0byAnMCcgd2hpbGVcbiAgICAgICAgICogLy8gZWxlbWVudHMgYmVpbmcgZmlsdGVyZWQgb3V0IHdpbGwgYmUgdHJhbnNsYXRlZCBmcm9tIDAgdG8gJy0xMDAlJ1xuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBlZmZlY3RzOiAnZmFkZSB0cmFuc2xhdGVYKDEwMCUpJyxcbiAgICAgICAgICogICAgICAgICByZXZlcnNlT3V0OiB0cnVlLFxuICAgICAgICAgKiAgICAgICAgIG51ZGdlOiBmYWxzZSAvLyBEaXNhYmxlIG51ZGdpbmcgdG8gY3JlYXRlIGEgY2Fyb3VzZWwtbGlrZSBlZmZlY3RcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICByZXZlcnNlT3V0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5hbmltYXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIGZhbHNlXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMucmV2ZXJzZU91dCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgb3Igbm90IHRvIFwibnVkZ2VcIiB0aGUgYW5pbWF0aW9uIHBhdGggb2YgdGFyZ2V0c1xuICAgICAgICAgKiB3aGVuIHRoZXkgYXJlIGJlaW5nIGZpbHRlcmVkIGluIGFuZCBvdXQgc2ltdWxhdGVub3VzbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaGFzIGJlZW4gdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgTWl4SXRVcCBzaW5jZSB2ZXJzaW9uIDEsIGJ1dCBpdFxuICAgICAgICAgKiBtYXkgYmUgZGVzaXJhYmxlIHRvIGRpc2FibGUgdGhpcyBlZmZlY3Qgd2hlbiBmaWx0ZXJpbmcgZGlyZWN0bHkgZnJvbVxuICAgICAgICAgKiBvbmUgZXhjbHVzaXZlIHNldCBvZiB0YXJnZXRzIHRvIGEgZGlmZmVyZW50IGV4Y2x1c2l2ZSBzZXQgb2YgdGFyZ2V0cyxcbiAgICAgICAgICogdG8gY3JlYXRlIGEgY2Fyb3VzZWwtbGlrZSBlZmZlY3QsIG9yIGEgZ2VuZXJhbGx5IG1vcmUgc3VidGxlIGFuaW1hdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogRGlzYWJsZSB0aGUgXCJudWRnaW5nXCIgb2YgdGFyZ2V0cyBiZWluZyBmaWx0ZXJlZCBpbiBhbmQgb3V0IHNpbXVsYXRlbm91c2x5PC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBudWRnZTogZmFsc2VcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBudWRnZVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuYW5pbWF0aW9uXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICB0cnVlXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMubnVkZ2UgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgb3Igbm90IHRvIGNsYW1wIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lciB3aGlsZSBNaXhJdFVwJ3NcbiAgICAgICAgICogZ2VvbWV0cnkgdGVzdHMgYXJlIGNhcnJpZWQgb3V0IGJlZm9yZSBhbiBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIHByZXZlbnQgc2Nyb2xsLWJhciBmbGlja2VyLCBjbGFtcGluZyBpcyB0dXJuZWQgb24gYnkgZGVmYXVsdC4gQnV0IGluIHRoZSBjYXNlIHdoZXJlIHRoZVxuICAgICAgICAgKiBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lciBtaWdodCBhZmZlY3QgaXRzIHZlcnRpY2FsIHBvc2l0aW9uaW5nIGluIHRoZSB2aWV3cG9ydFxuICAgICAgICAgKiAoZS5nLiBhIHZlcnRpY2FsbHktY2VudGVyZWQgY29udGFpbmVyKSwgdGhpcyBzaG91bGQgYmUgdHVybmVkIG9mZiB0byBlbnN1cmUgYWNjdXJhdGVcbiAgICAgICAgICogdGVzdCByZXN1bHRzIGFuZCBhIHNtb290aCBhbmltYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IERpc2FibGUgY29udGFpbmVyIGhlaWdodC1jbGFtcGluZzwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAqICAgICAgICAgY2xhbXBIZWlnaHQ6IGZhbHNlXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgY2xhbXBIZWlnaHRcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmFuaW1hdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgdHJ1ZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmNsYW1wSGVpZ2h0ID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIG9yIG5vdCB0byBjbGFtcCB0aGUgd2lkdGggb2YgdGhlIGNvbnRhaW5lciB3aGlsZSBNaXhJdFVwJ3NcbiAgICAgICAgICogZ2VvbWV0cnkgdGVzdHMgYXJlIGNhcnJpZWQgb3V0IGJlZm9yZSBhbiBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIHByZXZlbnQgc2Nyb2xsLWJhciBmbGlja2VyLCBjbGFtcGluZyBpcyB0dXJuZWQgb24gYnkgZGVmYXVsdC4gQnV0IGluIHRoZSBjYXNlIHdoZXJlIHRoZVxuICAgICAgICAgKiB3aWR0aCBvZiB0aGUgY29udGFpbmVyIG1pZ2h0IGFmZmVjdCBpdHMgaG9yaXR6b250YWwgcG9zaXRpb25pbmcgaW4gdGhlIHZpZXdwb3J0XG4gICAgICAgICAqIChlLmcuIGEgaG9yaXpvbnRhbGwtY2VudGVyZWQgY29udGFpbmVyKSwgdGhpcyBzaG91bGQgYmUgdHVybmVkIG9mZiB0byBlbnN1cmUgYWNjdXJhdGVcbiAgICAgICAgICogdGVzdCByZXN1bHRzIGFuZCBhIHNtb290aCBhbmltYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IERpc2FibGUgY29udGFpbmVyIHdpZHRoLWNsYW1waW5nPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBjbGFtcFdpZHRoOiBmYWxzZVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGNsYW1wV2lkdGhcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmFuaW1hdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgdHJ1ZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmNsYW1wV2lkdGggPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbmZpZ0FuaW1hdGlvbik7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ0FuaW1hdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5Db25maWdBbmltYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db25maWdBbmltYXRpb247XG5cbiAgICAvKipcbiAgICAgKiBBIGdyb3VwIG9mIHByb3BlcnRpZXMgcmVsYXRpbmcgdG8gdGhlIGJlaGF2aW9yIG9mIHRoZSBNaXhlci5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZ1xuICAgICAqIEBuYW1lICAgICAgICBiZWhhdmlvclxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAcHVibGljXG4gICAgICogQHNpbmNlICAgICAgIDMuMS4xMlxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db25maWdCZWhhdmlvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIHRvIGFsbG93IFwibGl2ZVwiIHNvcnRpbmcgb2YgdGhlIG1peGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCZWNhdXNlIG9mIHRoZSBleHBlbnNpdmUgbmF0dXJlIG9mIHNvcnRpbmcsIE1peEl0VXAgbWFrZXMgdXNlIG9mIHNldmVyYWxcbiAgICAgICAgICogaW50ZXJuYWwgb3B0aW1pemF0aW9ucyB0byBza2lwIHJlZHVuZGFudCBzb3J0aW5nIG9wZXJhdGlvbnMsIHN1Y2ggYXMgd2hlblxuICAgICAgICAgKiB0aGUgbmV3bHkgcmVxdWVzdGVkIHNvcnQgY29tbWFuZCBpcyB0aGUgc2FtZSBhcyB0aGUgYWN0aXZlIG9uZS4gVGhlIGNhdmVhdFxuICAgICAgICAgKiB0byB0aGlzIG9wdGltaXphdGlvbiBpcyB0aGF0IFwibGl2ZVwiIGVkaXRzIHRvIHRoZSB2YWx1ZSBvZiBhIHRhcmdldCdzIHNvcnRpbmdcbiAgICAgICAgICogYXR0cmlidXRlIHdpbGwgYmUgaWdub3JlZCB3aGVuIHJlcXVlc3RpbmcgYSByZS1zb3J0IGJ5IHRoZSBzYW1lIGF0dHJpYnV0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgc2V0dGluZyB0byBgYmVoYXZpb3IubGl2ZVNvcnRgIHRvIGB0cnVlYCwgdGhlIG1peGVyIHdpbGwgYWx3YXlzIHJlLXNvcnRcbiAgICAgICAgICogcmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgc29ydGluZyBhdHRyaWJ1dGUgYW5kIG9yZGVyIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogRW5hYmxpbmcgYGxpdmVTb3J0YCB0byBhbGxvdyBmb3IgcmUtc29ydGluZzwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgYmVoYXZpb3I6IHtcbiAgICAgICAgICogICAgICAgICBsaXZlU29ydDogdHJ1ZVxuICAgICAgICAgKiAgICAgfSxcbiAgICAgICAgICogICAgIGxvYWQ6IHtcbiAgICAgICAgICogICAgICAgICBzb3J0OiAnZWRpdGVkOmRlc2MnXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgdGFyZ2V0ID0gY29udGFpbmVyRWwuY2hpbGRyZW5bM107XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZWRpdGVkJykpOyAvLyAnMjAxNS0wNC0yNCdcbiAgICAgICAgICpcbiAgICAgICAgICogdGFyZ2V0LnNldEF0dHJpYnV0ZSgnZGF0YS1lZGl0ZWQnLCAnMjAxNy0wOC0xMCcpOyAvLyBVcGRhdGUgdGhlIHRhcmdldCdzIGVkaXRlZCBkYXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnNvcnQoJ2VkaXRlZDpkZXNjJylcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgLy8gVGhlIHRhcmdldCBpcyBub3cgYXQgdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnRhcmdldHNbMF0gPT09IHRhcmdldCk7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgbGl2ZVNvcnRcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmJlaGF2aW9yXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBmYWxzZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmxpdmVTb3J0ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuQ29uZmlnQmVoYXZpb3IpO1xuXG4gICAgbWl4aXR1cC5Db25maWdCZWhhdmlvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5Db25maWdCZWhhdmlvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLkNvbmZpZ0JlaGF2aW9yO1xuXG4gICAgLyoqXG4gICAgICogQSBncm91cCBvZiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbnMgdG8gYmUgaW52b2tlZCBhdCB2YXJpb3VzXG4gICAgICogcG9pbnRzIHdpdGhpbiB0aGUgbGlmZWN5Y2xlIG9mIGEgbWl4ZXIgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogRWFjaCBmdW5jdGlvbiBpcyBhbmFsb2dvdXMgdG8gYW4gZXZlbnQgb2YgdGhlIHNhbWUgbmFtZSB0cmlnZ2VyZWQgZnJvbSB0aGVcbiAgICAgKiBjb250YWluZXIgZWxlbWVudCwgYW5kIGlzIGludm9rZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQuXG4gICAgICpcbiAgICAgKiBBbGwgY2FsbGJhY2sgZnVuY3Rpb25zIHJlY2VpdmUgdGhlIGN1cnJlbnQgYHN0YXRlYCBvYmplY3QgYXMgdGhlaXIgZmlyc3RcbiAgICAgKiBhcmd1bWVudCwgYXMgd2VsbCBhcyBvdGhlciBtb3JlIHNwZWNpZmljIGFyZ3VtZW50cyBkZXNjcmliZWQgYmVsb3cuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWdcbiAgICAgKiBAbmFtZSAgICAgICAgY2FsbGJhY2tzXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAc2luY2UgICAgICAgMi4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29uZmlnQ2FsbGJhY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1peGl0dXAuQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbnN0cnVjdCcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYW55IE1peEl0VXAgb3BlcmF0aW9uIGlzIHJlcXVlc3RlZFxuICAgICAgICAgKiBhbmQgYmVmb3JlIGFuaW1hdGlvbnMgaGF2ZSBiZWd1bi5cbiAgICAgICAgICpcbiAgICAgICAgICogQSBzZWNvbmQgYGZ1dHVyZVN0YXRlYCBhcmd1bWVudCBpcyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIHdoaWNoIHJlcHJlc2VudHMgdGhlIGZpbmFsXG4gICAgICAgICAqIHN0YXRlIG9mIHRoZSBtaXhlciBvbmNlIHRoZSByZXF1ZXN0ZWQgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IEFkZGluZyBhbiBgb25NaXhTdGFydGAgY2FsbGJhY2sgZnVuY3Rpb248L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgKiAgICAgICAgIG9uTWl4U3RhcnQ6IGZ1bmN0aW9uKHN0YXRlLCBmdXR1cmVTdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIG9wZXJhdGlvbi4uLicpO1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBvbk1peFN0YXJ0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jYWxsYmFja3NcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7ZnVuY3Rpb259XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBudWxsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMub25NaXhTdGFydCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCB3aGVuIGEgTWl4SXRVcCBvcGVyYXRpb24gaXMgcmVxdWVzdGVkIHdoaWxlIGFub3RoZXJcbiAgICAgICAgICogb3BlcmF0aW9uIGlzIGluIHByb2dyZXNzLCBhbmQgdGhlIGFuaW1hdGlvbiBxdWV1ZSBpcyBmdWxsLCBvciBxdWV1ZWluZ1xuICAgICAgICAgKiBpcyBkaXNhYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogQWRkaW5nIGFuIGBvbk1peEJ1c3lgIGNhbGxiYWNrIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICogICAgICAgICBvbk1peEJ1c3k6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTWl4ZXIgYnVzeScpO1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBvbk1peEJ1c3lcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmNhbGxiYWNrc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtmdW5jdGlvbn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIG51bGxcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5vbk1peEJ1c3kgID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGFmdGVyIGFueSBNaXhJdFVwIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLCBhbmQgdGhlXG4gICAgICAgICAqIHN0YXRlIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IEFkZGluZyBhbiBgb25NaXhFbmRgIGNhbGxiYWNrIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICogICAgICAgICBvbk1peEVuZDogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdPcGVyYXRpb24gY29tcGxldGUnKTtcbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgb25NaXhFbmRcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmNhbGxiYWNrc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtmdW5jdGlvbn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIG51bGxcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5vbk1peEVuZCAgID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIHdoZW5ldmVyIGFuIG9wZXJhdGlvbiBcImZhaWxzXCIsIGkuZS4gbm8gdGFyZ2V0c1xuICAgICAgICAgKiBjb3VsZCBiZSBmb3VuZCBtYXRjaGluZyB0aGUgcmVxdWVzdGVkIGZpbHRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogQWRkaW5nIGFuIGBvbk1peEZhaWxgIGNhbGxiYWNrIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICogICAgICAgICBvbk1peEZhaWw6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gaXRlbXMgY291bGQgYmUgZm91bmQgbWF0Y2hpbmcgdGhlIHJlcXVlc3RlZCBmaWx0ZXInKTtcbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgb25NaXhGYWlsXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jYWxsYmFja3NcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7ZnVuY3Rpb259XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBudWxsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMub25NaXhGYWlsICA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCB3aGVuZXZlciBhIE1peEl0VXAgY29udHJvbCBpcyBjbGlja2VkLCBhbmQgYmVmb3JlIGl0c1xuICAgICAgICAgKiByZXNwZWN0aXZlIG9wZXJhdGlvbiBpcyByZXF1ZXN0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBjbGlja2VkIGVsZW1lbnQgaXMgYXNzaWduZWQgdG8gdGhlIGB0aGlzYCBrZXl3b3JkIHdpdGhpbiB0aGUgZnVuY3Rpb24uIFRoZSBvcmlnaW5hbFxuICAgICAgICAgKiBjbGljayBldmVudCBpcyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIHdoaWNoIGNhbiBiZSB1c2VmdWwgaWZcbiAgICAgICAgICogdXNpbmcgYDxhPmAgdGFncyBhcyBjb250cm9scyB3aGVyZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBuZWVkcyB0byBiZSBwcmV2ZW50ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybmluZyBgZmFsc2VgIGZyb20gdGhlIGNhbGxiYWNrIHdpbGwgcHJldmVudCB0aGUgY29udHJvbCBjbGljayBmcm9tIHRyaWdnZXJpbmdcbiAgICAgICAgICogYW4gb3BlcmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IEFkZGluZyBhbiBgb25NaXhDbGlja2AgY2FsbGJhY2sgZnVuY3Rpb248L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgKiAgICAgICAgIG9uTWl4Q2xpY2s6IGZ1bmN0aW9uKHN0YXRlLCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAqICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVGhlIGNvbnRyb2wgXCInICsgdGhpcy5pbm5lclRleHQgKyAnXCIgd2FzIGNsaWNrZWQnKTtcbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDI6IFVzaW5nIGBvbk1peENsaWNrYCB0byBtYW5pcHVsYXRlIHRoZSBvcmlnaW5hbCBjbGljayBldmVudDwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAqICAgICAgICAgb25NaXhDbGljazogZnVuY3Rpb24oc3RhdGUsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgICogICAgICAgICAgICAgIC8vIFByZXZlbnQgb3JpZ2luYWwgY2xpY2sgZXZlbnQgZnJvbSBidWJibGluZyB1cDpcbiAgICAgICAgICogICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3Igb2YgY2xpY2tlZCBlbGVtZW50OlxuICAgICAgICAgKiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMzogVXNpbmcgYG9uTWl4Q2xpY2tgIHRvIGNvbmRpdGlvbmFsbHkgY2FuY2VsIG9wZXJhdGlvbnM8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgKiAgICAgICAgIG9uTWl4Q2xpY2s6IGZ1bmN0aW9uKHN0YXRlLCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAqICAgICAgICAgICAgICAvLyBQZXJmb3JtIHNvbWUgY29uZGl0aW9uYWwgY2hlY2s6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgICAgICBpZiAobXlBcHAuaXNMb2FkaW5nKSB7XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgLy8gQnkgcmV0dXJuaW5nIGZhbHNlLCB3ZSBjYW4gcHJldmVudCB0aGUgY29udHJvbCBjbGljayBmcm9tIHRyaWdnZXJpbmcgYW4gb3BlcmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICogICAgICAgICAgICAgIH1cbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgb25NaXhDbGlja1xuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuY2FsbGJhY2tzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge2Z1bmN0aW9ufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgbnVsbFxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLm9uTWl4Q2xpY2sgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbmZpZ0NhbGxiYWNrcyk7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ0NhbGxiYWNrcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5Db25maWdDYWxsYmFja3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db25maWdDYWxsYmFja3M7XG5cbiAgICAvKipcbiAgICAgKiBBIGdyb3VwIG9mIHByb3BlcnRpZXMgcmVsYXRpbmcgdG8gY2xpY2thYmxlIGNvbnRyb2wgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWdcbiAgICAgKiBAbmFtZSAgICAgICAgY29udHJvbHNcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzaW5jZSAgICAgICAyLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db25maWdDb250cm9scyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIG9yIG5vdCBjb250cm9scyBzaG91bGQgYmUgZW5hYmxlZCBmb3IgdGhlIG1peGVyIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgdHJ1ZWAgKGRlZmF1bHQgYmVoYXZpb3IpLCBNaXhJdFVwIHdpbGwgc2VhcmNoIHRoZSBET00gZm9yIGFueSBjbGlja2FibGUgZWxlbWVudHMgd2l0aFxuICAgICAgICAgKiBgZGF0YS1maWx0ZXJgLCBgZGF0YS1zb3J0YCBvciBgZGF0YS10b2dnbGVgIGF0dHJpYnV0ZXMsIGFuZCBiaW5kIHRoZW0gZm9yIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGZhbHNlYCwgbm8gY2xpY2sgaGFuZGxlcnMgd2lsbCBiZSBib3VuZCwgYW5kIGFsbCBmdW5jdGlvbmFsaXR5IG11c3QgdGhlcmVmb3JlIGJlIHBlcmZvcm1lZFxuICAgICAgICAgKiB2aWEgdGhlIG1peGVyJ3MgQVBJIG1ldGhvZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSBkbyBub3QgaW50ZW5kIHRvIHVzZSB0aGUgZGVmYXVsdCBjb250cm9scywgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIGBmYWxzZWAgd2lsbFxuICAgICAgICAgKiBtYXJnaW5hbGx5IGltcHJvdmUgdGhlIHN0YXJ0dXAgdGltZSBvZiB5b3VyIG1peGVyIGluc3RhbmNlLCBhbmQgd2lsbCBhbHNvIHByZXZlbnQgYW55IG90aGVyIGFjdGl2ZVxuICAgICAgICAgKiBtaXhlciBpbnN0YW5jZXMgaW4gdGhlIERPTSB3aGljaCBhcmUgYm91bmQgdG8gY29udHJvbHMgZnJvbSBjb250cm9sbGluZyB0aGUgaW5zdGFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IERpc2FibGluZyBjb250cm9sczwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY29udHJvbHM6IHtcbiAgICAgICAgICogICAgICAgICBlbmFibGU6IGZhbHNlXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBXaXRoIHRoZSBkZWZhdWx0IGNvbnRyb2xzIGRpc2FibGVkLCB3ZSBjYW4gb25seSBjb250cm9sXG4gICAgICAgICAqIC8vIHRoZSBtaXhlciB2aWEgaXRzIEFQSSBtZXRob2RzLCBlLmcuOlxuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5maWx0ZXIoJy5jYXQtMScpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgZW5hYmxlXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jb250cm9sc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgdHJ1ZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmVuYWJsZSA9IHRydWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYm9vbGVhbiBkaWN0YXRpbmcgd2hldGhlciBvciBub3QgdG8gdXNlIGV2ZW50IGRlbGVnYXRpb24gd2hlbiBiaW5kaW5nIGNsaWNrIGV2ZW50c1xuICAgICAgICAgKiB0byB0aGUgZGVmYXVsdCBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGZhbHNlYCAoZGVmYXVsdCBiZWhhdmlvciksIGVhY2ggY29udHJvbCBidXR0b24gaW4gdGhlIERPTSB3aWxsIGJlIGZvdW5kIGFuZFxuICAgICAgICAgKiBpbmRpdmlkdWFsbHkgYm91bmQgd2hlbiBhIG1peGVyIGlzIGluc3RhbnRpYXRlZCwgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIGFjdGlvbnNcbiAgICAgICAgICogY2FjaGVkIGZvciBwZXJmb3JtYW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYHRydWVgLCBhIHNpbmdsZSBjbGljayBoYW5kbGVyIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgYHdpbmRvd2AgKG9yIGNvbnRhaW5lciBlbGVtZW50IC0gc2VlXG4gICAgICAgICAqIGBjb25maWcuY29udHJvbHMuc2NvcGVgKSwgYW5kIGFueSBjbGljayBldmVudHMgdHJpZ2dlcmVkIGJ5IGVsZW1lbnRzIHdpdGggYGRhdGEtZmlsdGVyYCxcbiAgICAgICAgICogYGRhdGEtc29ydGAgb3IgYGRhdGEtdG9nZ2xlYCBhdHRyaWJ1dGVzIHByZXNlbnQgd2lsbCBiZSBoYW5kbGVkIGFzIHRoZXkgcHJvcGFnYXRlIHVwd2FyZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSByZXF1aXJlIGEgdXNlciBpbnRlcmZhY2Ugd2hlcmUgY29udHJvbCBidXR0b25zIG1heSBiZSBhZGRlZCwgcmVtb3ZlZCwgb3IgY2hhbmdlZCBkdXJpbmcgdGhlXG4gICAgICAgICAqIGxpZmV0aW1lIG9mIGEgbWl4ZXIsIGBjb250cm9scy5saXZlYCBzaG91bGQgYmUgc2V0IHRvIGB0cnVlYC4gVGhlcmUgaXMgYSBtYXJnaW5hbCBidXQgdW5hdm9pZGFibGVcbiAgICAgICAgICogcGVyZm9ybWFuY2UgZGVmaWNpdCB3aGVuIHVzaW5nIGxpdmUgY29udHJvbHMsIGFzIHRoZSB2YWx1ZSBvZiBlYWNoIGNvbnRyb2wgYnV0dG9uIG11c3QgYmUgcmVhZFxuICAgICAgICAgKiBmcm9tIHRoZSBET00gaW4gcmVhbCB0aW1lIG9uY2UgdGhlIGNsaWNrIGV2ZW50IGhhcyBwcm9wYWdhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBTZXR0aW5nIGxpdmUgY29udHJvbHM8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGNvbnRyb2xzOiB7XG4gICAgICAgICAqICAgICAgICAgbGl2ZTogdHJ1ZVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQ29udHJvbCBidXR0b25zIGNhbiBub3cgYmUgYWRkZWQsIHJlbW92ZSBhbmQgY2hhbmdlZCB3aXRob3V0IGJyZWFraW5nXG4gICAgICAgICAqIC8vIHRoZSBtaXhlcidzIFVJXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBsaXZlXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jb250cm9sc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgdHJ1ZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmxpdmUgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgZGljdGF0aW5nIHRoZSBcInNjb3BlXCIgdG8gdXNlIHdoZW4gYmluZGluZyBvciBxdWVyeWluZyB0aGUgZGVmYXVsdCBjb250cm9scy4gVGhlIGF2YWlsYWJsZVxuICAgICAgICAgKiB2YWx1ZXMgYXJlIGAnZ2xvYmFsJ2Agb3IgYCdsb2NhbCdgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHNldCB0byBgJ2dsb2JhbCdgIChkZWZhdWx0IGJlaGF2aW9yKSwgTWl4SXRVcCB3aWxsIHF1ZXJ5IHRoZSBlbnRpcmUgZG9jdW1lbnQgZm9yIGNvbnRyb2wgYnV0dG9uc1xuICAgICAgICAgKiB0byBiaW5kLCBvciBkZWxlZ2F0ZSBjbGljayBldmVudHMgZnJvbSAoc2VlIGBjb25maWcuY29udHJvbHMubGl2ZWApLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHNldCB0byBgJ2xvY2FsJ2AsIE1peEl0VXAgd2lsbCBvbmx5IHF1ZXJ5IChvciBiaW5kIGNsaWNrIGV2ZW50cyB0bykgaXRzIG93biBjb250YWluZXIgZWxlbWVudC5cbiAgICAgICAgICogVGhpcyBtYXkgYmUgZGVzaXJlYWJsZSBpZiB5b3UgcmVxdWlyZSBtdWx0aXBsZSBhY3RpdmUgbWl4ZXIgaW5zdGFuY2VzIHdpdGhpbiB0aGUgc2FtZSBkb2N1bWVudCwgd2l0aFxuICAgICAgICAgKiBjb250cm9scyB0aGF0IHdvdWxkIG90aGVyd2lzZSBpbnRlZmVyZSB3aXRoIGVhY2ggb3RoZXIgaWYgc2NvcGVkIGdsb2JhbGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb252ZXJzZWx5LCBpZiB5b3Ugd2lzaCB0byBjb250cm9sIG11bHRpcGxlIGluc3RhbmNlcyB3aXRoIGEgc2luZ2xlIFVJLCB5b3Ugd291bGQgY3JlYXRlIG9uZVxuICAgICAgICAgKiBzZXQgb2YgY29udHJvbHMgYW5kIGtlZXAgdGhlIGNvbnRyb2xzIHNjb3BlIG9mIGVhY2ggbWl4ZXIgc2V0IHRvIGBnbG9iYWxgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBTZXR0aW5nICdsb2NhbCcgc2NvcGVkIGNvbnRyb2xzPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXJPbmUgPSBtaXhpdHVwKGNvbnRhaW5lck9uZSwge1xuICAgICAgICAgKiAgICAgY29udHJvbHM6IHtcbiAgICAgICAgICogICAgICAgICBzY29wZTogJ2xvY2FsJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyVHdvID0gbWl4aXR1cChjb250YWluZXJUd28sIHtcbiAgICAgICAgICogICAgIGNvbnRyb2xzOiB7XG4gICAgICAgICAqICAgICAgICAgc2NvcGU6ICdsb2NhbCdcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEJvdGggbWl4ZXJzIGNhbiBub3cgZXhpc3Qgd2l0aGluIHRoZSBzYW1lIGRvY3VtZW50IHdpdGhcbiAgICAgICAgICogLy8gaXNvbGF0ZWQgY29udHJvbHMgcGxhY2VkIHdpdGhpbiB0aGVpciBjb250YWluZXIgZWxlbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBzY29wZVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuY29udHJvbHNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJ2dsb2JhbCdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5zY29wZSA9ICdnbG9iYWwnOyAvLyBlbnVtOiBbJ2xvY2FsJyAsJ2dsb2JhbCddXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3RyaW5nIGRpY3RhdGluZyB0aGUgdHlwZSBvZiBsb2dpYyB0byBhcHBseSB3aGVuIGNvbmNhdGVuYXRpbmcgdGhlIGZpbHRlciBzZWxlY3RvcnMgb2ZcbiAgICAgICAgICogYWN0aXZlIHRvZ2dsZSBidXR0b25zIChpLmUuIGFueSBjbGlja2FibGUgZWxlbWVudCB3aXRoIGEgYGRhdGEtdG9nZ2xlYCBhdHRyaWJ1dGUpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBzZXQgdG8gYCdvcidgIChkZWZhdWx0IGJlaGF2aW9yKSwgc2VsZWN0b3JzIHdpbGwgYmUgY29uY2F0ZW5hdGVkIHRvZ2V0aGVyIGFzXG4gICAgICAgICAqIGEgY29tbWEtc2VwZXJhdGVkIGxpc3QuIEZvciBleGFtcGxlOlxuICAgICAgICAgKlxuICAgICAgICAgKiBgJy5jYXQtMSwgLmNhdC0yJ2AgKHNob3dzIGFueSBlbGVtZW50cyBtYXRjaGluZyBgJy5jYXQtMSdgIE9SIGAnLmNhdC0yJ2ApXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHNldCB0byBgJ2FuZCdgLCBzZWxlY3RvcnMgd2lsbCBiZSBkaXJlY3RseSBjb25jYXRlbmF0ZWQgdG9nZXRoZXIuIEZvciBleGFtcGxlOlxuICAgICAgICAgKlxuICAgICAgICAgKiBgJy5jYXQtMS5jYXQtMidgIChzaG93cyBhbnkgZWxlbWVudHMgd2hpY2ggbWF0Y2ggYm90aCBgJy5jYXQtMSdgIEFORCBgJy5jYXQtMidgKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBTZXR0aW5nIFwiYW5kXCIgdG9nZ2xlIGxvZ2ljPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjb250cm9sczoge1xuICAgICAgICAgKiAgICAgICAgIHRvZ2dsZUxvZ2ljOiAnYW5kJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIHRvZ2dsZUxvZ2ljXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jb250cm9sc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICAnb3InXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMudG9nZ2xlTG9naWMgPSAnb3InOyAvLyBlbnVtOiBbJ29yJywgJ2FuZCddXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3RyaW5nIGRpY3RhdGluZyB0aGUgZmlsdGVyIGJlaGF2aW9yIHdoZW4gYWxsIHRvZ2dsZXMgYXJlIGluYWN0aXZlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHNldCB0byBgJ2FsbCdgIChkZWZhdWx0IGJlaGF2aW9yKSwgKmFsbCogdGFyZ2V0cyB3aWxsIGJlIHNob3duIGJ5IGRlZmF1bHRcbiAgICAgICAgICogd2hlbiBubyB0b2dnbGVzIGFyZSBhY3RpdmUsIG9yIGF0IHRoZSBtb21lbnQgYWxsIGFjdGl2ZSB0b2dnbGVzIGFyZSB0b2dnbGVkIG9mZi5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBzZXQgdG8gYCdub25lJ2AsIG5vIHRhcmdldHMgd2lsbCBiZSBzaG93biBieSBkZWZhdWx0IHdoZW4gbm8gdG9nZ2xlcyBhcmVcbiAgICAgICAgICogYWN0aXZlLCBvciBhdCB0aGUgbW9tZW50IGFsbCBhY3RpdmUgdG9nZ2xlcyBhcmUgdG9nZ2xlZCBvZmYuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogU2V0dGluZyB0aGUgZGVmYXVsdCB0b2dnbGUgYmVoYXZpb3IgdG8gYCdhbGwnYDwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY29udHJvbHM6IHtcbiAgICAgICAgICogICAgICAgICB0b2dnbGVEZWZhdWx0OiAnYWxsJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIudG9nZ2xlT24oJy5jYXQtMicpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICogICAgICAgICAvLyBEZWFjdGl2YXRlIGFsbCBhY3RpdmUgdG9nZ2xlc1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIHJldHVybiBtaXhlci50b2dnbGVPZmYoJy5jYXQtMicpXG4gICAgICAgICAqICAgICB9KVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlRmlsdGVyLnNlbGVjdG9yKTsgLy8gJ2FsbCdcbiAgICAgICAgICogICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93KTsgLy8gMTJcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDI6IFNldHRpbmcgdGhlIGRlZmF1bHQgdG9nZ2xlIGJlaGF2aW9yIHRvIGAnbm9uZSdgPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjb250cm9sczoge1xuICAgICAgICAgKiAgICAgICAgIHRvZ2dsZURlZmF1bHQ6ICdub25lJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIudG9nZ2xlT24oJy5jYXQtMicpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICogICAgICAgICAvLyBEZWFjdGl2YXRlIGFsbCBhY3RpdmUgdG9nZ2xlc1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIHJldHVybiBtaXhlci50b2dnbGVPZmYoJy5jYXQtMicpXG4gICAgICAgICAqICAgICB9KVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlRmlsdGVyLnNlbGVjdG9yKTsgLy8gJ25vbmUnXG4gICAgICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnRvdGFsU2hvdyk7IC8vIDBcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgdG9nZ2xlRGVmYXVsdFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuY29udHJvbHNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJ2FsbCdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy50b2dnbGVEZWZhdWx0ID0gJ2FsbCc7IC8vIGVudW06IFsnYWxsJywgJ25vbmUnXVxuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbmZpZ0NvbnRyb2xzKTtcblxuICAgIG1peGl0dXAuQ29uZmlnQ29udHJvbHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29uZmlnQ29udHJvbHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db25maWdDb250cm9scztcblxuICAgIC8qKlxuICAgICAqIEEgZ3JvdXAgb2YgcHJvcGVydGllcyBkZWZpbmluZyB0aGUgb3V0cHV0IGFuZCBzdHJ1Y3R1cmUgb2YgY2xhc3MgbmFtZXMgcHJvZ3JhbW1hdGljYWxseVxuICAgICAqIGFkZGVkIHRvIGNvbnRyb2xzIGFuZCBjb250YWluZXJzIHRvIHJlZmxlY3QgdGhlIHN0YXRlIG9mIHRoZSBtaXhlci5cbiAgICAgKlxuICAgICAqIE1vc3QgY29tbW9ubHksIGNsYXNzIG5hbWVzIGFyZSBhZGRlZCB0byBjb250cm9scyBieSBNaXhJdFVwIHRvIGluZGljYXRlIHRoYXRcbiAgICAgKiB0aGUgY29udHJvbCBpcyBhY3RpdmUgc28gdGhhdCBpdCBjYW4gYmUgc3R5bGVkIGFjY29yZGluZ2x5IC0gYCdtaXhpdHVwLWNvbnRyb2wtYWN0aXZlJ2AgYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIFVzaW5nIGEgXCJCRU1cIiBsaWtlIHN0cnVjdHVyZSwgZWFjaCBjbGFzc25hbWUgaXMgYnJva2VuIGludG8gdGhlIHRocmVlIHBhcnRzOlxuICAgICAqIGEgYmxvY2sgbmFtZXNwYWNlIChgJ21peGl0dXAnYCksIGFuIGVsZW1lbnQgbmFtZSAoZS5nLiBgJ2NvbnRyb2wnYCksIGFuZCBhbiBvcHRpb25hbCBtb2RpZmllclxuICAgICAqIG5hbWUgKGUuZy4gYCdhY3RpdmUnYCkgcmVmbGVjdGluZyB0aGUgc3RhdGUgb2YgdGhlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBlYWNoIHBhcnQgb2YgdGhlIGNsYXNzbmFtZSBpcyBjb25jYXRlbmF0ZWQgdG9nZXRoZXIgdXNpbmcgc2luZ2xlIGh5cGhlbnMgYXNcbiAgICAgKiBkZWxpbmVhdG9ycywgYnV0IHRoaXMgY2FuIGJlIGVhc2lseSBjdXN0b21pc2VkIHRvIG1hdGNoIHRoZSBuYW1pbmcgY29udmVudGlvbiBhbmQgc3R5bGUgb2ZcbiAgICAgKiB5b3VyIHByb2plY3QuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWdcbiAgICAgKiBAbmFtZSAgICAgICAgY2xhc3NOYW1lc1xuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAcHVibGljXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkNvbmZpZ0NsYXNzTmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImJsb2NrXCIgcG9ydGlvbiwgb3IgdG9wLWxldmVsIG5hbWVzcGFjZSBhZGRlZCB0byB0aGUgc3RhcnQgb2YgYW55IGNsYXNzIG5hbWVzIGNyZWF0ZWQgYnkgTWl4SXRVcC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAxOiBjaGFuZ2luZyB0aGUgYGNvbmZpZy5jbGFzc05hbWVzLmJsb2NrYCB2YWx1ZTwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgKiAgICAgICAgIGJsb2NrOiAncG9ydGZvbGlvJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIGNvbnRyb2wgb3V0cHV0OiBcInBvcnRmb2xpby1jb250cm9sLWFjdGl2ZVwiXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogUmVtb3ZpbmcgYGNvbmZpZy5jbGFzc05hbWVzLmJsb2NrYDwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgKiAgICAgICAgIGJsb2NrOiAnJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIGNvbnRyb2wgb3V0cHV0OiBcImNvbnRyb2wtYWN0aXZlXCJcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGJsb2NrXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jbGFzc05hbWVzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICdtaXhpdHVwJ1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmJsb2NrID0gJ21peGl0dXAnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJlbGVtZW50XCIgcG9ydGlvbiBvZiB0aGUgY2xhc3MgbmFtZSBhZGRlZCB0byBjb250YWluZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBlbGVtZW50Q29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jbGFzc05hbWVzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICdjb250YWluZXInXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuZWxlbWVudENvbnRhaW5lciA9ICdjb250YWluZXInO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJlbGVtZW50XCIgcG9ydGlvbiBvZiB0aGUgY2xhc3MgbmFtZSBhZGRlZCB0byBmaWx0ZXIgY29udHJvbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIGFsbCBmaWx0ZXIsIHNvcnQsIG11bHRpbWl4IGFuZCB0b2dnbGUgY29udHJvbHMgdGFrZSB0aGUgc2FtZSBlbGVtZW50IHZhbHVlIG9mIGAnY29udHJvbCdgLCBidXRcbiAgICAgICAgICogZWFjaCB0eXBlJ3MgZWxlbWVudCB2YWx1ZSBjYW4gYmUgaW5kaXZpZHVhbGx5IG92ZXJ3cml0dGVuIHRvIG1hdGNoIHRoZSB1bmlxdWUgY2xhc3NOYW1lcyBvZiB5b3VyIGNvbnRyb2xzIGFzIG5lZWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAxOiBjaGFuZ2luZyB0aGUgYGNvbmZpZy5jbGFzc05hbWVzLmVsZW1lbnRGaWx0ZXJgIHZhbHVlPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjbGFzc05hbWVzOiB7XG4gICAgICAgICAqICAgICAgICAgZWxlbWVudEZpbHRlcjogJ2ZpbHRlcidcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEFjdGl2ZSBmaWx0ZXIgb3V0cHV0OiBcIm1peGl0dXAtZmlsdGVyLWFjdGl2ZVwiXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogY2hhbmdpbmcgdGhlIGBjb25maWcuY2xhc3NOYW1lcy5ibG9ja2AgYW5kIGBjb25maWcuY2xhc3NOYW1lcy5lbGVtZW50RmlsdGVyYCB2YWx1ZXM8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGNsYXNzTmFtZXM6IHtcbiAgICAgICAgICogICAgICAgICBibG9jazogJ3BvcnRmb2xpbycsXG4gICAgICAgICAqICAgICAgICAgZWxlbWVudEZpbHRlcjogJ2ZpbHRlcidcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEFjdGl2ZSBmaWx0ZXIgb3V0cHV0OiBcInBvcnRmb2xpby1maWx0ZXItYWN0aXZlXCJcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGVsZW1lbnRGaWx0ZXJcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmNsYXNzTmFtZXNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJ2NvbnRyb2wnXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuZWxlbWVudEZpbHRlciA9ICdjb250cm9sJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFwiZWxlbWVudFwiIHBvcnRpb24gb2YgdGhlIGNsYXNzIG5hbWUgYWRkZWQgdG8gc29ydCBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgYWxsIGZpbHRlciwgc29ydCwgbXVsdGltaXggYW5kIHRvZ2dsZSBjb250cm9scyB0YWtlIHRoZSBzYW1lIGVsZW1lbnQgdmFsdWUgb2YgYCdjb250cm9sJ2AsIGJ1dFxuICAgICAgICAgKiBlYWNoIHR5cGUncyBlbGVtZW50IHZhbHVlIGNhbiBiZSBpbmRpdmlkdWFsbHkgb3ZlcndyaXR0ZW4gdG8gbWF0Y2ggdGhlIHVuaXF1ZSBjbGFzc05hbWVzIG9mIHlvdXIgY29udHJvbHMgYXMgbmVlZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IGNoYW5naW5nIHRoZSBgY29uZmlnLmNsYXNzTmFtZXMuZWxlbWVudFNvcnRgIHZhbHVlPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjbGFzc05hbWVzOiB7XG4gICAgICAgICAqICAgICAgICAgZWxlbWVudFNvcnQ6ICdzb3J0J1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIHNvcnQgb3V0cHV0OiBcIm1peGl0dXAtc29ydC1hY3RpdmVcIlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDI6IGNoYW5naW5nIHRoZSBgY29uZmlnLmNsYXNzTmFtZXMuYmxvY2tgIGFuZCBgY29uZmlnLmNsYXNzTmFtZXMuZWxlbWVudFNvcnRgIHZhbHVlczwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgKiAgICAgICAgIGJsb2NrOiAncG9ydGZvbGlvJyxcbiAgICAgICAgICogICAgICAgICBlbGVtZW50U29ydDogJ3NvcnQnXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBBY3RpdmUgc29ydCBvdXRwdXQ6IFwicG9ydGZvbGlvLXNvcnQtYWN0aXZlXCJcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGVsZW1lbnRTb3J0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jbGFzc05hbWVzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICdjb250cm9sJ1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmVsZW1lbnRTb3J0ID0gJ2NvbnRyb2wnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJlbGVtZW50XCIgcG9ydGlvbiBvZiB0aGUgY2xhc3MgbmFtZSBhZGRlZCB0byBtdWx0aW1peCBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgYWxsIGZpbHRlciwgc29ydCwgbXVsdGltaXggYW5kIHRvZ2dsZSBjb250cm9scyB0YWtlIHRoZSBzYW1lIGVsZW1lbnQgdmFsdWUgb2YgYCdjb250cm9sJ2AsIGJ1dFxuICAgICAgICAgKiBlYWNoIHR5cGUncyBlbGVtZW50IHZhbHVlIGNhbiBiZSBpbmRpdmlkdWFsbHkgb3ZlcndyaXR0ZW4gdG8gbWF0Y2ggdGhlIHVuaXF1ZSBjbGFzc05hbWVzIG9mIHlvdXIgY29udHJvbHMgYXMgbmVlZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IGNoYW5naW5nIHRoZSBgY29uZmlnLmNsYXNzTmFtZXMuZWxlbWVudE11bHRpbWl4YCB2YWx1ZTwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgKiAgICAgICAgIGVsZW1lbnRNdWx0aW1peDogJ211bHRpbWl4J1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIG11bHRpbWl4IG91dHB1dDogXCJtaXhpdHVwLW11bHRpbWl4LWFjdGl2ZVwiXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogY2hhbmdpbmcgdGhlIGBjb25maWcuY2xhc3NOYW1lcy5ibG9ja2AgYW5kIGBjb25maWcuY2xhc3NOYW1lcy5lbGVtZW50TXVsdGltaXhgIHZhbHVlczwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgKiAgICAgICAgIGJsb2NrOiAncG9ydGZvbGlvJyxcbiAgICAgICAgICogICAgICAgICBlbGVtZW50U29ydDogJ211bHRpbWl4J1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIG11bHRpbWl4IG91dHB1dDogXCJwb3J0Zm9saW8tbXVsdGltaXgtYWN0aXZlXCJcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGVsZW1lbnRNdWx0aW1peFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuY2xhc3NOYW1lc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICAnY29udHJvbCdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5lbGVtZW50TXVsdGltaXggPSAnY29udHJvbCc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImVsZW1lbnRcIiBwb3J0aW9uIG9mIHRoZSBjbGFzcyBuYW1lIGFkZGVkIHRvIHRvZ2dsZSBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgYWxsIGZpbHRlciwgc29ydCwgbXVsdGltaXggYW5kIHRvZ2dsZSBjb250cm9scyB0YWtlIHRoZSBzYW1lIGVsZW1lbnQgdmFsdWUgb2YgYCdjb250cm9sJ2AsIGJ1dFxuICAgICAgICAgKiBlYWNoIHR5cGUncyBlbGVtZW50IHZhbHVlIGNhbiBiZSBpbmRpdmlkdWFsbHkgb3ZlcndyaXR0ZW4gdG8gbWF0Y2ggdGhlIHVuaXF1ZSBjbGFzc05hbWVzIG9mIHlvdXIgY29udHJvbHMgYXMgbmVlZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IGNoYW5naW5nIHRoZSBgY29uZmlnLmNsYXNzTmFtZXMuZWxlbWVudFRvZ2dsZWAgdmFsdWU8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGNsYXNzTmFtZXM6IHtcbiAgICAgICAgICogICAgICAgICBlbGVtZW50VG9nZ2xlOiAndG9nZ2xlJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIHRvZ2dsZSBvdXRwdXQ6IFwibWl4aXR1cC10b2dnbGUtYWN0aXZlXCJcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAyOiBjaGFuZ2luZyB0aGUgYGNvbmZpZy5jbGFzc05hbWVzLmJsb2NrYCBhbmQgYGNvbmZpZy5jbGFzc05hbWVzLmVsZW1lbnRUb2dnbGVgIHZhbHVlczwvY2FwdGlvbj5cbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgKiAgICAgICAgIGJsb2NrOiAncG9ydGZvbGlvJyxcbiAgICAgICAgICogICAgICAgICBlbGVtZW50VG9nZ2xlOiAndG9nZ2xlJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIHRvZ2dsZSBvdXRwdXQ6IFwicG9ydGZvbGlvLXRvZ2dsZS1hY3RpdmVcIlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgZWxlbWVudFRvZ2dsZVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuY2xhc3NOYW1lc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICAnY29udHJvbCdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5lbGVtZW50VG9nZ2xlID0gJ2NvbnRyb2wnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJtb2RpZmllclwiIHBvcnRpb24gb2YgdGhlIGNsYXNzIG5hbWUgYWRkZWQgdG8gYWN0aXZlIGNvbnRyb2xzLlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgbW9kaWZpZXJBY3RpdmVcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmNsYXNzTmFtZXNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJ2FjdGl2ZSdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5tb2RpZmllckFjdGl2ZSA9ICdhY3RpdmUnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJtb2RpZmllclwiIHBvcnRpb24gb2YgdGhlIGNsYXNzIG5hbWUgYWRkZWQgdG8gZGlzYWJsZWQgY29udHJvbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBtb2RpZmllckRpc2FibGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jbGFzc05hbWVzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICdkaXNhYmxlZCdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5tb2RpZmllckRpc2FibGVkID0gJ2Rpc2FibGVkJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFwibW9kaWZpZXJcIiBwb3J0aW9uIG9mIHRoZSBjbGFzcyBuYW1lIGFkZGVkIHRvIHRoZSBjb250YWluZXIgd2hlbiBpbiBhIFwiZmFpbGVkXCIgc3RhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBtb2RpZmllckZhaWxlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuY2xhc3NOYW1lc1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICAnZmFpbGVkJ1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLm1vZGlmaWVyRmFpbGVkID0gJ2ZhaWxlZCc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWxpbmVhdG9yIHVzZWQgYmV0d2VlbiB0aGUgXCJibG9ja1wiIGFuZCBcImVsZW1lbnRcIiBwb3J0aW9ucyBvZiBhbnkgY2xhc3MgbmFtZSBhZGRlZCBieSBNaXhJdFVwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgYmxvY2sgcG9ydGlvbiBpcyBvbW1pdGVkIGJ5IHNldHRpbmcgaXQgdG8gYW4gZW1wdHkgc3RyaW5nLCBubyBkZWxpbmVhdG9yIHdpbGwgYmUgYWRkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IGNoYW5naW5nIHRoZSBkZWxpbmVhdG9yIHRvIG1hdGNoIEJFTSBjb252ZW50aW9uPC9jYXB0aW9uPlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBjbGFzc05hbWVzOiB7XG4gICAgICAgICAqICAgICAgICAgZGVsaW5lYXRvckVsZW1lbnQ6ICdfXydcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGV4YW1wbGUgYWN0aXZlIGNvbnRyb2wgb3V0cHV0OiBcIm1peGl0dXBfX2NvbnRyb2wtYWN0aXZlXCJcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGRlbGluZWF0b3JFbGVtZW50XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5jbGFzc05hbWVzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICctJ1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmRlbGluZWF0b3JFbGVtZW50ID0gJy0nO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVsaW5lYXRvciB1c2VkIGJldHdlZW4gdGhlIFwiZWxlbWVudFwiIGFuZCBcIm1vZGlmaWVyXCIgcG9ydGlvbnMgb2YgYW55IGNsYXNzIG5hbWUgYWRkZWQgYnkgTWl4SXRVcC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGVsZW1lbnQgcG9ydGlvbiBpcyBvbW1pdGVkIGJ5IHNldHRpbmcgaXQgdG8gYW4gZW1wdHkgc3RyaW5nLCBubyBkZWxpbmVhdG9yIHdpbGwgYmUgYWRkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IGNoYW5naW5nIGJvdGggZGVsaW5lYXRvcnMgdG8gbWF0Y2ggQkVNIGNvbnZlbnRpb248L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGNsYXNzTmFtZXM6IHtcbiAgICAgICAgICogICAgICAgICBkZWxpbmVhdG9yRWxlbWVudDogJ19fJ1xuICAgICAgICAgKiAgICAgICAgIGRlbGluZWF0b3JNb2RpZmllcjogJy0tJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWN0aXZlIGNvbnRyb2wgb3V0cHV0OiBcIm1peGl0dXBfX2NvbnRyb2wtLWFjdGl2ZVwiXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBkZWxpbmVhdG9yTW9kaWZpZXJcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmNsYXNzTmFtZXNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJy0nXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuZGVsaW5lYXRvck1vZGlmaWVyID0gJy0nO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbmZpZ0NsYXNzTmFtZXMpO1xuXG4gICAgbWl4aXR1cC5Db25maWdDbGFzc05hbWVzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ0NsYXNzTmFtZXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db25maWdDbGFzc05hbWVzO1xuXG4gICAgLyoqXG4gICAgICogQSBncm91cCBvZiBwcm9wZXJ0aWVzIHJlbGF0aW5nIHRvIE1peEl0VXAncyBkYXRhc2V0IEFQSS5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZ1xuICAgICAqIEBuYW1lICAgICAgICBkYXRhXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29uZmlnRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgc3BlY2lmeWluZyB0aGUgbmFtZSBvZiB0aGUga2V5IGNvbnRhaW5pbmcgeW91ciBkYXRhIG1vZGVsJ3MgdW5pcXVlXG4gICAgICAgICAqIGlkZW50aWZpZXIgKFVJRCkuIFRvIHVzZSB0aGUgZGF0YXNldCBBUEksIGEgVUlEIGtleSBtdXN0IGJlIHNwZWNpZmllZCBhbmRcbiAgICAgICAgICogYmUgcHJlc2VudCBhbmQgdW5pcXVlIG9uIGFsbCBvYmplY3RzIGluIHRoZSBkYXRhc2V0IHlvdSBwcm92aWRlIHRvIE1peEl0VXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlLCBpZiB5b3VyIGRhdGFzZXQgaXMgbWFkZSB1cCBvZiBNb25nb0RCIGRvY3VtZW50cywgdGhlIFVJRFxuICAgICAgICAgKiBrZXkgd291bGQgYmUgYCdpZCdgIG9yIGAnX2lkJ2AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IFNldHRpbmcgdGhlIFVJRCB0byBgJ2lkJ2A8L2NhcHRpb24+XG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGRhdGE6IHtcbiAgICAgICAgICogICAgICAgICB1aWRLZXk6ICdpZCdcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICB1aWRLZXlcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmRhdGFcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJydcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy51aWRLZXkgPSAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIG9yIG5vdCBNaXhJdFVwIHNob3VsZCBcImRpcnR5IGNoZWNrXCIgZWFjaCBvYmplY3QgaW5cbiAgICAgICAgICogeW91ciBkYXRhc2V0IGZvciBjaGFuZ2VzIHdoZW5ldmVyIGAuZGF0YXNldCgpYCBpcyBjYWxsZWQsIGFuZCByZS1yZW5kZXIgYW55IHRhcmdldHNcbiAgICAgICAgICogZm9yIHdoaWNoIGEgY2hhbmdlIGlzIGZvdW5kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBEZXBlbmRpbmcgb24gdGhlIGNvbXBsZXhpdHkgb2YgeW91ciBkYXRhIG1vZGVsLCBkaXJ0eSBjaGVja2luZyBjYW4gYmUgZXhwZW5zaXZlXG4gICAgICAgICAqIGFuZCBpcyB0aGVyZWZvcmUgZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogTkI6IEZvciBjaGFuZ2VzIHRvIGJlIGRldGVjdGVkLCBhIG5ldyBpbW11dGFibGUgaW5zdGFuY2Ugb2YgdGhlIGVkaXRlZCBtb2RlbCBtdXN0IGJlXG4gICAgICAgICAqIHByb3ZpZGVkIHRvIG1peGl0dXAsIHJhdGhlciB0aGFuIG1hbmlwdWxhdGluZyBwcm9wZXJ0aWVzIG9uIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgICogSWYgeW91ciBjaGFuZ2VzIGFyZSBhIHJlc3VsdCBvZiBhIERCIHdyaXRlIGFuZCByZWFkLCB5b3Ugd2lsbCBtb3N0IGxpa2VseSBiZSBjYWxsaW5nXG4gICAgICAgICAqIGAuZGF0YXNldCgpYCB3aXRoIGEgY2xlYW4gc2V0IG9mIG9iamVjdHMgZWFjaCB0aW1lLCBzbyB0aGlzIHdpbGwgbm90IGJlIGFuIGlzc3VlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBFbmFibGluZyBkaXJ0eSBjaGVja2luZzwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG15RGF0YXNldCA9IFtcbiAgICAgICAgICogICAgIHtcbiAgICAgICAgICogICAgICAgICBpZDogMCxcbiAgICAgICAgICogICAgICAgICB0aXRsZTogXCJCbG9nIFBvc3QgVGl0bGUgMFwiXG4gICAgICAgICAqICAgICAgICAgLi4uXG4gICAgICAgICAqICAgICB9LFxuICAgICAgICAgKiAgICAge1xuICAgICAgICAgKiAgICAgICAgIGlkOiAxLFxuICAgICAgICAgKiAgICAgICAgIHRpdGxlOiBcIkJsb2cgUG9zdCBUaXRsZSAxXCJcbiAgICAgICAgICogICAgICAgICAuLi5cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogXTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gSW5zdGFudGlhdGUgYSBtaXhlciB3aXRoIGEgcHJlLWxvYWRlZCBkYXRhc2V0LCBhbmQgYSB0YXJnZXQgcmVuZGVyZXJcbiAgICAgICAgICogLy8gZnVuY3Rpb24gZGVmaW5lZFxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBkYXRhOiB7XG4gICAgICAgICAqICAgICAgICAgdWlkS2V5OiAnaWQnLFxuICAgICAgICAgKiAgICAgICAgIGRpcnR5Q2hlY2s6IHRydWVcbiAgICAgICAgICogICAgIH0sXG4gICAgICAgICAqICAgICBsb2FkOiB7XG4gICAgICAgICAqICAgICAgICAgZGF0YXNldDogbXlEYXRhc2V0XG4gICAgICAgICAqICAgICB9LFxuICAgICAgICAgKiAgICAgcmVuZGVyOiB7XG4gICAgICAgICAqICAgICAgICAgdGFyZ2V0OiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEZvciBpbGx1c3RyYXRpb24sIHdlIHdpbGwgY2xvbmUgYW5kIGVkaXQgdGhlIHNlY29uZCBvYmplY3QgaW4gdGhlIGRhdGFzZXQuXG4gICAgICAgICAqIC8vIE5COiB0aGlzIHdvdWxkIHR5cGljYWxseSBiZSBkb25lIHNlcnZlci1zaWRlIGluIHJlc3BvbnNlIHRvIGEgREIgdXBkYXRlLFxuICAgICAgICAgKiBhbmQgdGhlbiByZS1xdWVyaWVkIHZpYSBhbiBBUEkuXG4gICAgICAgICAqXG4gICAgICAgICAqIG15RGF0YXNldFsxXSA9IE9iamVjdC5hc3NpZ24oe30sIG15RGF0YXNldFsxXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIG15RGF0YXNldFsxXS50aXRsZSA9ICdCbG9nIFBvc3QgVGl0bGUgMTEnO1xuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5kYXRhc2V0KG15RGF0YXNldClcbiAgICAgICAgICogICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAqICAgICAgICAvLyB0aGUgdGFyZ2V0IHdpdGggSUQgXCIxXCIsIHdpbGwgYmUgcmUtcmVuZGVyZWQgcmVmbGVjdGluZyBpdHMgbmV3IHRpdGxlXG4gICAgICAgICAqICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgZGlydHlDaGVja1xuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuZGF0YVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgZmFsc2VcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5kaXJ0eUNoZWNrID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuQ29uZmlnRGF0YSk7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ0RhdGEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29uZmlnRGF0YS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLkNvbmZpZ0RhdGE7XG5cbiAgICAvKipcbiAgICAgKiBBIGdyb3VwIG9mIHByb3BlcnRpZXMgYWxsb3dpbmcgdGhlIHRvZ2dsaW5nIG9mIHZhcmlvdXMgZGVidWcgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWdcbiAgICAgKiBAbmFtZSAgICAgICAgZGVidWdcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db25maWdEZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgbWl4ZXIgaW5zdGFuY2UgcmV0dXJuZWQgYnkgdGhlXG4gICAgICAgICAqIGBtaXhpdHVwKClgIGZhY3RvcnkgZnVuY3Rpb24gc2hvdWxkIGV4cG9zZSBwcml2YXRlIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIG1peGVyIGluc3RhbmNlcyBvbmx5IGV4cG9zZSB0aGVpciBwdWJsaWMgQVBJLCBidXQgZW5hYmxpbmdcbiAgICAgICAgICogZGVidWcgbW9kZSB3aWxsIGdpdmUgeW91IGFjY2VzcyB0byB2YXJpb3VzIG1peGVyIGludGVybmFscyB3aGljaCBtYXkgYWlkXG4gICAgICAgICAqIGluIGRlYnVnZ2luZywgb3IgdGhlIGF1dGhvcmluZyBvZiBleHRlbnNpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBFbmFibGluZyBkZWJ1ZyBtb2RlPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBkZWJ1Zzoge1xuICAgICAgICAgKiAgICAgICAgIGVuYWJsZTogdHJ1ZVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gUHJpdmF0ZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHdpbGwgbm93IGJlIHZpc2libGUgb24gdGhlIG1peGVyIGluc3RhbmNlOlxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhtaXhlcik7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBlbmFibGVcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmRlYnVnXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBmYWxzZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmVuYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgb3Igbm90IHdhcm5pbmdzIHNob3VsZCBiZSBzaG93biB3aGVuIHZhcmlvdXNcbiAgICAgICAgICogY29tbW9uIGdvdGNoYXMgb2NjdXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdhcm5pbmdzIGFyZSBpbnRlbmRlZCB0byBwcm92aWRlIGluc2lnaHRzIGR1cmluZyBkZXZlbG9wbWVudCB3aGVuIHNvbWV0aGluZ1xuICAgICAgICAgKiBvY2N1cnMgdGhhdCBpcyBub3QgYSBmYXRhbCwgYnV0IG1heSBpbmRpY2F0ZSBhbiBpc3N1ZSB3aXRoIHlvdXIgaW50ZWdyYXRpb24sXG4gICAgICAgICAqIGFuZCBhcmUgdGhlcmVmb3JlIHR1cm5lZCBvbiBieSBkZWZhdWx0LiBIb3dldmVyLCB5b3UgbWF5IHdpc2ggdG8gZGlzYWJsZVxuICAgICAgICAgKiB0aGVtIGluIHByb2R1Y3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogRGlzYWJsaW5nIHdhcm5pbmdzPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBkZWJ1Zzoge1xuICAgICAgICAgKiAgICAgICAgIHNob3dXYXJuaW5nczogZmFsc2VcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogRGlzYWJsaW5nIHdhcm5pbmdzIGJhc2VkIG9uIGVudmlyb25tZW50PC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgc2hvd1dhcm5pbmdzID0gbXlBcHBDb25maWcuZW52aXJvbm1lbnQgPT09ICdkZXZlbG9wbWVudCcgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGRlYnVnOiB7XG4gICAgICAgICAqICAgICAgICAgc2hvd1dhcm5pbmdzOiBzaG93V2FybmluZ3NcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBzaG93V2FybmluZ3NcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmRlYnVnXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICB0cnVlXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuc2hvd1dhcm5pbmdzID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBmb3Igc2VydmVyLXNpZGUgdGVzdGluZyBvbmx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbmFtZSAgICAgICAgZmF1eEFzeW5jXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5kZWJ1Z1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgZmFsc2VcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5mYXV4QXN5bmMgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db25maWdEZWJ1Zyk7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ0RlYnVnLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ0RlYnVnLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29uZmlnRGVidWc7XG5cbiAgICAvKipcbiAgICAgKiBBIGdyb3VwIG9mIHByb3BlcnRpZXMgcmVsYXRpbmcgdG8gdGhlIGxheW91dCBvZiB0aGUgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnXG4gICAgICogQG5hbWUgICAgICAgIGxheW91dFxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAcHVibGljXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkNvbmZpZ0xheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIG9yIG5vdCBtaXhpdHVwIHNob3VsZCBxdWVyeSBhbGwgZGVzY2VuZGFudHNcbiAgICAgICAgICogb2YgdGhlIGNvbnRhaW5lciBmb3IgdGFyZ2V0cywgb3Igb25seSBpbW1lZGlhdGUgY2hpbGRyZW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIG1peGl0dXAgd2lsbCBxdWVyeSBhbGwgZGVzY2VuZGFudHMgbWF0Y2hpbmcgdGhlXG4gICAgICAgICAqIGBzZWxlY3RvcnMudGFyZ2V0YCBzZWxlY3RvciB3aGVuIGluZGV4aW5nIHRhcmdldHMgdXBvbiBpbnN0YW50aWF0aW9uLlxuICAgICAgICAgKiBUaGlzIGFsbG93cyBmb3IgdGFyZ2V0cyB0byBiZSBuZXN0ZWQgaW5zaWRlIGEgc3ViLWNvbnRhaW5lciB3aGljaCBpc1xuICAgICAgICAgKiB1c2VmdWwgd2hlbiByaW5nLWZlbmNpbmcgdGFyZ2V0cyBmcm9tIGxvY2FsbHkgc2NvcGVkIGNvbnRyb2xzIGluIHlvdXJcbiAgICAgICAgICogbWFya3VwIChzZWUgYGNvbnRyb2xzLnNjb3BlYCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEhvd2V2ZXIsIGlmIHlvdSBhcmUgYnVpbGRpbmcgYSBtb3JlIGNvbXBsZXggVUkgcmVxdWlyaW5nIHRoZSBuZXN0aW5nXG4gICAgICAgICAqIG9mIG1peGVycyB3aXRoaW4gbWl4ZXJzLCB5b3Ugd2lsbCBtb3N0IGxpa2VseSB3YW50IHRvIGxpbWl0IHRhcmdldHMgdG9cbiAgICAgICAgICogaW1tZWRpYXRlIGNoaWxkcmVuIG9mIHRoZSBjb250YWluZXIgYnkgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIGBmYWxzZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IFJlc3RyaWN0aW5nIHRhcmdldHMgdG8gaW1tZWRpYXRlIGNoaWxkcmVuPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICogICAgICAgICBhbGxvd05lc3RlZFRhcmdldHM6IGZhbHNlXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgYWxsb3dOZXN0ZWRUYXJnZXRzXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5sYXlvdXRcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIHRydWVcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5hbGxvd05lc3RlZFRhcmdldHMgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN0cmluZyBzcGVjaWZ5aW5nIGFuIG9wdGlvbmFsIGNsYXNzIG5hbWUgdG8gYXBwbHkgdG8gdGhlIGNvbnRhaW5lciB3aGVuIGluXG4gICAgICAgICAqIGl0cyBkZWZhdWx0IHN0YXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBjaGFuZ2luZyB0aGlzIGNsYXNzIG5hbWUgb3IgYWRkaW5nIGEgY2xhc3MgbmFtZSB0byB0aGUgY29udGFpbmVyIHZpYSB0aGVcbiAgICAgICAgICogYC5jaGFuZ2VMYXlvdXQoKWAgQVBJIG1ldGhvZCwgdGhlIENTUyBsYXlvdXQgb2YgdGhlIGNvbnRhaW5lciBjYW4gYmUgY2hhbmdlZCxcbiAgICAgICAgICogYW5kIE1peEl0VXAgd2lsbCBhdHRlbXAgdG8gZ3JhY2VmdWxseSBhbmltYXRlIHRoZSBjb250YWluZXIgYW5kIGl0cyB0YXJnZXRzXG4gICAgICAgICAqIGJldHdlZW4gc3RhdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IFNwZWNpZnlpbmcgYSBjb250YWluZXIgY2xhc3MgbmFtZTwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgbGF5b3V0OiB7XG4gICAgICAgICAqICAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lOiAnZ3JpZCdcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogQ2hhbmdpbmcgdGhlIGRlZmF1bHQgY2xhc3MgbmFtZSB3aXRoIGAuY2hhbmdlTGF5b3V0KClgPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICogICAgICAgICBjb250YWluZXJDbGFzc05hbWU6ICdncmlkJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuY2hhbmdlTGF5b3V0KCdsaXN0JylcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLmFjdGl2ZUNvbnRhaW5lckNsYXNzKTsgLy8gXCJsaXN0XCJcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5sYXlvdXRcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJydcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gYSBub24tdGFyZ2V0IHNpYmxpbmcgZWxlbWVudCBhZnRlciB3aGljaCB0byBpbnNlcnQgdGFyZ2V0c1xuICAgICAgICAgKiB3aGVuIHRoZXJlIGFyZSBubyB0YXJnZXRzIGluIHRoZSBjb250YWluZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IFNldHRpbmcgYSBgc2libGluZ0JlZm9yZWAgcmVmZXJlbmNlIGVsZW1lbnQ8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBhZGRCdXR0b24gPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgbGF5b3V0OiB7XG4gICAgICAgICAqICAgICAgICAgc2libGluZ0JlZm9yZTogYWRkQnV0dG9uXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgc2libGluZ0JlZm9yZVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcubGF5b3V0XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge0hUTUxFbGVtZW50fVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgbnVsbFxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLnNpYmxpbmdCZWZvcmUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byBhIG5vbi10YXJnZXQgc2libGluZyBlbGVtZW50IGJlZm9yZSB3aGljaCB0byBpbnNlcnQgdGFyZ2V0c1xuICAgICAgICAgKiB3aGVuIHRoZXJlIGFyZSBubyB0YXJnZXRzIGluIHRoZSBjb250YWluZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IFNldHRpbmcgYW4gYHNpYmxpbmdBZnRlcmAgcmVmZXJlbmNlIGVsZW1lbnQ8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBnYXAgPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCcuZ2FwJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGxheW91dDoge1xuICAgICAgICAgKiAgICAgICAgIHNpYmxpbmdBZnRlcjogZ2FwXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgc2libGluZ0FmdGVyXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5sYXlvdXRcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBudWxsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuc2libGluZ0FmdGVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db25maWdMYXlvdXQpO1xuXG4gICAgbWl4aXR1cC5Db25maWdMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29uZmlnTGF5b3V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29uZmlnTGF5b3V0O1xuXG4gICAgLyoqXG4gICAgICogQSBncm91cCBvZiBwcm9wZXJ0aWVzIGRlZmluaW5nIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBtaXhlciBvbiBsb2FkIChpbnN0YW50aWF0aW9uKS5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZ1xuICAgICAqIEBuYW1lICAgICAgICBsb2FkXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAc2luY2UgICAgICAgMi4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29uZmlnTG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgZGVmaW5pbmcgYW55IGZpbHRlcmluZyB0byBiZSBzdGF0aWNhbGx5IGFwcGxpZWQgdG8gdGhlIG1peGVyIG9uIGxvYWQuXG4gICAgICAgICAqIEFzIHBlciB0aGUgYC5maWx0ZXIoKWAgQVBJLCB0aGlzIGNhbiBiZSBhbnkgdmFsaWQgc2VsZWN0b3Igc3RyaW5nLCBvciB0aGVcbiAgICAgICAgICogdmFsdWVzIGAnYWxsJ2Agb3IgYCdub25lJ2AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogRGVmaW5pbmcgYW4gaW5pdGlhbCBmaWx0ZXIgc2VsZWN0b3IgdG8gYmUgYXBwbGllZCBvbiBsb2FkPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBUaGUgbWl4ZXIgd2lsbCBzaG93IG9ubHkgdGhvc2UgdGFyZ2V0cyBtYXRjaGluZyAnLmNhdGVnb3J5LWEnIG9uIGxvYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGxvYWQ6IHtcbiAgICAgICAgICogICAgICAgICBmaWx0ZXI6ICcuY2F0ZWdvcnktYSdcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogSGlkaW5nIGFsbCB0YXJnZXRzIG9uIGxvYWQ8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIFRoZSBtaXhlciB3aWxsIHNob3cgaGlkZSBhbGwgdGFyZ2V0cyBvbiBsb2FkLlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICAgICAqICAgICBsb2FkOiB7XG4gICAgICAgICAqICAgICAgICAgZmlsdGVyOiAnbm9uZSdcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBmaWx0ZXJcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuQ29uZmlnLmxvYWRcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgJ2FsbCdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5maWx0ZXIgPSAnYWxsJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgZGVmaW5pbmcgYW55IHNvcnRpbmcgdG8gYmUgc3RhdGljYWxseSBhcHBsaWVkIHRvIHRoZSBtaXhlciBvbiBsb2FkLlxuICAgICAgICAgKiBBcyBwZXIgdGhlIGAuc29ydCgpYCBBUEksIHRoaXMgc2hvdWxkIGJlIGEgdmFsaWQgXCJzb3J0IHN0cmluZ1wiIG1hZGUgdXAgb2ZcbiAgICAgICAgICogYW4gYXR0cmlidXRlIHRvIHNvcnQgYnkgKG9yIGAnZGVmYXVsdCdgKSBmb2xsb3dlZCBieSBhbiBvcHRpb25hbCBzb3J0aW5nXG4gICAgICAgICAqIG9yZGVyLCBvciB0aGUgdmFsdWUgYCdyYW5kb20nYDtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogRGVmaW5pbmcgc29ydGluZyB0byBiZSBhcHBsaWVkIG9uIGxvYWQ8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIFRoZSBtaXhlciB3aWxsIHNvcnQgdGhlIGNvbnRhaW5lciBieSB0aGUgdmFsdWUgb2YgdGhlIGBkYXRhLXB1Ymxpc2hlZC1kYXRlYFxuICAgICAgICAgKiAvLyBhdHRyaWJ1dGUsIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIGxvYWQ6IHtcbiAgICAgICAgICogICAgICAgICBzb3J0OiAncHVibGlzaGVkLWRhdGU6ZGVzYydcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBzb3J0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5sb2FkXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICdkZWZhdWx0OmFzYydcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5zb3J0ID0gJ2RlZmF1bHQ6YXNjJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2Ygb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIHVuZGVybHlpbmcgZGF0YSBvZiBhbnkgcHJlLXJlbmRlcmVkIHRhcmdldHMsXG4gICAgICAgICAqIHdoZW4gdXNpbmcgdGhlIGAuZGF0YXNldCgpYCBBUEkuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5COiBJZiB0YXJnZXRzIGFyZSBwcmUtcmVuZGVyZWQgd2hlbiB0aGUgbWl4ZXIgaXMgaW5zdGFudGlhdGVkLCB0aGlzIG11c3QgYmUgc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBEZWZpbmluZyB0aGUgaW5pdGlhbCB1bmRlcnlsaW5nIGRhdGFzZXQ8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBteURhdGFzZXQgPSBbXG4gICAgICAgICAqICAgICB7XG4gICAgICAgICAqICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAqICAgICAgICAgdGl0bGU6IFwiQmxvZyBQb3N0IFRpdGxlIDBcIixcbiAgICAgICAgICogICAgICAgICAuLi5cbiAgICAgICAgICogICAgIH0sXG4gICAgICAgICAqICAgICB7XG4gICAgICAgICAqICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAqICAgICAgICAgdGl0bGU6IFwiQmxvZyBQb3N0IFRpdGxlIDFcIixcbiAgICAgICAgICogICAgICAgICAuLi5cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogXTtcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgZGF0YToge1xuICAgICAgICAgKiAgICAgICAgIHVpZEtleTogJ2lkJ1xuICAgICAgICAgKiAgICAgfSxcbiAgICAgICAgICogICAgIGxvYWQ6IHtcbiAgICAgICAgICogICAgICAgICBkYXRhc2V0OiBteURhdGFzZXRcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBkYXRhc2V0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5sb2FkXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge0FycmF5LjxvYmplY3Q+fVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgbnVsbFxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmRhdGFzZXQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbmZpZ0xvYWQpO1xuXG4gICAgbWl4aXR1cC5Db25maWdMb2FkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ0xvYWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db25maWdMb2FkO1xuXG4gICAgLyoqXG4gICAgICogQSBncm91cCBvZiBwcm9wZXJ0aWVzIGRlZmluaW5nIHRoZSBzZWxlY3RvcnMgdXNlZCB0byBxdWVyeSBlbGVtZW50cyB3aXRoaW4gYSBtaXhpdHVwIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZ1xuICAgICAqIEBuYW1lICAgICAgICBzZWxlY3RvcnNcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db25maWdTZWxlY3RvcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2VsZWN0b3Igc3RyaW5nIHVzZWQgdG8gcXVlcnkgYW5kIGluZGV4IHRhcmdldCBlbGVtZW50cyB3aXRoaW4gdGhlIGNvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGNsYXNzIHNlbGVjdG9yIGAnLm1peCdgIGlzIHVzZWQsIGJ1dCB0aGlzIGNhbiBiZSBjaGFuZ2VkIHRvIGFuXG4gICAgICAgICAqIGF0dHJpYnV0ZSBvciBlbGVtZW50IHNlbGVjdG9yIHRvIG1hdGNoIHRoZSBzdHlsZSBvZiB5b3VyIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogQ2hhbmdpbmcgdGhlIHRhcmdldCBzZWxlY3RvcjwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgc2VsZWN0b3JzOiB7XG4gICAgICAgICAqICAgICAgICAgdGFyZ2V0OiAnLnBvcnRmb2xpby1pdGVtJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAyOiBVc2luZyBhbiBhdHRyaWJ1dGUgc2VsZWN0b3IgYXMgYSB0YXJnZXQgc2VsZWN0b3I8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIFRoZSBtaXhlciB3aWxsIHNlYXJjaCBmb3IgYW55IGNoaWxkcmVuIHdpdGggdGhlIGF0dHJpYnV0ZSBgZGF0YS1yZWY9XCJtaXhcImBcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgc2VsZWN0b3JzOiB7XG4gICAgICAgICAqICAgICAgICAgdGFyZ2V0OiAnW2RhdGEtcmVmPVwibWl4XCJdJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIHRhcmdldFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuc2VsZWN0b3JzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICcubWl4J1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLnRhcmdldCA9ICcubWl4JztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBvcHRpb25hbCBzZWxlY3RvciBzdHJpbmcgdXNlZCB0byBhZGQgZnVydGhlciBzcGVjaWZpY2l0eSB0byB0aGUgcXVlcnlpbmcgb2YgY29udHJvbCBlbGVtZW50cyxcbiAgICAgICAgICogaW4gYWRkaXRpb24gdG8gdGhlaXIgbWFuZGF0b3J5IGRhdGEgYXR0cmlidXRlIChlLmcuIGBkYXRhLWZpbHRlcmAsIGBkYXRhLXRvZ2dsZWAsIGBkYXRhLXNvcnRgKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBjYW4gYmUgdXNlZCBpZiBvdGhlciBlbGVtZW50cyBpbiB5b3VyIGRvY3VtZW50IG11c3QgY29udGFpbiB0aGUgYWJvdmUgYXR0cmlidXRlc1xuICAgICAgICAgKiAoZS5nLiBmb3IgdXNlIGluIHRoaXJkLXBhcnR5IHNjcmlwdHMpLCBhbmQgd291bGQgb3RoZXJ3aXNlIGludGVyZmVyZSB3aXRoIE1peEl0VXAuIEFkZGluZ1xuICAgICAgICAgKiBhbiBhZGRpdGlvbmFsIGBjb250cm9sYCBzZWxlY3RvciBvZiB5b3VyIGNob2ljZSBhbGxvd3MgTWl4SXRVcCB0byByZXN0cmljdCBldmVudCBoYW5kbGluZ1xuICAgICAgICAgKiB0byBvbmx5IHRob3NlIGVsZW1lbnRzIG1hdGNoaW5nIHRoZSBkZWZpbmVkIHNlbGVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgY29udHJvbFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWcuc2VsZWN0b3JzXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICcnXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogQWRkaW5nIGEgYHNlbGVjdG9ycy5jb250cm9sYCBzZWxlY3RvcjwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgc2VsZWN0b3JzOiB7XG4gICAgICAgICAqICAgICAgICAgY29udHJvbDogJy5taXhpdHVwLWNvbnRyb2wnXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBXaWxsIG5vdCBiZSBoYW5kbGVkOlxuICAgICAgICAgKiAvLyA8YnV0dG9uIGRhdGEtZmlsdGVyPVwiLmNhdGVnb3J5LWFcIj48L2J1dHRvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogLy8gV2lsbCBiZSBoYW5kbGVkOlxuICAgICAgICAgKiAvLyA8YnV0dG9uIGNsYXNzPVwibWl4aXR1cC1jb250cm9sXCIgZGF0YS1maWx0ZXI9XCIuY2F0ZWdvcnktYVwiPjwvYnV0dG9uPlxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmNvbnRyb2wgPSAnJztcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db25maWdTZWxlY3RvcnMpO1xuXG4gICAgbWl4aXR1cC5Db25maWdTZWxlY3RvcnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29uZmlnU2VsZWN0b3JzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29uZmlnU2VsZWN0b3JzO1xuXG4gICAgLyoqXG4gICAgICogQSBncm91cCBvZiBvcHRpb25hbCByZW5kZXIgZnVuY3Rpb25zIGZvciBjcmVhdGluZyBhbmQgdXBkYXRpbmcgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBBbGwgcmVuZGVyIGZ1bmN0aW9ucyByZWNlaXZlIGEgZGF0YSBvYmplY3QsIGFuZCBzaG91bGQgcmV0dXJuIGEgdmFsaWQgSFRNTCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5Db25maWdcbiAgICAgKiBAbmFtZSAgICAgICAgcmVuZGVyXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29uZmlnUmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1peGl0dXAuQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbnN0cnVjdCcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHJldHVybmluZyBhbiBIVE1MIHN0cmluZyByZXByZXNlbnRpbmcgYSB0YXJnZXQgZWxlbWVudCwgb3IgYSByZWZlcmVuY2UgdG8gYVxuICAgICAgICAgKiBzaW5nbGUgRE9NIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIGFzIHBhcnQgb2YgdGhlIGAuZGF0YXNldCgpYCBBUEksIHdoZW5ldmVyIGEgbmV3IGl0ZW0gaXMgYWRkZWRcbiAgICAgICAgICogdG8gdGhlIGRhdGFzZXQsIG9yIGFuIGl0ZW0gaW4gdGhlIGRhdGFzZXQgY2hhbmdlcyAoaWYgYGRhdGFzZXQuZGlydHlDaGVja2AgaXMgZW5hYmxlZCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgcmVsZXZhbnQgZGF0YXNldCBpdGVtIGFzIGl0cyBmaXJzdCBwYXJhbWV0ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogVXNpbmcgc3RyaW5nIGNvbmNhdGVuYXRpb248L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIHJlbmRlcjoge1xuICAgICAgICAgKiAgICAgICAgIHRhcmdldDogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgKiAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgJyZsdDtkaXYgY2xhc3M9XCJtaXhcIiZndDsnICtcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAnJmx0O2gyJmd0OycgKyBpdGVtLnRpdGxlICsgJyZsdDsvaDImZ3Q7JyArXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAnJmx0Oy9kaXYmZ3Q7J1xuICAgICAgICAgKiAgICAgICAgICAgICApO1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogVXNpbmcgYW4gRVMyMDE1IHRlbXBsYXRlIGxpdGVyYWw8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBtaXhlciA9IG1peGl0dXAoY29udGFpbmVyRWwsIHtcbiAgICAgICAgICogICAgIHJlbmRlcjoge1xuICAgICAgICAgKiAgICAgICAgIHRhcmdldDogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgKiAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgYCZsdDtkaXYgY2xhc3M9XCJtaXhcIiZndDtcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAmbHQ7aDImZ3Q7JHtpdGVtLnRpdGxlfSZsdDsvaDImZ3Q7XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgJmx0Oy9kaXYmZ3Q7YFxuICAgICAgICAgKiAgICAgICAgICAgICApO1xuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMzogVXNpbmcgYSBIYW5kbGViYXJzIHRlbXBsYXRlPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgdGFyZ2V0VGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoJyZsdDtkaXYgY2xhc3M9XCJtaXhcIiZndDsmbHQ7aDImZ3Q7e3t0aXRsZX19Jmx0Oy9oMiZndDsmbHQ7L2RpdiZndDsnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgcmVuZGVyOiB7XG4gICAgICAgICAqICAgICAgICAgdGFyZ2V0OiB0YXJnZXRUZW1wbGF0ZVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSA0OiBSZXR1cm5pbmcgYSBET00gZWxlbWVudDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgcmVuZGVyOiB7XG4gICAgICAgICAqICAgICAgICAgdGFyZ2V0OiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAqICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBzaW5nbGUgZWxlbWVudCB1c2luZyB5b3VyIGZyYW1ld29yaydzIGJ1aWx0LWluIHJlbmRlcmVyXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgICAgICB2YXIgZWwgPSAuLi5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgdGFyZ2V0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkNvbmZpZy5yZW5kZXJcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7ZnVuY3Rpb259XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICAnbnVsbCdcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbmZpZ1JlbmRlcik7XG5cbiAgICBtaXhpdHVwLkNvbmZpZ1JlbmRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5Db25maWdSZW5kZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db25maWdSZW5kZXI7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkNvbmZpZ1RlbXBsYXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db25maWdUZW1wbGF0ZXMpO1xuXG4gICAgbWl4aXR1cC5Db25maWdUZW1wbGF0ZXMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29uZmlnVGVtcGxhdGVzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29uZmlnVGVtcGxhdGVzO1xuXG4gICAgLyoqXG4gICAgICogYG1peGl0dXAuQ29uZmlnYCBpcyBhbiBpbnRlcmZhY2UgdXNlZCBmb3IgY3VzdG9taXNpbmcgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYVxuICAgICAqIG1peGVyIGluc3RhbmNlLiBJdCBpcyBvcmdhbmlzZWQgaW50byBzZXZlcmFsIHNlbWFudGljYWxseSBkaXN0aW5jdCBzdWItb2JqZWN0cyxcbiAgICAgKiBlYWNoIG9uZSBwZXJ0YWluaW5nIHRvIGEgcGFydGljdWxhciBhc3BlY3Qgb2YgTWl4SXRVcCBmdW5jdGlvbmFsaXR5LlxuICAgICAqXG4gICAgICogQW4gb2JqZWN0IGxpdGVyYWwgY29udGFpbmluZyBhbnkgb3IgYWxsIG9mIHRoZSBhdmFpbGFibGUgcHJvcGVyaWVzLFxuICAgICAqIGtub3duIGFzIHRoZSBcImNvbmZpZ3VyYXRpb24gb2JqZWN0XCIsIGNhbiBiZSBwYXNzZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG9cbiAgICAgKiB0aGUgYG1peGl0dXBgIGZhY3RvcnkgZnVuY3Rpb24gd2hlbiBjcmVhdGluZyBhIG1peGVyIGluc3RhbmNlIHRvIGN1c3RvbWlzZSBpdHNcbiAgICAgKiBmdW5jdGlvbmFsaXR5IGFzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIElmIG5vIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGlzIHBhc3NlZCwgdGhlIG1peGVyIGluc3RhbmNlIHdpbGwgdGFrZSBvbiB0aGUgZGVmYXVsdFxuICAgICAqIGNvbmZpZ3VyYXRpb24gdmFsdWVzIGRldGFpbGVkIGJlbG93LlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAxOiBDcmVhdGluZyBhbmQgcGFzc2luZyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3Q8L2NhcHRpb24+XG4gICAgICogLy8gQ3JlYXRlIGEgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBkZXNpcmVkIHZhbHVlc1xuICAgICAqXG4gICAgICogdmFyIGNvbmZpZyA9IHtcbiAgICAgKiAgICAgYW5pbWF0aW9uOiB7XG4gICAgICogICAgICAgICBlbmFibGU6IGZhbHNlXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHNlbGVjdG9yczoge1xuICAgICAqICAgICAgICAgdGFyZ2V0OiAnLml0ZW0nXG4gICAgICogICAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gUGFzcyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gdGhlIG1peGl0dXAgZmFjdG9yeSBmdW5jdGlvblxuICAgICAqXG4gICAgICogdmFyIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwgY29uZmlnKTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogUGFzc2luZyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgaW5saW5lPC9jYXB0aW9uPlxuICAgICAqIC8vIFR5cGljYWxseSwgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGlzIHBhc3NlZCBpbmxpbmUgZm9yIGJyZXZpdHkuXG4gICAgICpcbiAgICAgKiB2YXIgbWl4ZXIgPSBtaXhpdHVwKGNvbnRhaW5lckVsLCB7XG4gICAgICogICAgIGNvbnRyb2xzOiB7XG4gICAgICogICAgICAgICBsaXZlOiB0cnVlLFxuICAgICAqICAgICAgICAgdG9nZ2xlTG9naWM6ICdhbmQnXG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzaW5jZSAgICAgICAyLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db25maWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb24gICAgICAgICAgPSBuZXcgbWl4aXR1cC5Db25maWdBbmltYXRpb24oKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvciAgICAgICAgICAgPSBuZXcgbWl4aXR1cC5Db25maWdCZWhhdmlvcigpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyAgICAgICAgICA9IG5ldyBtaXhpdHVwLkNvbmZpZ0NhbGxiYWNrcygpO1xuICAgICAgICB0aGlzLmNvbnRyb2xzICAgICAgICAgICA9IG5ldyBtaXhpdHVwLkNvbmZpZ0NvbnRyb2xzKCk7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lcyAgICAgICAgID0gbmV3IG1peGl0dXAuQ29uZmlnQ2xhc3NOYW1lcygpO1xuICAgICAgICB0aGlzLmRhdGEgICAgICAgICAgICAgICA9IG5ldyBtaXhpdHVwLkNvbmZpZ0RhdGEoKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyAgICAgICAgICAgICAgPSBuZXcgbWl4aXR1cC5Db25maWdEZWJ1ZygpO1xuICAgICAgICB0aGlzLmxheW91dCAgICAgICAgICAgICA9IG5ldyBtaXhpdHVwLkNvbmZpZ0xheW91dCgpO1xuICAgICAgICB0aGlzLmxvYWQgICAgICAgICAgICAgICA9IG5ldyBtaXhpdHVwLkNvbmZpZ0xvYWQoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMgICAgICAgICAgPSBuZXcgbWl4aXR1cC5Db25maWdTZWxlY3RvcnMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXIgICAgICAgICAgICAgPSBuZXcgbWl4aXR1cC5Db25maWdSZW5kZXIoKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMgICAgICAgICAgPSBuZXcgbWl4aXR1cC5Db25maWdUZW1wbGF0ZXMoKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db25maWcpO1xuXG4gICAgbWl4aXR1cC5Db25maWcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29uZmlnLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29uZmlnO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5NaXhlckRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLmRvY3VtZW50ICAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmJvZHkgICAgICAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmVudCAgICAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldHMgICAgICAgICAgICAgICAgPSBbXTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5NaXhlckRvbSk7XG5cbiAgICBtaXhpdHVwLk1peGVyRG9tLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLk1peGVyRG9tLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuTWl4ZXJEb207XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLlVpQ2xhc3NOYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLmJhc2UgICAgICAgPSAnJztcbiAgICAgICAgdGhpcy5hY3RpdmUgICAgID0gJyc7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgICA9ICcnO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLlVpQ2xhc3NOYW1lcyk7XG5cbiAgICBtaXhpdHVwLlVpQ2xhc3NOYW1lcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5VaUNsYXNzTmFtZXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5VaUNsYXNzTmFtZXM7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgaW50byB3aGljaCBhbGwgYXJiaXRyYXJ5IGFyZ3VtZW50cyBzZW50IHRvICcuZGF0YXNldCgpJyBhcmUgbWFwcGVkLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db21tYW5kRGF0YXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLmRhdGFzZXQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbW1hbmREYXRhc2V0KTtcblxuICAgIG1peGl0dXAuQ29tbWFuZERhdGFzZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29tbWFuZERhdGFzZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db21tYW5kRGF0YXNldDtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBpbnRvIHdoaWNoIGFsbCBhcmJpdHJhcnkgYXJndW1lbnRzIHNlbnQgdG8gJy5tdWx0aW1peCgpJyBhcmUgbWFwcGVkLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db21tYW5kTXVsdGltaXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5maWx0ZXIgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLnNvcnQgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5zZXJ0ICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW1vdmUgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmNoYW5nZUxheW91dCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuQ29tbWFuZE11bHRpbWl4KTtcblxuICAgIG1peGl0dXAuQ29tbWFuZE11bHRpbWl4LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLkNvbW1hbmRNdWx0aW1peC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLkNvbW1hbmRNdWx0aW1peDtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBpbnRvIHdoaWNoIGFsbCBhcmJpdHJhcnkgYXJndW1lbnRzIHNlbnQgdG8gJy5maWx0ZXIoKScgYXJlIG1hcHBlZC5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29tbWFuZEZpbHRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLnNlbGVjdG9yICAgPSAnJztcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3Rpb24gICAgID0gJ3Nob3cnOyAvLyBlbnVtOiBbJ3Nob3cnLCAnaGlkZSddXG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuQ29tbWFuZEZpbHRlcik7XG5cbiAgICBtaXhpdHVwLkNvbW1hbmRGaWx0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29tbWFuZEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLkNvbW1hbmRGaWx0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgaW50byB3aGljaCBhbGwgYXJiaXRyYXJ5IGFyZ3VtZW50cyBzZW50IHRvICcuc29ydCgpJyBhcmUgbWFwcGVkLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5Db21tYW5kU29ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLnNvcnRTdHJpbmcgPSAnJztcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGUgID0gJyc7XG4gICAgICAgIHRoaXMub3JkZXIgICAgICA9ICdhc2MnO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgICAgICAgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkNvbW1hbmRTb3J0KTtcblxuICAgIG1peGl0dXAuQ29tbWFuZFNvcnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29tbWFuZFNvcnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5Db21tYW5kU29ydDtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBpbnRvIHdoaWNoIGFsbCBhcmJpdHJhcnkgYXJndW1lbnRzIHNlbnQgdG8gJy5pbnNlcnQoKScgYXJlIG1hcHBlZC5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29tbWFuZEluc2VydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLmluZGV4ICAgICAgPSAwO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBbXTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiAgID0gJ2JlZm9yZSc7IC8vIGVudW06IFsnYmVmb3JlJywgJ2FmdGVyJ11cbiAgICAgICAgdGhpcy5zaWJsaW5nICAgID0gbnVsbDtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db21tYW5kSW5zZXJ0KTtcblxuICAgIG1peGl0dXAuQ29tbWFuZEluc2VydC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5Db21tYW5kSW5zZXJ0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29tbWFuZEluc2VydDtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBpbnRvIHdoaWNoIGFsbCBhcmJpdHJhcnkgYXJndW1lbnRzIHNlbnQgdG8gJy5yZW1vdmUoKScgYXJlIG1hcHBlZC5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29tbWFuZFJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLnRhcmdldHMgICAgPSBbXTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gW107XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuQ29tbWFuZFJlbW92ZSk7XG5cbiAgICBtaXhpdHVwLkNvbW1hbmRSZW1vdmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuQ29tbWFuZFJlbW92ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLkNvbW1hbmRSZW1vdmU7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgaW50byB3aGljaCBhbGwgYXJiaXRyYXJ5IGFyZ3VtZW50cyBzZW50IHRvICcuY2hhbmdlTGF5b3V0KCknIGFyZSBtYXBwZWQuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkNvbW1hbmRDaGFuZ2VMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSAnJztcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db21tYW5kQ2hhbmdlTGF5b3V0KTtcblxuICAgIG1peGl0dXAuQ29tbWFuZENoYW5nZUxheW91dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5Db21tYW5kQ2hhbmdlTGF5b3V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29tbWFuZENoYW5nZUxheW91dDtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgICAgIHR5cGVcbiAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgICAgIHNlbGVjdG9yXG4gICAgICogQHBhcmFtICAgICAgIHtib29sZWFufSAgICAgICBbbGl2ZV1cbiAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgICAgIFtwYXJlbnRdXG4gICAgICogICAgIEFuIG9wdGlvbmFsIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIG1peGVyLmRvbSBwcm9wZXJ0eSBjb250YWluaW5nIGEgcmVmZXJlbmNlIHRvIGEgcGFyZW50IGVsZW1lbnQuXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkNvbnRyb2xEZWZpbml0aW9uID0gZnVuY3Rpb24odHlwZSwgc2VsZWN0b3IsIGxpdmUsIHBhcmVudCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLnR5cGUgICAgPSB0eXBlO1xuICAgICAgICB0aGlzLnNlbGVjdG9yICA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmxpdmUgICAgICA9IGxpdmUgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucGFyZW50ICAgID0gcGFyZW50IHx8ICcnO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5mcmVlemUodGhpcyk7XG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db250cm9sRGVmaW5pdGlvbik7XG5cbiAgICBtaXhpdHVwLkNvbnRyb2xEZWZpbml0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLkNvbnRyb2xEZWZpbml0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuQ29udHJvbERlZmluaXRpb247XG5cbiAgICBtaXhpdHVwLmNvbnRyb2xEZWZpbml0aW9ucyA9IFtdO1xuXG4gICAgbWl4aXR1cC5jb250cm9sRGVmaW5pdGlvbnMucHVzaChuZXcgbWl4aXR1cC5Db250cm9sRGVmaW5pdGlvbignbXVsdGltaXgnLCAnW2RhdGEtZmlsdGVyXVtkYXRhLXNvcnRdJykpO1xuICAgIG1peGl0dXAuY29udHJvbERlZmluaXRpb25zLnB1c2gobmV3IG1peGl0dXAuQ29udHJvbERlZmluaXRpb24oJ2ZpbHRlcicsICdbZGF0YS1maWx0ZXJdJykpO1xuICAgIG1peGl0dXAuY29udHJvbERlZmluaXRpb25zLnB1c2gobmV3IG1peGl0dXAuQ29udHJvbERlZmluaXRpb24oJ3NvcnQnLCAnW2RhdGEtc29ydF0nKSk7XG4gICAgbWl4aXR1cC5jb250cm9sRGVmaW5pdGlvbnMucHVzaChuZXcgbWl4aXR1cC5Db250cm9sRGVmaW5pdGlvbigndG9nZ2xlJywgJ1tkYXRhLXRvZ2dsZV0nKSk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkNvbnRyb2wgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5lbCAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWxlY3RvciAgID0gJyc7XG4gICAgICAgIHRoaXMuYm91bmQgICAgICA9IFtdO1xuICAgICAgICB0aGlzLnBlbmRpbmcgICAgPSAtMTtcbiAgICAgICAgdGhpcy50eXBlICAgICAgID0gJyc7XG4gICAgICAgIHRoaXMuc3RhdHVzICAgICA9ICdpbmFjdGl2ZSc7IC8vIGVudW06IFsnaW5hY3RpdmUnLCAnYWN0aXZlJywgJ2Rpc2FibGVkJywgJ2xpdmUnXVxuICAgICAgICB0aGlzLmZpbHRlciAgICAgPSAnJztcbiAgICAgICAgdGhpcy5zb3J0ICAgICAgID0gJyc7XG4gICAgICAgIHRoaXMuY2FuRGlzYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhbmRsZXIgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZXMgPSBuZXcgbWl4aXR1cC5VaUNsYXNzTmFtZXMoKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db250cm9sKTtcblxuICAgIG1peGl0dXAuQ29udHJvbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgaC5leHRlbmQobWl4aXR1cC5Db250cm9sLnByb3RvdHlwZSxcbiAgICAvKiogQGxlbmRzIG1peGl0dXAuQ29udHJvbCAqL1xuICAgIHtcbiAgICAgICAgY29uc3RydWN0b3I6IG1peGl0dXAuQ29udHJvbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICBzZWxlY3RvclxuICAgICAgICAgKi9cblxuICAgICAgICBpbml0OiBmdW5jdGlvbihlbCwgdHlwZSwgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlSW5pdCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYuZWwgICAgICAgICA9IGVsO1xuICAgICAgICAgICAgc2VsZi50eXBlICAgICAgID0gdHlwZTtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0b3IgICA9IHNlbGVjdG9yO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHNlbGYuc3RhdHVzID0gJ2xpdmUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbkRpc2FibGUgPSB0eXBlb2Ygc2VsZi5lbC5kaXNhYmxlID09PSAnYm9vbGVhbic7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNlbGYudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmaWx0ZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5maWx0ZXIgPSBzZWxmLmVsLmdldEF0dHJpYnV0ZSgnZGF0YS1maWx0ZXInKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvZ2dsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZpbHRlciA9IHNlbGYuZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRvZ2dsZScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc29ydCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNvcnQgICA9IHNlbGYuZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNvcnQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ211bHRpbWl4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmlsdGVyID0gc2VsZi5lbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmlsdGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNvcnQgICA9IHNlbGYuZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNvcnQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmJpbmRDbGljaygpO1xuXG4gICAgICAgICAgICBtaXhpdHVwLmNvbnRyb2xzLnB1c2goc2VsZik7XG5cbiAgICAgICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVySW5pdCcsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAge21peGl0dXAuTWl4ZXJ9IG1peGVyXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuXG4gICAgICAgIGlzQm91bmQ6IGZ1bmN0aW9uKG1peGVyKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaXNCb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVJc0JvdW5kJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaXNCb3VuZCA9IHNlbGYuYm91bmQuaW5kZXhPZihtaXhlcikgPiAtMTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ2FmdGVySXNCb3VuZCcsIGlzQm91bmQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSAge21peGl0dXAuTWl4ZXJ9IG1peGVyXG4gICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGFkZEJpbmRpbmc6IGZ1bmN0aW9uKG1peGVyKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUFkZEJpbmRpbmcnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNCb3VuZCgpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ib3VuZC5wdXNoKG1peGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJBZGRCaW5kaW5nJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICB7bWl4aXR1cC5NaXhlcn0gbWl4ZXJcbiAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgcmVtb3ZlQmluZGluZzogZnVuY3Rpb24obWl4ZXIpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVtb3ZlSW5kZXggPSAtMTtcblxuICAgICAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlUmVtb3ZlQmluZGluZycsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmICgocmVtb3ZlSW5kZXggPSBzZWxmLmJvdW5kLmluZGV4T2YobWl4ZXIpKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ib3VuZC5zcGxpY2UocmVtb3ZlSW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZi5ib3VuZC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gYmluZGluZ3MgZXhpc3QsIHVuYmluZCBldmVudCBjbGljayBoYW5kbGVyc1xuXG4gICAgICAgICAgICAgICAgc2VsZi51bmJpbmRDbGljaygpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYG1peGl0dXAuY29udHJvbHNgIGxpc3RcblxuICAgICAgICAgICAgICAgIHJlbW92ZUluZGV4ID0gbWl4aXR1cC5jb250cm9scy5pbmRleE9mKHNlbGYpO1xuXG4gICAgICAgICAgICAgICAgbWl4aXR1cC5jb250cm9scy5zcGxpY2UocmVtb3ZlSW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc3RhdHVzID09PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlclN0YXR1cyhzZWxmLmVsLCAnaW5hY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyUmVtb3ZlQmluZGluZycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGJpbmRDbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUJpbmRDbGljaycsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYuaGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZUNsaWNrKGUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaC5vbihzZWxmLmVsLCAnY2xpY2snLCBzZWxmLmhhbmRsZXIpO1xuXG4gICAgICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckJpbmRDbGljaycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHVuYmluZENsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlVW5iaW5kQ2xpY2snLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBoLm9mZihzZWxmLmVsLCAnY2xpY2snLCBzZWxmLmhhbmRsZXIpO1xuXG4gICAgICAgICAgICBzZWxmLmhhbmRsZXIgPSBudWxsO1xuXG4gICAgICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlclVuYmluZENsaWNrJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtICAge01vdXNlRXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGJ1dHRvbiAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBtaXhlciAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgaXNBY3RpdmUgICAgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHZvaWQoMCksXG4gICAgICAgICAgICAgICAgY29tbWFuZCAgICAgPSB7fSxcbiAgICAgICAgICAgICAgICBjbG9uZSAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgY29tbWFuZHMgICAgPSBbXSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVIYW5kbGVDbGljaycsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IDA7XG5cbiAgICAgICAgICAgIG1peGVyID0gc2VsZi5ib3VuZFswXTtcblxuICAgICAgICAgICAgaWYgKCFzZWxmLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uID0gc2VsZi5lbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uID0gaC5jbG9zZXN0UGFyZW50KGUudGFyZ2V0LCBtaXhlci5jb25maWcuc2VsZWN0b3JzLmNvbnRyb2wgKyBzZWxmLnNlbGVjdG9yLCB0cnVlLCBtaXhlci5kb20uZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVySGFuZGxlQ2xpY2snLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHNlbGYudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbHRlcic6XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQuZmlsdGVyID0gc2VsZi5maWx0ZXIgfHwgYnV0dG9uLmdldEF0dHJpYnV0ZSgnZGF0YS1maWx0ZXInKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzb3J0JzpcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5zb3J0ID0gc2VsZi5zb3J0IHx8IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtc29ydCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ211bHRpbWl4JzpcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5maWx0ZXIgID0gc2VsZi5maWx0ZXIgfHwgYnV0dG9uLmdldEF0dHJpYnV0ZSgnZGF0YS1maWx0ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5zb3J0ICAgID0gc2VsZi5zb3J0IHx8IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtc29ydCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvZ2dsZSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQuZmlsdGVyICA9IHNlbGYuZmlsdGVyIHx8IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9nZ2xlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuc3RhdHVzID09PSAnbGl2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlID0gaC5oYXNDbGFzcyhidXR0b24sIHNlbGYuY2xhc3NOYW1lcy5hY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmUgPSBzZWxmLnN0YXR1cyA9PT0gJ2FjdGl2ZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGYuYm91bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBjbG9uZSBvZiB0aGUgY29tbWFuZCBmb3IgZWFjaCBib3VuZCBtaXhlciBpbnN0YW5jZVxuXG4gICAgICAgICAgICAgICAgY2xvbmUgPSBuZXcgbWl4aXR1cC5Db21tYW5kTXVsdGltaXgoKTtcblxuICAgICAgICAgICAgICAgIGguZXh0ZW5kKGNsb25lLCBjb21tYW5kKTtcblxuICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goY2xvbmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb21tYW5kcyA9IHNlbGYuY2FsbEZpbHRlcnMoJ2NvbW1hbmRzSGFuZGxlQ2xpY2snLCBjb21tYW5kcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5wZW5kaW5nID0gc2VsZi5ib3VuZC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IG1peGVyID0gc2VsZi5ib3VuZFtpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZCA9IGNvbW1hbmRzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuIGV4dGVuc2lvbiBtYXkgc2V0IGEgY29tbWFuZCBudWxsIHRvIGluZGljYXRlIHRoYXQgdGhlIGNsaWNrIHNob3VsZCBub3QgYmUgaGFuZGxlZFxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbWl4ZXIubGFzdENsaWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWl4ZXIubGFzdENsaWNrZWQgPSBidXR0b247XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWl4aXR1cC5ldmVudHMuZmlyZSgnbWl4Q2xpY2snLCBtaXhlci5kb20uY29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBtaXhlci5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IG1peGVyLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sOiBtaXhlci5sYXN0Q2xpY2tlZFxuICAgICAgICAgICAgICAgIH0sIG1peGVyLmRvbS5kb2N1bWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1peGVyLmNvbmZpZy5jYWxsYmFja3Mub25NaXhDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IG1peGVyLmNvbmZpZy5jYWxsYmFja3Mub25NaXhDbGljay5jYWxsKG1peGVyLmxhc3RDbGlja2VkLCBtaXhlci5zdGF0ZSwgZSwgbWl4ZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZXIgaGFzIHJldHVybmVkIGBmYWxzZWAgZnJvbSB0aGUgY2FsbGJhY2ssIHNvIGRvIG5vdCBoYW5kbGUgY2xpY2tcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi50eXBlID09PSAndG9nZ2xlJykge1xuICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZSA/IG1peGVyLnRvZ2dsZU9mZihjb21tYW5kLmZpbHRlcikgOiBtaXhlci50b2dnbGVPbihjb21tYW5kLmZpbHRlcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWl4ZXIubXVsdGltaXgoY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckhhbmRsZUNsaWNrJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICAge29iamVjdH0gICAgICAgICAgY29tbWFuZFxuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXk8c3RyaW5nPn0gICB0b2dnbGVBcnJheVxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihjb21tYW5kLCB0b2dnbGVBcnJheSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBuZXcgbWl4aXR1cC5Db21tYW5kTXVsdGltaXgoKTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlVXBkYXRlJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5wZW5kaW5nLS07XG5cbiAgICAgICAgICAgIHNlbGYucGVuZGluZyA9IE1hdGgubWF4KDAsIHNlbGYucGVuZGluZyk7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLnBlbmRpbmcgPiAwKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChzZWxmLnN0YXR1cyA9PT0gJ2xpdmUnKSB7XG4gICAgICAgICAgICAgICAgLy8gTGl2ZSBjb250cm9sIChzdGF0dXMgdW5rbm93bilcblxuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlTGl2ZShjb21tYW5kLCB0b2dnbGVBcnJheSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFN0YXRpYyBjb250cm9sXG5cbiAgICAgICAgICAgICAgICBhY3Rpb25zLnNvcnQgICAgPSBzZWxmLnNvcnQ7XG4gICAgICAgICAgICAgICAgYWN0aW9ucy5maWx0ZXIgID0gc2VsZi5maWx0ZXI7XG5cbiAgICAgICAgICAgICAgICBzZWxmLmNhbGxGaWx0ZXJzKCdhY3Rpb25zVXBkYXRlJywgYWN0aW9ucywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIHNlbGYucGFyc2VTdGF0dXNDaGFuZ2Uoc2VsZi5lbCwgY29tbWFuZCwgYWN0aW9ucywgdG9nZ2xlQXJyYXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlclVwZGF0ZScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAgIHttaXhpdHVwLkNvbW1hbmRNdWx0aW1peH0gY29tbWFuZFxuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXk8c3RyaW5nPn0gICAgICAgICAgIHRvZ2dsZUFycmF5XG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICB1cGRhdGVMaXZlOiBmdW5jdGlvbihjb21tYW5kLCB0b2dnbGVBcnJheSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgY29udHJvbEJ1dHRvbnMgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGJ1dHRvbiAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVVwZGF0ZUxpdmUnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGYuZWwpIHJldHVybjtcblxuICAgICAgICAgICAgY29udHJvbEJ1dHRvbnMgPSBzZWxmLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZi5zZWxlY3Rvcik7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGJ1dHRvbiA9IGNvbnRyb2xCdXR0b25zW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gbmV3IG1peGl0dXAuQ29tbWFuZE11bHRpbWl4KCk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNlbGYudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmaWx0ZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5maWx0ZXIgPSBidXR0b24uZ2V0QXR0cmlidXRlKCdkYXRhLWZpbHRlcicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc29ydCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnNvcnQgPSBidXR0b24uZ2V0QXR0cmlidXRlKCdkYXRhLXNvcnQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ211bHRpbWl4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMuZmlsdGVyICA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmlsdGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnNvcnQgICAgPSBidXR0b24uZ2V0QXR0cmlidXRlKCdkYXRhLXNvcnQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvZ2dsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLmZpbHRlciAgPSBidXR0b24uZ2V0QXR0cmlidXRlKCdkYXRhLXRvZ2dsZScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gc2VsZi5jYWxsRmlsdGVycygnYWN0aW9uc1VwZGF0ZUxpdmUnLCBhY3Rpb25zLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5wYXJzZVN0YXR1c0NoYW5nZShidXR0b24sIGNvbW1hbmQsIGFjdGlvbnMsIHRvZ2dsZUFycmF5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJVcGRhdGVMaXZlJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgICAgICAgICAgICBidXR0b25cbiAgICAgICAgICogQHBhcmFtICAge21peGl0dXAuQ29tbWFuZE11bHRpbWl4fSBjb21tYW5kXG4gICAgICAgICAqIEBwYXJhbSAgIHttaXhpdHVwLkNvbW1hbmRNdWx0aW1peH0gYWN0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXk8c3RyaW5nPn0gICAgICAgICAgIHRvZ2dsZUFycmF5XG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBwYXJzZVN0YXR1c0NoYW5nZTogZnVuY3Rpb24oYnV0dG9uLCBjb21tYW5kLCBhY3Rpb25zLCB0b2dnbGVBcnJheSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFsaWFzICAgPSAnJyxcbiAgICAgICAgICAgICAgICB0b2dnbGUgID0gJycsXG4gICAgICAgICAgICAgICAgaSAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVQYXJzZVN0YXR1c0NoYW5nZScsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoc2VsZi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmlsdGVyJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQuZmlsdGVyID09PSBhY3Rpb25zLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW5kZXJTdGF0dXMoYnV0dG9uLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlclN0YXR1cyhidXR0b24sICdpbmFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbXVsdGltaXgnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZC5zb3J0ID09PSBhY3Rpb25zLnNvcnQgJiYgY29tbWFuZC5maWx0ZXIgPT09IGFjdGlvbnMuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlclN0YXR1cyhidXR0b24sICdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVuZGVyU3RhdHVzKGJ1dHRvbiwgJ2luYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzb3J0JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQuc29ydC5tYXRjaCgvOmFzYy9nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXMgPSBjb21tYW5kLnNvcnQucmVwbGFjZSgvOmFzYy9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZC5zb3J0ID09PSBhY3Rpb25zLnNvcnQgfHwgYWxpYXMgPT09IGFjdGlvbnMuc29ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW5kZXJTdGF0dXMoYnV0dG9uLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlclN0YXR1cyhidXR0b24sICdpbmFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9nZ2xlJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvZ2dsZUFycmF5Lmxlbmd0aCA8IDEpIHNlbGYucmVuZGVyU3RhdHVzKGJ1dHRvbiwgJ2luYWN0aXZlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQuZmlsdGVyID09PSBhY3Rpb25zLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW5kZXJTdGF0dXMoYnV0dG9uLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9nZ2xlQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZSA9IHRvZ2dsZUFycmF5W2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9nZ2xlID09PSBhY3Rpb25zLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dHRvbiBtYXRjaGVzIG9uZSBhY3RpdmUgdG9nZ2xlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlclN0YXR1cyhidXR0b24sICdhY3RpdmUnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlclN0YXR1cyhidXR0b24sICdpbmFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyUGFyc2VTdGF0dXNDaGFuZ2UnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgYnV0dG9uXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgICBzdGF0dXNcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHJlbmRlclN0YXR1czogZnVuY3Rpb24oYnV0dG9uLCBzdGF0dXMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlUmVuZGVyU3RhdHVzJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhY3RpdmUnOlxuICAgICAgICAgICAgICAgICAgICBoLmFkZENsYXNzKGJ1dHRvbiwgc2VsZi5jbGFzc05hbWVzLmFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGgucmVtb3ZlQ2xhc3MoYnV0dG9uLCBzZWxmLmNsYXNzTmFtZXMuZGlzYWJsZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNhbkRpc2FibGUpIHNlbGYuZWwuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbmFjdGl2ZSc6XG4gICAgICAgICAgICAgICAgICAgIGgucmVtb3ZlQ2xhc3MoYnV0dG9uLCBzZWxmLmNsYXNzTmFtZXMuYWN0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgaC5yZW1vdmVDbGFzcyhidXR0b24sIHNlbGYuY2xhc3NOYW1lcy5kaXNhYmxlZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FuRGlzYWJsZSkgc2VsZi5lbC5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FuRGlzYWJsZSkgc2VsZi5lbC5kaXNhYmxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaC5hZGRDbGFzcyhidXR0b24sIHNlbGYuY2xhc3NOYW1lcy5kaXNhYmxlZCk7XG4gICAgICAgICAgICAgICAgICAgIGgucmVtb3ZlQ2xhc3MoYnV0dG9uLCBzZWxmLmNsYXNzTmFtZXMuYWN0aXZlKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuc3RhdHVzICE9PSAnbGl2ZScpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbnRyb2wncyBzdGF0dXMgcHJvcGVyeSBpZiBub3QgbGl2ZVxuXG4gICAgICAgICAgICAgICAgc2VsZi5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyUmVuZGVyU3RhdHVzJywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbWl4aXR1cC5jb250cm9scyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5TdHlsZURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy54ICAgICAgICAgICAgICA9IDA7XG4gICAgICAgIHRoaXMueSAgICAgICAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLnRvcCAgICAgICAgICAgID0gMDtcbiAgICAgICAgdGhpcy5yaWdodCAgICAgICAgICA9IDA7XG4gICAgICAgIHRoaXMuYm90dG9tICAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLmxlZnQgICAgICAgICAgID0gMDtcbiAgICAgICAgdGhpcy53aWR0aCAgICAgICAgICA9IDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ICAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLm1hcmdpblJpZ2h0ICAgID0gMDtcbiAgICAgICAgdGhpcy5tYXJnaW5Cb3R0b20gICA9IDA7XG4gICAgICAgIHRoaXMub3BhY2l0eSAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLnNjYWxlICAgICAgICAgID0gbmV3IG1peGl0dXAuVHJhbnNmb3JtRGF0YSgpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZVggICAgID0gbmV3IG1peGl0dXAuVHJhbnNmb3JtRGF0YSgpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZVkgICAgID0gbmV3IG1peGl0dXAuVHJhbnNmb3JtRGF0YSgpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZVogICAgID0gbmV3IG1peGl0dXAuVHJhbnNmb3JtRGF0YSgpO1xuICAgICAgICB0aGlzLnJvdGF0ZVggICAgICAgID0gbmV3IG1peGl0dXAuVHJhbnNmb3JtRGF0YSgpO1xuICAgICAgICB0aGlzLnJvdGF0ZVkgICAgICAgID0gbmV3IG1peGl0dXAuVHJhbnNmb3JtRGF0YSgpO1xuICAgICAgICB0aGlzLnJvdGF0ZVogICAgICAgID0gbmV3IG1peGl0dXAuVHJhbnNmb3JtRGF0YSgpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLlN0eWxlRGF0YSk7XG5cbiAgICBtaXhpdHVwLlN0eWxlRGF0YS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5TdHlsZURhdGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5TdHlsZURhdGE7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLlRyYW5zZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy52YWx1ZSAgPSAwO1xuICAgICAgICB0aGlzLnVuaXQgICA9ICcnO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLlRyYW5zZm9ybURhdGEpO1xuXG4gICAgbWl4aXR1cC5UcmFuc2Zvcm1EYXRhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLlRyYW5zZm9ybURhdGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5UcmFuc2Zvcm1EYXRhO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5UcmFuc2Zvcm1EZWZhdWx0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLlN0eWxlRGF0YS5hcHBseSh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLnNjYWxlLnZhbHVlICAgICAgICA9IDAuMDE7XG4gICAgICAgIHRoaXMuc2NhbGUudW5pdCAgICAgICAgID0gJyc7XG5cbiAgICAgICAgdGhpcy50cmFuc2xhdGVYLnZhbHVlICAgPSAyMDtcbiAgICAgICAgdGhpcy50cmFuc2xhdGVYLnVuaXQgICAgPSAncHgnO1xuXG4gICAgICAgIHRoaXMudHJhbnNsYXRlWS52YWx1ZSAgID0gMjA7XG4gICAgICAgIHRoaXMudHJhbnNsYXRlWS51bml0ICAgID0gJ3B4JztcblxuICAgICAgICB0aGlzLnRyYW5zbGF0ZVoudmFsdWUgICA9IDIwO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZVoudW5pdCAgICA9ICdweCc7XG5cbiAgICAgICAgdGhpcy5yb3RhdGVYLnZhbHVlICAgICAgPSA5MDtcbiAgICAgICAgdGhpcy5yb3RhdGVYLnVuaXQgICAgICAgPSAnZGVnJztcblxuICAgICAgICB0aGlzLnJvdGF0ZVkudmFsdWUgICAgICA9IDkwO1xuICAgICAgICB0aGlzLnJvdGF0ZVkudW5pdCAgICAgICA9ICdkZWcnO1xuXG4gICAgICAgIHRoaXMucm90YXRlWC52YWx1ZSAgICAgID0gOTA7XG4gICAgICAgIHRoaXMucm90YXRlWC51bml0ICAgICAgID0gJ2RlZyc7XG5cbiAgICAgICAgdGhpcy5yb3RhdGVaLnZhbHVlICAgICAgPSAxODA7XG4gICAgICAgIHRoaXMucm90YXRlWi51bml0ICAgICAgID0gJ2RlZyc7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuVHJhbnNmb3JtRGVmYXVsdHMpO1xuXG4gICAgbWl4aXR1cC5UcmFuc2Zvcm1EZWZhdWx0cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuU3R5bGVEYXRhLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLlRyYW5zZm9ybURlZmF1bHRzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuVHJhbnNmb3JtRGVmYXVsdHM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAqIEB0eXBlICAgIHttaXhpdHVwLlRyYW5zZm9ybURlZmF1bHRzfVxuICAgICAqL1xuXG4gICAgbWl4aXR1cC50cmFuc2Zvcm1EZWZhdWx0cyA9IG5ldyBtaXhpdHVwLlRyYW5zZm9ybURlZmF1bHRzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkV2ZW50RGV0YWlsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmZ1dHVyZVN0YXRlICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCAgPSBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYG1peGl0dXAuRXZlbnRzYCBjbGFzcyBjb250YWlucyBhbGwgY3VzdG9tIGV2ZW50cyBkaXNwYXRjaGVkIGJ5IE1peEl0VXAgYXQgdmFyaW91c1xuICAgICAqIHBvaW50cyB3aXRoaW4gdGhlIGxpZmVjeWNsZSBvZiBhIG1peGVyIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEVhY2ggZXZlbnQgaXMgYW5hbG9nb3VzIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBvZiB0aGUgc2FtZSBuYW1lIGRlZmluZWQgaW5cbiAgICAgKiB0aGUgYGNhbGxiYWNrc2AgY29uZmlndXJhdGlvbiBvYmplY3QsIGFuZCBpcyB0cmlnZ2VyZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGl0LlxuICAgICAqXG4gICAgICogRXZlbnRzIGFyZSBhbHdheXMgdHJpZ2dlcmVkIGZyb20gdGhlIGNvbnRhaW5lciBlbGVtZW50IG9uIHdoaWNoIE1peEl0VXAgaXMgaW5zdGFudGlhdGVkXG4gICAgICogdXBvbi5cbiAgICAgKlxuICAgICAqIEFzIHdpdGggYW55IGV2ZW50LCByZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXJzIHJlY2VpdmUgdGhlIGV2ZW50IG9iamVjdCBhcyBhIHBhcmFtZXRlclxuICAgICAqIHdoaWNoIGluY2x1ZGVzIGEgYGRldGFpbGAgcHJvcGVydHkgY29udGFpbnRpbmcgcmVmZXJlbmNlcyB0byB0aGUgY3VycmVudCBgc3RhdGVgLFxuICAgICAqIHRoZSBgbWl4ZXJgIGluc3RhbmNlLCBhbmQgb3RoZXIgZXZlbnQtc3BlY2lmaWMgcHJvcGVydGllcyBkZXNjcmliZWQgYmVsb3cuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHVibGljXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjdXN0b20gZXZlbnQgdHJpZ2dlcmVkIGltbWVkaWF0ZWx5IGFmdGVyIGFueSBNaXhJdFVwIG9wZXJhdGlvbiBpcyByZXF1ZXN0ZWRcbiAgICAgICAgICogYW5kIGJlZm9yZSBhbmltYXRpb25zIGhhdmUgYmVndW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBgbWl4U3RhcnRgIGV2ZW50IGFsc28gZXhwb3NlcyBhIGBmdXR1cmVTdGF0ZWAgcHJvcGVydHkgdmlhIHRoZVxuICAgICAgICAgKiBgZXZlbnQuZGV0YWlsYCBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGZpbmFsIHN0YXRlIG9mIHRoZSBtaXhlciBvbmNlXG4gICAgICAgICAqIHRoZSByZXF1ZXN0ZWQgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBtaXhTdGFydFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5FdmVudHNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAdHlwZSAgICAgICAge0N1c3RvbUV2ZW50fVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLm1peFN0YXJ0ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjdXN0b20gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSBNaXhJdFVwIG9wZXJhdGlvbiBpcyByZXF1ZXN0ZWQgd2hpbGUgYW5vdGhlclxuICAgICAgICAgKiBvcGVyYXRpb24gaXMgaW4gcHJvZ3Jlc3MsIGFuZCB0aGUgYW5pbWF0aW9uIHF1ZXVlIGlzIGZ1bGwsIG9yIHF1ZXVlaW5nXG4gICAgICAgICAqIGlzIGRpc2FibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgbWl4QnVzeVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5FdmVudHNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAdHlwZSAgICAgICAge0N1c3RvbUV2ZW50fVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLm1peEJ1c3kgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGN1c3RvbSBldmVudCB0cmlnZ2VyZWQgYWZ0ZXIgYW55IE1peEl0VXAgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQsIGFuZCB0aGVcbiAgICAgICAgICogc3RhdGUgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIG1peEVuZFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5FdmVudHNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAdHlwZSAgICAgICAge0N1c3RvbUV2ZW50fVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLm1peEVuZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY3VzdG9tIGV2ZW50IHRyaWdnZXJlZCB3aGVuZXZlciBhIGZpbHRlciBvcGVyYXRpb24gXCJmYWlsc1wiLCBpLmUuIG5vIHRhcmdldHNcbiAgICAgICAgICogY291bGQgYmUgZm91bmQgbWF0Y2hpbmcgdGhlIHJlcXVlc3RlZCBmaWx0ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBtaXhGYWlsXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLkV2ZW50c1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7Q3VzdG9tRXZlbnR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMubWl4RmFpbCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY3VzdG9tIGV2ZW50IHRyaWdnZXJlZCB3aGVuZXZlciBhIE1peEl0VXAgY29udHJvbCBpcyBjbGlja2VkLCBhbmQgYmVmb3JlIGl0c1xuICAgICAgICAgKiByZXNwZWN0aXZlIG9wZXJhdGlvbiBpcyByZXF1ZXN0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgYWxzbyBleHBvc2VzIGFuIGBvcmlnaW5hbEV2ZW50YCBwcm9wZXJ0eSB2aWEgdGhlIGBldmVudC5kZXRhaWxgXG4gICAgICAgICAqIG9iamVjdCwgd2hpY2ggaG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIGNsaWNrIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgbWl4Q2xpY2tcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuRXZlbnRzXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtDdXN0b21FdmVudH1cbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5taXhDbGljayA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuRXZlbnRzKTtcblxuICAgIG1peGl0dXAuRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLkV2ZW50cy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLkV2ZW50cztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICBldmVudFR5cGVcbiAgICAgKiBAcGFyYW0gICB7RWxlbWVudH0gICAgIGVsXG4gICAgICogQHBhcmFtICAge29iamVjdH0gICAgICBkZXRhaWxcbiAgICAgKiBAcGFyYW0gICB7RG9jdW1lbnR9ICAgIFtkb2NdXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkV2ZW50cy5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZWwsIGRldGFpbCwgZG9jKSB7XG4gICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBldmVudCAgICAgICA9IG51bGwsXG4gICAgICAgICAgICBldmVudERldGFpbCA9IG5ldyBtaXhpdHVwLkV2ZW50RGV0YWlsKCk7XG5cbiAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlRmlyZScsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmW2V2ZW50VHlwZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IHR5cGUgXCInICsgZXZlbnRUeXBlICsgJ1wiIG5vdCBmb3VuZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50RGV0YWlsLnN0YXRlID0gbmV3IG1peGl0dXAuU3RhdGUoKTtcblxuICAgICAgICBoLmV4dGVuZChldmVudERldGFpbC5zdGF0ZSwgZGV0YWlsLnN0YXRlKTtcblxuICAgICAgICBpZiAoZGV0YWlsLmZ1dHVyZVN0YXRlKSB7XG4gICAgICAgICAgICBldmVudERldGFpbC5mdXR1cmVTdGF0ZSA9IG5ldyBtaXhpdHVwLlN0YXRlKCk7XG5cbiAgICAgICAgICAgIGguZXh0ZW5kKGV2ZW50RGV0YWlsLmZ1dHVyZVN0YXRlLCBkZXRhaWwuZnV0dXJlU3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnREZXRhaWwuaW5zdGFuY2UgPSBkZXRhaWwuaW5zdGFuY2U7XG5cbiAgICAgICAgaWYgKGRldGFpbC5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgICBldmVudERldGFpbC5vcmlnaW5hbEV2ZW50ID0gZGV0YWlsLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBldmVudCA9IGguZ2V0Q3VzdG9tRXZlbnQoZXZlbnRUeXBlLCBldmVudERldGFpbCwgZG9jKTtcblxuICAgICAgICBzZWxmLmNhbGxGaWx0ZXJzKCdldmVudEZpcmUnLCBldmVudCwgYXJndW1lbnRzKTtcblxuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9O1xuXG4gICAgLy8gQXNpZ24gYSBzaW5nbGV0b24gaW5zdGFuY2UgdG8gYG1peGl0dXAuZXZlbnRzYDpcblxuICAgIG1peGl0dXAuZXZlbnRzID0gbmV3IG1peGl0dXAuRXZlbnRzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICovXG5cbiAgICBtaXhpdHVwLlF1ZXVlSXRlbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLmFyZ3MgICAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb24gICAgPSBudWxsO1xuICAgICAgICB0aGlzLnRyaWdnZXJFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWZlcnJlZCAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNUb2dnbGluZyAgICAgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5RdWV1ZUl0ZW0pO1xuXG4gICAgbWl4aXR1cC5RdWV1ZUl0ZW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuUXVldWVJdGVtLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuUXVldWVJdGVtO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBtaXhpdHVwLk1peGVyYCBjbGFzcyBpcyB1c2VkIHRvIGhvbGQgZGlzY3JlZXQsIHVzZXItY29uZmlndXJlZFxuICAgICAqIGluc3RhbmNlcyBvZiBNaXhJdFVwIG9uIGEgcHJvdmlkZWQgY29udGFpbmVyIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBNaXhlciBpbnN0YW5jZXMgYXJlIHJldHVybmVkIHdoZW5ldmVyIHRoZSBgbWl4aXR1cCgpYCBmYWN0b3J5IGZ1bmN0aW9uIGlzIGNhbGxlZCxcbiAgICAgKiB3aGljaCBleHBvc2UgYSByYW5nZSBvZiBtZXRob2RzIGVuYWJsaW5nIEFQSS1iYXNlZCBmaWx0ZXJpbmcsIHNvcnRpbmcsXG4gICAgICogaW5zZXJ0aW9uLCByZW1vdmFsIGFuZCBtb3JlLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5NaXhlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICB0aGlzLmNvbmZpZyAgICAgICAgICAgID0gbmV3IG1peGl0dXAuQ29uZmlnKCk7XG5cbiAgICAgICAgdGhpcy5pZCAgICAgICAgICAgICAgICA9ICcnO1xuXG4gICAgICAgIHRoaXMuaXNCdXN5ICAgICAgICAgICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1RvZ2dsaW5nICAgICAgICA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluY1BhZGRpbmcgICAgICAgID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmNvbnRyb2xzICAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMudGFyZ2V0cyAgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy5vcmlnT3JkZXIgICAgICAgICA9IFtdO1xuICAgICAgICB0aGlzLmNhY2hlICAgICAgICAgICAgID0ge307XG5cbiAgICAgICAgdGhpcy50b2dnbGVBcnJheSAgICAgICA9IFtdO1xuXG4gICAgICAgIHRoaXMudGFyZ2V0c01vdmVkICAgICAgPSAwO1xuICAgICAgICB0aGlzLnRhcmdldHNJbW1vdmFibGUgID0gMDtcbiAgICAgICAgdGhpcy50YXJnZXRzQm91bmQgICAgICA9IDA7XG4gICAgICAgIHRoaXMudGFyZ2V0c0RvbmUgICAgICAgPSAwO1xuXG4gICAgICAgIHRoaXMuc3RhZ2dlckR1cmF0aW9uICAgPSAwO1xuICAgICAgICB0aGlzLmVmZmVjdHNJbiAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5lZmZlY3RzT3V0ICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtSW4gICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1PdXQgICAgICA9IFtdO1xuICAgICAgICB0aGlzLnF1ZXVlICAgICAgICAgICAgID0gW107XG5cbiAgICAgICAgdGhpcy5zdGF0ZSAgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE9wZXJhdGlvbiAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDbGlja2VkICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy51c2VyQ2FsbGJhY2sgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMudXNlckRlZmVycmVkICAgICAgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuZG9tICAgICAgICAgICAgICAgPSBuZXcgbWl4aXR1cC5NaXhlckRvbSgpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLk1peGVyKTtcblxuICAgIG1peGl0dXAuTWl4ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIGguZXh0ZW5kKG1peGl0dXAuTWl4ZXIucHJvdG90eXBlLFxuICAgIC8qKiBAbGVuZHMgbWl4aXR1cC5NaXhlciAqL1xuICAgIHtcbiAgICAgICAgY29uc3RydWN0b3I6IG1peGl0dXAuTWl4ZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvY3VtZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgIGlkXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgIFtjb25maWddXG4gICAgICAgICAqL1xuXG4gICAgICAgIGF0dGFjaDogZnVuY3Rpb24oY29udGFpbmVyLCBkb2N1bWVudCwgaWQsIGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlQXR0YWNoJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5pZCA9IGlkO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaC5leHRlbmQoc2VsZi5jb25maWcsIGNvbmZpZywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuc2FuaXRpemVDb25maWcoKTtcblxuICAgICAgICAgICAgc2VsZi5jYWNoZURvbShjb250YWluZXIsIGRvY3VtZW50KTtcblxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmxheW91dC5jb250YWluZXJDbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBoLmFkZENsYXNzKHNlbGYuZG9tLmNvbnRhaW5lciwgc2VsZi5jb25maWcubGF5b3V0LmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbWl4aXR1cC5mZWF0dXJlcy5oYXMudHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmNvbnNvbGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZGVidWcuc2hvd1dhcm5pbmdzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5kYXRhLnVpZEtleSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhc2V0IEFQSSBpcyBpbiB1c2UsIGZvcmNlIGRpc2FibGUgY29udHJvbHNcblxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmNvbnRyb2xzLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmluZGV4VGFyZ2V0cygpO1xuXG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gc2VsZi5nZXRJbml0aWFsU3RhdGUoKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gc2VsZi5sYXN0T3BlcmF0aW9uLnRvSGlkZVtpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmhpZGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmNvbnRyb2xzLmVuYWJsZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuaW5pdENvbnRyb2xzKCk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLmJ1aWxkVG9nZ2xlQXJyYXkobnVsbCwgc2VsZi5zdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUNvbnRyb2xzKHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBzZWxmLnN0YXRlLmFjdGl2ZUZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgc29ydDogc2VsZi5zdGF0ZS5hY3RpdmVTb3J0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYucGFyc2VFZmZlY3RzKCk7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyQXR0YWNoJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBzYW5pdGl6ZUNvbmZpZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVNhbml0aXplQ29uZmlnJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gU2FuaXRpemUgZW51bS9zdHJpbmcgY29uZmlnIG9wdGlvbnNcblxuICAgICAgICAgICAgc2VsZi5jb25maWcuY29udHJvbHMuc2NvcGUgICAgICAgICAgPSBzZWxmLmNvbmZpZy5jb250cm9scy5zY29wZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgICAgIHNlbGYuY29uZmlnLmNvbnRyb2xzLnRvZ2dsZUxvZ2ljICAgID0gc2VsZi5jb25maWcuY29udHJvbHMudG9nZ2xlTG9naWMudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgICAgICBzZWxmLmNvbmZpZy5jb250cm9scy50b2dnbGVEZWZhdWx0ICA9IHNlbGYuY29uZmlnLmNvbnRyb2xzLnRvZ2dsZURlZmF1bHQudG9Mb3dlckNhc2UoKS50cmltKCk7XG5cbiAgICAgICAgICAgIHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lZmZlY3RzICAgICAgID0gc2VsZi5jb25maWcuYW5pbWF0aW9uLmVmZmVjdHMudHJpbSgpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlclNhbml0aXplQ29uZmlnJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEByZXR1cm4gIHttaXhpdHVwLlN0YXRlfVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzdGF0ZSAgICAgICA9IG5ldyBtaXhpdHVwLlN0YXRlKCksXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uICAgPSBuZXcgbWl4aXR1cC5PcGVyYXRpb24oKTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlR2V0SW5pdGlhbFN0YXRlJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gTWFwIGluaXRpYWwgdmFsdWVzIGludG8gYSBtb2NrIHN0YXRlIG9iamVjdCBpbiBvcmRlciB0byBjb25zdHJ1Y3QgYW4gb3BlcmF0aW9uXG5cbiAgICAgICAgICAgIHN0YXRlLmFjdGl2ZUNvbnRhaW5lckNsYXNzTmFtZSA9IHNlbGYuY29uZmlnLmxheW91dC5jb250YWluZXJDbGFzc05hbWU7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5sb2FkLmRhdGFzZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRhc2V0IEFQSVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5kYXRhLnVpZEtleSB8fCB0eXBlb2Ygc2VsZi5jb25maWcuZGF0YS51aWRLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobWl4aXR1cC5tZXNzYWdlcy5lcnJvckNvbmZpZ0RhdGFVaWRLZXlOb3RTZXQoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnN0YXJ0RGF0YXNldCA9IG9wZXJhdGlvbi5uZXdEYXRhc2V0ID0gc3RhdGUuYWN0aXZlRGF0YXNldCA9IHNlbGYuY29uZmlnLmxvYWQuZGF0YXNldC5zbGljZSgpO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydENvbnRhaW5lckNsYXNzTmFtZSA9IG9wZXJhdGlvbi5uZXdDb250YWluZXJDbGFzc05hbWUgPSBzdGF0ZS5hY3RpdmVDb250YWluZXJDbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnNob3cgPSBzZWxmLnRhcmdldHMuc2xpY2UoKTtcblxuICAgICAgICAgICAgICAgIHN0YXRlID0gc2VsZi5jYWxsRmlsdGVycygnc3RhdGVHZXRJbml0aWFsU3RhdGUnLCBzdGF0ZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRE9NIEFQSVxuXG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlRmlsdGVyICAgICAgICAgICAgICA9IHNlbGYucGFyc2VGaWx0ZXJBcmdzKFtzZWxmLmNvbmZpZy5sb2FkLmZpbHRlcl0pLmNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlU29ydCAgICAgICAgICAgICAgICA9IHNlbGYucGFyc2VTb3J0QXJncyhbc2VsZi5jb25maWcubG9hZC5zb3J0XSkuY29tbWFuZDtcbiAgICAgICAgICAgICAgICBzdGF0ZS50b3RhbFRhcmdldHMgICAgICAgICAgICAgID0gc2VsZi50YXJnZXRzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHN0YXRlID0gc2VsZi5jYWxsRmlsdGVycygnc3RhdGVHZXRJbml0aWFsU3RhdGUnLCBzdGF0ZSwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlU29ydC5jb2xsZWN0aW9uIHx8IHN0YXRlLmFjdGl2ZVNvcnQuYXR0cmlidXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVNvcnQub3JkZXIgPT09ICdyYW5kb20nIHx8IHN0YXRlLmFjdGl2ZVNvcnQub3JkZXIgPT09ICdkZXNjJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTb3J0aW5nIG9uIGxvYWRcblxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmV3U29ydCA9IHN0YXRlLmFjdGl2ZVNvcnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zb3J0T3BlcmF0aW9uKG9wZXJhdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcmludFNvcnQoZmFsc2UsIG9wZXJhdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi50YXJnZXRzID0gb3BlcmF0aW9uLm5ld09yZGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydE9yZGVyID0gb3BlcmF0aW9uLm5ld09yZGVyID0gc2VsZi50YXJnZXRzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydEZpbHRlciAgICAgICAgICAgICAgID0gb3BlcmF0aW9uLm5ld0ZpbHRlciAgICAgICAgICAgICAgID0gc3RhdGUuYWN0aXZlRmlsdGVyO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydFNvcnQgICAgICAgICAgICAgICAgID0gb3BlcmF0aW9uLm5ld1NvcnQgICAgICAgICAgICAgICAgID0gc3RhdGUuYWN0aXZlU29ydDtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uc3RhcnRDb250YWluZXJDbGFzc05hbWUgICA9IG9wZXJhdGlvbi5uZXdDb250YWluZXJDbGFzc05hbWUgICA9IHN0YXRlLmFjdGl2ZUNvbnRhaW5lckNsYXNzTmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ubmV3RmlsdGVyLnNlbGVjdG9yID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmV3RmlsdGVyLnNlbGVjdG9yID0gc2VsZi5jb25maWcuc2VsZWN0b3JzLnRhcmdldDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5uZXdGaWx0ZXIuc2VsZWN0b3IgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmV3RmlsdGVyLnNlbGVjdG9yID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcGVyYXRpb24gPSBzZWxmLmNhbGxGaWx0ZXJzKCdvcGVyYXRpb25HZXRJbml0aWFsU3RhdGUnLCBvcGVyYXRpb24sIFtzdGF0ZV0pO1xuXG4gICAgICAgICAgICBzZWxmLmxhc3RPcGVyYXRpb24gPSBvcGVyYXRpb247XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ubmV3RmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5maWx0ZXJPcGVyYXRpb24ob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUgPSBzZWxmLmJ1aWxkU3RhdGUob3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoZXMgcmVmZXJlbmNlcyBvZiBET00gZWxlbWVudHMgbmVjY2Vzc2FyeSBmb3IgdGhlIG1peGVyJ3MgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gICAgICAgZWxcbiAgICAgICAgICogQHBhcmFtICAge0hUTUxIdG1sRWxlbWVudH0gICBkb2N1bWVudFxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgY2FjaGVEb206IGZ1bmN0aW9uKGVsLCBkb2N1bWVudCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVDYWNoZURvbScsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYuZG9tLmRvY3VtZW50ICA9IGRvY3VtZW50O1xuICAgICAgICAgICAgc2VsZi5kb20uYm9keSAgICAgID0gc2VsZi5kb20uZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuICAgICAgICAgICAgc2VsZi5kb20uY29udGFpbmVyID0gZWw7XG4gICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQgICAgPSBlbDtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJDYWNoZURvbScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4ZXMgYWxsIGNoaWxkIGVsZW1lbnRzIG9mIHRoZSBtaXhlciBtYXRjaGluZyB0aGUgYHNlbGVjdG9ycy50YXJnZXRgXG4gICAgICAgICAqIHNlbGVjdG9yLCBpbnN0YW50aWF0aW5nIGEgbWl4aXR1cC5UYXJnZXQgZm9yIGVhY2ggb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGluZGV4VGFyZ2V0czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB0YXJnZXQgICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGVsICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgZGF0YXNldCAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlSW5kZXhUYXJnZXRzJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5kb20udGFyZ2V0cyA9IHNlbGYuY29uZmlnLmxheW91dC5hbGxvd05lc3RlZFRhcmdldHMgP1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHNlbGYuY29uZmlnLnNlbGVjdG9ycy50YXJnZXQpIDpcbiAgICAgICAgICAgICAgICBoLmNoaWxkcmVuKHNlbGYuZG9tLmNvbnRhaW5lciwgc2VsZi5jb25maWcuc2VsZWN0b3JzLnRhcmdldCwgc2VsZi5kb20uZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICBzZWxmLmRvbS50YXJnZXRzID0gaC5hcnJheUZyb21MaXN0KHNlbGYuZG9tLnRhcmdldHMpO1xuXG4gICAgICAgICAgICBzZWxmLnRhcmdldHMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKChkYXRhc2V0ID0gc2VsZi5jb25maWcubG9hZC5kYXRhc2V0KSAmJiBkYXRhc2V0Lmxlbmd0aCAhPT0gc2VsZi5kb20udGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWl4aXR1cC5tZXNzYWdlcy5lcnJvckRhdGFzZXRQcmVyZW5kZXJlZE1pc21hdGNoKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZi5kb20udGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBlbCA9IHNlbGYuZG9tLnRhcmdldHNbaV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBuZXcgbWl4aXR1cC5UYXJnZXQoKTtcblxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuaW5pdChlbCwgc2VsZiwgZGF0YXNldCA/IGRhdGFzZXRbaV0gOiB2b2lkKDApKTtcblxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuaXNJbkRvbSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi50YXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQgPSBzZWxmLmRvbS50YXJnZXRzWzBdLnBhcmVudEVsZW1lbnQgPT09IHNlbGYuZG9tLmNvbnRhaW5lciA/XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZG9tLmNvbnRhaW5lciA6XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZG9tLnRhcmdldHNbMF0ucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5vcmlnT3JkZXIgPSBzZWxmLnRhcmdldHM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVySW5kZXhUYXJnZXRzJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0Q29udHJvbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRlZmluaXRpb24gICAgICAgICAgPSAnJyxcbiAgICAgICAgICAgICAgICBjb250cm9sRWxlbWVudHMgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBlbCAgICAgICAgICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJlbnQgICAgICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBkZWxhZ2F0b3JzICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBjb250cm9sICAgICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgICAgID0gLTEsXG4gICAgICAgICAgICAgICAgaiAgICAgICAgICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVJbml0Q29udHJvbHMnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHNlbGYuY29uZmlnLmNvbnRyb2xzLnNjb3BlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbG9jYWwnOlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBzZWxmLmRvbS5jb250YWluZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZ2xvYmFsJzpcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gc2VsZi5kb20uZG9jdW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1peGl0dXAubWVzc2FnZXMuZXJyb3JDb25maWdJbnZhbGlkQ29udHJvbHNTY29wZSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgZGVmaW5pdGlvbiA9IG1peGl0dXAuY29udHJvbERlZmluaXRpb25zW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuY29udHJvbHMubGl2ZSB8fCBkZWZpbml0aW9uLmxpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24ucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxhZ2F0b3JzID0gc2VsZi5kb21bZGVmaW5pdGlvbi5wYXJlbnRdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRlbGFnYXRvcnMgfHwgZGVsYWdhdG9ycy5sZW5ndGggPCAwKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWxhZ2F0b3JzLmxlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxhZ2F0b3JzID0gW2RlbGFnYXRvcnNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYWdhdG9ycyA9IFtwYXJlbnRdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgKGVsID0gZGVsYWdhdG9yc1tqXSk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHNlbGYuZ2V0Q29udHJvbChlbCwgIGRlZmluaXRpb24udHlwZSwgZGVmaW5pdGlvbi5zZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29udHJvbHMucHVzaChjb250cm9sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xFbGVtZW50cyA9IHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGYuY29uZmlnLnNlbGVjdG9ycy5jb250cm9sICsgZGVmaW5pdGlvbi5zZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgKGVsID0gY29udHJvbEVsZW1lbnRzW2pdKTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gc2VsZi5nZXRDb250cm9sKGVsLCBkZWZpbml0aW9uLnR5cGUsICcnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250cm9sKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb250cm9scy5wdXNoKGNvbnRyb2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckluaXRDb250cm9scycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGVsXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgICAgdHlwZVxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICAgIHNlbGVjdG9yXG4gICAgICAgICAqIEByZXR1cm4gIHttaXhpdHVwLkNvbnRyb2x8bnVsbH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0Q29udHJvbDogZnVuY3Rpb24oZWwsIHR5cGUsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgY29udHJvbCA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVHZXRDb250cm9sJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIC8vIFN0YXRpYyBjb250cm9scyBvbmx5XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBjb250cm9sID0gbWl4aXR1cC5jb250cm9sc1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sLmVsID09PSBlbCAmJiBjb250cm9sLmlzQm91bmQoc2VsZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRyb2wgYWxyZWFkeSBib3VuZCB0byB0aGlzIG1peGVyIChhcyBhbm90aGVyIHR5cGUpLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOQjogVGhpcyBwcmV2ZW50cyBkdXBsaWNhdGUgY29udHJvbHMgZnJvbSBiZWluZyByZWdpc3RlcmVkIHdoZXJlIGEgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pZ2h0IGNvbGxpZGUsIGVnOiBcIltkYXRhLWZpbHRlcl1cIiBhbmQgXCJbZGF0YS1maWx0ZXJdW2RhdGEtc29ydF1cIlxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsRmlsdGVycygnY29udHJvbEdldENvbnRyb2wnLCBudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRyb2wuZWwgPT09IGVsICYmIGNvbnRyb2wudHlwZSA9PT0gdHlwZSAmJiBjb250cm9sLnNlbGVjdG9yID09PSBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5vdGhlciBtaXhlciBpcyBhbHJlYWR5IHVzaW5nIHRoaXMgY29udHJvbCwgYWRkIHRoaXMgbWl4ZXIgYXMgYSBiaW5kaW5nXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuYWRkQmluZGluZyhzZWxmKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ2NvbnRyb2xHZXRDb250cm9sJywgY29udHJvbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBjb250cm9sXG5cbiAgICAgICAgICAgIGNvbnRyb2wgPSBuZXcgbWl4aXR1cC5Db250cm9sKCk7XG5cbiAgICAgICAgICAgIGNvbnRyb2wuaW5pdChlbCwgdHlwZSwgc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICBjb250cm9sLmNsYXNzTmFtZXMuYmFzZSAgICAgPSBoLmdldENsYXNzbmFtZShzZWxmLmNvbmZpZy5jbGFzc05hbWVzLCB0eXBlKTtcbiAgICAgICAgICAgIGNvbnRyb2wuY2xhc3NOYW1lcy5hY3RpdmUgICA9IGguZ2V0Q2xhc3NuYW1lKHNlbGYuY29uZmlnLmNsYXNzTmFtZXMsIHR5cGUsIHNlbGYuY29uZmlnLmNsYXNzTmFtZXMubW9kaWZpZXJBY3RpdmUpO1xuICAgICAgICAgICAgY29udHJvbC5jbGFzc05hbWVzLmRpc2FibGVkID0gaC5nZXRDbGFzc25hbWUoc2VsZi5jb25maWcuY2xhc3NOYW1lcywgdHlwZSwgc2VsZi5jb25maWcuY2xhc3NOYW1lcy5tb2RpZmllckRpc2FibGVkKTtcblxuICAgICAgICAgICAgLy8gQWRkIGEgcmVmZXJlbmNlIHRvIHRoaXMgbWl4ZXIgYXMgYSBiaW5kaW5nXG5cbiAgICAgICAgICAgIGNvbnRyb2wuYWRkQmluZGluZyhzZWxmKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ2NvbnRyb2xHZXRDb250cm9sJywgY29udHJvbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGNvbXBvdW5kIHNlbGVjdG9yIGJ5IGpvaW5pbmcgdGhlIGB0b2dnbGVBcnJheWAgdmFsdWUgYXMgcGVyIHRoZVxuICAgICAgICAgKiBkZWZpbmVkIHRvZ2dsZSBsb2dpYy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEByZXR1cm4gIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGdldFRvZ2dsZVNlbGVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRlbGluZWF0b3IgICAgICA9IHNlbGYuY29uZmlnLmNvbnRyb2xzLnRvZ2dsZUxvZ2ljID09PSAnb3InID8gJywgJyA6ICcnLFxuICAgICAgICAgICAgICAgIHRvZ2dsZVNlbGVjdG9yICA9ICcnO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVHZXRUb2dnbGVTZWxlY3RvcicsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYudG9nZ2xlQXJyYXkgPSBoLmNsZWFuKHNlbGYudG9nZ2xlQXJyYXkpO1xuXG4gICAgICAgICAgICB0b2dnbGVTZWxlY3RvciA9IHNlbGYudG9nZ2xlQXJyYXkuam9pbihkZWxpbmVhdG9yKTtcblxuICAgICAgICAgICAgaWYgKHRvZ2dsZVNlbGVjdG9yID09PSAnJykge1xuICAgICAgICAgICAgICAgIHRvZ2dsZVNlbGVjdG9yID0gc2VsZi5jb25maWcuY29udHJvbHMudG9nZ2xlRGVmYXVsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ3NlbGVjdG9yR2V0VG9nZ2xlU2VsZWN0b3InLCB0b2dnbGVTZWxlY3RvciwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQnJlYWtzIGNvbXBvdW5kIHNlbGVjdG9yIHN0cmluZ3MgaW4gYW4gYXJyYXkgb2YgZGlzY3JlZXQgc2VsZWN0b3JzLFxuICAgICAgICAgKiBhcyBwZXIgdGhlIGFjdGl2ZSBgY29udHJvbHMudG9nZ2xlTG9naWNgIGNvbmZpZ3VyYXRpb24gb3B0aW9uLiBBY2NlcHRzXG4gICAgICAgICAqIGVpdGhlciBhIGR5bmFtaWMgY29tbWFuZCBvYmplY3QsIG9yIGEgc3RhdGUgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAge29iamVjdH0gICAgICAgIFtjb21tYW5kXVxuICAgICAgICAgKiBAcGFyYW0gICB7bWl4aXR1cC5TdGF0ZX0gW3N0YXRlXVxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgYnVpbGRUb2dnbGVBcnJheTogZnVuY3Rpb24oY29tbWFuZCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYWN0aXZlRmlsdGVyU2VsZWN0b3IgICAgPSAnJztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlQnVpbGRUb2dnbGVBcnJheScsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChjb21tYW5kICYmIGNvbW1hbmQuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlRmlsdGVyU2VsZWN0b3IgPSBjb21tYW5kLmZpbHRlci5zZWxlY3Rvci5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUZpbHRlclNlbGVjdG9yID0gc3RhdGUuYWN0aXZlRmlsdGVyLnNlbGVjdG9yLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFjdGl2ZUZpbHRlclNlbGVjdG9yID09PSBzZWxmLmNvbmZpZy5zZWxlY3RvcnMudGFyZ2V0IHx8IGFjdGl2ZUZpbHRlclNlbGVjdG9yID09PSAnYWxsJykge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUZpbHRlclNlbGVjdG9yID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5jb250cm9scy50b2dnbGVMb2dpYyA9PT0gJ29yJykge1xuICAgICAgICAgICAgICAgIHNlbGYudG9nZ2xlQXJyYXkgPSBhY3RpdmVGaWx0ZXJTZWxlY3Rvci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRvZ2dsZUFycmF5ID0gc2VsZi5zcGxpdENvbXBvdW5kU2VsZWN0b3IoYWN0aXZlRmlsdGVyU2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnRvZ2dsZUFycmF5ID0gaC5jbGVhbihzZWxmLnRvZ2dsZUFycmF5KTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJCdWlsZFRvZ2dsZUFycmF5JywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBjb21wb3VuZCBzZWxlY3RvciAoZS5nLiBgLmNhdC0xLmNhdC0yYCwgYFtkYXRhLWNhdD1cIjFcIl1bZGF0YS1jYXQ9XCIyXCJdYClcbiAgICAgICAgICogYW5kIGJyZWFrcyBpbnRvIGl0cyBpbmRpdmlkdWFsIHNlbGVjdG9ycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9IGNvbXBvdW5kU2VsZWN0b3JcbiAgICAgICAgICogQHJldHVybiAge3N0cmluZ1tdfVxuICAgICAgICAgKi9cblxuICAgICAgICBzcGxpdENvbXBvdW5kU2VsZWN0b3I6IGZ1bmN0aW9uKGNvbXBvdW5kU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIC8vIEJyZWFrIGF0IGEgYC5gIG9yIGBbYCwgY2FwdHVyaW5nIHRoZSBkZWxpbmVhdG9yXG5cbiAgICAgICAgICAgIHZhciBwYXJ0aWFscyAgICA9IGNvbXBvdW5kU2VsZWN0b3Iuc3BsaXQoLyhbXFwuXFxbXSkvZyksXG4gICAgICAgICAgICAgICAgdG9nZ2xlQXJyYXkgPSBbXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvciAgICA9ICcnLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0aWFsc1swXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFscy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFydGlhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxlY3RvciArPSBwYXJ0aWFsc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChpICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0b2dnbGVBcnJheS5wdXNoKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0b2dnbGVBcnJheTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyBjb250cm9scyB0byB0aGVpciBhY3RpdmUvaW5hY3RpdmUgc3RhdGUgYmFzZWQgb24gdGhlIGNvbW1hbmQgb3JcbiAgICAgICAgICogY3VycmVudCBzdGF0ZSBvZiB0aGUgbWl4ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSBjb21tYW5kXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICB1cGRhdGVDb250cm9sczogZnVuY3Rpb24oY29tbWFuZCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBudWxsLFxuICAgICAgICAgICAgICAgIG91dHB1dCAgPSBuZXcgbWl4aXR1cC5Db21tYW5kTXVsdGltaXgoKSxcbiAgICAgICAgICAgICAgICBpICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVVwZGF0ZUNvbnRyb2xzJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gU2FuaXRpc2UgdG8gZGVmYXVsdHNcblxuICAgICAgICAgICAgaWYgKGNvbW1hbmQuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmZpbHRlciA9IGNvbW1hbmQuZmlsdGVyLnNlbGVjdG9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuZmlsdGVyID0gc2VsZi5zdGF0ZS5hY3RpdmVGaWx0ZXIuc2VsZWN0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb21tYW5kLnNvcnQpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc29ydCA9IHNlbGYuYnVpbGRTb3J0U3RyaW5nKGNvbW1hbmQuc29ydCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zb3J0ID0gc2VsZi5idWlsZFNvcnRTdHJpbmcoc2VsZi5zdGF0ZS5hY3RpdmVTb3J0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG91dHB1dC5maWx0ZXIgPT09IHNlbGYuY29uZmlnLnNlbGVjdG9ycy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuZmlsdGVyID0gJ2FsbCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvdXRwdXQuZmlsdGVyID09PSAnJykge1xuICAgICAgICAgICAgICAgIG91dHB1dC5maWx0ZXIgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGguZnJlZXplKG91dHB1dCk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGNvbnRyb2wgPSBzZWxmLmNvbnRyb2xzW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLnVwZGF0ZShvdXRwdXQsIHNlbGYudG9nZ2xlQXJyYXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlclVwZGF0ZUNvbnRyb2xzJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHttaXhpdHVwLkNvbW1hbmRTb3J0fSAgIGNvbW1hbmRcbiAgICAgICAgICogQHJldHVybiAge3N0cmluZ31cbiAgICAgICAgICovXG5cbiAgICAgICAgYnVpbGRTb3J0U3RyaW5nOiBmdW5jdGlvbihjb21tYW5kKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ICA9ICcnO1xuXG4gICAgICAgICAgICBvdXRwdXQgKz0gY29tbWFuZC5zb3J0U3RyaW5nO1xuXG4gICAgICAgICAgICBpZiAoY29tbWFuZC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICcgJyArIHNlbGYuYnVpbGRTb3J0U3RyaW5nKGNvbW1hbmQubmV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICAgICAgY29tbWFuZFxuICAgICAgICAgKiBAcGFyYW0gICB7T3BlcmF0aW9ufSAgICAgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHtQcm9taXNlLjxtaXhpdHVwLlN0YXRlPn1cbiAgICAgICAgICovXG5cbiAgICAgICAgaW5zZXJ0VGFyZ2V0czogZnVuY3Rpb24oY29tbWFuZCwgb3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBuZXh0U2libGluZyAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGluc2VydGlvbkluZGV4ICA9IC0xLFxuICAgICAgICAgICAgICAgIGZyYWcgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgdGFyZ2V0ICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBlbCAgICAgICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVJbnNlcnRUYXJnZXRzJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kLmluZGV4ID09PSAndW5kZWZpbmVkJykgY29tbWFuZC5pbmRleCA9IDA7XG5cbiAgICAgICAgICAgIG5leHRTaWJsaW5nID0gc2VsZi5nZXROZXh0U2libGluZyhjb21tYW5kLmluZGV4LCBjb21tYW5kLnNpYmxpbmcsIGNvbW1hbmQucG9zaXRpb24pO1xuICAgICAgICAgICAgZnJhZyAgICAgICAgPSBzZWxmLmRvbS5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIGluc2VydGlvbkluZGV4ID0gaC5pbmRleChuZXh0U2libGluZywgc2VsZi5jb25maWcuc2VsZWN0b3JzLnRhcmdldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc2VydGlvbkluZGV4ID0gc2VsZi50YXJnZXRzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbW1hbmQuY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGVsID0gY29tbWFuZC5jb2xsZWN0aW9uW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZG9tLnRhcmdldHMuaW5kZXhPZihlbCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1peGl0dXAubWVzc2FnZXMuZXJyb3JJbnNlcnRQcmVleGlzdGluZ0VsZW1lbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgZWxlbWVudHMgYXJlIGhpZGRlbiB3aGVuIHRoZXkgYXJlIGFkZGVkIHRvIHRoZSBET00sIHNvIHRoZXkgY2FuXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIGFuaW1hdGVkIGluIGdyYWNlZnVsbHlcblxuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKHNlbGYuZG9tLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaC5pc0VsZW1lbnQoZWwsIHNlbGYuZG9tLmRvY3VtZW50KSB8fCAhZWwubWF0Y2hlcyhzZWxmLmNvbmZpZy5zZWxlY3RvcnMudGFyZ2V0KSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gbmV3IG1peGl0dXAuVGFyZ2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmluaXQoZWwsIHNlbGYpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5pc0luRG9tID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLnRhcmdldHMuc3BsaWNlKGluc2VydGlvbkluZGV4LCAwLCB0YXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGlvbkluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50Lmluc2VydEJlZm9yZShmcmFnLCBuZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNpbmNlIHRhcmdldHMgaGF2ZSBiZWVuIGFkZGVkLCB0aGUgb3JpZ2luYWwgb3JkZXIgbXVzdCBiZSB1cGRhdGVkXG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydE9yZGVyID0gc2VsZi5vcmlnT3JkZXIgPSBzZWxmLnRhcmdldHM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVySW5zZXJ0VGFyZ2V0cycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7TnVtYmVyfSAgICAgIFtpbmRleF1cbiAgICAgICAgICogQHBhcmFtICAge0VsZW1lbnR9ICAgICBbc2libGluZ11cbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICBbcG9zaXRpb25dXG4gICAgICAgICAqIEByZXR1cm4gIHtFbGVtZW50fVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXROZXh0U2libGluZzogZnVuY3Rpb24oaW5kZXgsIHNpYmxpbmcsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5tYXgoaW5kZXgsIDApO1xuXG4gICAgICAgICAgICBpZiAoc2libGluZyAmJiBwb3NpdGlvbiA9PT0gJ2JlZm9yZScpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCBzaWJsaW5nXG5cbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2libGluZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2libGluZyAmJiBwb3NpdGlvbiA9PT0gJ2FmdGVyJykge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IHNpYmxpbmdcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzaWJsaW5nLm5leHRFbGVtZW50U2libGluZyB8fCBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLnRhcmdldHMubGVuZ3RoID4gMCAmJiB0eXBlb2YgaW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5kZXggYW5kIHRhcmdldHMgZXhpc3RcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSAoaW5kZXggPCBzZWxmLnRhcmdldHMubGVuZ3RoIHx8ICFzZWxmLnRhcmdldHMubGVuZ3RoKSA/XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudGFyZ2V0c1tpbmRleF0uZG9tLmVsIDpcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50YXJnZXRzW3NlbGYudGFyZ2V0cy5sZW5ndGggLSAxXS5kb20uZWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLnRhcmdldHMubGVuZ3RoID09PSAwICYmIHNlbGYuZG9tLnBhcmVudC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gdGFyZ2V0cyBidXQgb3RoZXIgc2libGluZ3NcblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5sYXlvdXQuc2libGluZ0FmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZWxmLmNvbmZpZy5sYXlvdXQuc2libGluZ0FmdGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5jb25maWcubGF5b3V0LnNpYmxpbmdCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlbGYuY29uZmlnLmxheW91dC5zaWJsaW5nQmVmb3JlLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID09PSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsRmlsdGVycygnZWxlbWVudEdldE5leHRTaWJsaW5nJywgZWxlbWVudCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtPcGVyYXRpb259ICAgICBvcGVyYXRpb25cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGZpbHRlck9wZXJhdGlvbjogZnVuY3Rpb24ob3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRlc3RSZXN1bHQgID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgaW5kZXggICAgICAgPSAtMSxcbiAgICAgICAgICAgICAgICBhY3Rpb24gICAgICA9ICcnLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVGaWx0ZXJPcGVyYXRpb24nLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBhY3Rpb24gPSBvcGVyYXRpb24ubmV3RmlsdGVyLmFjdGlvbjtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gb3BlcmF0aW9uLm5ld09yZGVyW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLm5ld0ZpbHRlci5jb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3cgdmlhIGNvbGxlY3Rpb25cblxuICAgICAgICAgICAgICAgICAgICB0ZXN0UmVzdWx0ID0gb3BlcmF0aW9uLm5ld0ZpbHRlci5jb2xsZWN0aW9uLmluZGV4T2YodGFyZ2V0LmRvbS5lbCkgPiAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaG93IHZpYSBzZWxlY3RvclxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ubmV3RmlsdGVyLnNlbGVjdG9yID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdFJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdFJlc3VsdCA9IHRhcmdldC5kb20uZWwubWF0Y2hlcyhvcGVyYXRpb24ubmV3RmlsdGVyLnNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYuZXZhbHVhdGVIaWRlU2hvdyh0ZXN0UmVzdWx0LCB0YXJnZXQsIGFjdGlvbiwgb3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi50b1JlbW92ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24uc2hvd1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24udG9SZW1vdmUuaW5kZXhPZih0YXJnZXQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGFueSBzaG93biB0YXJnZXRzIHNob3VsZCBiZSByZW1vdmVkLCBtb3ZlIHRoZW0gaW50byB0aGUgdG9IaWRlIGFycmF5XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zaG93LnNwbGljZShpLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpbmRleCA9IG9wZXJhdGlvbi50b1Nob3cuaW5kZXhPZih0YXJnZXQpKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLnRvU2hvdy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24udG9IaWRlLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5oaWRlLnB1c2godGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcGVyYXRpb24ubWF0Y2hpbmcgPSBvcGVyYXRpb24uc2hvdy5zbGljZSgpO1xuXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLnNob3cubGVuZ3RoID09PSAwICYmIG9wZXJhdGlvbi5uZXdGaWx0ZXIuc2VsZWN0b3IgIT09ICcnICYmIHNlbGYudGFyZ2V0cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uaGFzRmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJGaWx0ZXJPcGVyYXRpb24nLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge2Jvb2xlYW59ICAgdGVzdFJlc3VsdFxuICAgICAgICAgKiBAcGFyYW0gICB7RWxlbWVudH0gICB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgYWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSAgIHtPcGVyYXRpb259IG9wZXJhdGlvblxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZXZhbHVhdGVIaWRlU2hvdzogZnVuY3Rpb24odGVzdFJlc3VsdCwgdGFyZ2V0LCBhY3Rpb24sIG9wZXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGZpbHRlcmVkVGVzdFJlc3VsdCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgICAgICAgICBmaWx0ZXJlZFRlc3RSZXN1bHQgPSBzZWxmLmNhbGxGaWx0ZXJzKCd0ZXN0UmVzdWx0RXZhbHVhdGVIaWRlU2hvdycsIHRlc3RSZXN1bHQsIGFyZ3MpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVFdmFsdWF0ZUhpZGVTaG93JywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGZpbHRlcmVkVGVzdFJlc3VsdCA9PT0gdHJ1ZSAmJiBhY3Rpb24gPT09ICdzaG93JyB8fFxuICAgICAgICAgICAgICAgIGZpbHRlcmVkVGVzdFJlc3VsdCA9PT0gZmFsc2UgJiYgYWN0aW9uID09PSAnaGlkZSdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zaG93LnB1c2godGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgICF0YXJnZXQuaXNTaG93biAmJiBvcGVyYXRpb24udG9TaG93LnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLmhpZGUucHVzaCh0YXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmlzU2hvd24gJiYgb3BlcmF0aW9uLnRvSGlkZS5wdXNoKHRhcmdldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyRXZhbHVhdGVIaWRlU2hvdycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7T3BlcmF0aW9ufSAgICAgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBzb3J0T3BlcmF0aW9uOiBmdW5jdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgbmV3T3JkZXIgPSBbXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgZWwgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVNvcnRPcGVyYXRpb24nLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBvcGVyYXRpb24uc3RhcnRPcmRlciA9IHNlbGYudGFyZ2V0cztcblxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5uZXdTb3J0LmNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBTb3J0IGJ5IGNvbGxlY3Rpb25cblxuICAgICAgICAgICAgICAgIG5ld09yZGVyID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyAoZWwgPSBvcGVyYXRpb24ubmV3U29ydC5jb2xsZWN0aW9uW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmRvbS50YXJnZXRzLmluZGV4T2YoZWwpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1peGl0dXAubWVzc2FnZXMuZXJyb3JTb3J0Tm9uRXhpc3RlbnRFbGVtZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gbmV3IG1peGl0dXAuVGFyZ2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmluaXQoZWwsIHNlbGYpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5pc0luRG9tID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBuZXdPcmRlci5wdXNoKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLm5ld09yZGVyID0gbmV3T3JkZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5uZXdTb3J0Lm9yZGVyID09PSAncmFuZG9tJykge1xuICAgICAgICAgICAgICAgIC8vIFNvcnQgcmFuZG9tXG5cbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmV3T3JkZXIgPSBoLmFycmF5U2h1ZmZsZShvcGVyYXRpb24uc3RhcnRPcmRlcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5uZXdTb3J0LmF0dHJpYnV0ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyBTb3J0IGJ5IGRlZmF1bHRcblxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdPcmRlciA9IHNlbGYub3JpZ09yZGVyLnNsaWNlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLm5ld1NvcnQub3JkZXIgPT09ICdkZXNjJykge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmV3T3JkZXIucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU29ydCBieSBhdHRyaWJ1dGVcblxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdPcmRlciA9IG9wZXJhdGlvbi5zdGFydE9yZGVyLnNsaWNlKCk7XG5cbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmV3T3JkZXIuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbXBhcmUoYSwgYiwgb3BlcmF0aW9uLm5ld1NvcnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaC5pc0VxdWFsQXJyYXkob3BlcmF0aW9uLm5ld09yZGVyLCBvcGVyYXRpb24uc3RhcnRPcmRlcikpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ud2lsbFNvcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJTb3J0T3BlcmF0aW9uJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHttaXhpdHVwLlRhcmdldH0gICAgICAgIGFcbiAgICAgICAgICogQHBhcmFtICAge21peGl0dXAuVGFyZ2V0fSAgICAgICAgYlxuICAgICAgICAgKiBAcGFyYW0gICB7bWl4aXR1cC5Db21tYW5kU29ydH0gICBjb21tYW5kXG4gICAgICAgICAqIEByZXR1cm4gIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGEsIGIsIGNvbW1hbmQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgb3JkZXIgICAgICAgPSBjb21tYW5kLm9yZGVyLFxuICAgICAgICAgICAgICAgIGF0dHJBICAgICAgID0gc2VsZi5nZXRBdHRyaWJ1dGVWYWx1ZShhLCBjb21tYW5kLmF0dHJpYnV0ZSksXG4gICAgICAgICAgICAgICAgYXR0ckIgICAgICAgPSBzZWxmLmdldEF0dHJpYnV0ZVZhbHVlKGIsIGNvbW1hbmQuYXR0cmlidXRlKTtcblxuICAgICAgICAgICAgaWYgKGlzTmFOKGF0dHJBICogMSkgfHwgaXNOYU4oYXR0ckIgKiAxKSkge1xuICAgICAgICAgICAgICAgIGF0dHJBID0gYXR0ckEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBhdHRyQiA9IGF0dHJCLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJBID0gYXR0ckEgKiAxO1xuICAgICAgICAgICAgICAgIGF0dHJCID0gYXR0ckIgKiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXR0ckEgPCBhdHRyQikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmRlciA9PT0gJ2FzYycgPyAtMSA6IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhdHRyQSA+IGF0dHJCKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yZGVyID09PSAnYXNjJyA/IDEgOiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF0dHJBID09PSBhdHRyQiAmJiBjb21tYW5kLm5leHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jb21wYXJlKGEsIGIsIGNvbW1hbmQubmV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkcyB0aGUgdmFsdWVzIG9mIGFueSBkYXRhIGF0dHJpYnV0ZXMgcHJlc2VudCB0aGUgcHJvdmlkZWQgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICogd2hpY2ggbWF0Y2ggdGhlIGN1cnJlbnQgc29ydCBjb21tYW5kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge21peGl0dXAuVGFyZ2V0fSAgICB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgICAgICBbYXR0cmlidXRlXVxuICAgICAgICAgKiBAcmV0dXJuICB7KFN0cmluZ3xOdW1iZXIpfVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXRBdHRyaWJ1dGVWYWx1ZTogZnVuY3Rpb24odGFyZ2V0LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgID0gJyc7XG5cbiAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0LmRvbS5lbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5kZWJ1Zy5zaG93V2FybmluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb3VyYWdlIHVzZXJzIHRvIGFzc2lnbiB2YWx1ZXMgdG8gYWxsIHRhcmdldHMgdG8gYXZvaWQgZXJyb25lb3VzIHNvcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0eXBlcyBhcmUgbWl4ZWRcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obWl4aXR1cC5tZXNzYWdlcy53YXJuaW5nSW5jb25zaXN0ZW50U29ydGluZ0F0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiAnZGF0YS0nICsgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGFuIGF0dHJpYnV0ZSBpcyBub3QgcHJlc2VudCwgcmV0dXJuIDAgYXMgYSBzYWZldHkgdmFsdWVcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ3ZhbHVlR2V0QXR0cmlidXRlVmFsdWUnLCB2YWx1ZSB8fCAwLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIGVsZW1lbnRzIGludG8gdGhlIERPTSBpbiB0aGUgYXBwcm9wcmlhdGVcbiAgICAgICAgICogb3JkZXIgdXNpbmcgYSBkb2N1bWVudCBmcmFnbWVudCBmb3IgbWluaW1hbFxuICAgICAgICAgKiBET00gdGhyYXNoaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gICBpc1Jlc2V0dGluZ1xuICAgICAgICAgKiBAcGFyYW0gICB7T3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHByaW50U29ydDogZnVuY3Rpb24oaXNSZXNldHRpbmcsIG9wZXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzdGFydE9yZGVyICA9IGlzUmVzZXR0aW5nID8gb3BlcmF0aW9uLm5ld09yZGVyIDogb3BlcmF0aW9uLnN0YXJ0T3JkZXIsXG4gICAgICAgICAgICAgICAgbmV3T3JkZXIgICAgPSBpc1Jlc2V0dGluZyA/IG9wZXJhdGlvbi5zdGFydE9yZGVyIDogb3BlcmF0aW9uLm5ld09yZGVyLFxuICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nID0gc3RhcnRPcmRlci5sZW5ndGggPyBzdGFydE9yZGVyW3N0YXJ0T3JkZXIubGVuZ3RoIC0gMV0uZG9tLmVsLm5leHRFbGVtZW50U2libGluZyA6IG51bGwsXG4gICAgICAgICAgICAgICAgZnJhZyAgICAgICAgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgID0gbnVsbCxcbiAgICAgICAgICAgICAgICB0YXJnZXQgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgZWwgICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVByaW50U29ydCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIC8vIEVtcHR5IHRoZSBjb250YWluZXJcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gc3RhcnRPcmRlcltpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZWwgPSB0YXJnZXQuZG9tLmVsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsLnN0eWxlLnBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGgucmVtb3ZlV2hpdGVzcGFjZShlbC5wcmV2aW91c1NpYmxpbmcpO1xuXG4gICAgICAgICAgICAgICAgZWwucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaXRlc3BhY2UgPSBuZXh0U2libGluZyA/IG5leHRTaWJsaW5nLnByZXZpb3VzU2libGluZyA6IHNlbGYuZG9tLnBhcmVudC5sYXN0Q2hpbGQ7XG5cbiAgICAgICAgICAgIGlmICh3aGl0ZXNwYWNlICYmIHdoaXRlc3BhY2Uubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICBoLnJlbW92ZVdoaXRlc3BhY2Uod2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHRhcmdldCA9IG5ld09yZGVyW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGFyZ2V0cyBpbnRvIGEgZG9jdW1lbnQgZnJhZ21lbnRcblxuICAgICAgICAgICAgICAgIGVsID0gdGFyZ2V0LmRvbS5lbDtcblxuICAgICAgICAgICAgICAgIGlmIChoLmlzRWxlbWVudChmcmFnLmxhc3RDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZCh3aW5kb3cuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgZG9jdW1lbnQgZnJhZ21lbnQgaW50byB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICAvLyBiZWZvcmUgYW55IG90aGVyIG5vbi10YXJnZXQgZWxlbWVudHNcblxuICAgICAgICAgICAgaWYgKHNlbGYuZG9tLnBhcmVudC5maXJzdENoaWxkICYmIHNlbGYuZG9tLnBhcmVudC5maXJzdENoaWxkICE9PSBuZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIGZyYWcuaW5zZXJ0QmVmb3JlKHdpbmRvdy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnICcpLCBmcmFnLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKHdpbmRvdy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnICcpKTtcblxuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5pbnNlcnRCZWZvcmUoZnJhZywgbmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuYXBwZW5kQ2hpbGQoZnJhZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyUHJpbnRTb3J0JywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIHVzZXItZGVmaW5lZCBzb3J0IHN0cmluZ3MgKGkuZS4gYGRlZmF1bHQ6YXNjYCkgaW50byBzb3J0IGNvbW1hbmRzIG9iamVjdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICAgICAgICAgICAgICBzb3J0U3RyaW5nXG4gICAgICAgICAqIEBwYXJhbSAgIHttaXhpdHVwLkNvbW1hbmRTb3J0fSAgIGNvbW1hbmRcbiAgICAgICAgICogQHJldHVybiAge21peGl0dXAuQ29tbWFuZFNvcnR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHBhcnNlU29ydFN0cmluZzogZnVuY3Rpb24oc29ydFN0cmluZywgY29tbWFuZCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBydWxlcyAgICAgICA9IHNvcnRTdHJpbmcuc3BsaXQoJyAnKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50ICAgICA9IGNvbW1hbmQsXG4gICAgICAgICAgICAgICAgcnVsZSAgICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICAvLyBjb21tYW5kLnNvcnRTdHJpbmcgPSBzb3J0U3RyaW5nO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBydWxlID0gcnVsZXNbaV0uc3BsaXQoJzonKTtcblxuICAgICAgICAgICAgICAgIGN1cnJlbnQuc29ydFN0cmluZyAgPSBydWxlc1tpXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmF0dHJpYnV0ZSAgID0gaC5kYXNoQ2FzZShydWxlWzBdKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm9yZGVyICAgICAgID0gcnVsZVsxXSB8fCAnYXNjJztcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY3VycmVudC5hdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVmYXVsdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmVhdCBcImRlZmF1bHRcIiBhcyBzb3J0aW5nIGJ5IG5vIGF0dHJpYnV0ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmF0dHJpYnV0ZSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFuZG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyZWF0IFwicmFuZG9tXCIgYXMgYW4gb3JkZXIgbm90IGFuIGF0dHJpYnV0ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmF0dHJpYnV0ZSAgID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm9yZGVyICAgICAgID0gJ3JhbmRvbSc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudC5hdHRyaWJ1dGUgfHwgY3VycmVudC5vcmRlciA9PT0gJ3JhbmRvbScpIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPCBydWxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVtYmVkIHJlZmVyZW5jZSB0byB0aGUgbmV4dCBjb21tYW5kXG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5uZXh0ID0gbmV3IG1peGl0dXAuQ29tbWFuZFNvcnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBoLmZyZWV6ZShjdXJyZW50KTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ2NvbW1hbmRzUGFyc2VTb3J0JywgY29tbWFuZCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VzIGFsbCBlZmZlY3RzIG91dCBvZiB0aGUgdXNlci1kZWZpbmVkIGBhbmltYXRpb24uZWZmZWN0c2Agc3RyaW5nIGludG9cbiAgICAgICAgICogdGhlaXIgcmVzcGVjdGl2ZSBwcm9wZXJ0aWVzIGFuZCB1bml0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBwYXJzZUVmZmVjdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtTmFtZSAgID0gJycsXG4gICAgICAgICAgICAgICAgZWZmZWN0c0luICAgICAgID0gc2VsZi5jb25maWcuYW5pbWF0aW9uLmVmZmVjdHNJbiB8fCBzZWxmLmNvbmZpZy5hbmltYXRpb24uZWZmZWN0cyxcbiAgICAgICAgICAgICAgICBlZmZlY3RzT3V0ICAgICAgPSBzZWxmLmNvbmZpZy5hbmltYXRpb24uZWZmZWN0c091dCB8fCBzZWxmLmNvbmZpZy5hbmltYXRpb24uZWZmZWN0cztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlUGFyc2VFZmZlY3RzJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5lZmZlY3RzSW4gICAgICA9IG5ldyBtaXhpdHVwLlN0eWxlRGF0YSgpO1xuICAgICAgICAgICAgc2VsZi5lZmZlY3RzT3V0ICAgICA9IG5ldyBtaXhpdHVwLlN0eWxlRGF0YSgpO1xuICAgICAgICAgICAgc2VsZi50cmFuc2Zvcm1JbiAgICA9IFtdO1xuICAgICAgICAgICAgc2VsZi50cmFuc2Zvcm1PdXQgICA9IFtdO1xuXG4gICAgICAgICAgICBzZWxmLmVmZmVjdHNJbi5vcGFjaXR5ID0gc2VsZi5lZmZlY3RzT3V0Lm9wYWNpdHkgPSAxO1xuXG4gICAgICAgICAgICBzZWxmLnBhcnNlRWZmZWN0KCdmYWRlJywgZWZmZWN0c0luLCBzZWxmLmVmZmVjdHNJbiwgc2VsZi50cmFuc2Zvcm1Jbik7XG4gICAgICAgICAgICBzZWxmLnBhcnNlRWZmZWN0KCdmYWRlJywgZWZmZWN0c091dCwgc2VsZi5lZmZlY3RzT3V0LCBzZWxmLnRyYW5zZm9ybU91dCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGZvciAodHJhbnNmb3JtTmFtZSBpbiBtaXhpdHVwLnRyYW5zZm9ybURlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWl4aXR1cC50cmFuc2Zvcm1EZWZhdWx0c1t0cmFuc2Zvcm1OYW1lXSBpbnN0YW5jZW9mIG1peGl0dXAuVHJhbnNmb3JtRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5wYXJzZUVmZmVjdCh0cmFuc2Zvcm1OYW1lLCBlZmZlY3RzSW4sIHNlbGYuZWZmZWN0c0luLCBzZWxmLnRyYW5zZm9ybUluKTtcbiAgICAgICAgICAgICAgICBzZWxmLnBhcnNlRWZmZWN0KHRyYW5zZm9ybU5hbWUsIGVmZmVjdHNPdXQsIHNlbGYuZWZmZWN0c091dCwgc2VsZi50cmFuc2Zvcm1PdXQsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnBhcnNlRWZmZWN0KCdzdGFnZ2VyJywgZWZmZWN0c0luLCBzZWxmLmVmZmVjdHNJbiwgc2VsZi50cmFuc2Zvcm1Jbik7XG4gICAgICAgICAgICBzZWxmLnBhcnNlRWZmZWN0KCdzdGFnZ2VyJywgZWZmZWN0c091dCwgc2VsZi5lZmZlY3RzT3V0LCBzZWxmLnRyYW5zZm9ybU91dCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyUGFyc2VFZmZlY3RzJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIGVmZmVjdE5hbWVcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgZWZmZWN0U3RyaW5nXG4gICAgICAgICAqIEBwYXJhbSAgIHtTdHlsZURhdGF9IGVmZmVjdHNcbiAgICAgICAgICogQHBhcmFtICAge1N0cmluZ1tdfSAgdHJhbnNmb3JtXG4gICAgICAgICAqIEBwYXJhbSAgIHtib29sZWFufSAgIFtpc091dF1cbiAgICAgICAgICovXG5cbiAgICAgICAgcGFyc2VFZmZlY3Q6IGZ1bmN0aW9uKGVmZmVjdE5hbWUsIGVmZmVjdFN0cmluZywgZWZmZWN0cywgdHJhbnNmb3JtLCBpc091dCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICByZSAgICAgICAgICA9IC9cXCgoW14pXSspXFwpLyxcbiAgICAgICAgICAgICAgICBwcm9wSW5kZXggICA9IC0xLFxuICAgICAgICAgICAgICAgIHN0ciAgICAgICAgID0gJycsXG4gICAgICAgICAgICAgICAgbWF0Y2ggICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICB2YWwgICAgICAgICA9ICcnLFxuICAgICAgICAgICAgICAgIHVuaXRzICAgICAgID0gWyclJywgJ3B4JywgJ2VtJywgJ3JlbScsICd2aCcsICd2dycsICdkZWcnXSxcbiAgICAgICAgICAgICAgICB1bml0ICAgICAgICA9ICcnLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVBhcnNlRWZmZWN0JywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3RTdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtaXhpdHVwLm1lc3NhZ2VzLmVycm9yQ29uZmlnSW52YWxpZEFuaW1hdGlvbkVmZmVjdHMoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlZmZlY3RTdHJpbmcuaW5kZXhPZihlZmZlY3ROYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZWZmZWN0IGlzIG5vdCBwcmVzZW50IGluIHRoZSBlZmZlY3RzIHN0cmluZ1xuXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdE5hbWUgPT09ICdzdGFnZ2VyJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBzdGFnZ2VyIHRvIDBcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YWdnZXJEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgZWZmZWN0IGlzIHByZXNlbnRcblxuICAgICAgICAgICAgcHJvcEluZGV4ID0gZWZmZWN0U3RyaW5nLmluZGV4T2YoZWZmZWN0TmFtZSArICcoJyk7XG5cbiAgICAgICAgICAgIGlmIChwcm9wSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBlZmZlY3QgaGFzIGEgdXNlciBkZWZpbmVkIHZhbHVlIGluIHBhcmVudGhlc2VzXG5cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZpcnN0IHBhcmVudGhlc2lzIHRvIHRoZSBlbmQgb2Ygc3RyaW5nXG5cbiAgICAgICAgICAgICAgICBzdHIgPSBlZmZlY3RTdHJpbmcuc3Vic3RyaW5nKHByb3BJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAvLyBNYXRjaCBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMgYmV0d2VlbiBcIihcIiBhbmQgXCIpXCJcblxuICAgICAgICAgICAgICAgIG1hdGNoID0gcmUuZXhlYyhzdHIpO1xuXG4gICAgICAgICAgICAgICAgdmFsID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAoZWZmZWN0TmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhZGUnOlxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzLm9wYWNpdHkgPSB2YWwgPyBwYXJzZUZsb2F0KHZhbCkgOiAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YWdnZXInOlxuICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YWdnZXJEdXJhdGlvbiA9IHZhbCA/IHBhcnNlRmxvYXQodmFsKSA6IDEwMDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBDdXJyZW50bHkgc3RhZ2dlciBtdXN0IGJlIGFwcGxpZWQgZ2xvYmFsbHksIGJ1dFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBzZXBlcmF0ZSB2YWx1ZXMgYXJlIHNwZWNpZmllZCBmb3IgaW4vb3V0LCB0aGlzIHNob3VsZFxuICAgICAgICAgICAgICAgICAgICAvLyBiZSByZXNwZWN0ZWRcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBBbGwgb3RoZXIgZWZmZWN0cyBhcmUgdHJhbnNmb3JtcyBmb2xsb3dpbmcgdGhlIHNhbWUgc3RydWN0dXJlXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT3V0ICYmIHNlbGYuY29uZmlnLmFuaW1hdGlvbi5yZXZlcnNlT3V0ICYmIGVmZmVjdE5hbWUgIT09ICdzY2FsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdHNbZWZmZWN0TmFtZV0udmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh2YWwgPyBwYXJzZUZsb2F0KHZhbCkgOiBtaXhpdHVwLnRyYW5zZm9ybURlZmF1bHRzW2VmZmVjdE5hbWVdLnZhbHVlKSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0c1tlZmZlY3ROYW1lXS52YWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbCA/IHBhcnNlRmxvYXQodmFsKSA6IG1peGl0dXAudHJhbnNmb3JtRGVmYXVsdHNbZWZmZWN0TmFtZV0udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgdW5pdCA9IHVuaXRzW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsLmluZGV4T2YodW5pdCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3RzW2VmZmVjdE5hbWVdLnVuaXQgPSB1bml0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdHNbZWZmZWN0TmFtZV0udW5pdCA9IG1peGl0dXAudHJhbnNmb3JtRGVmYXVsdHNbZWZmZWN0TmFtZV0udW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0TmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0c1tlZmZlY3ROYW1lXS52YWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3RzW2VmZmVjdE5hbWVdLnVuaXQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyUGFyc2VFZmZlY3QnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAge09wZXJhdGlvbn0gICAgIG9wZXJhdGlvblxuICAgICAgICAgKiBAcmV0dXJuICB7U3RhdGV9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGJ1aWxkU3RhdGU6IGZ1bmN0aW9uKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzdGF0ZSAgICAgICA9IG5ldyBtaXhpdHVwLlN0YXRlKCksXG4gICAgICAgICAgICAgICAgdGFyZ2V0ICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZUJ1aWxkU3RhdGUnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAvLyBNYXAgdGFyZ2V0IGVsZW1lbnRzIGludG8gc3RhdGUgYXJyYXlzLlxuICAgICAgICAgICAgLy8gdGhlIHJlYWwgdGFyZ2V0IG9iamVjdHMgc2hvdWxkIG5ldmVyIGJlIGV4cG9zZWRcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gc2VsZi50YXJnZXRzW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wZXJhdGlvbi50b1JlbW92ZS5sZW5ndGggfHwgb3BlcmF0aW9uLnRvUmVtb3ZlLmluZGV4T2YodGFyZ2V0KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudGFyZ2V0cy5wdXNoKHRhcmdldC5kb20uZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gb3BlcmF0aW9uLm1hdGNoaW5nW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5tYXRjaGluZy5wdXNoKHRhcmdldC5kb20uZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24uc2hvd1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuc2hvdy5wdXNoKHRhcmdldC5kb20uZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24uaGlkZVtpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcGVyYXRpb24udG9SZW1vdmUubGVuZ3RoIHx8IG9wZXJhdGlvbi50b1JlbW92ZS5pbmRleE9mKHRhcmdldCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmhpZGUucHVzaCh0YXJnZXQuZG9tLmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLmlkICAgICAgICAgICAgICAgICAgICAgICAgPSBzZWxmLmlkO1xuICAgICAgICAgICAgc3RhdGUuY29udGFpbmVyICAgICAgICAgICAgICAgICA9IHNlbGYuZG9tLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIHN0YXRlLmFjdGl2ZUZpbHRlciAgICAgICAgICAgICAgPSBvcGVyYXRpb24ubmV3RmlsdGVyO1xuICAgICAgICAgICAgc3RhdGUuYWN0aXZlU29ydCAgICAgICAgICAgICAgICA9IG9wZXJhdGlvbi5uZXdTb3J0O1xuICAgICAgICAgICAgc3RhdGUuYWN0aXZlRGF0YXNldCAgICAgICAgICAgICA9IG9wZXJhdGlvbi5uZXdEYXRhc2V0O1xuICAgICAgICAgICAgc3RhdGUuYWN0aXZlQ29udGFpbmVyQ2xhc3NOYW1lICA9IG9wZXJhdGlvbi5uZXdDb250YWluZXJDbGFzc05hbWU7XG4gICAgICAgICAgICBzdGF0ZS5oYXNGYWlsZWQgICAgICAgICAgICAgICAgID0gb3BlcmF0aW9uLmhhc0ZhaWxlZDtcbiAgICAgICAgICAgIHN0YXRlLnRvdGFsVGFyZ2V0cyAgICAgICAgICAgICAgPSBzZWxmLnRhcmdldHMubGVuZ3RoO1xuICAgICAgICAgICAgc3RhdGUudG90YWxTaG93ICAgICAgICAgICAgICAgICA9IG9wZXJhdGlvbi5zaG93Lmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXRlLnRvdGFsSGlkZSAgICAgICAgICAgICAgICAgPSBvcGVyYXRpb24uaGlkZS5sZW5ndGg7XG4gICAgICAgICAgICBzdGF0ZS50b3RhbE1hdGNoaW5nICAgICAgICAgICAgID0gb3BlcmF0aW9uLm1hdGNoaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXRlLnRyaWdnZXJFbGVtZW50ICAgICAgICAgICAgPSBvcGVyYXRpb24udHJpZ2dlckVsZW1lbnQ7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxGaWx0ZXJzKCdzdGF0ZUJ1aWxkU3RhdGUnLCBzdGF0ZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtib29sZWFufSAgIHNob3VsZEFuaW1hdGVcbiAgICAgICAgICogQHBhcmFtICAge09wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBnb01peDogZnVuY3Rpb24oc2hvdWxkQW5pbWF0ZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRlZmVycmVkICAgID0gbnVsbDtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlR29NaXgnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIGlzIHNldCB0byAwbXMsXG4gICAgICAgICAgICAvLyBvciBubyBlZmZlY3RzIHNwZWNpZmllZCxcbiAgICAgICAgICAgIC8vIG9yIHRoZSBjb250YWluZXIgaXMgaGlkZGVuXG4gICAgICAgICAgICAvLyB0aGVuIGFib3J0IGFuaW1hdGlvblxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmFuaW1hdGlvbi5kdXJhdGlvbiB8fCAhc2VsZi5jb25maWcuYW5pbWF0aW9uLmVmZmVjdHMgfHwgIWguaXNWaXNpYmxlKHNlbGYuZG9tLmNvbnRhaW5lcilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNob3VsZEFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFvcGVyYXRpb24udG9TaG93Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICFvcGVyYXRpb24udG9IaWRlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICFvcGVyYXRpb24ud2lsbFNvcnQgJiZcbiAgICAgICAgICAgICAgICAhb3BlcmF0aW9uLndpbGxDaGFuZ2VMYXlvdXRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vdGhpbmcgdG8gc2hvdyBvciBoaWRlLCBhbmQgbm90IHNvcnRpbmcgb3JcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2luZyBsYXlvdXRcblxuICAgICAgICAgICAgICAgIHNob3VsZEFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFvcGVyYXRpb24uc3RhcnRTdGF0ZS5zaG93Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICFvcGVyYXRpb24uc2hvdy5sZW5ndGhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vdGhpbmcgY3VycmVudGx5IHNob3duLCBub3RoaW5nIHRvIHNob3dcblxuICAgICAgICAgICAgICAgIHNob3VsZEFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWl4aXR1cC5ldmVudHMuZmlyZSgnbWl4U3RhcnQnLCBzZWxmLmRvbS5jb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogb3BlcmF0aW9uLnN0YXJ0U3RhdGUsXG4gICAgICAgICAgICAgICAgZnV0dXJlU3RhdGU6IG9wZXJhdGlvbi5uZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogc2VsZlxuICAgICAgICAgICAgfSwgc2VsZi5kb20uZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYuY29uZmlnLmNhbGxiYWNrcy5vbk1peFN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuY2FsbGJhY2tzLm9uTWl4U3RhcnQuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kb20uY29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24uc3RhcnRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLm5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICBzZWxmXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaC5yZW1vdmVDbGFzcyhzZWxmLmRvbS5jb250YWluZXIsIGguZ2V0Q2xhc3NuYW1lKHNlbGYuY29uZmlnLmNsYXNzTmFtZXMsICdjb250YWluZXInLCBzZWxmLmNvbmZpZy5jbGFzc05hbWVzLm1vZGlmaWVyRmFpbGVkKSk7XG5cbiAgICAgICAgICAgIGlmICghc2VsZi51c2VyRGVmZXJyZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBRdWV1ZSBlbXB0eSwgbm8gcGVuZGluZyBvcGVyYXRpb25zXG5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZCA9IHNlbGYudXNlckRlZmVycmVkID0gaC5kZWZlcihtaXhpdHVwLmxpYnJhcmllcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBleGlzdGluZyBkZWZlcnJlZFxuXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSBzZWxmLnVzZXJEZWZlcnJlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5pc0J1c3kgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIXNob3VsZEFuaW1hdGUgfHwgIW1peGl0dXAuZmVhdHVyZXMuaGFzLnRyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gQWJvcnRcblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5kZWJ1Zy5mYXV4QXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYW5VcChvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9LCBzZWxmLmNvbmZpZy5hbmltYXRpb24uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYW5VcChvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxGaWx0ZXJzKCdwcm9taXNlR29NaXgnLCBkZWZlcnJlZC5wcm9taXNlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB3ZSBzaG91bGQgYW5pbWF0ZSBhbmQgdGhlIHBsYXRmb3JtIHN1cHBvcnRzIHRyYW5zaXRpb25zLCBnbyBmb3IgaXRcblxuICAgICAgICAgICAgaWYgKHdpbmRvdy5wYWdlWU9mZnNldCAhPT0gb3BlcmF0aW9uLmRvY1N0YXRlLnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyhvcGVyYXRpb24uZG9jU3RhdGUuc2Nyb2xsTGVmdCwgb3BlcmF0aW9uLmRvY1N0YXRlLnNjcm9sbFRvcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hbmltYXRpb24uYXBwbHlQZXJzcGVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZVttaXhpdHVwLmZlYXR1cmVzLnBlcnNwZWN0aXZlUHJvcF0gPVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hbmltYXRpb24ucGVyc3BlY3RpdmVEaXN0YW5jZTtcblxuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZVttaXhpdHVwLmZlYXR1cmVzLnBlcnNwZWN0aXZlT3JpZ2luUHJvcF0gPVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hbmltYXRpb24ucGVyc3BlY3RpdmVPcmlnaW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hbmltYXRpb24uYW5pbWF0ZVJlc2l6ZUNvbnRhaW5lciAmJlxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydEhlaWdodCAhPT0gb3BlcmF0aW9uLm5ld0hlaWdodCAmJlxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi52aWV3cG9ydERlbHRhWSAhPT0gb3BlcmF0aW9uLnN0YXJ0SGVpZ2h0IC0gb3BlcmF0aW9uLm5ld0hlaWdodFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlLmhlaWdodCA9IG9wZXJhdGlvbi5zdGFydEhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hbmltYXRpb24uYW5pbWF0ZVJlc2l6ZUNvbnRhaW5lciAmJlxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydFdpZHRoICE9PSBvcGVyYXRpb24ubmV3V2lkdGggJiZcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24udmlld3BvcnREZWx0YVggIT09IG9wZXJhdGlvbi5zdGFydFdpZHRoIC0gb3BlcmF0aW9uLm5ld1dpZHRoXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuc3R5bGUud2lkdGggPSBvcGVyYXRpb24uc3RhcnRXaWR0aCArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24uc3RhcnRIZWlnaHQgPT09IG9wZXJhdGlvbi5uZXdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuc3R5bGUuaGVpZ2h0ID0gb3BlcmF0aW9uLnN0YXJ0SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5zdGFydFdpZHRoID09PSBvcGVyYXRpb24ubmV3V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuc3R5bGUud2lkdGggPSBvcGVyYXRpb24uc3RhcnRXaWR0aCArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24uc3RhcnRIZWlnaHQgPT09IG9wZXJhdGlvbi5uZXdIZWlnaHQgJiYgb3BlcmF0aW9uLnN0YXJ0V2lkdGggPT09IG9wZXJhdGlvbi5uZXdXaWR0aCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb3ZlVGFyZ2V0cyhvcGVyYXRpb24pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxGaWx0ZXJzKCdwcm9taXNlR29NaXgnLCBkZWZlcnJlZC5wcm9taXNlLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAge09wZXJhdGlvbn0gICAgIG9wZXJhdGlvblxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0U3RhcnRNaXhEYXRhOiBmdW5jdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcGFyZW50U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzZWxmLmRvbS5wYXJlbnQpLFxuICAgICAgICAgICAgICAgIHBhcmVudFJlY3QgID0gc2VsZi5kb20ucGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBkYXRhICAgICAgICA9IHt9LFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTEsXG4gICAgICAgICAgICAgICAgYm94U2l6aW5nICAgPSBwYXJlbnRTdHlsZVttaXhpdHVwLmZlYXR1cmVzLmJveFNpemluZ1Byb3BdO1xuXG4gICAgICAgICAgICBzZWxmLmluY1BhZGRpbmcgPSAoYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVHZXRTdGFydE1peERhdGEnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24uc2hvd1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRhcmdldC5nZXRQb3NEYXRhKCk7XG5cbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uc2hvd1Bvc0RhdGFbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zRGF0YTogZGF0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHRhcmdldCA9IG9wZXJhdGlvbi50b0hpZGVbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0YXJnZXQuZ2V0UG9zRGF0YSgpO1xuXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnRvSGlkZVBvc0RhdGFbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zRGF0YTogZGF0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydFggPSBwYXJlbnRSZWN0LmxlZnQ7XG4gICAgICAgICAgICBvcGVyYXRpb24uc3RhcnRZID0gcGFyZW50UmVjdC50b3A7XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydEhlaWdodCA9IHNlbGYuaW5jUGFkZGluZyA/XG4gICAgICAgICAgICAgICAgcGFyZW50UmVjdC5oZWlnaHQgOlxuICAgICAgICAgICAgICAgIHBhcmVudFJlY3QuaGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChwYXJlbnRTdHlsZS5wYWRkaW5nVG9wKSAtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQocGFyZW50U3R5bGUucGFkZGluZ0JvdHRvbSkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHBhcmVudFN0eWxlLmJvcmRlclRvcCkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHBhcmVudFN0eWxlLmJvcmRlckJvdHRvbSk7XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydFdpZHRoID0gc2VsZi5pbmNQYWRkaW5nID9cbiAgICAgICAgICAgICAgICBwYXJlbnRSZWN0LndpZHRoIDpcbiAgICAgICAgICAgICAgICBwYXJlbnRSZWN0LndpZHRoIC1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChwYXJlbnRTdHlsZS5wYWRkaW5nTGVmdCkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHBhcmVudFN0eWxlLnBhZGRpbmdSaWdodCkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHBhcmVudFN0eWxlLmJvcmRlckxlZnQpIC1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChwYXJlbnRTdHlsZS5ib3JkZXJSaWdodCk7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyR2V0U3RhcnRNaXhEYXRhJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtPcGVyYXRpb259ICAgICBvcGVyYXRpb25cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHNldEludGVyOiBmdW5jdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB0YXJnZXQgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVNldEludGVyJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gUHJldmVudCBzY3JvbGxiYXIgZmxpY2tlciBvbiBub24taW5lcnRpYWwgc2Nyb2xsIHBsYXRmb3JtcyBieSBjbGFtcGluZyBoZWlnaHQvd2lkdGhcblxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFuaW1hdGlvbi5jbGFtcEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZS5oZWlnaHQgICAgPSBvcGVyYXRpb24uc3RhcnRIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZS5vdmVyZmxvdyAgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFuaW1hdGlvbi5jbGFtcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlLndpZHRoICAgICA9IG9wZXJhdGlvbi5zdGFydFdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuc3R5bGUub3ZlcmZsb3cgID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHRhcmdldCA9IG9wZXJhdGlvbi50b1Nob3dbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zaG93KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ud2lsbENoYW5nZUxheW91dCkge1xuICAgICAgICAgICAgICAgIGgucmVtb3ZlQ2xhc3Moc2VsZi5kb20uY29udGFpbmVyLCBvcGVyYXRpb24uc3RhcnRDb250YWluZXJDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIGguYWRkQ2xhc3Moc2VsZi5kb20uY29udGFpbmVyLCBvcGVyYXRpb24ubmV3Q29udGFpbmVyQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJTZXRJbnRlcicsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7T3BlcmF0aW9ufSAgICAgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXRJbnRlck1peERhdGE6IGZ1bmN0aW9uKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlR2V0SW50ZXJNaXhEYXRhJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gb3BlcmF0aW9uLnNob3dbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zaG93UG9zRGF0YVtpXS5pbnRlclBvc0RhdGEgPSB0YXJnZXQuZ2V0UG9zRGF0YSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24udG9IaWRlW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24udG9IaWRlUG9zRGF0YVtpXS5pbnRlclBvc0RhdGEgPSB0YXJnZXQuZ2V0UG9zRGF0YSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckdldEludGVyTWl4RGF0YScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7T3BlcmF0aW9ufSAgICAgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBzZXRGaW5hbDogZnVuY3Rpb24ob3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdGFyZ2V0ICA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVTZXRGaW5hbCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi53aWxsU29ydCAmJiBzZWxmLnByaW50U29ydChmYWxzZSwgb3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gb3BlcmF0aW9uLnRvSGlkZVtpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmhpZGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJTZXRGaW5hbCcsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7T3BlcmF0aW9ufSAgICAgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXRGaW5hbE1peERhdGE6IGZ1bmN0aW9uKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBwYXJlbnRTdHlsZSA9IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyZW50UmVjdCAgPSBudWxsLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVHZXRGaW5hbE1peERhdGEnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24uc2hvd1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnNob3dQb3NEYXRhW2ldLmZpbmFsUG9zRGF0YSA9IHRhcmdldC5nZXRQb3NEYXRhKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHRhcmdldCA9IG9wZXJhdGlvbi50b0hpZGVbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi50b0hpZGVQb3NEYXRhW2ldLmZpbmFsUG9zRGF0YSA9IHRhcmdldC5nZXRQb3NEYXRhKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBjbGFtcGluZ1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuYW5pbWF0aW9uLmNsYW1wSGVpZ2h0IHx8IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5jbGFtcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlLmhlaWdodCAgICA9XG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlLndpZHRoICAgICA9XG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlLm92ZXJmbG93ICA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNlbGYuaW5jUGFkZGluZykge1xuICAgICAgICAgICAgICAgIHBhcmVudFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc2VsZi5kb20ucGFyZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyZW50UmVjdCAgPSBzZWxmLmRvbS5wYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdYID0gcGFyZW50UmVjdC5sZWZ0O1xuICAgICAgICAgICAgb3BlcmF0aW9uLm5ld1kgPSBwYXJlbnRSZWN0LnRvcDtcblxuICAgICAgICAgICAgb3BlcmF0aW9uLm5ld0hlaWdodCA9IHNlbGYuaW5jUGFkZGluZyA/XG4gICAgICAgICAgICAgICAgcGFyZW50UmVjdC5oZWlnaHQgOlxuICAgICAgICAgICAgICAgIHBhcmVudFJlY3QuaGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChwYXJlbnRTdHlsZS5wYWRkaW5nVG9wKSAtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQocGFyZW50U3R5bGUucGFkZGluZ0JvdHRvbSkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHBhcmVudFN0eWxlLmJvcmRlclRvcCkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHBhcmVudFN0eWxlLmJvcmRlckJvdHRvbSk7XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdXaWR0aCA9IHNlbGYuaW5jUGFkZGluZyA/XG4gICAgICAgICAgICAgICAgcGFyZW50UmVjdC53aWR0aCA6XG4gICAgICAgICAgICAgICAgcGFyZW50UmVjdC53aWR0aCAtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQocGFyZW50U3R5bGUucGFkZGluZ0xlZnQpIC1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChwYXJlbnRTdHlsZS5wYWRkaW5nUmlnaHQpIC1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChwYXJlbnRTdHlsZS5ib3JkZXJMZWZ0KSAtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQocGFyZW50U3R5bGUuYm9yZGVyUmlnaHQpO1xuXG4gICAgICAgICAgICBvcGVyYXRpb24udmlld3BvcnREZWx0YVggPSBvcGVyYXRpb24uZG9jU3RhdGUudmlld3BvcnRXaWR0aCAtIHRoaXMuZG9tLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIG9wZXJhdGlvbi52aWV3cG9ydERlbHRhWSA9IG9wZXJhdGlvbi5kb2NTdGF0ZS52aWV3cG9ydEhlaWdodCAtIHRoaXMuZG9tLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ud2lsbFNvcnQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnByaW50U29ydCh0cnVlLCBvcGVyYXRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24udG9TaG93W2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaGlkZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24udG9IaWRlW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2hvdygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLndpbGxDaGFuZ2VMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICBoLnJlbW92ZUNsYXNzKHNlbGYuZG9tLmNvbnRhaW5lciwgb3BlcmF0aW9uLm5ld0NvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgaC5hZGRDbGFzcyhzZWxmLmRvbS5jb250YWluZXIsIHNlbGYuY29uZmlnLmxheW91dC5jb250YWluZXJDbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckdldEZpbmFsTWl4RGF0YScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAgIHtPcGVyYXRpb259ICAgICBvcGVyYXRpb25cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0VHdlZW5EYXRhOiBmdW5jdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgcG9zRGF0YSAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBlZmZlY3ROYW1lcyAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzZWxmLmVmZmVjdHNJbiksXG4gICAgICAgICAgICAgICAgZWZmZWN0TmFtZSAgICAgID0gJycsXG4gICAgICAgICAgICAgICAgZWZmZWN0ICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICB3aWR0aENoYW5nZSAgICAgPSAtMSxcbiAgICAgICAgICAgICAgICBoZWlnaHRDaGFuZ2UgICAgPSAtMSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgPSAtMSxcbiAgICAgICAgICAgICAgICBqICAgICAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlR2V0VHdlZW5EYXRhJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gb3BlcmF0aW9uLnNob3dbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIHBvc0RhdGEgICAgICAgICAgICAgPSBvcGVyYXRpb24uc2hvd1Bvc0RhdGFbaV07XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbiAgICAgICA9IG5ldyBtaXhpdHVwLlN0eWxlRGF0YSgpO1xuICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zT3V0ICAgICAgPSBuZXcgbWl4aXR1cC5TdHlsZURhdGEoKTtcbiAgICAgICAgICAgICAgICBwb3NEYXRhLnR3ZWVuRGF0YSAgID0gbmV3IG1peGl0dXAuU3R5bGVEYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHggYW5kIHlcblxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaXNTaG93bikge1xuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc0luLnggPSBwb3NEYXRhLnN0YXJ0UG9zRGF0YS54IC0gcG9zRGF0YS5pbnRlclBvc0RhdGEueDtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbi55ID0gcG9zRGF0YS5zdGFydFBvc0RhdGEueSAtIHBvc0RhdGEuaW50ZXJQb3NEYXRhLnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbi54ID0gcG9zRGF0YS5wb3NJbi55ID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc091dC54ID0gcG9zRGF0YS5maW5hbFBvc0RhdGEueCAtIHBvc0RhdGEuaW50ZXJQb3NEYXRhLng7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXQueSA9IHBvc0RhdGEuZmluYWxQb3NEYXRhLnkgLSBwb3NEYXRhLmludGVyUG9zRGF0YS55O1xuXG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBvcGFjaXR5XG5cbiAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc0luLm9wYWNpdHkgICAgICAgPSB0YXJnZXQuaXNTaG93biA/IDEgOiBzZWxmLmVmZmVjdHNJbi5vcGFjaXR5O1xuICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zT3V0Lm9wYWNpdHkgICAgICA9IDE7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGEub3BhY2l0eSAgID0gcG9zRGF0YS5wb3NPdXQub3BhY2l0eSAtIHBvc0RhdGEucG9zSW4ub3BhY2l0eTtcblxuICAgICAgICAgICAgICAgIC8vIEFkanVzdCB4IGFuZCB5IGlmIG5vdCBudWRnaW5nXG5cbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5pc1Nob3duICYmICFzZWxmLmNvbmZpZy5hbmltYXRpb24ubnVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbi54ID0gcG9zRGF0YS5wb3NPdXQueDtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbi55ID0gcG9zRGF0YS5wb3NPdXQueTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb3NEYXRhLnR3ZWVuRGF0YS54ID0gcG9zRGF0YS5wb3NPdXQueCAtIHBvc0RhdGEucG9zSW4ueDtcbiAgICAgICAgICAgICAgICBwb3NEYXRhLnR3ZWVuRGF0YS55ID0gcG9zRGF0YS5wb3NPdXQueSAtIHBvc0RhdGEucG9zSW4ueTtcblxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3Mgd2lkdGgsIGhlaWdodCwgYW5kIG1hcmdpbnNcblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hbmltYXRpb24uYW5pbWF0ZVJlc2l6ZVRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbi53aWR0aCAgICAgPSBwb3NEYXRhLnN0YXJ0UG9zRGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbi5oZWlnaHQgICAgPSBwb3NEYXRhLnN0YXJ0UG9zRGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gXCJ8fFwiIFByZXZlbnRzIHdpZHRoL2hlaWdodCBjaGFuZ2UgZnJvbSBpbmNsdWRpbmcgMCB3aWR0aC9oZWlnaHQgaWYgaGlkaW5nIG9yIHNob3dpbmdcblxuICAgICAgICAgICAgICAgICAgICB3aWR0aENoYW5nZSA9IChwb3NEYXRhLnN0YXJ0UG9zRGF0YS53aWR0aCB8fCBwb3NEYXRhLmZpbmFsUG9zRGF0YS53aWR0aCkgLSBwb3NEYXRhLmludGVyUG9zRGF0YS53aWR0aDtcblxuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc0luLm1hcmdpblJpZ2h0ID0gcG9zRGF0YS5zdGFydFBvc0RhdGEubWFyZ2luUmlnaHQgLSB3aWR0aENoYW5nZTtcblxuICAgICAgICAgICAgICAgICAgICBoZWlnaHRDaGFuZ2UgPSAocG9zRGF0YS5zdGFydFBvc0RhdGEuaGVpZ2h0IHx8IHBvc0RhdGEuZmluYWxQb3NEYXRhLmhlaWdodCkgLSBwb3NEYXRhLmludGVyUG9zRGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbi5tYXJnaW5Cb3R0b20gPSBwb3NEYXRhLnN0YXJ0UG9zRGF0YS5tYXJnaW5Cb3R0b20gLSBoZWlnaHRDaGFuZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXQud2lkdGggICAgPSBwb3NEYXRhLmZpbmFsUG9zRGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXQuaGVpZ2h0ICAgPSBwb3NEYXRhLmZpbmFsUG9zRGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgd2lkdGhDaGFuZ2UgPSAocG9zRGF0YS5maW5hbFBvc0RhdGEud2lkdGggfHwgcG9zRGF0YS5zdGFydFBvc0RhdGEud2lkdGgpIC0gcG9zRGF0YS5pbnRlclBvc0RhdGEud2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXQubWFyZ2luUmlnaHQgPSBwb3NEYXRhLmZpbmFsUG9zRGF0YS5tYXJnaW5SaWdodCAtIHdpZHRoQ2hhbmdlO1xuXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodENoYW5nZSA9IChwb3NEYXRhLmZpbmFsUG9zRGF0YS5oZWlnaHQgfHwgcG9zRGF0YS5zdGFydFBvc0RhdGEuaGVpZ2h0KSAtIHBvc0RhdGEuaW50ZXJQb3NEYXRhLmhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc091dC5tYXJnaW5Cb3R0b20gPSBwb3NEYXRhLmZpbmFsUG9zRGF0YS5tYXJnaW5Cb3R0b20gLSBoZWlnaHRDaGFuZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGEud2lkdGggICAgICAgICA9IHBvc0RhdGEucG9zT3V0LndpZHRoIC0gcG9zRGF0YS5wb3NJbi53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGEuaGVpZ2h0ICAgICAgICA9IHBvc0RhdGEucG9zT3V0LmhlaWdodCAtIHBvc0RhdGEucG9zSW4uaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnR3ZWVuRGF0YS5tYXJnaW5SaWdodCAgID0gcG9zRGF0YS5wb3NPdXQubWFyZ2luUmlnaHQgLSBwb3NEYXRhLnBvc0luLm1hcmdpblJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnR3ZWVuRGF0YS5tYXJnaW5Cb3R0b20gID0gcG9zRGF0YS5wb3NPdXQubWFyZ2luQm90dG9tIC0gcG9zRGF0YS5wb3NJbi5tYXJnaW5Cb3R0b207XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0cmFuc2Zvcm1zXG5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBlZmZlY3ROYW1lID0gZWZmZWN0TmFtZXNbal07IGorKykge1xuICAgICAgICAgICAgICAgICAgICBlZmZlY3QgPSBzZWxmLmVmZmVjdHNJbltlZmZlY3ROYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIShlZmZlY3QgaW5zdGFuY2VvZiBtaXhpdHVwLlRyYW5zZm9ybURhdGEpIHx8ICFlZmZlY3QudmFsdWUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zSW5bZWZmZWN0TmFtZV0udmFsdWUgICAgID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc091dFtlZmZlY3ROYW1lXS52YWx1ZSAgICA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGFbZWZmZWN0TmFtZV0udmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXRbZWZmZWN0TmFtZV0udmFsdWUgLSBwb3NEYXRhLnBvc0luW2VmZmVjdE5hbWVdLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zSW5bZWZmZWN0TmFtZV0udW5pdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc091dFtlZmZlY3ROYW1lXS51bml0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc0RhdGEudHdlZW5EYXRhW2VmZmVjdE5hbWVdLnVuaXQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0LnVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24udG9IaWRlW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwb3NEYXRhICAgICAgICAgICAgID0gb3BlcmF0aW9uLnRvSGlkZVBvc0RhdGFbaV07XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbiAgICAgICA9IG5ldyBtaXhpdHVwLlN0eWxlRGF0YSgpO1xuICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zT3V0ICAgICAgPSBuZXcgbWl4aXR1cC5TdHlsZURhdGEoKTtcbiAgICAgICAgICAgICAgICBwb3NEYXRhLnR3ZWVuRGF0YSAgID0gbmV3IG1peGl0dXAuU3R5bGVEYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHggYW5kIHlcblxuICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zSW4ueCAgICAgPSB0YXJnZXQuaXNTaG93biA/IHBvc0RhdGEuc3RhcnRQb3NEYXRhLnggLSBwb3NEYXRhLmludGVyUG9zRGF0YS54IDogMDtcbiAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc0luLnkgICAgID0gdGFyZ2V0LmlzU2hvd24gPyBwb3NEYXRhLnN0YXJ0UG9zRGF0YS55IC0gcG9zRGF0YS5pbnRlclBvc0RhdGEueSA6IDA7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXQueCAgICA9IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5udWRnZSA/IDAgOiBwb3NEYXRhLnBvc0luLng7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXQueSAgICA9IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5udWRnZSA/IDAgOiBwb3NEYXRhLnBvc0luLnk7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGEueCA9IHBvc0RhdGEucG9zT3V0LnggLSBwb3NEYXRhLnBvc0luLng7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGEueSA9IHBvc0RhdGEucG9zT3V0LnkgLSBwb3NEYXRhLnBvc0luLnk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHdpZHRoLCBoZWlnaHQsIGFuZCBtYXJnaW5zXG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuYW5pbWF0aW9uLmFuaW1hdGVSZXNpemVUYXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zSW4ud2lkdGggICAgICAgICA9IHBvc0RhdGEuc3RhcnRQb3NEYXRhLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc0luLmhlaWdodCAgICAgICAgPSBwb3NEYXRhLnN0YXJ0UG9zRGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgd2lkdGhDaGFuZ2UgPSBwb3NEYXRhLnN0YXJ0UG9zRGF0YS53aWR0aCAtIHBvc0RhdGEuaW50ZXJQb3NEYXRhLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zSW4ubWFyZ2luUmlnaHQgPSBwb3NEYXRhLnN0YXJ0UG9zRGF0YS5tYXJnaW5SaWdodCAtIHdpZHRoQ2hhbmdlO1xuXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodENoYW5nZSA9IHBvc0RhdGEuc3RhcnRQb3NEYXRhLmhlaWdodCAtIHBvc0RhdGEuaW50ZXJQb3NEYXRhLmhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc0luLm1hcmdpbkJvdHRvbSA9IHBvc0RhdGEuc3RhcnRQb3NEYXRhLm1hcmdpbkJvdHRvbSAtIGhlaWdodENoYW5nZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIG9wYWNpdHlcblxuICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zSW4ub3BhY2l0eSAgICAgICA9IDE7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NPdXQub3BhY2l0eSAgICAgID0gc2VsZi5lZmZlY3RzT3V0Lm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGEub3BhY2l0eSAgID0gcG9zRGF0YS5wb3NPdXQub3BhY2l0eSAtIHBvc0RhdGEucG9zSW4ub3BhY2l0eTtcblxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgdHJhbnNmb3Jtc1xuXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgZWZmZWN0TmFtZSA9IGVmZmVjdE5hbWVzW2pdOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0ID0gc2VsZi5lZmZlY3RzT3V0W2VmZmVjdE5hbWVdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGVmZmVjdCBpbnN0YW5jZW9mIG1peGl0dXAuVHJhbnNmb3JtRGF0YSkgfHwgIWVmZmVjdC52YWx1ZSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbltlZmZlY3ROYW1lXS52YWx1ZSAgICAgPSAwO1xuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc091dFtlZmZlY3ROYW1lXS52YWx1ZSAgICA9IGVmZmVjdC52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnR3ZWVuRGF0YVtlZmZlY3ROYW1lXS52YWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc091dFtlZmZlY3ROYW1lXS52YWx1ZSAtIHBvc0RhdGEucG9zSW5bZWZmZWN0TmFtZV0udmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS5wb3NJbltlZmZlY3ROYW1lXS51bml0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc0RhdGEucG9zT3V0W2VmZmVjdE5hbWVdLnVuaXQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zRGF0YS50d2VlbkRhdGFbZWZmZWN0TmFtZV0udW5pdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3QudW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyR2V0VHdlZW5EYXRhJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtPcGVyYXRpb259ICAgICBvcGVyYXRpb25cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIG1vdmVUYXJnZXRzOiBmdW5jdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgbW92ZURhdGEgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBwb3NEYXRhICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXR1c0NoYW5nZSAgICA9ICcnLFxuICAgICAgICAgICAgICAgIHdpbGxUcmFuc2l0aW9uICA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0YWdnZXJJbmRleCAgICA9IC0xLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgICA9IC0xLFxuICAgICAgICAgICAgICAgIGNoZWNrUHJvZ3Jlc3MgICA9IHNlbGYuY2hlY2tQcm9ncmVzcy5iaW5kKHNlbGYpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVNb3ZlVGFyZ2V0cycsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgYW4gZXh0cmEgbG9vcCBpbiBhZGRpdGlvbiB0byB0aGUgY2FsY3NcbiAgICAgICAgICAgIC8vIGRvbmUgaW4gZ2V0T3BlcmF0aW9uLCBjb3VsZCBzb21lIG9mIHRoaXMgYmUgZG9uZSB0aGVyZT9cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gb3BlcmF0aW9uLnNob3dbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIG1vdmVEYXRhICAgID0gbmV3IG1peGl0dXAuSU1vdmVEYXRhKCk7XG4gICAgICAgICAgICAgICAgcG9zRGF0YSAgICAgPSBvcGVyYXRpb24uc2hvd1Bvc0RhdGFbaV07XG5cbiAgICAgICAgICAgICAgICBzdGF0dXNDaGFuZ2UgPSB0YXJnZXQuaXNTaG93biA/ICdub25lJyA6ICdzaG93JztcblxuICAgICAgICAgICAgICAgIHdpbGxUcmFuc2l0aW9uID0gc2VsZi53aWxsVHJhbnNpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24uaGFzRWZmZWN0LFxuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc0luLFxuICAgICAgICAgICAgICAgICAgICBwb3NEYXRhLnBvc091dFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZiAod2lsbFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBub24tdHJhbnNpdGlvbmluZyB0YXJnZXRzIGZyb20gaW5jcmVtZW50aW5nIHRoZSBzdGFnZ2VySW5kZXhcblxuICAgICAgICAgICAgICAgICAgICBzdGFnZ2VySW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQuc2hvdygpO1xuXG4gICAgICAgICAgICAgICAgbW92ZURhdGEucG9zSW4gICAgICAgICAgPSBwb3NEYXRhLnBvc0luO1xuICAgICAgICAgICAgICAgIG1vdmVEYXRhLnBvc091dCAgICAgICAgID0gcG9zRGF0YS5wb3NPdXQ7XG4gICAgICAgICAgICAgICAgbW92ZURhdGEuc3RhdHVzQ2hhbmdlICAgPSBzdGF0dXNDaGFuZ2U7XG4gICAgICAgICAgICAgICAgbW92ZURhdGEuc3RhZ2dlckluZGV4ICAgPSBzdGFnZ2VySW5kZXg7XG4gICAgICAgICAgICAgICAgbW92ZURhdGEub3BlcmF0aW9uICAgICAgPSBvcGVyYXRpb247XG4gICAgICAgICAgICAgICAgbW92ZURhdGEuY2FsbGJhY2sgICAgICAgPSB3aWxsVHJhbnNpdGlvbiA/IGNoZWNrUHJvZ3Jlc3MgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0Lm1vdmUobW92ZURhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24udG9IaWRlW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwb3NEYXRhICA9IG9wZXJhdGlvbi50b0hpZGVQb3NEYXRhW2ldO1xuICAgICAgICAgICAgICAgIG1vdmVEYXRhID0gbmV3IG1peGl0dXAuSU1vdmVEYXRhKCk7XG5cbiAgICAgICAgICAgICAgICBzdGF0dXNDaGFuZ2UgPSAnaGlkZSc7XG5cbiAgICAgICAgICAgICAgICB3aWxsVHJhbnNpdGlvbiA9IHNlbGYud2lsbFRyYW5zaXRpb24oc3RhdHVzQ2hhbmdlLCBwb3NEYXRhLnBvc0luLCBwb3NEYXRhLnBvc091dCk7XG5cbiAgICAgICAgICAgICAgICBtb3ZlRGF0YS5wb3NJbiAgICAgICAgICA9IHBvc0RhdGEucG9zSW47XG4gICAgICAgICAgICAgICAgbW92ZURhdGEucG9zT3V0ICAgICAgICAgPSBwb3NEYXRhLnBvc091dDtcbiAgICAgICAgICAgICAgICBtb3ZlRGF0YS5zdGF0dXNDaGFuZ2UgICA9IHN0YXR1c0NoYW5nZTtcbiAgICAgICAgICAgICAgICBtb3ZlRGF0YS5zdGFnZ2VySW5kZXggICA9IGk7XG4gICAgICAgICAgICAgICAgbW92ZURhdGEub3BlcmF0aW9uICAgICAgPSBvcGVyYXRpb247XG4gICAgICAgICAgICAgICAgbW92ZURhdGEuY2FsbGJhY2sgICAgICAgPSB3aWxsVHJhbnNpdGlvbiA/IGNoZWNrUHJvZ3Jlc3MgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0Lm1vdmUobW92ZURhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuYW5pbWF0aW9uLmFuaW1hdGVSZXNpemVDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuc3R5bGVbbWl4aXR1cC5mZWF0dXJlcy50cmFuc2l0aW9uUHJvcF0gPVxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0ICcgKyBzZWxmLmNvbmZpZy5hbmltYXRpb24uZHVyYXRpb24gKyAnbXMgZWFzZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCAnICsgc2VsZi5jb25maWcuYW5pbWF0aW9uLmR1cmF0aW9uICsgJ21zIGVhc2UgJztcblxuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLnN0YXJ0SGVpZ2h0ICE9PSBvcGVyYXRpb24ubmV3SGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24udmlld3BvcnREZWx0YVkgIT09IG9wZXJhdGlvbi5zdGFydEhlaWdodCAtIG9wZXJhdGlvbi5uZXdIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuc3R5bGUuaGVpZ2h0ID0gb3BlcmF0aW9uLm5ld0hlaWdodCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24uc3RhcnRXaWR0aCAhPT0gb3BlcmF0aW9uLm5ld1dpZHRoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24udmlld3BvcnREZWx0YVggIT09IG9wZXJhdGlvbi5zdGFydFdpZHRoIC0gb3BlcmF0aW9uLm5ld1dpZHRoXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlLndpZHRoID0gb3BlcmF0aW9uLm5ld1dpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLndpbGxDaGFuZ2VMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICBoLnJlbW92ZUNsYXNzKHNlbGYuZG9tLmNvbnRhaW5lciwgc2VsZi5jb25maWcubGF5b3V0LkNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgaC5hZGRDbGFzcyhzZWxmLmRvbS5jb250YWluZXIsIG9wZXJhdGlvbi5uZXdDb250YWluZXJDbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlck1vdmVUYXJnZXRzJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm4gIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICBoYXNFZmZlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBFRkZFQ1RBQkxFUyA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ3NjYWxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICd0cmFuc2xhdGVaJyxcbiAgICAgICAgICAgICAgICAgICAgJ3JvdGF0ZVgnLCAncm90YXRlWScsICdyb3RhdGVaJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZWZmZWN0TmFtZSAgPSAnJyxcbiAgICAgICAgICAgICAgICBlZmZlY3QgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgcmVzdWx0ICAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgICA9IC0xLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmVmZmVjdHNJbi5vcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ3Jlc3VsdEhhc0VmZmVjdCcsIHRydWUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGVmZmVjdE5hbWUgPSBFRkZFQ1RBQkxFU1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZWZmZWN0ICA9IHNlbGYuZWZmZWN0c0luW2VmZmVjdE5hbWVdO1xuICAgICAgICAgICAgICAgIHZhbHVlICAgPSAodHlwZW9mIGVmZmVjdCAmJiBlZmZlY3QudmFsdWUgIT09ICd1bmRlZmluZWQnKSA/XG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdC52YWx1ZSA6IGVmZmVjdDtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ3Jlc3VsdEhhc0VmZmVjdCcsIHJlc3VsdCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiBhIHRhcmdldCBlbGVtZW50IHdpbGwgdHJhbnNpdGlvbiBpblxuICAgICAgICAgKiBzb21lIGZhc2lvbiBhbmQgdGhlcmVmb3JlIHJlcXVpcmVzIGJpbmRpbmcgb2ZcbiAgICAgICAgICogdHJhbnNpdGlvbkVuZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgICAgIHN0YXR1c0NoYW5nZVxuICAgICAgICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gICAgICAgaGFzRWZmZWN0XG4gICAgICAgICAqIEBwYXJhbSAgIHtTdHlsZURhdGF9ICAgICBwb3NJblxuICAgICAgICAgKiBAcGFyYW0gICB7U3R5bGVEYXRhfSAgICAgcG9zT3V0XG4gICAgICAgICAqIEByZXR1cm4gIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICB3aWxsVHJhbnNpdGlvbjogZnVuY3Rpb24oc3RhdHVzQ2hhbmdlLCBoYXNFZmZlY3QsIHBvc0luLCBwb3NPdXQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICByZXN1bHQgID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICghaC5pc1Zpc2libGUoc2VsZi5kb20uY29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb250YWluZXIgaXMgbm90IHZpc2libGUsIHRoZSB0cmFuc2l0aW9uRW5kXG4gICAgICAgICAgICAgICAgLy8gZXZlbnQgd2lsbCBub3Qgb2NjdXIgYW5kIE1peEl0VXAgd2lsbCBoYW5nXG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgKHN0YXR1c0NoYW5nZSAhPT0gJ25vbmUnICYmIGhhc0VmZmVjdCkgfHxcbiAgICAgICAgICAgICAgICBwb3NJbi54ICE9PSBwb3NPdXQueCB8fFxuICAgICAgICAgICAgICAgIHBvc0luLnkgIT09IHBvc091dC55XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBvcGFjaXR5IGFuZC9vciB0cmFuc2xhdGUgd2lsbCBjaGFuZ2VcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuY29uZmlnLmFuaW1hdGlvbi5hbmltYXRlUmVzaXplVGFyZ2V0cykge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdpZHRoLCBoZWlnaHQgb3IgbWFyZ2lucyB3aWxsIGNoYW5nZVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKFxuICAgICAgICAgICAgICAgICAgICBwb3NJbi53aWR0aCAhPT0gcG9zT3V0LndpZHRoIHx8XG4gICAgICAgICAgICAgICAgICAgIHBvc0luLmhlaWdodCAhPT0gcG9zT3V0LmhlaWdodCB8fFxuICAgICAgICAgICAgICAgICAgICBwb3NJbi5tYXJnaW5SaWdodCAhPT0gcG9zT3V0Lm1hcmdpblJpZ2h0IHx8XG4gICAgICAgICAgICAgICAgICAgIHBvc0luLm1hcmdpblRvcCAhPT0gcG9zT3V0Lm1hcmdpblRvcFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsRmlsdGVycygncmVzdWx0V2lsbFRyYW5zaXRpb24nLCByZXN1bHQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7T3BlcmF0aW9ufSAgICAgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBjaGVja1Byb2dyZXNzOiBmdW5jdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi50YXJnZXRzRG9uZSsrO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi50YXJnZXRzQm91bmQgPT09IHNlbGYudGFyZ2V0c0RvbmUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNsZWFuVXAob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtPcGVyYXRpb259ICAgICBvcGVyYXRpb25cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGNsZWFuVXA6IGZ1bmN0aW9uKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICAgICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2VCZWZvcmUgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2VBZnRlciAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIG5leHRJblF1ZXVlICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlQ2xlYW5VcCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYudGFyZ2V0c01vdmVkICAgICAgICAgID1cbiAgICAgICAgICAgICAgICBzZWxmLnRhcmdldHNJbW1vdmFibGUgID1cbiAgICAgICAgICAgICAgICBzZWxmLnRhcmdldHNCb3VuZCAgICAgID1cbiAgICAgICAgICAgICAgICBzZWxmLnRhcmdldHNEb25lICAgICAgID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gb3BlcmF0aW9uLnNob3dbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5jbGVhblVwKCk7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQuc2hvdygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBvcGVyYXRpb24udG9IaWRlW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuY2xlYW5VcCgpO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmhpZGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi53aWxsU29ydCkge1xuICAgICAgICAgICAgICAgIHNlbGYucHJpbnRTb3J0KGZhbHNlLCBvcGVyYXRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgYW55IHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBwYXJlbnQgY29udGFpbmVyXG5cbiAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZVttaXhpdHVwLmZlYXR1cmVzLnRyYW5zaXRpb25Qcm9wXSAgICAgICAgICAgICA9XG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlLmhlaWdodCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPVxuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZS53aWR0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID1cbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuc3R5bGUub3ZlcmZsb3cgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9XG4gICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnN0eWxlW21peGl0dXAuZmVhdHVyZXMucGVyc3BlY3RpdmVQcm9wXSAgICAgICAgPVxuICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5zdHlsZVttaXhpdHVwLmZlYXR1cmVzLnBlcnNwZWN0aXZlT3JpZ2luUHJvcF0gID0gJyc7XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ud2lsbENoYW5nZUxheW91dCkge1xuICAgICAgICAgICAgICAgIGgucmVtb3ZlQ2xhc3Moc2VsZi5kb20uY29udGFpbmVyLCBvcGVyYXRpb24uc3RhcnRDb250YWluZXJDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIGguYWRkQ2xhc3Moc2VsZi5kb20uY29udGFpbmVyLCBvcGVyYXRpb24ubmV3Q29udGFpbmVyQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi50b1JlbW92ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyB0YXJnZXQgPSBzZWxmLnRhcmdldHNbaV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLnRvUmVtb3ZlLmluZGV4T2YodGFyZ2V0KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdoaXRlc3BhY2VCZWZvcmUgPSB0YXJnZXQuZG9tLmVsLnByZXZpb3VzU2libGluZykgJiYgd2hpdGVzcGFjZUJlZm9yZS5ub2RlTmFtZSA9PT0gJyN0ZXh0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3aGl0ZXNwYWNlQWZ0ZXIgPSB0YXJnZXQuZG9tLmVsLm5leHRTaWJsaW5nKSAmJiB3aGl0ZXNwYWNlQWZ0ZXIubm9kZU5hbWUgPT09ICcjdGV4dCdcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgucmVtb3ZlV2hpdGVzcGFjZSh3aGl0ZXNwYWNlQmVmb3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcGVyYXRpb24ud2lsbFNvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOQjogU29ydGluZyB3aWxsIHJlbW92ZSB0YXJnZXRzIGFzIGEgYmktcHJvZHVjdCBvZiBgcHJpbnRTb3J0KClgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQucmVtb3ZlQ2hpbGQodGFyZ2V0LmRvbS5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudGFyZ2V0cy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5pc0luRG9tID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRhcmdldHMgaGF2ZSBiZWVuIHJlbW92ZWQsIHRoZSBvcmlnaW5hbCBvcmRlciBtdXN0IGJlIHVwZGF0ZWRcblxuICAgICAgICAgICAgICAgIHNlbGYub3JpZ09yZGVyID0gc2VsZi50YXJnZXRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLndpbGxTb3J0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi50YXJnZXRzID0gb3BlcmF0aW9uLm5ld09yZGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gb3BlcmF0aW9uLm5ld1N0YXRlO1xuICAgICAgICAgICAgc2VsZi5sYXN0T3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgICBzZWxmLmRvbS50YXJnZXRzID0gc2VsZi5zdGF0ZS50YXJnZXRzO1xuXG4gICAgICAgICAgICAvLyBtaXhFbmRcblxuICAgICAgICAgICAgbWl4aXR1cC5ldmVudHMuZmlyZSgnbWl4RW5kJywgc2VsZi5kb20uY29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgc3RhdGU6IHNlbGYuc3RhdGUsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHNlbGZcbiAgICAgICAgICAgIH0sIHNlbGYuZG9tLmRvY3VtZW50KTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLmNvbmZpZy5jYWxsYmFja3Mub25NaXhFbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5jYWxsYmFja3Mub25NaXhFbmQuY2FsbChzZWxmLmRvbS5jb250YWluZXIsIHNlbGYuc3RhdGUsIHNlbGYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLmhhc0ZhaWxlZCkge1xuICAgICAgICAgICAgICAgIC8vIG1peEZhaWxcblxuICAgICAgICAgICAgICAgIG1peGl0dXAuZXZlbnRzLmZpcmUoJ21peEZhaWwnLCBzZWxmLmRvbS5jb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHNlbGYuc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBzZWxmXG4gICAgICAgICAgICAgICAgfSwgc2VsZi5kb20uZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLmNvbmZpZy5jYWxsYmFja3Mub25NaXhGYWlsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmNhbGxiYWNrcy5vbk1peEZhaWwuY2FsbChzZWxmLmRvbS5jb250YWluZXIsIHNlbGYuc3RhdGUsIHNlbGYpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGguYWRkQ2xhc3Moc2VsZi5kb20uY29udGFpbmVyLCBoLmdldENsYXNzbmFtZShzZWxmLmNvbmZpZy5jbGFzc05hbWVzLCAnY29udGFpbmVyJywgc2VsZi5jb25maWcuY2xhc3NOYW1lcy5tb2RpZmllckZhaWxlZCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2VyLWRlZmluZWQgY2FsbGJhY2sgZnVuY3Rpb25cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLnVzZXJDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHNlbGYudXNlckNhbGxiYWNrLmNhbGwoc2VsZi5kb20uY29udGFpbmVyLCBzZWxmLnN0YXRlLCBzZWxmKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLnVzZXJEZWZlcnJlZC5yZXNvbHZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc2VsZi51c2VyRGVmZXJyZWQucmVzb2x2ZShzZWxmLnN0YXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi51c2VyQ2FsbGJhY2sgID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYudXNlckRlZmVycmVkICA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmxhc3RDbGlja2VkICAgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5pc1RvZ2dsaW5nICAgID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLmlzQnVzeSAgICAgICAgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHNlbGYucXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlUmVhZFF1ZXVlQ2xlYW5VcCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICBuZXh0SW5RdWV1ZSA9IHNlbGYucXVldWUuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBub24tcHVibGljIEFQSSBwcm9wZXJ0aWVzIHN0b3JlZCBpbiBxdWV1ZVxuXG4gICAgICAgICAgICAgICAgc2VsZi51c2VyRGVmZXJyZWQgID0gbmV4dEluUXVldWUuZGVmZXJyZWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5pc1RvZ2dsaW5nICAgID0gbmV4dEluUXVldWUuaXNUb2dnbGluZztcbiAgICAgICAgICAgICAgICBzZWxmLmxhc3RDbGlja2VkICAgPSBuZXh0SW5RdWV1ZS50cmlnZ2VyRWxlbWVudDtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0SW5RdWV1ZS5pbnN0cnVjdGlvbi5jb21tYW5kIGluc3RhbmNlb2YgbWl4aXR1cC5Db21tYW5kTXVsdGltaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tdWx0aW1peC5hcHBseShzZWxmLCBuZXh0SW5RdWV1ZS5hcmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRhdGFzZXQuYXBwbHkoc2VsZiwgbmV4dEluUXVldWUuYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckNsZWFuVXAnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAge0FycmF5PCo+fSAgYXJnc1xuICAgICAgICAgKiBAcmV0dXJuICB7bWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb259XG4gICAgICAgICAqL1xuXG4gICAgICAgIHBhcnNlTXVsdGltaXhBcmdzOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uID0gbmV3IG1peGl0dXAuVXNlckluc3RydWN0aW9uKCksXG4gICAgICAgICAgICAgICAgYXJnICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIGluc3RydWN0aW9uLmFuaW1hdGUgPSBzZWxmLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZCA9IG5ldyBtaXhpdHVwLkNvbW1hbmRNdWx0aW1peCgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBoLmV4dGVuZChpbnN0cnVjdGlvbi5jb21tYW5kLCBhcmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmFuaW1hdGUgPSBhcmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNhbGxiYWNrID0gYXJnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29lcmNlIGFyYml0cmFyeSBjb21tYW5kIGFyZ3VtZW50cyBpbnRvIHR5cGVkIGNvbW1hbmQgb2JqZWN0c1xuXG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uY29tbWFuZC5pbnNlcnQgJiYgIShpbnN0cnVjdGlvbi5jb21tYW5kLmluc2VydCBpbnN0YW5jZW9mIG1peGl0dXAuQ29tbWFuZEluc2VydCkpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kLmluc2VydCA9IHNlbGYucGFyc2VJbnNlcnRBcmdzKFtpbnN0cnVjdGlvbi5jb21tYW5kLmluc2VydF0pLmNvbW1hbmQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5jb21tYW5kLnJlbW92ZSAmJiAhKGluc3RydWN0aW9uLmNvbW1hbmQucmVtb3ZlIGluc3RhbmNlb2YgbWl4aXR1cC5Db21tYW5kUmVtb3ZlKSkge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQucmVtb3ZlID0gc2VsZi5wYXJzZVJlbW92ZUFyZ3MoW2luc3RydWN0aW9uLmNvbW1hbmQucmVtb3ZlXSkuY29tbWFuZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLmNvbW1hbmQuZmlsdGVyICYmICEoaW5zdHJ1Y3Rpb24uY29tbWFuZC5maWx0ZXIgaW5zdGFuY2VvZiBtaXhpdHVwLkNvbW1hbmRGaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5maWx0ZXIgPSBzZWxmLnBhcnNlRmlsdGVyQXJncyhbaW5zdHJ1Y3Rpb24uY29tbWFuZC5maWx0ZXJdKS5jb21tYW5kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uY29tbWFuZC5zb3J0ICYmICEoaW5zdHJ1Y3Rpb24uY29tbWFuZC5zb3J0IGluc3RhbmNlb2YgbWl4aXR1cC5Db21tYW5kU29ydCkpIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kLnNvcnQgPSBzZWxmLnBhcnNlU29ydEFyZ3MoW2luc3RydWN0aW9uLmNvbW1hbmQuc29ydF0pLmNvbW1hbmQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5jb21tYW5kLmNoYW5nZUxheW91dCAmJiAhKGluc3RydWN0aW9uLmNvbW1hbmQuY2hhbmdlTGF5b3V0IGluc3RhbmNlb2YgbWl4aXR1cC5Db21tYW5kQ2hhbmdlTGF5b3V0KSkge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQuY2hhbmdlTGF5b3V0ID0gc2VsZi5wYXJzZUNoYW5nZUxheW91dEFyZ3MoW2luc3RydWN0aW9uLmNvbW1hbmQuY2hhbmdlTGF5b3V0XSkuY29tbWFuZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBzZWxmLmNhbGxGaWx0ZXJzKCdpbnN0cnVjdGlvblBhcnNlTXVsdGltaXhBcmdzJywgaW5zdHJ1Y3Rpb24sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGguZnJlZXplKGluc3RydWN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAge0FycmF5PCo+fSAgYXJnc1xuICAgICAgICAgKiBAcmV0dXJuICB7bWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb259XG4gICAgICAgICAqL1xuXG4gICAgICAgIHBhcnNlRmlsdGVyQXJnczogZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbiA9IG5ldyBtaXhpdHVwLlVzZXJJbnN0cnVjdGlvbigpLFxuICAgICAgICAgICAgICAgIGFyZyAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5hbmltYXRlID0gc2VsZi5jb25maWcuYW5pbWF0aW9uLmVuYWJsZTtcbiAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQgPSBuZXcgbWl4aXR1cC5Db21tYW5kRmlsdGVyKCk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gYXJnc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3RvclxuXG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQuc2VsZWN0b3IgPSBhcmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5jb2xsZWN0aW9uID0gW107XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBoLmlzRWxlbWVudChhcmcsIHNlbGYuZG9tLmRvY3VtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5nbGUgZWxlbWVudFxuXG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQuY29sbGVjdGlvbiA9IFthcmddO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGFyZy5sZW5ndGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11bHRpcGxlIGVsZW1lbnRzIGluIGFycmF5LCBOb2RlTGlzdCBvciBqUXVlcnkgY29sbGVjdGlvblxuXG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQuY29sbGVjdGlvbiA9IGguYXJyYXlGcm9tTGlzdChhcmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGNvbW1hbmRcblxuICAgICAgICAgICAgICAgICAgICBoLmV4dGVuZChpbnN0cnVjdGlvbi5jb21tYW5kLCBhcmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmFuaW1hdGUgPSBhcmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNhbGxiYWNrID0gYXJnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLmNvbW1hbmQuc2VsZWN0b3IgJiYgaW5zdHJ1Y3Rpb24uY29tbWFuZC5jb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1peGl0dXAubWVzc2FnZXMuZXJyb3JGaWx0ZXJJbnZhbGlkQXJndW1lbnRzKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnN0cnVjdGlvbiA9IHNlbGYuY2FsbEZpbHRlcnMoJ2luc3RydWN0aW9uUGFyc2VGaWx0ZXJBcmdzJywgaW5zdHJ1Y3Rpb24sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGguZnJlZXplKGluc3RydWN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlU29ydEFyZ3M6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBuZXcgbWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb24oKSxcbiAgICAgICAgICAgICAgICBhcmcgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgc29ydFN0cmluZyAgPSAnJyxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5hbmltYXRlID0gc2VsZi5jb25maWcuYW5pbWF0aW9uLmVuYWJsZTtcbiAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQgPSBuZXcgbWl4aXR1cC5Db21tYW5kU29ydCgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGFyZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29ydCBzdHJpbmdcblxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydFN0cmluZyA9IGFyZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcnJheSBvZiBlbGVtZW50IHJlZmVyZW5jZXNcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kLmNvbGxlY3Rpb24gPSBoLmFycmF5RnJvbUxpc3QoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uYW5pbWF0ZSA9IGFyZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNhbGxiYWNrID0gYXJnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzb3J0U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZCA9IHNlbGYucGFyc2VTb3J0U3RyaW5nKHNvcnRTdHJpbmcsIGluc3RydWN0aW9uLmNvbW1hbmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnN0cnVjdGlvbiA9IHNlbGYuY2FsbEZpbHRlcnMoJ2luc3RydWN0aW9uUGFyc2VTb3J0QXJncycsIGluc3RydWN0aW9uLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBoLmZyZWV6ZShpbnN0cnVjdGlvbik7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnN0cnVjdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtBcnJheTwqPn0gIGFyZ3NcbiAgICAgICAgICogQHJldHVybiAge21peGl0dXAuVXNlckluc3RydWN0aW9ufVxuICAgICAgICAgKi9cblxuICAgICAgICBwYXJzZUluc2VydEFyZ3M6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBuZXcgbWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb24oKSxcbiAgICAgICAgICAgICAgICBhcmcgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uYW5pbWF0ZSA9IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGU7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kID0gbmV3IG1peGl0dXAuQ29tbWFuZEluc2VydCgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgaW5kZXhcblxuICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kLmluZGV4ID0gYXJnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgJiYgWydiZWZvcmUnLCAnYWZ0ZXInXS5pbmRleE9mKGFyZykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAnYmVmb3JlJy8nYWZ0ZXInXG5cbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5wb3NpdGlvbiA9IGFyZztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hcmt1cFxuXG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQuY29sbGVjdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICBoLmFycmF5RnJvbUxpc3QoaC5jcmVhdGVFbGVtZW50KGFyZykuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBoLmlzRWxlbWVudChhcmcsIHNlbGYuZG9tLmRvY3VtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5nbGUgZWxlbWVudFxuXG4gICAgICAgICAgICAgICAgICAgICFpbnN0cnVjdGlvbi5jb21tYW5kLmNvbGxlY3Rpb24ubGVuZ3RoID9cbiAgICAgICAgICAgICAgICAgICAgICAgIChpbnN0cnVjdGlvbi5jb21tYW5kLmNvbGxlY3Rpb24gPSBbYXJnXSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgKGluc3RydWN0aW9uLmNvbW1hbmQuc2libGluZyA9IGFyZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11bHRpcGxlIGVsZW1lbnRzIGluIGFycmF5IG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgIWluc3RydWN0aW9uLmNvbW1hbmQuY29sbGVjdGlvbi5sZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICAgICAgKGluc3RydWN0aW9uLmNvbW1hbmQuY29sbGVjdGlvbiA9IGFyZykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5zaWJsaW5nID0gYXJnWzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnLmNoaWxkTm9kZXMgJiYgYXJnLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IGZyYWdtZW50XG5cbiAgICAgICAgICAgICAgICAgICAgIWluc3RydWN0aW9uLmNvbW1hbmQuY29sbGVjdGlvbi5sZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5jb2xsZWN0aW9uID0gaC5hcnJheUZyb21MaXN0KGFyZy5jaGlsZE5vZGVzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kLnNpYmxpbmcgPSBhcmcuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBjb21tYW5kXG5cbiAgICAgICAgICAgICAgICAgICAgaC5leHRlbmQoaW5zdHJ1Y3Rpb24uY29tbWFuZCwgYXJnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5hbmltYXRlID0gYXJnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jYWxsYmFjayA9IGFyZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5jb21tYW5kLmluZGV4ICYmIGluc3RydWN0aW9uLmNvbW1hbmQuc2libGluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtaXhpdHVwLm1lc3NhZ2VzLmVycm9ySW5zZXJ0SW52YWxpZEFyZ3VtZW50cygpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpbnN0cnVjdGlvbi5jb21tYW5kLmNvbGxlY3Rpb24ubGVuZ3RoICYmIHNlbGYuY29uZmlnLmRlYnVnLnNob3dXYXJuaW5ncykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihtaXhpdHVwLm1lc3NhZ2VzLndhcm5pbmdJbnNlcnROb0VsZW1lbnRzKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnN0cnVjdGlvbiA9IHNlbGYuY2FsbEZpbHRlcnMoJ2luc3RydWN0aW9uUGFyc2VJbnNlcnRBcmdzJywgaW5zdHJ1Y3Rpb24sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGguZnJlZXplKGluc3RydWN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge0FycmF5PCo+fSAgYXJnc1xuICAgICAgICAgKiBAcmV0dXJuICB7bWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb259XG4gICAgICAgICAqL1xuXG4gICAgICAgIHBhcnNlUmVtb3ZlQXJnczogZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbiA9IG5ldyBtaXhpdHVwLlVzZXJJbnN0cnVjdGlvbigpLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBhcmcgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uYW5pbWF0ZSA9IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGU7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kID0gbmV3IG1peGl0dXAuQ29tbWFuZFJlbW92ZSgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGFyZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYudGFyZ2V0c1thcmddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC50YXJnZXRzWzBdID0gc2VsZi50YXJnZXRzW2FyZ107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5jb2xsZWN0aW9uID0gaC5hcnJheUZyb21MaXN0KHNlbGYuZG9tLnBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKGFyZykpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcgJiYgYXJnLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmNvbW1hbmQuY29sbGVjdGlvbiA9IGFyZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaC5pc0VsZW1lbnQoYXJnLCBzZWxmLmRvbS5kb2N1bWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kLmNvbGxlY3Rpb24gPSBbYXJnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGNvbW1hbmRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGguZXh0ZW5kKGluc3RydWN0aW9uLmNvbW1hbmQsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmFuaW1hdGUgPSBhcmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jYWxsYmFjayA9IGFyZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uY29tbWFuZC5jb2xsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IHRhcmdldCA9IHNlbGYudGFyZ2V0c1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5jb21tYW5kLmNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQuZG9tLmVsKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kLnRhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWluc3RydWN0aW9uLmNvbW1hbmQudGFyZ2V0cy5sZW5ndGggJiYgc2VsZi5jb25maWcuZGVidWcuc2hvd1dhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1peGl0dXAubWVzc2FnZXMud2FybmluZ1JlbW92ZU5vRWxlbWVudHMoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGguZnJlZXplKGluc3RydWN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge0FycmF5PCo+fSAgYXJnc1xuICAgICAgICAgKiBAcmV0dXJuICB7bWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb259XG4gICAgICAgICAqL1xuXG4gICAgICAgIHBhcnNlRGF0YXNldEFyZ3M6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBuZXcgbWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb24oKSxcbiAgICAgICAgICAgICAgICBhcmcgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uYW5pbWF0ZSA9IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGU7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kID0gbmV3IG1peGl0dXAuQ29tbWFuZERhdGFzZXQoKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmcgPSBhcmdzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gbnVsbCkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykgfHwgdHlwZW9mIGFyZy5sZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5kYXRhc2V0ID0gYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgbGF5b3V0IGNvbW1hbmRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGguZXh0ZW5kKGluc3RydWN0aW9uLmNvbW1hbmQsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmFuaW1hdGUgPSBhcmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jYWxsYmFjayA9IGFyZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoLmZyZWV6ZShpbnN0cnVjdGlvbik7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnN0cnVjdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtBcnJheTwqPn0gIGFyZ3NcbiAgICAgICAgICogQHJldHVybiAge21peGl0dXAuVXNlckluc3RydWN0aW9ufVxuICAgICAgICAgKi9cblxuICAgICAgICBwYXJzZUNoYW5nZUxheW91dEFyZ3M6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBuZXcgbWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb24oKSxcbiAgICAgICAgICAgICAgICBhcmcgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSAgICAgICAgICAgPSAtMTtcblxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uYW5pbWF0ZSA9IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGU7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5jb21tYW5kID0gbmV3IG1peGl0dXAuQ29tbWFuZENoYW5nZUxheW91dCgpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGFyZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY29tbWFuZC5jb250YWluZXJDbGFzc05hbWUgPSBhcmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIGxheW91dCBjb21tYW5kXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGguZXh0ZW5kKGluc3RydWN0aW9uLmNvbW1hbmQsIGFyZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmFuaW1hdGUgPSBhcmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5jYWxsYmFjayA9IGFyZztcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoLmZyZWV6ZShpbnN0cnVjdGlvbik7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnN0cnVjdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICAgICAge21peGl0dXAuUXVldWVJdGVtfSAgICAgICAgIHF1ZXVlSXRlbVxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2UuPG1peGl0dXAuU3RhdGU+fVxuICAgICAgICAgKi9cblxuICAgICAgICBxdWV1ZU1peDogZnVuY3Rpb24ocXVldWVJdGVtKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZCAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIHRvZ2dsZVNlbGVjdG9yICA9ICcnO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVRdWV1ZU1peCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGRlZmVycmVkID0gaC5kZWZlcihtaXhpdHVwLmxpYnJhcmllcyk7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hbmltYXRpb24ucXVldWUgJiYgc2VsZi5xdWV1ZS5sZW5ndGggPCBzZWxmLmNvbmZpZy5hbmltYXRpb24ucXVldWVMaW1pdCkge1xuICAgICAgICAgICAgICAgIHF1ZXVlSXRlbS5kZWZlcnJlZCA9IGRlZmVycmVkO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5xdWV1ZS5wdXNoKHF1ZXVlSXRlbSk7XG5cbiAgICAgICAgICAgICAgICAvLyBLZWVwIGNvbnRyb2xzIGluIHN5bmMgd2l0aCB1c2VyIGludGVyYWN0aW9ucy4gTWl4ZXIgd2lsbCBjYXRjaCB1cCBhcyBpdCBkcmFpbnMgdGhlIHF1ZXVlLlxuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmNvbnRyb2xzLmVuYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5pc1RvZ2dsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJ1aWxkVG9nZ2xlQXJyYXkocXVldWVJdGVtLmluc3RydWN0aW9uLmNvbW1hbmQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVTZWxlY3RvciA9IHNlbGYuZ2V0VG9nZ2xlU2VsZWN0b3IoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVDb250cm9scyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiB0b2dnbGVTZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVDb250cm9scyhxdWV1ZUl0ZW0uaW5zdHJ1Y3Rpb24uY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5kZWJ1Zy5zaG93V2FybmluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1peGl0dXAubWVzc2FnZXMud2FybmluZ011bHRpbWl4SW5zdGFuY2VRdWV1ZUZ1bGwoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShzZWxmLnN0YXRlKTtcblxuICAgICAgICAgICAgICAgIG1peGl0dXAuZXZlbnRzLmZpcmUoJ21peEJ1c3knLCBzZWxmLmRvbS5jb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHNlbGYuc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBzZWxmXG4gICAgICAgICAgICAgICAgfSwgc2VsZi5kb20uZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLmNvbmZpZy5jYWxsYmFja3Mub25NaXhCdXN5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmNhbGxiYWNrcy5vbk1peEJ1c3kuY2FsbChzZWxmLmRvbS5jb250YWluZXIsIHNlbGYuc3RhdGUsIHNlbGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ3Byb21pc2VRdWV1ZU1peCcsIGRlZmVycmVkLnByb21pc2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7QXJyYXkuPG9iamVjdD59ICAgIG5ld0RhdGFzZXRcbiAgICAgICAgICogQHJldHVybiAge09wZXJhdGlvbn1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0RGF0YU9wZXJhdGlvbjogZnVuY3Rpb24obmV3RGF0YXNldCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiAgICAgICAgICAgPSBuZXcgbWl4aXR1cC5PcGVyYXRpb24oKSxcbiAgICAgICAgICAgICAgICBzdGFydERhdGFzZXQgICAgICAgID0gW107XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IHNlbGYuY2FsbEZpbHRlcnMoJ29wZXJhdGlvblVubWFwcGVkR2V0RGF0YU9wZXJhdGlvbicsIG9wZXJhdGlvbiwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKHNlbGYuZG9tLnRhcmdldHMubGVuZ3RoICYmICEoc3RhcnREYXRhc2V0ID0gKHNlbGYuc3RhdGUuYWN0aXZlRGF0YXNldCB8fCBbXSkpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtaXhpdHVwLm1lc3NhZ2VzLmVycm9yRGF0YXNldE5vdFNldCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3BlcmF0aW9uLmlkICAgICAgICAgICAgPSBoLnJhbmRvbUhleCgpO1xuICAgICAgICAgICAgb3BlcmF0aW9uLnN0YXJ0U3RhdGUgICAgPSBzZWxmLnN0YXRlO1xuICAgICAgICAgICAgb3BlcmF0aW9uLnN0YXJ0RGF0YXNldCAgPSBzdGFydERhdGFzZXQ7XG4gICAgICAgICAgICBvcGVyYXRpb24ubmV3RGF0YXNldCAgICA9IG5ld0RhdGFzZXQuc2xpY2UoKTtcblxuICAgICAgICAgICAgc2VsZi5kaWZmRGF0YXNldHMob3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgb3BlcmF0aW9uLnN0YXJ0T3JkZXIgPSBzZWxmLnRhcmdldHM7XG4gICAgICAgICAgICBvcGVyYXRpb24ubmV3T3JkZXIgPSBvcGVyYXRpb24uc2hvdztcblxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmdldFN0YXJ0TWl4RGF0YShvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0SW50ZXIob3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5kb2NTdGF0ZSA9IGguZ2V0RG9jdW1lbnRTdGF0ZShzZWxmLmRvbS5kb2N1bWVudCk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLmdldEludGVyTWl4RGF0YShvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0RmluYWwob3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICBzZWxmLmdldEZpbmFsTWl4RGF0YShvcGVyYXRpb24pO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5wYXJzZUVmZmVjdHMoKTtcblxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5oYXNFZmZlY3QgPSBzZWxmLmhhc0VmZmVjdCgpO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRUd2VlbkRhdGEob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi50YXJnZXRzID0gb3BlcmF0aW9uLnNob3cuc2xpY2UoKTtcblxuICAgICAgICAgICAgb3BlcmF0aW9uLm5ld1N0YXRlID0gc2VsZi5idWlsZFN0YXRlKG9wZXJhdGlvbik7XG5cbiAgICAgICAgICAgIC8vIE5COiBUYXJnZXRzIHRvIGJlIHJlbW92ZWQgbXVzdCBiZSBpbmNsdWRlZCBpbiBgc2VsZi50YXJnZXRzYCBmb3IgcmVtb3ZhbCBkdXJpbmcgY2xlYW4gdXAsXG4gICAgICAgICAgICAvLyBidXQgYXJlIGFkZGVkIGFmdGVyIHN0YXRlIGlzIGJ1aWx0IHNvIHRoYXQgc3RhdGUgaXMgYWNjdXJhdGVcblxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoc2VsZi50YXJnZXRzLCBvcGVyYXRpb24udG9SZW1vdmUpO1xuXG4gICAgICAgICAgICBvcGVyYXRpb24gPSBzZWxmLmNhbGxGaWx0ZXJzKCdvcGVyYXRpb25NYXBwZWRHZXREYXRhT3BlcmF0aW9uJywgb3BlcmF0aW9uLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge21peGl0dXAuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGRpZmZEYXRhc2V0czogZnVuY3Rpb24ob3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcGVyc2lzdGFudFN0YXJ0SWRzICA9IFtdLFxuICAgICAgICAgICAgICAgIHBlcnNpc3RhbnROZXdJZHMgICAgPSBbXSxcbiAgICAgICAgICAgICAgICBpbnNlcnRlZFRhcmdldHMgICAgID0gW10sXG4gICAgICAgICAgICAgICAgZGF0YSAgICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgdGFyZ2V0ICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgZWwgICAgICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgZnJhZyAgICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgbmV4dEVsICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgdWlkcyAgICAgICAgICAgICAgICA9IHt9LFxuICAgICAgICAgICAgICAgIGlkICAgICAgICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgICAgID0gLTE7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZURpZmZEYXRhc2V0cycsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGRhdGEgPSBvcGVyYXRpb24ubmV3RGF0YXNldFtpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaWQgPSBkYXRhW3NlbGYuY29uZmlnLmRhdGEudWlkS2V5XSkgPT09ICd1bmRlZmluZWQnIHx8IGlkLnRvU3RyaW5nKCkubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG1peGl0dXAubWVzc2FnZXMuZXJyb3JEYXRhc2V0SW52YWxpZFVpZEtleSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aWRLZXk6IHNlbGYuY29uZmlnLmRhdGEudWlkS2V5XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXVpZHNbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWl4aXR1cC5tZXNzYWdlcy5lcnJvckRhdGFzZXREdXBsaWNhdGVVaWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiBpZFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCh0YXJnZXQgPSBzZWxmLmNhY2hlW2lkXSkgaW5zdGFuY2VvZiBtaXhpdHVwLlRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGluIGNhY2hlXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmRhdGEuZGlydHlDaGVjayAmJiAhaC5kZWVwRXF1YWxzKGRhdGEsIHRhcmdldC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIGRldGVjdGVkXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gdGFyZ2V0LnJlbmRlcihkYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmRhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwgIT09IHRhcmdldC5kb20uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGFyZ2V0IGVsZW1lbnQgcmVmZXJlbmNlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzSW5Eb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnVuYmluZEV2ZW50cygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZG9tLnBhcmVudC5yZXBsYWNlQ2hpbGQoZWwsIHRhcmdldC5kb20uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0LmlzU2hvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZG9tLmVsID0gZWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzSW5Eb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlbCA9IHRhcmdldC5kb20uZWw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV3IHRhcmdldFxuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IG5ldyBtaXhpdHVwLlRhcmdldCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5pbml0KG51bGwsIHNlbGYsIGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuaXNJbkRvbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGRpbmcgdG8gRE9NXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVuIGZyYWdcblxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IHNlbGYuZG9tLmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmxhc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoc2VsZi5kb20uZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKHRhcmdldC5kb20uZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5pc0luRG9tID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQudW5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5oaWRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLnRvU2hvdy5wdXNoKHRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWRUYXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGluIERPTVxuXG4gICAgICAgICAgICAgICAgICAgIG5leHRFbCA9IHRhcmdldC5kb20uZWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RhbnROZXdJZHMucHVzaChpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsb3NlIGFuZCBpbnNlcnQgcHJldmlvdXNseSBvcGVuZWQgZnJhZ1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy5sYXN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChzZWxmLmRvbS5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnICcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnNlcnREYXRhc2V0RnJhZyhmcmFnLCB0YXJnZXQuZG9tLmVsLCBpbnNlcnRlZFRhcmdldHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zaG93LnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgICAgICAvLyBVbmNsb3NlZCBmcmFnIHJlbWFpbmluZ1xuXG4gICAgICAgICAgICAgICAgbmV4dEVsID0gbmV4dEVsIHx8IHNlbGYuY29uZmlnLmxheW91dC5zaWJsaW5nQWZ0ZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dEVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoc2VsZi5kb20uZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5pbnNlcnREYXRhc2V0RnJhZyhmcmFnLCBuZXh0RWwsIGluc2VydGVkVGFyZ2V0cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGRhdGEgPSBvcGVyYXRpb24uc3RhcnREYXRhc2V0W2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZCA9IGRhdGFbc2VsZi5jb25maWcuZGF0YS51aWRLZXldO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gc2VsZi5jYWNoZVtpZF07XG5cbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLnNob3cuaW5kZXhPZih0YXJnZXQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2aW91c2x5IHNob3duIGJ1dCBub3cgYWJzZW50XG5cbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLmhpZGUucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24udG9IaWRlLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLnRvUmVtb3ZlLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0YW50U3RhcnRJZHMucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWguaXNFcXVhbEFycmF5KHBlcnNpc3RhbnRTdGFydElkcywgcGVyc2lzdGFudE5ld0lkcykpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ud2lsbFNvcnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckRpZmZEYXRhc2V0cycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjEuNVxuICAgICAgICAgKiBAcGFyYW0gICB7RG9jdW1lbnRGcmFnbWVudH0gICAgICAgICAgZnJhZ1xuICAgICAgICAgKiBAcGFyYW0gICB7KEhUTUxFbGVtZW50fG51bGwpfSAgICAgICAgbmV4dEVsXG4gICAgICAgICAqIEBwYXJhbSAgIHtBcnJheS48bWl4aXR1cC5UYXJnZXQ+fSAgICB0YXJnZXRzXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBpbnNlcnREYXRhc2V0RnJhZzogZnVuY3Rpb24oZnJhZywgbmV4dEVsLCB0YXJnZXRzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0QXQgPSBuZXh0RWwgPyBoLmFycmF5RnJvbUxpc3Qoc2VsZi5kb20ucGFyZW50LmNoaWxkcmVuKS5pbmRleE9mKG5leHRFbCkgOiBzZWxmLnRhcmdldHMubGVuZ3RoO1xuXG4gICAgICAgICAgICBzZWxmLmRvbS5wYXJlbnQuaW5zZXJ0QmVmb3JlKGZyYWcsIG5leHRFbCk7XG5cbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNlbGYudGFyZ2V0cy5zcGxpY2UoaW5zZXJ0QXQsIDAsIHRhcmdldHMuc2hpZnQoKSk7XG5cbiAgICAgICAgICAgICAgICBpbnNlcnRBdCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge21peGl0dXAuQ29tbWFuZFNvcnR9IHNvcnRDb21tYW5kQVxuICAgICAgICAgKiBAcGFyYW0gICB7bWl4aXR1cC5Db21tYW5kU29ydH0gc29ydENvbW1hbmRCXG4gICAgICAgICAqIEByZXR1cm4gIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgICAgICB3aWxsU29ydDogZnVuY3Rpb24oc29ydENvbW1hbmRBLCBzb3J0Q29tbWFuZEIpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICByZXN1bHQgID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5iZWhhdmlvci5saXZlU29ydCB8fFxuICAgICAgICAgICAgICAgIHNvcnRDb21tYW5kQS5vcmRlciAgICAgICA9PT0gJ3JhbmRvbScgfHxcbiAgICAgICAgICAgICAgICBzb3J0Q29tbWFuZEEuYXR0cmlidXRlICAgIT09IHNvcnRDb21tYW5kQi5hdHRyaWJ1dGUgfHxcbiAgICAgICAgICAgICAgICBzb3J0Q29tbWFuZEEub3JkZXIgICAgICAgIT09IHNvcnRDb21tYW5kQi5vcmRlciB8fFxuICAgICAgICAgICAgICAgIHNvcnRDb21tYW5kQS5jb2xsZWN0aW9uICAhPT0gc29ydENvbW1hbmRCLmNvbGxlY3Rpb24gfHxcbiAgICAgICAgICAgICAgICAoc29ydENvbW1hbmRBLm5leHQgPT09IG51bGwgJiYgc29ydENvbW1hbmRCLm5leHQpIHx8XG4gICAgICAgICAgICAgICAgKHNvcnRDb21tYW5kQS5uZXh0ICYmIHNvcnRDb21tYW5kQi5uZXh0ID09PSBudWxsKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc29ydENvbW1hbmRBLm5leHQgJiYgc29ydENvbW1hbmRCLm5leHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmLndpbGxTb3J0KHNvcnRDb21tYW5kQS5uZXh0LCBzb3J0Q29tbWFuZEIubmV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsRmlsdGVycygncmVzdWx0V2lsbFNvcnQnLCByZXN1bHQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2hvcnRoYW5kIG1ldGhvZCBmb3IgYC5maWx0ZXIoJ2FsbCcpYC4gU2hvd3MgYWxsIHRhcmdldHMgaW4gdGhlIGNvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogLnNob3coKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBTaG93aW5nIGFsbCB0YXJnZXRzPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5zaG93KClcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93ID09PSBzdGF0ZS50b3RhbFRhcmdldHMpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICAgICAqIEByZXR1cm4gICAgICB7UHJvbWlzZS48bWl4aXR1cC5TdGF0ZT59XG4gICAgICAgICAqL1xuXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5maWx0ZXIoJ2FsbCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNob3J0aGFuZCBtZXRob2QgZm9yIGAuZmlsdGVyKCdub25lJylgLiBIaWRlcyBhbGwgdGFyZ2V0cyBpbiB0aGUgY29udGFpbmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAuaGlkZSgpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IEhpZGluZyBhbGwgdGFyZ2V0czwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuaGlkZSgpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnRvdGFsU2hvdyA9PT0gMCk7IC8vIHRydWVcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS50b3RhbEhpZGUgPT09IHN0YXRlLnRvdGFsVGFyZ2V0cyk7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgICAgICogQHJldHVybiAgICAgIHtQcm9taXNlLjxtaXhpdHVwLlN0YXRlPn1cbiAgICAgICAgICovXG5cbiAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmZpbHRlcignbm9uZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IGEgTWl4SXRVcCBvcGVyYXRpb24gaXNcbiAgICAgICAgICogY3VycmVudGx5IGluIHByb2dyZXNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAuaXNNaXhpbmcoKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBDaGVja2luZyB0aGUgc3RhdHVzIG9mIGEgbWl4ZXI8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnNvcnQoJ3JhbmRvbScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgKiAgICAgY29uc29sZS5sb2cobWl4ZXIuaXNNaXhpbmcoKSkgLy8gZmFsc2VcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG1peGVyLmlzTWl4aW5nKCkpIC8vIHRydWVcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHJldHVybiAge2Jvb2xlYW59XG4gICAgICAgICAqL1xuXG4gICAgICAgIGlzTWl4aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaXNCdXN5O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWx0ZXJzIGFsbCB0YXJnZXRzIGluIHRoZSBjb250YWluZXIgYnkgYSBwcm92aWRlZCBzZWxlY3RvciBzdHJpbmcsIG9yIHRoZSB2YWx1ZXMgYCdhbGwnYFxuICAgICAgICAgKiBvciBgJ25vbmUnYC4gT25seSB0YXJnZXRzIG1hdGNoaW5nIHRoZSBzZWxlY3RvciB3aWxsIGJlIHNob3duLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAuZmlsdGVyKHNlbGVjdG9yIFssIGFuaW1hdGVdIFssIGNhbGxiYWNrXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAxOiBGaWx0ZXJpbmcgdGFyZ2V0cyBieSBhIGNsYXNzIHNlbGVjdG9yPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5maWx0ZXIoJy5jYXRlZ29yeS1hJylcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93ID09PSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCcuY2F0ZWdvcnktYScpLmxlbmd0aCk7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDI6IEZpbHRlcmluZyB0YXJnZXRzIGJ5IGFuIGF0dHJpYnV0ZSBzZWxlY3RvcjwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuZmlsdGVyKCdbZGF0YS1jYXRlZ29yeX49XCJhXCJdJylcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93ID09PSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jYXRlZ29yeX49XCJhXCJdJykubGVuZ3RoKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMzogRmlsdGVyaW5nIHRhcmdldHMgYnkgYSBjb21wb3VuZCBzZWxlY3RvcjwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogLy8gU2hvdyBvbmx5IHRob3NlIHRhcmdldHMgd2l0aCB0aGUgY2xhc3NlcyAnY2F0ZWdvcnktYScgQU5EICdjYXRlZ29yeS1iJ1xuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5maWx0ZXIoJy5jYXRlZ29yeS1hLmNhdGVnb3J5LWMnKVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS50b3RhbFNob3cgPT09IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXRlZ29yeS1hLmNhdGVnb3J5LWMnKS5sZW5ndGgpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSA0OiBGaWx0ZXJpbmcgdmlhIGFuIGVsZW1lbnQgY29sbGVjdGlvbjwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGNvbGxlY3Rpb24gPSBBcnJheS5mcm9tKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcubWl4JykpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhjb2xsZWN0aW9uLmxlbmd0aCk7IC8vIDM0XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEZpbHRlciB0aGUgY29sbGVjdGlvbiBtYW51YWxseSB1c2luZyBBcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBmaWx0ZXJlZCA9IGNvbGxlY3Rpb24uZmlsdGVyKGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgKiAgICByZXR1cm4gcGFyc2VJbnQodGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1wcmljZScpKSA+IDEwO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2coZmlsdGVyZWQubGVuZ3RoKTsgLy8gMjJcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gUGFzcyB0aGUgZmlsdGVyZWQgY29sbGVjdGlvbiB0byBNaXhJdFVwXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmZpbHRlcihmaWx0ZXJlZClcbiAgICAgICAgICogICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLmFjdGl2ZUZpbHRlci5jb2xsZWN0aW9uLmxlbmd0aCA9PT0gMjIpOyAvLyB0cnVlXG4gICAgICAgICAqICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHsoc3RyaW5nfEhUTUxFbGVtZW50fEFycmF5LjxIVE1MRWxlbWVudD4pfSBzZWxlY3RvclxuICAgICAgICAgKiAgICAgIEFueSB2YWxpZCBDU1Mgc2VsZWN0b3IgKGkuZS4gYCcuY2F0ZWdvcnktYSdgKSwgb3IgdGhlIHZhbHVlcyBgJ2FsbCdgIG9yIGAnbm9uZSdgLiBUaGUgZmlsdGVyIG1ldGhvZCBhbHNvIGFjY2VwdHMgYSByZWZlcmVuY2UgdG8gc2luZ2xlIHRhcmdldCBlbGVtZW50IG9yIGEgY29sbGVjdGlvbiBvZiB0YXJnZXQgZWxlbWVudHMgdG8gc2hvdy5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtib29sZWFufSAgIFthbmltYXRlPXRydWVdXG4gICAgICAgICAqICAgICAgQW4gb3B0aW9uYWwgYm9vbGVhbiBkaWN0YXRpbmcgd2hldGhlciB0aGUgb3BlcmF0aW9uIHNob3VsZCBhbmltYXRlLCBvciBvY2N1ciBzeW5jcm9ub3VzbHkgd2l0aCBubyBhbmltYXRpb24uIGB0cnVlYCBieSBkZWZhdWx0LlxuICAgICAgICAgKiBAcGFyYW0gICAgICAge2Z1bmN0aW9ufSAgW2NhbGxiYWNrPW51bGxdXG4gICAgICAgICAqICAgICAgQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAqIEByZXR1cm4gICAgICB7UHJvbWlzZS48bWl4aXR1cC5TdGF0ZT59XG4gICAgICAgICAqICAgICAgQSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9iamVjdC5cbiAgICAgICAgICovXG5cbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBzZWxmLnBhcnNlRmlsdGVyQXJncyhhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5tdWx0aW1peCh7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiBpbnN0cnVjdGlvbi5jb21tYW5kXG4gICAgICAgICAgICB9LCBpbnN0cnVjdGlvbi5hbmltYXRlLCBpbnN0cnVjdGlvbi5jYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYW4gYWRkaXRpb25hbCBzZWxlY3RvciB0byB0aGUgY3VycmVudGx5IGFjdGl2ZSBmaWx0ZXIgc2VsZWN0b3IsIGNvbmNhdGVuYXRpbmdcbiAgICAgICAgICogYXMgcGVyIHRoZSBsb2dpYyBkZWZpbmVkIGluIGBjb250cm9scy50b2dnbGVMb2dpY2AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC50b2dnbGVPbihzZWxlY3RvciBbLCBhbmltYXRlXSBbLCBjYWxsYmFja10pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGU6IFRvZ2dsaW5nIG9uIGEgZmlsdGVyIHNlbGVjdG9yPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhtaXhlci5nZXRTdGF0ZSgpLmFjdGl2ZUZpbHRlci5zZWxlY3Rvcik7IC8vICcuY2F0ZWdvcnktYSdcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIudG9nZ2xlT24oJy5jYXRlZ29yeS1iJylcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlRmlsdGVyLnNlbGVjdG9yKTsgLy8gJy5jYXRlZ29yeS1hLCAuY2F0ZWdvcnktYidcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgIHNlbGVjdG9yXG4gICAgICAgICAqICAgICAgQW55IHZhbGlkIENTUyBzZWxlY3RvciAoaS5lLiBgJy5jYXRlZ29yeS1hJ2ApXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7Ym9vbGVhbn0gICBbYW5pbWF0ZT10cnVlXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzaG91bGQgYW5pbWF0ZSwgb3Igb2NjdXIgc3luY3Jvbm91c2x5IHdpdGggbm8gYW5pbWF0aW9uLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtmdW5jdGlvbn0gIFtjYWxsYmFjaz1udWxsXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2UuPG1peGl0dXAuU3RhdGU+fVxuICAgICAgICAgKiAgICAgIEEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRvZ2dsZU9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uICAgICA9IHNlbGYucGFyc2VGaWx0ZXJBcmdzKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgICAgICAgID0gaW5zdHJ1Y3Rpb24uY29tbWFuZC5zZWxlY3RvcixcbiAgICAgICAgICAgICAgICB0b2dnbGVTZWxlY3RvciAgPSAnJztcblxuICAgICAgICAgICAgc2VsZi5pc1RvZ2dsaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHNlbGYudG9nZ2xlQXJyYXkuaW5kZXhPZihzZWxlY3RvcikgPCAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi50b2dnbGVBcnJheS5wdXNoKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9nZ2xlU2VsZWN0b3IgPSBzZWxmLmdldFRvZ2dsZVNlbGVjdG9yKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLm11bHRpbWl4KHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHRvZ2dsZVNlbGVjdG9yXG4gICAgICAgICAgICB9LCBpbnN0cnVjdGlvbi5hbmltYXRlLCBpbnN0cnVjdGlvbi5jYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBzZWxlY3RvciBmcm9tIHRoZSBhY3RpdmUgZmlsdGVyIHNlbGVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAudG9nZ2xlT2ZmKHNlbGVjdG9yIFssIGFuaW1hdGVdIFssIGNhbGxiYWNrXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogVG9nZ2xpbmcgb2ZmIGEgZmlsdGVyIHNlbGVjdG9yPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhtaXhlci5nZXRTdGF0ZSgpLmFjdGl2ZUZpbHRlci5zZWxlY3Rvcik7IC8vICcuY2F0ZWdvcnktYSwgLmNhdGVnb3J5LWInXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnRvZ2dsZU9mZignLmNhdGVnb3J5LWInKVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5hY3RpdmVGaWx0ZXIuc2VsZWN0b3IpOyAvLyAnLmNhdGVnb3J5LWEnXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICBzZWxlY3RvclxuICAgICAgICAgKiAgICAgIEFueSB2YWxpZCBDU1Mgc2VsZWN0b3IgKGkuZS4gYCcuY2F0ZWdvcnktYSdgKVxuICAgICAgICAgKiBAcGFyYW0gICAgICAge2Jvb2xlYW59ICAgW2FuaW1hdGU9dHJ1ZV1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIHRoZSBvcGVyYXRpb24gc2hvdWxkIGFuaW1hdGUsIG9yIG9jY3VyIHN5bmNyb25vdXNseSB3aXRoIG5vIGFuaW1hdGlvbi4gYHRydWVgIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7ZnVuY3Rpb259ICBbY2FsbGJhY2s9bnVsbF1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICogQHJldHVybiAgICAgIHtQcm9taXNlLjxtaXhpdHVwLlN0YXRlPn1cbiAgICAgICAgICogICAgICBBIHByb21pc2UgcmVzb2x2aW5nIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2JqZWN0LlxuICAgICAgICAgKi9cblxuICAgICAgICB0b2dnbGVPZmY6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gICAgID0gc2VsZi5wYXJzZUZpbHRlckFyZ3MoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvciAgICAgICAgPSBpbnN0cnVjdGlvbi5jb21tYW5kLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9ySW5kZXggICA9IHNlbGYudG9nZ2xlQXJyYXkuaW5kZXhPZihzZWxlY3RvciksXG4gICAgICAgICAgICAgICAgdG9nZ2xlU2VsZWN0b3IgID0gJyc7XG5cbiAgICAgICAgICAgIHNlbGYuaXNUb2dnbGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RvckluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRvZ2dsZUFycmF5LnNwbGljZShzZWxlY3RvckluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9nZ2xlU2VsZWN0b3IgPSBzZWxmLmdldFRvZ2dsZVNlbGVjdG9yKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLm11bHRpbWl4KHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHRvZ2dsZVNlbGVjdG9yXG4gICAgICAgICAgICB9LCBpbnN0cnVjdGlvbi5hbmltYXRlLCBpbnN0cnVjdGlvbi5jYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvcnRzIGFsbCB0YXJnZXRzIGluIHRoZSBjb250YWluZXIgYWNjb3JkaW5nIHRvIGEgcHJvdmlkZWQgc29ydCBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5zb3J0KHNvcnRTdHJpbmcgWywgYW5pbWF0ZV0gWywgY2FsbGJhY2tdKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IFNvcnRpbmcgYnkgdGhlIGRlZmF1bHQgRE9NIG9yZGVyPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBSZXZlcnNlIHRoZSBkZWZhdWx0IG9yZGVyIG9mIHRoZSB0YXJnZXRzXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnNvcnQoJ2RlZmF1bHQ6ZGVzYycpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLmFjdGl2ZVNvcnQuYXR0cmlidXRlID09PSAnZGVmYXVsdCcpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlU29ydC5vcmRlciA9PT0gJ2Rlc2MnKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogU29ydGluZyBieSBhIGN1c3RvbSBkYXRhLWF0dHJpYnV0ZTwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogLy8gU29ydCB0aGUgdGFyZ2V0cyBieSB0aGUgdmFsdWUgb2YgYSBgZGF0YS1wdWJsaXNoZWQtZGF0ZWAgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnNvcnQoJ3B1Ymxpc2hlZC1kYXRlOmFzYycpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLmFjdGl2ZVNvcnQuYXR0cmlidXRlID09PSAncHVibGlzaGVkLWRhdGUnKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLmFjdGl2ZVNvcnQub3JkZXIgPT09ICdhc2MnKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMzogU29ydGluZyBieSBtdWx0aXBsZSBhdHRyaWJ1dGVzPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBTb3J0IHRoZSB0YXJnZXRzIGJ5IHRoZSB2YWx1ZSBvZiBhIGBkYXRhLXB1Ymxpc2hlZC1kYXRlYCBhdHRyaWJ1dGUsIHRoZW4gYnkgYGRhdGEtdGl0bGVgXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnNvcnQoJ3B1Ymxpc2hlZC1kYXRlOmRlc2MgZGF0YS10aXRsZTphc2MnKVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5hY3RpdmVTb3J0LmF0dHJpYnV0ZSA9PT0gJ3B1Ymxpc2hlZC1kYXRlJyk7IC8vIHRydWVcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5hY3RpdmVTb3J0Lm9yZGVyID09PSAnZGVzYycpOyAvLyB0cnVlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlU29ydC5uZXh0LmF0dHJpYnV0ZSA9PT0gJ3RpdGxlJyk7IC8vIHRydWVcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5hY3RpdmVTb3J0Lm5leHQub3JkZXIgPT09ICdhc2MnKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgNDogU29ydGluZyBieSByYW5kb208L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnNvcnQoJ3JhbmRvbScpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLmFjdGl2ZVNvcnQub3JkZXIgPT09ICdyYW5kb20nKSAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSA1OiBTb3J0aW5nIHZpYSBhbiBlbGVtZW50IGNvbGxlY3Rpb248L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBjb2xsZWN0aW9uID0gQXJyYXkuZnJvbShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLm1peCcpKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gU3dhcCB0aGUgcG9zaXRpb24gb2YgdHdvIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uOlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgdGVtcCA9IGNvbGxlY3Rpb25bMV07XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbGxlY3Rpb25bMV0gPSBjb2xsZWN0aW9uWzBdO1xuICAgICAgICAgKiBjb2xsZWN0aW9uWzBdID0gdGVtcDtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gUGFzcyB0aGUgc29ydGVkIGNvbGxlY3Rpb24gdG8gTWl4SXRVcFxuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5zb3J0KGNvbGxlY3Rpb24pXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnRhcmdldHNbMF0gPT09IGNvbGxlY3Rpb25bMF0pOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgICAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7KHN0cmluZ3xBcnJheS48SFRNTEVsZW1lbnQ+KX0gICAgc29ydFN0cmluZ1xuICAgICAgICAgKiAgICAgIEEgdmFsaWQgc29ydCBzdHJpbmcgKGUuZy4gYCdkZWZhdWx0J2AsIGAncHVibGlzaGVkLWRhdGU6YXNjJ2AsIG9yIGAncmFuZG9tJ2ApLiBUaGUgc29ydCBtZXRob2QgYWxzbyBhY2NlcHRzIGFuIGFycmF5IG9mIGFsbCB0YXJnZXQgZWxlbWVudHMgaW4gYSB1c2VyLWRlZmluZWQgb3JkZXIuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7Ym9vbGVhbn0gICBbYW5pbWF0ZT10cnVlXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzaG91bGQgYW5pbWF0ZSwgb3Igb2NjdXIgc3luY3Jvbm91c2x5IHdpdGggbm8gYW5pbWF0aW9uLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtmdW5jdGlvbn0gIFtjYWxsYmFjaz1udWxsXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2UuPG1peGl0dXAuU3RhdGU+fVxuICAgICAgICAgKiAgICAgIEEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICAgICAqL1xuXG4gICAgICAgIHNvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbiA9IHNlbGYucGFyc2VTb3J0QXJncyhhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5tdWx0aW1peCh7XG4gICAgICAgICAgICAgICAgc29ydDogaW5zdHJ1Y3Rpb24uY29tbWFuZFxuICAgICAgICAgICAgfSwgaW5zdHJ1Y3Rpb24uYW5pbWF0ZSwgaW5zdHJ1Y3Rpb24uY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2VzIHRoZSBsYXlvdXQgb2YgdGhlIGNvbnRhaW5lciBieSBhZGRpbmcsIHJlbW92aW5nIG9yIHVwZGF0aW5nIGFcbiAgICAgICAgICogbGF5b3V0LXNwZWNpZmljIGNsYXNzIG5hbWUuIElmIGBhbmltYXRpb24uYW5pbWF0ZVJlc2l6ZXRhcmdldHNgIGlzXG4gICAgICAgICAqIGVuYWJsZWQsIE1peEl0VXAgd2lsbCBhdHRlbXB0IHRvIGdyYWNlZnVsbHkgYW5pbWF0ZSB0aGUgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICogYW5kIHBvc2l0aW9uIG9mIHRhcmdldHMgYmV0d2VlbiBsYXlvdXQgc3RhdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAuY2hhbmdlTGF5b3V0KGNvbnRhaW5lckNsYXNzTmFtZSBbLCBhbmltYXRlXSBbLCBjYWxsYmFja10pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogQWRkaW5nIGEgbmV3IGNsYXNzIG5hbWUgdG8gdGhlIGNvbnRhaW5lcjwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuY2hhbmdlTGF5b3V0KCdjb250YWluZXItbGlzdCcpXG4gICAgICAgICAqICAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlQ29udGFpbmVyQ2xhc3MgPT09ICdjb250YWluZXItbGlzdCcpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogUmVtb3ZpbmcgYSBwcmV2aW91c2x5IGFkZGVkIGNsYXNzIG5hbWUgZnJvbSB0aGUgY29udGFpbmVyPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5jaGFuZ2VMYXlvdXQoJycpXG4gICAgICAgICAqICAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlQ29udGFpbmVyQ2xhc3MgPT09ICcnKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgIGNvbnRhaW5lckNsYXNzTmFtZVxuICAgICAgICAgKiAgICAgIEEgbGF5b3V0LXNwZWNpZmljIGNsYXNzIG5hbWUgdG8gYWRkIHRvIHRoZSBjb250YWluZXIuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7Ym9vbGVhbn0gICBbYW5pbWF0ZT10cnVlXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzaG91bGQgYW5pbWF0ZSwgb3Igb2NjdXIgc3luY3Jvbm91c2x5IHdpdGggbm8gYW5pbWF0aW9uLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtmdW5jdGlvbn0gIFtjYWxsYmFjaz1udWxsXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2UuPG1peGl0dXAuU3RhdGU+fVxuICAgICAgICAgKiAgICAgIEEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICAgICAqL1xuXG4gICAgICAgIGNoYW5nZUxheW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uID0gc2VsZi5wYXJzZUNoYW5nZUxheW91dEFyZ3MoYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYubXVsdGltaXgoe1xuICAgICAgICAgICAgICAgIGNoYW5nZUxheW91dDogaW5zdHJ1Y3Rpb24uY29tbWFuZFxuICAgICAgICAgICAgfSwgaW5zdHJ1Y3Rpb24uYW5pbWF0ZSwgaW5zdHJ1Y3Rpb24uY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBjb250ZW50cyBhbmQgb3JkZXIgb2YgdGhlIGNvbnRhaW5lciB0byByZWZsZWN0IHRoZSBwcm92aWRlZCBkYXRhc2V0LFxuICAgICAgICAgKiBpZiB0aGUgZGF0YXNldCBBUEkgaXMgaW4gdXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZGF0YXNldCBBUEkgaXMgZGVzaWduZWQgZm9yIHVzZSBpbiBBUEktZHJpdmVuIEphdmFTY3JpcHQgYXBwbGljYXRpb25zLCBhbmRcbiAgICAgICAgICogY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBET00tYmFzZWQgbWV0aG9kcyBzdWNoIGFzIGAuZmlsdGVyKClgLCBgLnNvcnQoKWAsXG4gICAgICAgICAqIGAuaW5zZXJ0KClgLCBldGMuIFdoZW4gdXNlZCwgaW5zZXJ0aW9uLCByZW1vdmFsLCBzb3J0aW5nIGFuZCBwYWdpbmF0aW9uIGNhbiBiZVxuICAgICAgICAgKiBhY2hpZXZlZCBwdXJlbHkgdmlhIGNoYW5nZXMgdG8geW91ciBkYXRhIG1vZGVsLCB3aXRob3V0IHRoZSB1Z2x5bmVzcyBvZiBoYXZpbmdcbiAgICAgICAgICogdG8gaW50ZXJhY3Qgd2l0aCBvciBxdWVyeSB0aGUgRE9NIGRpcmVjdGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAuZGF0YXNldChkYXRhc2V0IFssIGFuaW1hdGVdIFssIGNhbGxiYWNrXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAxOiBSZW5kZXJpbmcgYSBkYXRhc2V0PC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbXlEYXRhc2V0ID0gW1xuICAgICAgICAgKiAgICAge2lkOiAxLCAuLi59LFxuICAgICAgICAgKiAgICAge2lkOiAyLCAuLi59LFxuICAgICAgICAgKiAgICAge2lkOiAzLCAuLi59XG4gICAgICAgICAqIF07XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmRhdGFzZXQobXlEYXRhc2V0KVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS50b3RhbFNob3cgPT09IDMpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAyOiBTb3J0aW5nIGEgZGF0YXNldDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQ3JlYXRlIGEgbmV3IGRhdGFzZXQgaW4gcmV2ZXJzZSBvcmRlclxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbmV3RGF0YXNldCA9IG15RGF0YXNldC5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuZGF0YXNldChuZXdEYXRhc2V0KVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5hY3RpdmVEYXRhc2V0WzBdID09PSBteURhdGFzZXRbMl0pOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAzOiBSZW1vdmluZyBhbiBpdGVtIGZyb20gdGhlIGRhdGFzZXQ8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG15RGF0YXNldC5sZW5ndGgpOyAvLyAzXG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIENyZWF0ZSBhIG5ldyBkYXRhc2V0IHdpdGggdGhlIGxhc3QgaXRlbSByZW1vdmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbmV3RGF0YXNldCA9IG15RGF0YXNldC5zbGljZSgpLnBvcCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5kYXRhc2V0KG5ld0RhdGFzZXQpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnRvdGFsU2hvdyA9PT0gMik7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHtBcnJheS48b2JqZWN0Pn0gICAgZGF0YXNldFxuICAgICAgICAgKiAgICAgIEFuIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb25lIHJlcHJlc2VudGluZyB0aGUgdW5kZXJseWluZyBkYXRhIG1vZGVsIG9mIGEgdGFyZ2V0IHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICAgKiBAcGFyYW0gICAgICAge2Jvb2xlYW59ICAgICAgICAgICBbYW5pbWF0ZT10cnVlXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzaG91bGQgYW5pbWF0ZSwgb3Igb2NjdXIgc3luY3Jvbm91c2x5IHdpdGggbm8gYW5pbWF0aW9uLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtmdW5jdGlvbn0gICAgICAgICAgW2NhbGxiYWNrPW51bGxdXG4gICAgICAgICAqICAgICAgQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAqIEByZXR1cm4gICAgICB7UHJvbWlzZS48bWl4aXR1cC5TdGF0ZT59XG4gICAgICAgICAqICAgICAgQSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9iamVjdC5cbiAgICAgICAgICovXG5cbiAgICAgICAgZGF0YXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uID0gc2VsZi5wYXJzZURhdGFzZXRBcmdzKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIHF1ZXVlSXRlbSAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBhbmltYXRlICAgICA9IGZhbHNlO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVEYXRhc2V0JywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKCFzZWxmLmlzQnVzeSkge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5jYWxsYmFjaykgc2VsZi51c2VyQ2FsbGJhY2sgPSBpbnN0cnVjdGlvbi5jYWxsYmFjaztcblxuICAgICAgICAgICAgICAgIGFuaW1hdGUgPSAoaW5zdHJ1Y3Rpb24uYW5pbWF0ZSBeIHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGUpID8gaW5zdHJ1Y3Rpb24uYW5pbWF0ZSA6IHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGU7XG5cbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBzZWxmLmdldERhdGFPcGVyYXRpb24oaW5zdHJ1Y3Rpb24uY29tbWFuZC5kYXRhc2V0KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdvTWl4KGFuaW1hdGUsIG9wZXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlSXRlbSA9IG5ldyBtaXhpdHVwLlF1ZXVlSXRlbSgpO1xuXG4gICAgICAgICAgICAgICAgcXVldWVJdGVtLmFyZ3MgICAgICAgICAgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgcXVldWVJdGVtLmluc3RydWN0aW9uICAgPSBpbnN0cnVjdGlvbjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnF1ZXVlTWl4KHF1ZXVlSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIHNpbXVsdGFuZW91cyBgZmlsdGVyYCwgYHNvcnRgLCBgaW5zZXJ0YCwgYHJlbW92ZWAgYW5kIGBjaGFuZ2VMYXlvdXRgXG4gICAgICAgICAqIG9wZXJhdGlvbnMgYXMgcmVxdWVzdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAubXVsdGltaXgobXVsdGltaXhDb21tYW5kIFssIGFuaW1hdGVdIFssIGNhbGxiYWNrXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAxOiBQZXJmb3JtaW5nIHNpbXVsdGFuZW91cyBmaWx0ZXJpbmcgYW5kIHNvcnRpbmc8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLm11bHRpbWl4KHtcbiAgICAgICAgICogICAgIGZpbHRlcjogJy5jYXRlZ29yeS1iJyxcbiAgICAgICAgICogICAgIHNvcnQ6ICdwdWJsaXNoZWQtZGF0ZTpkZXNjJ1xuICAgICAgICAgKiB9KVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5hY3RpdmVGaWx0ZXIuc2VsZWN0b3IgPT09ICcuY2F0ZWdvcnktYicpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlU29ydC5hdHRyaWJ1dGUgPT09ICdwdWJsaXNoZWQtZGF0ZScpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAyOiBQZXJmb3JtaW5nIHNpbXVsdGFuZW91cyBzb3J0aW5nLCBpbnNlcnRpb24sIGFuZCByZW1vdmFsPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhtaXhlci5nZXRTdGF0ZSgpLnRvdGFsU2hvdyk7IC8vIDZcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gTkI6IFdoZW4gaW5zZXJ0aW5nIHZpYSBgbXVsdGltaXgoKWAsIGFuIG9iamVjdCBzaG91bGQgYmUgcHJvdmlkZWQgYXMgdGhlIHZhbHVlXG4gICAgICAgICAqIC8vIGZvciB0aGUgYGluc2VydGAgcG9ydGlvbiBvZiB0aGUgY29tbWFuZCwgYWxsb3dpbmcgZm9yIGEgY29sbGVjdGlvbiBvZiBlbGVtZW50c1xuICAgICAgICAgKiAvLyBhbmQgYW4gaW5zZXJ0aW9uIGluZGV4IHRvIGJlIHNwZWNpZmllZC5cbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIubXVsdGltaXgoe1xuICAgICAgICAgKiAgICAgc29ydDogJ3B1Ymxpc2hlZC1kYXRlOmRlc2MnLCAvLyBTb3J0IHRoZSBjb250YWluZXIsIGluY2x1ZGluZyBhbnkgbmV3IGVsZW1lbnRzXG4gICAgICAgICAqICAgICBpbnNlcnQ6IHtcbiAgICAgICAgICogICAgICAgICBjb2xsZWN0aW9uOiBbbmV3RWxlbWVudFJlZmVyZW5jZUEsIG5ld0VsZW1lbnRSZWZlcmVuY2VCXSwgLy8gQWRkIDIgbmV3IGVsZW1lbnRzIGF0IGluZGV4IDVcbiAgICAgICAgICogICAgICAgICBpbmRleDogNVxuICAgICAgICAgKiAgICAgfSxcbiAgICAgICAgICogICAgIHJlbW92ZTogZXhpc3RpbmdFbGVtZW50UmVmZXJlbmNlIC8vIFJlbW92ZSAxIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgICogfSlcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuYWN0aXZlU29ydC5hdHRyaWJ1dGUgPT09ICdwdWJsaXNoZWQtZGF0ZScpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93ID09PSA3KTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgICAgICAyLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICAgICAge29iamVjdH0gICAgbXVsdGltaXhDb21tYW5kXG4gICAgICAgICAqICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgdGhpbmdzIHRvIGRvXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7Ym9vbGVhbn0gICBbYW5pbWF0ZT10cnVlXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzaG91bGQgYW5pbWF0ZSwgb3Igb2NjdXIgc3luY3Jvbm91c2x5IHdpdGggbm8gYW5pbWF0aW9uLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtmdW5jdGlvbn0gIFtjYWxsYmFjaz1udWxsXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2UuPG1peGl0dXAuU3RhdGU+fVxuICAgICAgICAgKiAgICAgIEEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICAgICAqL1xuXG4gICAgICAgIG11bHRpbWl4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGFuaW1hdGUgICAgID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgcXVldWVJdGVtICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uID0gc2VsZi5wYXJzZU11bHRpbWl4QXJncyhhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVNdWx0aW1peCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmICghc2VsZi5pc0J1c3kpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBzZWxmLmdldE9wZXJhdGlvbihpbnN0cnVjdGlvbi5jb21tYW5kKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5jb250cm9scy5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbnRyb2xzIGZvciBBUEkgY2FsbHNcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uY29tbWFuZC5maWx0ZXIgJiYgIXNlbGYuaXNUb2dnbGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXMgd2UgYXJlIG5vdCB0b2dnbGluZywgcmVzZXQgdGhlIHRvZ2dsZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gbmV3IGZpbHRlciBvdmVycmlkZXMgZXhpc3RpbmcgdG9nZ2xlc1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnRvZ2dsZUFycmF5Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJ1aWxkVG9nZ2xlQXJyYXkob3BlcmF0aW9uLmNvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYucXVldWUubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVDb250cm9scyhvcGVyYXRpb24uY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uY2FsbGJhY2spIHNlbGYudXNlckNhbGxiYWNrID0gaW5zdHJ1Y3Rpb24uY2FsbGJhY2s7XG5cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgYWxsb3cgdGhlIGluc3RydWN0aW9uIHRvIG92ZXJyaWRlIHRoZSBpbnN0YW5jZSBzZXR0aW5nXG5cbiAgICAgICAgICAgICAgICBhbmltYXRlID0gKGluc3RydWN0aW9uLmFuaW1hdGUgXiBzZWxmLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlKSA/XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uLmFuaW1hdGUgOlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5jYWxsRmlsdGVycygnb3BlcmF0aW9uTXVsdGltaXgnLCBvcGVyYXRpb24sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nb01peChhbmltYXRlLCBvcGVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWV1ZUl0ZW0gPSBuZXcgbWl4aXR1cC5RdWV1ZUl0ZW0oKTtcblxuICAgICAgICAgICAgICAgIHF1ZXVlSXRlbS5hcmdzICAgICAgICAgICA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBxdWV1ZUl0ZW0uaW5zdHJ1Y3Rpb24gICAgPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgICAgICAgICBxdWV1ZUl0ZW0udHJpZ2dlckVsZW1lbnQgPSBzZWxmLmxhc3RDbGlja2VkO1xuICAgICAgICAgICAgICAgIHF1ZXVlSXRlbS5pc1RvZ2dsaW5nICAgICA9IHNlbGYuaXNUb2dnbGluZztcblxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnF1ZXVlTWl4KHF1ZXVlSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICAgICAgICAgIG11bHRpbWl4Q29tbWFuZFxuICAgICAgICAgKiBAcGFyYW0gICB7Ym9vbGVhbn0gICAgICAgICAgIFtpc1ByZUZldGNoXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBvcGVyYXRpb24gaXMgYmVpbmcgcHJlLWZldGNoZWQgZm9yIGV4ZWN1dGlvbiBhdCBhIGxhdGVyIHRpbWUuXG4gICAgICAgICAqIEByZXR1cm4gIHtPcGVyYXRpb258bnVsbH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0T3BlcmF0aW9uOiBmdW5jdGlvbihtdWx0aW1peENvbW1hbmQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzb3J0Q29tbWFuZCAgICAgICAgID0gbXVsdGltaXhDb21tYW5kLnNvcnQsXG4gICAgICAgICAgICAgICAgZmlsdGVyQ29tbWFuZCAgICAgICA9IG11bHRpbWl4Q29tbWFuZC5maWx0ZXIsXG4gICAgICAgICAgICAgICAgY2hhbmdlTGF5b3V0Q29tbWFuZCA9IG11bHRpbWl4Q29tbWFuZC5jaGFuZ2VMYXlvdXQsXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ29tbWFuZCAgICAgICA9IG11bHRpbWl4Q29tbWFuZC5yZW1vdmUsXG4gICAgICAgICAgICAgICAgaW5zZXJ0Q29tbWFuZCAgICAgICA9IG11bHRpbWl4Q29tbWFuZC5pbnNlcnQsXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uICAgICAgICAgICA9IG5ldyBtaXhpdHVwLk9wZXJhdGlvbigpO1xuXG4gICAgICAgICAgICBvcGVyYXRpb24gPSBzZWxmLmNhbGxGaWx0ZXJzKCdvcGVyYXRpb25Vbm1hcHBlZEdldE9wZXJhdGlvbicsIG9wZXJhdGlvbiwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgb3BlcmF0aW9uLmlkICAgICAgICAgICAgICAgID0gaC5yYW5kb21IZXgoKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5jb21tYW5kICAgICAgICAgICA9IG11bHRpbWl4Q29tbWFuZDtcbiAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydFN0YXRlICAgICAgICA9IHNlbGYuc3RhdGU7XG4gICAgICAgICAgICBvcGVyYXRpb24udHJpZ2dlckVsZW1lbnQgICAgPSBzZWxmLmxhc3RDbGlja2VkO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5pc0J1c3kpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZGVidWcuc2hvd1dhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihtaXhpdHVwLm1lc3NhZ2VzLndhcm5pbmdHZXRPcGVyYXRpb25JbnN0YW5jZUJ1c3koKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnNlcnRDb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnNlcnRUYXJnZXRzKGluc2VydENvbW1hbmQsIG9wZXJhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW1vdmVDb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnRvUmVtb3ZlID0gcmVtb3ZlQ29tbWFuZC50YXJnZXRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcGVyYXRpb24uc3RhcnRTb3J0ID0gb3BlcmF0aW9uLm5ld1NvcnQgPSBvcGVyYXRpb24uc3RhcnRTdGF0ZS5hY3RpdmVTb3J0O1xuICAgICAgICAgICAgb3BlcmF0aW9uLnN0YXJ0T3JkZXIgPSBvcGVyYXRpb24ubmV3T3JkZXIgPSBzZWxmLnRhcmdldHM7XG5cbiAgICAgICAgICAgIGlmIChzb3J0Q29tbWFuZCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydFNvcnQgPSBvcGVyYXRpb24uc3RhcnRTdGF0ZS5hY3RpdmVTb3J0O1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdTb3J0ICAgPSBzb3J0Q29tbWFuZDtcblxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi53aWxsU29ydCA9IHNlbGYud2lsbFNvcnQoc29ydENvbW1hbmQsIG9wZXJhdGlvbi5zdGFydFN0YXRlLmFjdGl2ZVNvcnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi53aWxsU29ydCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNvcnRPcGVyYXRpb24ob3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5zdGFydEZpbHRlciA9IG9wZXJhdGlvbi5zdGFydFN0YXRlLmFjdGl2ZUZpbHRlcjtcblxuICAgICAgICAgICAgaWYgKGZpbHRlckNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ubmV3RmlsdGVyID0gZmlsdGVyQ29tbWFuZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLm5ld0ZpbHRlciA9IGguZXh0ZW5kKG5ldyBtaXhpdHVwLkNvbW1hbmRGaWx0ZXIoKSwgb3BlcmF0aW9uLnN0YXJ0RmlsdGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5uZXdGaWx0ZXIuc2VsZWN0b3IgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLm5ld0ZpbHRlci5zZWxlY3RvciA9IHNlbGYuY29uZmlnLnNlbGVjdG9ycy50YXJnZXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5uZXdGaWx0ZXIuc2VsZWN0b3IgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdGaWx0ZXIuc2VsZWN0b3IgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5maWx0ZXJPcGVyYXRpb24ob3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgb3BlcmF0aW9uLnN0YXJ0Q29udGFpbmVyQ2xhc3NOYW1lID0gb3BlcmF0aW9uLnN0YXJ0U3RhdGUuYWN0aXZlQ29udGFpbmVyQ2xhc3NOYW1lO1xuXG4gICAgICAgICAgICBpZiAoY2hhbmdlTGF5b3V0Q29tbWFuZCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdDb250YWluZXJDbGFzc05hbWUgPSBjaGFuZ2VMYXlvdXRDb21tYW5kLmNvbnRhaW5lckNsYXNzTmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ubmV3Q29udGFpbmVyQ2xhc3NOYW1lICE9PSBvcGVyYXRpb24uc3RhcnRDb250YWluZXJDbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLndpbGxDaGFuZ2VMYXlvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLm5ld0NvbnRhaW5lckNsYXNzTmFtZSA9IG9wZXJhdGlvbi5zdGFydENvbnRhaW5lckNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFuaW1hdGlvbi5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgb3BlcmF0aW9uJ3MgcG9zaXRpb24gZGF0YVxuXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRTdGFydE1peERhdGEob3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNldEludGVyKG9wZXJhdGlvbik7XG5cbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uZG9jU3RhdGUgPSBoLmdldERvY3VtZW50U3RhdGUoc2VsZi5kb20uZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRJbnRlck1peERhdGEob3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNldEZpbmFsKG9wZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgc2VsZi5nZXRGaW5hbE1peERhdGEob3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgICAgIHNlbGYucGFyc2VFZmZlY3RzKCk7XG5cbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uaGFzRWZmZWN0ID0gc2VsZi5oYXNFZmZlY3QoKTtcblxuICAgICAgICAgICAgICAgIHNlbGYuZ2V0VHdlZW5EYXRhKG9wZXJhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ud2lsbFNvcnQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRhcmdldHMgPSBvcGVyYXRpb24ubmV3T3JkZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wZXJhdGlvbi5uZXdTdGF0ZSA9IHNlbGYuYnVpbGRTdGF0ZShvcGVyYXRpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsRmlsdGVycygnb3BlcmF0aW9uTWFwcGVkR2V0T3BlcmF0aW9uJywgb3BlcmF0aW9uLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXJzIGEgcHJldmlvdXNseSBjcmVhdGVkIG9wZXJhdGlvbiBhdCBhIHNwZWNpZmljIHBvaW50IGluIGl0cyBwYXRoLCBhc1xuICAgICAgICAgKiBkZXRlcm1pbmVkIGJ5IGEgbXVsdGlwbGllciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC50d2VlbihvcGVyYXRpb24sIG11bHRpcGxpZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7bWl4aXR1cC5PcGVyYXRpb259ICAgICBvcGVyYXRpb25cbiAgICAgICAgICogICAgICBBbiBvcGVyYXRpb24gb2JqZWN0IGNyZWF0ZWQgdmlhIHRoZSBgZ2V0T3BlcmF0aW9uYCBtZXRob2RcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICAge0Zsb2F0fSAgICAgICAgICAgICAgICAgbXVsdGlwbGllclxuICAgICAgICAgKiAgICAgIEFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIHJlcHJlc2VudGluZyB0aGUgcGVyY2VudGFnZSBjb21wbGV0ZSBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICB0d2VlbjogZnVuY3Rpb24ob3BlcmF0aW9uLCBtdWx0aXBsaWVyKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ICAgICAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBwb3NEYXRhICAgICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIHRvSGlkZUluZGV4ICAgICA9IC0xLFxuICAgICAgICAgICAgICAgIGkgICAgICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBtdWx0aXBsaWVyID0gTWF0aC5taW4obXVsdGlwbGllciwgMSk7XG4gICAgICAgICAgICBtdWx0aXBsaWVyID0gTWF0aC5tYXgobXVsdGlwbGllciwgMCk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHRhcmdldCA9IG9wZXJhdGlvbi5zaG93W2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwb3NEYXRhID0gb3BlcmF0aW9uLnNob3dQb3NEYXRhW2ldO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGx5VHdlZW4ocG9zRGF0YSwgbXVsdGlwbGllcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IHRhcmdldCA9IG9wZXJhdGlvbi5oaWRlW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzU2hvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoKHRvSGlkZUluZGV4ID0gb3BlcmF0aW9uLnRvSGlkZS5pbmRleE9mKHRhcmdldCkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zRGF0YSA9IG9wZXJhdGlvbi50b0hpZGVQb3NEYXRhW3RvSGlkZUluZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5pc1Nob3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGx5VHdlZW4ocG9zRGF0YSwgbXVsdGlwbGllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIG9uZSBvciBtb3JlIG5ldyB0YXJnZXQgZWxlbWVudHMgaW50byB0aGUgY29udGFpbmVyIGF0IGEgc3BlY2lmaWVkXG4gICAgICAgICAqIGluZGV4LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyBiZSBpbmRleGVkIGFzIHRhcmdldHMsIG5ldyBlbGVtZW50cyBtdXN0IG1hdGNoIHRoZSBgc2VsZWN0b3JzLnRhcmdldGBcbiAgICAgICAgICogc2VsZWN0b3IgKGAnLm1peCdgIGJ5IGRlZmF1bHQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAuaW5zZXJ0KG5ld0VsZW1lbnRzIFssIGluZGV4XSBbLCBhbmltYXRlXSwgWywgY2FsbGJhY2tdKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IEluc2VydGluZyBhIHNpbmdsZSBlbGVtZW50IHZpYSByZWZlcmVuY2U8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG1peGVyLmdldFN0YXRlKCkudG90YWxTaG93KTsgLy8gMFxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBDcmVhdGUgYSBuZXcgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbmV3RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgKiBuZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ21peCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5pbnNlcnQobmV3RWxlbWVudClcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93ID09PSAxKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMjogSW5zZXJ0aW5nIGEgc2luZ2xlIGVsZW1lbnQgdmlhIEhUTUwgc3RyaW5nPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhtaXhlci5nZXRTdGF0ZSgpLnRvdGFsU2hvdyk7IC8vIDFcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQ3JlYXRlIGEgbmV3IGVsZW1lbnQgdmlhIHJlZmVyZW5jZVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbmV3RWxlbWVudEh0bWwgPSAnJmx0O2RpdiBjbGFzcz1cIm1peFwiJmd0OyZsdDsvZGl2Jmd0Oyc7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIENyZWF0ZSBhbmQgaW5zZXJ0IHRoZSBuZXcgZWxlbWVudCBhdCBpbmRleCAxXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmluc2VydChuZXdFbGVtZW50SHRtbCwgMSlcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93ID09PSAyKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnNob3dbMV0ub3V0ZXJIVE1MID09PSBuZXdFbGVtZW50SHRtbCk7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDM6IEluc2VydGluZyBtdWx0aXBsZSBlbGVtZW50cyB2aWEgcmVmZXJlbmNlPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhtaXhlci5nZXRTdGF0ZSgpLnRvdGFsU2hvdyk7IC8vIDJcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQ3JlYXRlIGFuIGFycmF5IG9mIG5ldyBlbGVtZW50cyB0byBpbnNlcnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBuZXdFbGVtZW50MSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgKiB2YXIgbmV3RWxlbWVudDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogbmV3RWxlbWVudDEuY2xhc3NMaXN0LmFkZCgnbWl4Jyk7XG4gICAgICAgICAqIG5ld0VsZW1lbnQyLmNsYXNzTGlzdC5hZGQoJ21peCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbmV3RWxlbWVudHNDb2xsZWN0aW9uID0gW25ld0VsZW1lbnQxLCBuZXdFbGVtZW50Ml07XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEluc2VydCB0aGUgbmV3IGVsZW1lbnRzIHN0YXJ0aW5nIGF0IGluZGV4IDFcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuaW5zZXJ0KG5ld0VsZW1lbnRzQ29sbGVjdGlvbiwgMSlcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudG90YWxTaG93ID09PSA0KTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnNob3dbMV0gPT09IG5ld0VsZW1lbnQxKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnNob3dbMl0gPT09IG5ld0VsZW1lbnQyKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgNDogSW5zZXJ0aW5nIGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2JqZWN0IGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgZWxlbWVudHM8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG1peGVyLmdldFN0YXRlKCkudG90YWxTaG93KTsgLy8gNFxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgJG5ld0VsZW1lbnQgPSAkKCcmbHQ7ZGl2IGNsYXNzPVwibWl4XCImZ3Q7Jmx0Oy9kaXYmZ3Q7Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEluc2VydCB0aGUgbmV3IGVsZW1lbnRzIHN0YXJ0aW5nIGF0IGluZGV4IDNcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuaW5zZXJ0KCRuZXdFbGVtZW50LCAzKVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS50b3RhbFNob3cgPT09IDUpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuc2hvd1szXSA9PT0gJG5ld0VsZW1lbnRbMF0pOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgICAgIDIuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7KEhUTUxFbGVtZW50fEFycmF5LjxIVE1MRWxlbWVudD58c3RyaW5nKX0gICAgbmV3RWxlbWVudHNcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byBhIHNpbmdsZSBlbGVtZW50IHRvIGluc2VydCwgYW4gYXJyYXktbGlrZSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzLCBvciBhbiBIVE1MIHN0cmluZyByZXByZXNlbnRpbmcgYSBzaW5nbGUgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgIGluZGV4PTBcbiAgICAgICAgICogICAgICBUaGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBuZXcgZWxlbWVudChzKS4gYDBgIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7Ym9vbGVhbn0gICBbYW5pbWF0ZT10cnVlXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzaG91bGQgYW5pbWF0ZSwgb3Igb2NjdXIgc3luY3Jvbm91c2x5IHdpdGggbm8gYW5pbWF0aW9uLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtmdW5jdGlvbn0gIFtjYWxsYmFjaz1udWxsXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2UuPG1peGl0dXAuU3RhdGU+fVxuICAgICAgICAgKiAgICAgIEEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICAgICAqL1xuXG4gICAgICAgIGluc2VydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncyA9IHNlbGYucGFyc2VJbnNlcnRBcmdzKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLm11bHRpbWl4KHtcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IGFyZ3MuY29tbWFuZFxuICAgICAgICAgICAgfSwgYXJncy5hbmltYXRlLCBhcmdzLmNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyBvbmUgb3IgbW9yZSBuZXcgZWxlbWVudHMgYmVmb3JlIGEgcHJvdmlkZWQgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5pbnNlcnRCZWZvcmUobmV3RWxlbWVudHMsIHJlZmVyZW5jZUVsZW1lbnQgWywgYW5pbWF0ZV0gWywgY2FsbGJhY2tdKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBJbnNlcnRpbmcgYSBuZXcgZWxlbWVudCBiZWZvcmUgYSByZWZlcmVuY2UgZWxlbWVudDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQW4gZXhpc3RpbmcgcmVmZXJlbmNlIGVsZW1lbnQgaXMgY2hvc2VuIGF0IGluZGV4IDJcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIHJlZmVyZW5jZUVsZW1lbnQgPSBtaXhlci5nZXRTdGF0ZSgpLnNob3dbMl07XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIENyZWF0ZSBhIG5ldyBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBuZXdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAqIG5ld0VsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbWl4Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmluc2VydEJlZm9yZShuZXdFbGVtZW50LCByZWZlcmVuY2VFbGVtZW50KVxuICAgICAgICAgKiAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICAvLyBUaGUgbmV3IGVsZW1lbnQgaXMgaW5zZXJ0ZWQgaW50byB0aGUgY29udGFpbmVyIGF0IGluZGV4IDIsIGJlZm9yZSB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5zaG93WzJdID09PSBuZXdFbGVtZW50KTsgLy8gdHJ1ZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIC8vIFRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBub3cgYXQgaW5kZXggM1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnNob3dbM10gPT09IHJlZmVyZW5jZUVsZW1lbnQpOyAvLyB0cnVlXG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7KEhUTUxFbGVtZW50fEFycmF5LjxIVE1MRWxlbWVudD58c3RyaW5nKX0gICAgbmV3RWxlbWVudHNcbiAgICAgICAgICogICAgICBBIHJlZmVyZW5jZSB0byBhIHNpbmdsZSBlbGVtZW50IHRvIGluc2VydCwgYW4gYXJyYXktbGlrZSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzLCBvciBhbiBIVE1MIHN0cmluZyByZXByZXNlbnRpbmcgYSBzaW5nbGUgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtIVE1MRWxlbWVudH0gICAgcmVmZXJlbmNlRWxlbWVudFxuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIGFuIGV4aXN0aW5nIGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lciB0byBpbnNlcnQgbmV3IGVsZW1lbnRzIGJlZm9yZS5cbiAgICAgICAgICpAcGFyYW0gICAgICAge2Jvb2xlYW59ICAgW2FuaW1hdGU9dHJ1ZV1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIHRoZSBvcGVyYXRpb24gc2hvdWxkIGFuaW1hdGUsIG9yIG9jY3VyIHN5bmNyb25vdXNseSB3aXRoIG5vIGFuaW1hdGlvbi4gYHRydWVgIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7ZnVuY3Rpb259ICBbY2FsbGJhY2s9bnVsbF1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICogQHJldHVybiAgICAgIHtQcm9taXNlLjxtaXhpdHVwLlN0YXRlPn1cbiAgICAgICAgICogICAgICBBIHByb21pc2UgcmVzb2x2aW5nIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2JqZWN0LlxuICAgICAgICAgKi9cblxuICAgICAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBzZWxmLnBhcnNlSW5zZXJ0QXJncyhhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5pbnNlcnQoYXJncy5jb21tYW5kLmNvbGxlY3Rpb24sICdiZWZvcmUnLCBhcmdzLmNvbW1hbmQuc2libGluZywgYXJncy5hbmltYXRlLCBhcmdzLmNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyBvbmUgb3IgbW9yZSBuZXcgZWxlbWVudHMgYWZ0ZXIgYSBwcm92aWRlZCByZWZlcmVuY2UgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogLmluc2VydEFmdGVyKG5ld0VsZW1lbnRzLCByZWZlcmVuY2VFbGVtZW50IFssIGFuaW1hdGVdIFssIGNhbGxiYWNrXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogSW5zZXJ0aW5nIGEgbmV3IGVsZW1lbnQgYWZ0ZXIgYSByZWZlcmVuY2UgZWxlbWVudDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQW4gZXhpc3RpbmcgcmVmZXJlbmNlIGVsZW1lbnQgaXMgY2hvc2VuIGF0IGluZGV4IDJcbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIHJlZmVyZW5jZUVsZW1lbnQgPSBtaXhlci5nZXRTdGF0ZSgpLnNob3dbMl07XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIENyZWF0ZSBhIG5ldyBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBuZXdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAqIG5ld0VsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbWl4Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmluc2VydEFmdGVyKG5ld0VsZW1lbnQsIHJlZmVyZW5jZUVsZW1lbnQpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIC8vIFRoZSBuZXcgZWxlbWVudCBpcyBpbnNlcnRlZCBpbnRvIHRoZSBjb250YWluZXIgYXQgaW5kZXggMywgYWZ0ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuc2hvd1szXSA9PT0gbmV3RWxlbWVudCk7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHsoSFRNTEVsZW1lbnR8QXJyYXkuPEhUTUxFbGVtZW50PnxzdHJpbmcpfSAgICBuZXdFbGVtZW50c1xuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIGEgc2luZ2xlIGVsZW1lbnQgdG8gaW5zZXJ0LCBhbiBhcnJheS1saWtlIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMsIG9yIGFuIEhUTUwgc3RyaW5nIHJlcHJlc2VudGluZyBhIHNpbmdsZSBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0gICAgICAge0hUTUxFbGVtZW50fSAgICByZWZlcmVuY2VFbGVtZW50XG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gYW4gZXhpc3RpbmcgZWxlbWVudCBpbiB0aGUgY29udGFpbmVyIHRvIGluc2VydCBuZXcgZWxlbWVudHMgYWZ0ZXIuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7Ym9vbGVhbn0gICBbYW5pbWF0ZT10cnVlXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGJvb2xlYW4gZGljdGF0aW5nIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzaG91bGQgYW5pbWF0ZSwgb3Igb2NjdXIgc3luY3Jvbm91c2x5IHdpdGggbm8gYW5pbWF0aW9uLiBgdHJ1ZWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtmdW5jdGlvbn0gIFtjYWxsYmFjaz1udWxsXVxuICAgICAgICAgKiAgICAgIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2UuPG1peGl0dXAuU3RhdGU+fVxuICAgICAgICAgKiAgICAgIEEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICAgICAqL1xuXG4gICAgICAgIGluc2VydEFmdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzID0gc2VsZi5wYXJzZUluc2VydEFyZ3MoYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW5zZXJ0KGFyZ3MuY29tbWFuZC5jb2xsZWN0aW9uLCAnYWZ0ZXInLCBhcmdzLmNvbW1hbmQuc2libGluZywgYXJncy5hbmltYXRlLCBhcmdzLmNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyBvbmUgb3IgbW9yZSBuZXcgZWxlbWVudHMgaW50byB0aGUgY29udGFpbmVyIGJlZm9yZSBhbGwgZXhpc3RpbmcgdGFyZ2V0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogLnByZXBlbmQobmV3RWxlbWVudHMgWyxhbmltYXRlXSBbLGNhbGxiYWNrXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogUHJlcGVuZGluZyBhIG5ldyBlbGVtZW50PC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBDcmVhdGUgYSBuZXcgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgbmV3RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgKiBuZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ21peCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBJbnNlcnQgdGhlIGVsZW1lbnQgaW50byB0aGUgY29udGFpbmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnByZXBlbmQobmV3RWxlbWVudClcbiAgICAgICAgICogICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuc2hvd1swXSA9PT0gbmV3RWxlbWVudCk7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHsoSFRNTEVsZW1lbnR8QXJyYXkuPEhUTUxFbGVtZW50PnxzdHJpbmcpfSAgICBuZXdFbGVtZW50c1xuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIGEgc2luZ2xlIGVsZW1lbnQgdG8gaW5zZXJ0LCBhbiBhcnJheS1saWtlIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMsIG9yIGFuIEhUTUwgc3RyaW5nIHJlcHJlc2VudGluZyBhIHNpbmdsZSBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0gICAgICAge2Jvb2xlYW59ICAgW2FuaW1hdGU9dHJ1ZV1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIHRoZSBvcGVyYXRpb24gc2hvdWxkIGFuaW1hdGUsIG9yIG9jY3VyIHN5bmNyb25vdXNseSB3aXRoIG5vIGFuaW1hdGlvbi4gYHRydWVgIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7ZnVuY3Rpb259ICBbY2FsbGJhY2s9bnVsbF1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICogQHJldHVybiAgICAgIHtQcm9taXNlLjxtaXhpdHVwLlN0YXRlPn1cbiAgICAgICAgICogICAgICBBIHByb21pc2UgcmVzb2x2aW5nIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2JqZWN0LlxuICAgICAgICAgKi9cblxuICAgICAgICBwcmVwZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzID0gc2VsZi5wYXJzZUluc2VydEFyZ3MoYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW5zZXJ0KDAsIGFyZ3MuY29tbWFuZC5jb2xsZWN0aW9uLCBhcmdzLmFuaW1hdGUsIGFyZ3MuY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIG9uZSBvciBtb3JlIG5ldyBlbGVtZW50cyBpbnRvIHRoZSBjb250YWluZXIgYWZ0ZXIgYWxsIGV4aXN0aW5nIHRhcmdldHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5hcHBlbmQobmV3RWxlbWVudHMgWyxhbmltYXRlXSBbLGNhbGxiYWNrXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogQXBwZW5kaW5nIGEgbmV3IGVsZW1lbnQ8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIENyZWF0ZSBhIG5ldyBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBuZXdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAqIG5ld0VsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbWl4Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIEluc2VydCB0aGUgZWxlbWVudCBpbnRvIHRoZSBjb250YWluZXJcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuYXBwZW5kKG5ld0VsZW1lbnQpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnNob3dbc3RhdGUuc2hvdy5sZW5ndGggLSAxXSA9PT0gbmV3RWxlbWVudCk7IC8vIHRydWVcbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHsoSFRNTEVsZW1lbnR8QXJyYXkuPEhUTUxFbGVtZW50PnxzdHJpbmcpfSAgICBuZXdFbGVtZW50c1xuICAgICAgICAgKiAgICAgIEEgcmVmZXJlbmNlIHRvIGEgc2luZ2xlIGVsZW1lbnQgdG8gaW5zZXJ0LCBhbiBhcnJheS1saWtlIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMsIG9yIGFuIEhUTUwgc3RyaW5nIHJlcHJlc2VudGluZyBhIHNpbmdsZSBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0gICAgICAge2Jvb2xlYW59ICAgW2FuaW1hdGU9dHJ1ZV1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIHRoZSBvcGVyYXRpb24gc2hvdWxkIGFuaW1hdGUsIG9yIG9jY3VyIHN5bmNyb25vdXNseSB3aXRoIG5vIGFuaW1hdGlvbi4gYHRydWVgIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7ZnVuY3Rpb259ICBbY2FsbGJhY2s9bnVsbF1cbiAgICAgICAgICogICAgICBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICogQHJldHVybiAgICAgIHtQcm9taXNlLjxtaXhpdHVwLlN0YXRlPn1cbiAgICAgICAgICogICAgICBBIHByb21pc2UgcmVzb2x2aW5nIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2JqZWN0LlxuICAgICAgICAgKi9cblxuICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBzZWxmLnBhcnNlSW5zZXJ0QXJncyhhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5pbnNlcnQoc2VsZi5zdGF0ZS50b3RhbFRhcmdldHMsIGFyZ3MuY29tbWFuZC5jb2xsZWN0aW9uLCBhcmdzLmFuaW1hdGUsIGFyZ3MuY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIG9uZSBvciBtb3JlIGV4aXN0aW5nIHRhcmdldCBlbGVtZW50cyBmcm9tIHRoZSBjb250YWluZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5yZW1vdmUoZWxlbWVudHMgWywgYW5pbWF0ZV0gWywgY2FsbGJhY2tdKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDE6IFJlbW92aW5nIGFuIGVsZW1lbnQgYnkgcmVmZXJlbmNlPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgZWxlbWVudFRvUmVtb3ZlID0gY29udGFpbmVyRWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLnJlbW92ZShlbGVtZW50VG9SZW1vdmUpXG4gICAgICAgICAqICAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICogICAgICAgICAgY29uc29sZS5sb2coc3RhdGUudGFyZ2V0cy5pbmRleE9mKGVsZW1lbnRUb1JlbW92ZSkgPT09IC0xKTsgLy8gdHJ1ZVxuICAgICAgICAgKiAgICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDI6IFJlbW92aW5nIGEgY29sbGVjdGlvbiBvZiBlbGVtZW50cyBieSByZWZlcmVuY2U8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBlbGVtZW50c1RvUmVtb3ZlID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvckFsbCgnLmNhdGVnb3J5LWEnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2coZWxlbWVudHNUb1JlbW92ZS5sZW5ndGgpIC8vIDNcbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIucmVtb3ZlKGVsZW1lbnRzVG9SZW1vdmUpXG4gICAgICAgICAqICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXRlZ29yeS1hJykubGVuZ3RoKTsgLy8gMFxuICAgICAgICAgKiAgICAgIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDM6IFJlbW92aW5nIG9uZSBvciBtb3JlIGVsZW1lbnRzIGJ5IHNlbGVjdG9yPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5yZW1vdmUoJy5jYXRlZ29yeS1hJylcbiAgICAgICAgICogICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICogICAgICAgICAgY29uc29sZS5sb2coY29udGFpbmVyRWwucXVlcnlTZWxlY3RvckFsbCgnLmNhdGVnb3J5LWEnKS5sZW5ndGgpOyAvLyAwXG4gICAgICAgICAqICAgICAgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgNDogUmVtb3ZpbmcgYW4gZWxlbWVudCBieSBpbmRleDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2cobWl4ZXIuZ2V0U3RhdGUudG90YWxTaG93KTsgLy8gNFxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBSZW1vdmUgdGhlIGVsZW1lbnQgYXQgaW5kZXggM1xuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5yZW1vdmUoMylcbiAgICAgICAgICogICAgICAudGhlbihmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS50b3RhbFNob3cpOyAvLyAzXG4gICAgICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnNob3dbM10pOyAvLyB1bmRlZmluZWRcbiAgICAgICAgICogICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7KEhUTUxFbGVtZW50fEFycmF5LjxIVE1MRWxlbWVudD58c3RyaW5nfG51bWJlcil9ICAgIGVsZW1lbnRzXG4gICAgICAgICAqICAgICAgQSByZWZlcmVuY2UgdG8gYSBzaW5nbGUgZWxlbWVudCB0byByZW1vdmUsIGFuIGFycmF5LWxpa2UgY29sbGVjdGlvbiBvZiBlbGVtZW50cywgYSBzZWxlY3RvciBzdHJpbmcsIG9yIHRoZSBpbmRleCBvZiBhbiBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICAgICAgICogQHBhcmFtICAgICAgIHtib29sZWFufSAgIFthbmltYXRlPXRydWVdXG4gICAgICAgICAqICAgICAgQW4gb3B0aW9uYWwgYm9vbGVhbiBkaWN0YXRpbmcgd2hldGhlciB0aGUgb3BlcmF0aW9uIHNob3VsZCBhbmltYXRlLCBvciBvY2N1ciBzeW5jcm9ub3VzbHkgd2l0aCBubyBhbmltYXRpb24uIGB0cnVlYCBieSBkZWZhdWx0LlxuICAgICAgICAgKiBAcGFyYW0gICAgICAge2Z1bmN0aW9ufSAgW2NhbGxiYWNrPW51bGxdXG4gICAgICAgICAqICAgICAgQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAqIEByZXR1cm4gICAgICB7UHJvbWlzZS48bWl4aXR1cC5TdGF0ZT59XG4gICAgICAgICAqICAgICAgQSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9iamVjdC5cbiAgICAgICAgICovXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzID0gc2VsZi5wYXJzZVJlbW92ZUFyZ3MoYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYubXVsdGltaXgoe1xuICAgICAgICAgICAgICAgIHJlbW92ZTogYXJncy5jb21tYW5kXG4gICAgICAgICAgICB9LCBhcmdzLmFuaW1hdGUsIGFyZ3MuY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIHRoZSB2YWx1ZSBvZiBhbnkgcHJvcGVydHkgb3Igc3ViLW9iamVjdCB3aXRoaW4gdGhlIGN1cnJlbnRcbiAgICAgICAgICogbWl4aXR1cCBjb25maWd1cmF0aW9uLCBvciB0aGUgd2hvbGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5nZXRDb25maWcoW3N0cmluZ0tleV0pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogcmV0cmlldmUgdGhlIGVudGlyZSBjb25maWd1cmF0aW9uIG9iamVjdDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGNvbmZpZyA9IG1peGVyLmdldENvbmZpZygpOyAvLyBDb25maWcgeyAuLi4gfVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIDI6IHJldHJpZXZlIGEgbmFtZWQgc3ViLW9iamVjdCBvZiBjb25maWd1cmF0aW9uIG9iamVjdDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGFuaW1hdGlvbiA9IG1peGVyLmdldENvbmZpZygnYW5pbWF0aW9uJyk7IC8vIENvbmZpZ0FuaW1hdGlvbiB7IC4uLiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMzogcmV0cmlldmUgYSB2YWx1ZSBvZiBjb25maWd1cmF0aW9uIG9iamVjdCB2aWEgYSBkb3Qtbm90YXRpb24gc3RyaW5nIGtleTwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGVmZmVjdHMgPSBtaXhlci5nZXRDb25maWcoJ2FuaW1hdGlvbi5lZmZlY3RzJyk7IC8vICdmYWRlIHNjYWxlJ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgIFtzdHJpbmdLZXldICAgIEEgXCJkb3Qtbm90YXRpb25cIiBzdHJpbmcga2V5XG4gICAgICAgICAqIEByZXR1cm4gICAgICB7Kn1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0Q29uZmlnOiBmdW5jdGlvbihzdHJpbmdLZXkpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCFzdHJpbmdLZXkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNlbGYuY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGguZ2V0UHJvcGVydHkoc2VsZi5jb25maWcsIHN0cmluZ0tleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxGaWx0ZXJzKCd2YWx1ZUdldENvbmZpZycsIHZhbHVlLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBtaXhlciwgYWZ0ZXIgaXQgaGFzIGJlZW4gaW5zdGFudGlhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgdGhlIENvbmZpZ3VyYXRpb24gT2JqZWN0IGRvY3VtZW50YXRpb24gZm9yIGEgZnVsbCBsaXN0IG9mIGF2aWxhYmxlXG4gICAgICAgICAqIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogLmNvbmZpZ3VyZShjb25maWcpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkV4YW1wbGUgMTogVXBkYXRpbmcgYW5pbWF0aW9uIG9wdGlvbnM8L2NhcHRpb24+XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmNvbmZpZ3VyZSh7XG4gICAgICAgICAqICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICogICAgICAgICBlZmZlY3RzOiAnZmFkZSB0cmFuc2xhdGVYKC0xMDAlKScsXG4gICAgICAgICAqICAgICAgICAgZHVyYXRpb246IDMwMFxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZSAyOiBSZW1vdmluZyBhIGNhbGxiYWNrIGFmdGVyIGl0IGhhcyBiZWVuIHNldDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIG1peGVyO1xuICAgICAgICAgKlxuICAgICAgICAgKiBmdW5jdGlvbiBoYW5kbGVNaXhFbmRPbmNlKCkge1xuICAgICAgICAgKiAgICAgLy8gRG8gc29tZXRoaW5nIC4uXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBUaGVuIG51bGxpZnkgdGhlIGNhbGxiYWNrXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBtaXhlci5jb25maWd1cmUoe1xuICAgICAgICAgKiAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgKiAgICAgICAgICAgICBvbk1peEVuZDogbnVsbFxuICAgICAgICAgKiAgICAgICAgIH1cbiAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgKiB9O1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBJbnN0YW50aWF0ZSBhIG1peGVyIHdpdGggYSBjYWxsYmFjayBkZWZpbmVkXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyID0gbWl4aXR1cChjb250YWluZXJFbCwge1xuICAgICAgICAgKiAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAqICAgICAgICAgb25NaXhFbmQ6IGhhbmRsZU1peEVuZE9uY2VcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICAgICAge29iamVjdH0gICAgY29uZmlnXG4gICAgICAgICAqICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgb25lIG9mIG1vcmUgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAgICAgKiBAcmV0dXJuICAgICAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbmZpZ3VyZScsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGguZXh0ZW5kKHNlbGYuY29uZmlnLCBjb25maWcsIHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckNvbmZpZ3VyZScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlXG4gICAgICAgICAqIG1peGVyLiBTZWUgdGhlIFN0YXRlIE9iamVjdCBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOQjogU3RhdGUgb2JqZWN0cyBhcmUgaW1tdXRhYmxlIGFuZCBzaG91bGQgdGhlcmVmb3JlIGJlIHJlZ2VuZXJhdGVkXG4gICAgICAgICAqIGFmdGVyIGFueSBvcGVyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5nZXRTdGF0ZSgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBSZXRyaWV2aW5nIGEgc3RhdGUgb2JqZWN0PC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgc3RhdGUgPSBtaXhlci5nZXRTdGF0ZSgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhzdGF0ZS50b3RhbFNob3cgKyAndGFyZ2V0cyBhcmUgY3VycmVudGx5IHNob3duJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgICAgICAyLjAuMFxuICAgICAgICAgKiBAcmV0dXJuICAgICAge21peGl0dXAuU3RhdGV9IEFuIG9iamVjdCByZWZsZWN0aW5nIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBtaXhlci5cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHN0YXRlICAgPSBudWxsO1xuXG4gICAgICAgICAgICBzdGF0ZSA9IG5ldyBtaXhpdHVwLlN0YXRlKCk7XG5cbiAgICAgICAgICAgIGguZXh0ZW5kKHN0YXRlLCBzZWxmLnN0YXRlKTtcblxuICAgICAgICAgICAgaC5mcmVlemUoc3RhdGUpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsRmlsdGVycygnc3RhdGVHZXRTdGF0ZScsIHN0YXRlLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JjZXMgdGhlIHJlLWluZGV4aW5nIGFsbCB0YXJnZXRzIHdpdGhpbiB0aGUgY29udGFpbmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgc29tZSBvdGhlciBwaWVjZSBvZiBjb2RlIGluIHlvdXIgYXBwbGljYXRpb25cbiAgICAgICAgICogaGFzIG1hbmlwdWxhdGVkIHRoZSBjb250ZW50cyBvZiB5b3VyIGNvbnRhaW5lciwgd2hpY2ggc2hvdWxkIGJlIGF2b2lkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSBuZWVkIHRvIGFkZCBvciByZW1vdmUgdGFyZ2V0IGVsZW1lbnRzIGZyb20gdGhlIGNvbnRhaW5lciwgdXNlXG4gICAgICAgICAqIHRoZSBidWlsdC1pbiBgLmluc2VydCgpYCBvciBgLnJlbW92ZSgpYCBtZXRob2RzLCBhbmQgTWl4SXRVcCB3aWxsIGtlZXBcbiAgICAgICAgICogaXRzZWxmIHVwIHRvIGRhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5mb3JjZVJlZnJlc2goKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBGb3JjZSByZWZyZXNoaW5nIHRoZSBtaXhlciBhZnRlciBleHRlcm5hbCBET00gbWFuaXB1bGF0aW9uPC9jYXB0aW9uPlxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhtaXhlci5nZXRTdGF0ZSgpLnRvdGFsU2hvdyk7IC8vIDNcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQW4gZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIGNvbnRhaW5lciB2aWEgc29tZSBleHRlcm5hbCBET00gbWFuaXB1bGF0aW9uIGNvZGU6XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnRhaW5lckVsLnJlbW92ZUNoaWxkKGNvbnRhaW5lckVsLmZpcnN0RWxlbWVudENoaWxkKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gVGhlIG1peGVyIGRvZXMgbm90IGtub3cgdGhhdCB0aGUgbnVtYmVyIG9mIHRhcmdldHMgaGFzIGNoYW5nZWQ6XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG1peGVyLmdldFN0YXRlKCkudG90YWxTaG93KTsgLy8gM1xuICAgICAgICAgKlxuICAgICAgICAgKiBtaXhlci5mb3JjZVJlZnJlc2goKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQWZ0ZXIgZm9yY2VSZWZyZXNoLCB0aGUgbWl4ZXIgaXMgaW4gc3luYyBhZ2FpbjpcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2cobWl4ZXIuZ2V0U3RhdGUoKS50b3RhbFNob3cpOyAvLyAyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAyLjEuMlxuICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBmb3JjZVJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBzZWxmLmluZGV4VGFyZ2V0cygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JjZXMgdGhlIHJlLXJlbmRlcmluZyBvZiBhbGwgdGFyZ2V0cyB3aGVuIHVzaW5nIHRoZSBEYXRhc2V0IEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGFyZ2V0cyBhcmUgb25seSByZS1yZW5kZXJlZCB3aGVuIGBkYXRhLmRpcnR5Q2hlY2tgIGlzXG4gICAgICAgICAqIGVuYWJsZWQsIGFuZCBhbiBpdGVtJ3MgZGF0YSBoYXMgY2hhbmdlZCB3aGVuIGBkYXRhc2V0KClgIGlzIGNhbGxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGBmb3JjZVJlbmRlcigpYCBtZXRob2QgYWxsb3dzIGZvciB0aGUgcmUtcmVuZGVyaW5nIG9mIGFsbCB0YXJnZXRzXG4gICAgICAgICAqIGluIHJlc3BvbnNlIHRvIHNvbWUgYXJiaXRyYXJ5IGV2ZW50LCBzdWNoIGFzIHRoZSBjaGFuZ2luZyBvZiB0aGUgdGFyZ2V0XG4gICAgICAgICAqIHJlbmRlciBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGFyZ2V0cyBhcmUgcmVuZGVyZWQgYWdhaW5zdCB0aGVpciBleGlzdGluZyBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAuZm9yY2VSZW5kZXIoKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlOiBGb3JjZSByZW5kZXIgdGFyZ2V0cyBhZnRlciBjaGFuZ2luZyB0aGUgdGFyZ2V0IHJlbmRlciBmdW5jdGlvbjwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2coY29udGFpbmVyLmlubmVySFRNTCk7IC8vIC4uLiAmbHQ7c3BhbiBjbGFzcz1cIm1peFwiJmd0O0ZvbyZsdDsvc3BhbiZndDsgLi4uXG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmNvbmZpZ3VyZSh7XG4gICAgICAgICAqICAgICByZW5kZXI6IHtcbiAgICAgICAgICogICAgICAgICB0YXJnZXQ6IChpdGVtKSA9PiBgJmx0O2EgaHJlZj1cIi8ke2l0ZW0uc2x1Z30vXCIgY2xhc3M9XCJtaXhcIiZndDske2l0ZW0udGl0bGV9Jmx0Oy9hJmd0O2BcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIG1peGVyLmZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKGNvbnRhaW5lci5pbm5lckhUTUwpOyAvLyAuLi4gJmx0O2EgaHJlZj1cIi9mb28vXCIgY2xhc3M9XCJtaXhcIiZndDtGb28mbHQ7L2EmZ3Q7IC4uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgMy4yLjFcbiAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZm9yY2VSZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGVsICAgICAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGlkICAgICAgPSAnJztcblxuICAgICAgICAgICAgZm9yIChpZCBpbiBzZWxmLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gc2VsZi5jYWNoZVtpZF07XG5cbiAgICAgICAgICAgICAgICBlbCA9IHRhcmdldC5yZW5kZXIodGFyZ2V0LmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsICE9PSB0YXJnZXQuZG9tLmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0YXJnZXQgZWxlbWVudCByZWZlcmVuY2VcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzSW5Eb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC51bmJpbmRFdmVudHMoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kb20ucGFyZW50LnJlcGxhY2VDaGlsZChlbCwgdGFyZ2V0LmRvbS5lbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5pc1Nob3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmRvbS5lbCA9IGVsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaXNJbkRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuYnVpbGRTdGF0ZShzZWxmLmxhc3RPcGVyYXRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIG1peGl0dXAgZnVuY3Rpb25hbGl0eSBmcm9tIHRoZSBjb250YWluZXIsIHVuYmluZHMgYWxsIGNvbnRyb2xcbiAgICAgICAgICogZXZlbnQgaGFuZGxlcnMsIGFuZCBkZWxldGVzIHRoZSBtaXhlciBpbnN0YW5jZSBmcm9tIE1peEl0VXAncyBpbnRlcm5hbFxuICAgICAgICAgKiBjYWNoZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBzaG91bGQgYmUgcGVyZm9ybWVkIHdoZW5ldmVyIGEgbWl4ZXIncyBjb250YWluZXIgaXMgcmVtb3ZlZCBmcm9tXG4gICAgICAgICAqIHRoZSBET00sIHN1Y2ggYXMgZHVyaW5nIGEgcGFnZSBjaGFuZ2UgaW4gYSBzaW5nbGUgcGFnZSBhcHBsaWNhdGlvbixcbiAgICAgICAgICogb3IgUmVhY3QncyBgY29tcG9uZW50V2lsbFVubW91bnQoKWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIC5kZXN0cm95KFtjbGVhblVwXSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgPGNhcHRpb24+RXhhbXBsZTogRGVzdHJveWluZyB0aGUgbWl4ZXIgYmVmb3JlIHJlbW92aW5nIGl0cyBjb250YWluZXIgZWxlbWVudDwvY2FwdGlvbj5cbiAgICAgICAgICpcbiAgICAgICAgICogbWl4ZXIuZGVzdHJveSgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb250YWluZXJFbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGNvbnRhaW5lckVsKTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAge2Jvb2xlYW59ICAgW2NsZWFuVXA9ZmFsc2VdXG4gICAgICAgICAqICAgICBBbiBvcHRpb25hbCBib29sZWFuIGRpY3RhdGluZyB3aGV0aGVyIG9yIG5vdCB0byBjbGVhbiB1cCBhbnkgaW5saW5lIGBkaXNwbGF5OiBub25lO2Agc3R5bGluZyBhcHBsaWVkIHRvIGhpZGRlbiB0YXJnZXRzLlxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oY2xlYW5VcCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBudWxsLFxuICAgICAgICAgICAgICAgIHRhcmdldCAgPSBudWxsLFxuICAgICAgICAgICAgICAgIGkgICAgICAgPSAwO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVEZXN0cm95JywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgY29udHJvbCA9IHNlbGYuY29udHJvbHNbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wucmVtb3ZlQmluZGluZyhzZWxmKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgdGFyZ2V0ID0gc2VsZi50YXJnZXRzW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW5VcCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2hvdygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhcmdldC51bmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuZG9tLmNvbnRhaW5lci5pZC5tYXRjaCgvXk1peEl0VXAvKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBtaXhpdHVwLmluc3RhbmNlc1tzZWxmLmlkXTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJEZXN0cm95JywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5JTW92ZURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5wb3NJbiAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMucG9zT3V0ICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbiAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlICAgPSAnJztcbiAgICAgICAgdGhpcy5kdXJhdGlvbiAgICAgICA9IC0xO1xuICAgICAgICB0aGlzLnN0YWdnZXJJbmRleCAgID0gLTE7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuSU1vdmVEYXRhKTtcblxuICAgIG1peGl0dXAuSU1vdmVEYXRhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLklNb3ZlRGF0YS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLklNb3ZlRGF0YTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuVGFyZ2V0RG9tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1peGl0dXAuQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbnN0cnVjdCcpO1xuXG4gICAgICAgIHRoaXMuZWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLlRhcmdldERvbSk7XG5cbiAgICBtaXhpdHVwLlRhcmdldERvbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5UYXJnZXREb20ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5UYXJnZXREb207XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5UYXJnZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5pZCAgICAgICAgID0gJyc7XG4gICAgICAgIHRoaXMuc29ydFN0cmluZyA9ICcnO1xuICAgICAgICB0aGlzLm1peGVyICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmNhbGxiYWNrICAgPSBudWxsO1xuICAgICAgICB0aGlzLmlzU2hvd24gICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0JvdW5kICAgID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNFeGNsdWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzSW5Eb20gICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcGVyYXRpb24gID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gICAgICAgID0gbmV3IG1peGl0dXAuVGFyZ2V0RG9tKCk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuVGFyZ2V0KTtcblxuICAgIG1peGl0dXAuVGFyZ2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBoLmV4dGVuZChtaXhpdHVwLlRhcmdldC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IG1peGl0dXAuVGFyZ2V0LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXNlcyBhIG5ld2x5IGluc3RhbnRpYXRlZCBUYXJnZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7KEVsZW1lbnR8bnVsbCl9ICAgIGVsXG4gICAgICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgICAgICAgICAgbWl4ZXJcbiAgICAgICAgICogQHBhcmFtICAge29iamVjdH0gICAgICAgICAgICBbZGF0YV1cbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVsLCBtaXhlciwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGlkICAgPSAnJztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlSW5pdCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYubWl4ZXIgPSBtaXhlcjtcblxuICAgICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIGVsZW1lbnQgaXMgcHJvdmlkZWQsIHJlbmRlciBpdFxuXG4gICAgICAgICAgICAgICAgZWwgPSBzZWxmLnJlbmRlcihkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWNoZURvbShlbCk7XG5cbiAgICAgICAgICAgIHNlbGYuYmluZEV2ZW50cygpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5kb20uZWwuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pc1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEgJiYgbWl4ZXIuY29uZmlnLmRhdGEudWlkS2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaWQgPSBkYXRhW21peGVyLmNvbmZpZy5kYXRhLnVpZEtleV0pID09PSAndW5kZWZpbmVkJyB8fCBpZC50b1N0cmluZygpLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtaXhpdHVwLm1lc3NhZ2VzLmVycm9yRGF0YXNldEludmFsaWRVaWRLZXkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdWlkS2V5OiBtaXhlci5jb25maWcuZGF0YS51aWRLZXlcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYuaWQgICAgID0gaWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5kYXRhICAgPSBkYXRhO1xuXG4gICAgICAgICAgICAgICAgbWl4ZXIuY2FjaGVbaWRdID0gc2VsZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJJbml0JywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVycyB0aGUgdGFyZ2V0IGVsZW1lbnQgdXNpbmcgYSB1c2VyLWRlZmluZWQgcmVuZGVyZXIgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjEuNFxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSBkYXRhXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICByZW5kZXIgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBlbCAgICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICB0ZW1wICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgID0gJyc7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVJlbmRlcicsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHJlbmRlciA9IHNlbGYuY2FsbEZpbHRlcnMoJ3JlbmRlclJlbmRlcicsIHNlbGYubWl4ZXIuY29uZmlnLnJlbmRlci50YXJnZXQsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtaXhpdHVwLm1lc3NhZ2VzLmVycm9yRGF0YXNldFJlbmRlcmVyTm90U2V0KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdXRwdXQgPSByZW5kZXIoZGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChvdXRwdXQgJiYgdHlwZW9mIG91dHB1dCA9PT0gJ29iamVjdCcgJiYgaC5pc0VsZW1lbnQob3V0cHV0KSkge1xuICAgICAgICAgICAgICAgIGVsID0gb3V0cHV0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3V0cHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICB0ZW1wLmlubmVySFRNTCA9IG91dHB1dDtcblxuICAgICAgICAgICAgICAgIGVsID0gdGVtcC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbEZpbHRlcnMoJ2VsUmVuZGVyJywgZWwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlcyByZWZlcmVuY2VzIG9mIERPTSBlbGVtZW50cyBuZWNjZXNzYXJ5IGZvciB0aGUgdGFyZ2V0J3MgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBzaW5jZSAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgIHtFbGVtZW50fSBlbFxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgY2FjaGVEb206IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZUNhY2hlRG9tJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5kb20uZWwgPSBlbDtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJDYWNoZURvbScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICBhdHRyaWJ1dGVOYW1lXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBnZXRTb3J0U3RyaW5nOiBmdW5jdGlvbihhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdmFsdWUgICA9IHNlbGYuZG9tLmVsLmdldEF0dHJpYnV0ZSgnZGF0YS0nICsgYXR0cmlidXRlTmFtZSkgfHwgJyc7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZUdldFNvcnRTdHJpbmcnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB2YWx1ZSA9IGlzTmFOKHZhbHVlICogMSkgP1xuICAgICAgICAgICAgICAgIHZhbHVlLnRvTG93ZXJDYXNlKCkgOlxuICAgICAgICAgICAgICAgIHZhbHVlICogMTtcblxuICAgICAgICAgICAgc2VsZi5zb3J0U3RyaW5nID0gdmFsdWU7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyR2V0U29ydFN0cmluZycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVNob3cnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNTaG93bikge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgICAgICAgICAgIHNlbGYuaXNTaG93biA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyU2hvdycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZUhpZGUnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5pc1Nob3duKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kb20uZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAgICAgICAgIHNlbGYuaXNTaG93biA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckhpZGUnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge21peGl0dXAuSU1vdmVEYXRhfSBtb3ZlRGF0YVxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgbW92ZTogZnVuY3Rpb24obW92ZURhdGEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlTW92ZScsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmICghc2VsZi5pc0V4Y2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5taXhlci50YXJnZXRzTW92ZWQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5hcHBseVN0eWxlc0luKG1vdmVEYXRhKTtcblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYXBwbHlTdHlsZXNPdXQobW92ZURhdGEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyTW92ZScsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICBwb3NEYXRhXG4gICAgICAgICAqIEBwYXJhbSAgIHtudW1iZXJ9ICAgIG11bHRpcGxpZXJcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGFwcGx5VHdlZW46IGZ1bmN0aW9uKHBvc0RhdGEsIG11bHRpcGxpZXIpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lICAgICAgICAgICAgPSAnJyxcbiAgICAgICAgICAgICAgICB0d2VlbkRhdGEgICAgICAgICAgICAgICA9IG51bGwsXG4gICAgICAgICAgICAgICAgcG9zSW4gICAgICAgICAgICAgICAgICAgPSBwb3NEYXRhLnBvc0luLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm1WYWx1ZXMgID0gW10sXG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlcyAgICAgICAgICAgPSBuZXcgbWl4aXR1cC5TdHlsZURhdGEoKSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICAgICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVBcHBseVR3ZWVuJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgY3VycmVudFZhbHVlcy54ICAgICA9IHBvc0luLng7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWVzLnkgICAgID0gcG9zSW4ueTtcblxuICAgICAgICAgICAgaWYgKG11bHRpcGxpZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNlbGYuaXNTaG93bikge1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvdygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBwcm9wZXJ0eU5hbWUgPSBtaXhpdHVwLmZlYXR1cmVzLlRXRUVOQUJMRVtpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHdlZW5EYXRhID0gcG9zRGF0YS50d2VlbkRhdGFbcHJvcGVydHlOYW1lXTtcblxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICd4Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXR3ZWVuRGF0YSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlcy54ID0gcG9zSW4ueCArICh0d2VlbkRhdGEgKiBtdWx0aXBsaWVyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5TmFtZSA9PT0gJ3knKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHdlZW5EYXRhKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVzLnkgPSBwb3NJbi55ICsgKHR3ZWVuRGF0YSAqIG11bHRpcGxpZXIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHdlZW5EYXRhIGluc3RhbmNlb2YgbWl4aXR1cC5UcmFuc2Zvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHdlZW5EYXRhLnZhbHVlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVzW3Byb3BlcnR5TmFtZV0udmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zSW5bcHJvcGVydHlOYW1lXS52YWx1ZSArICh0d2VlbkRhdGEudmFsdWUgKiBtdWx0aXBsaWVyKTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVzW3Byb3BlcnR5TmFtZV0udW5pdCAgPSB0d2VlbkRhdGEudW5pdDtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtVmFsdWVzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgKyAnKCcgKyBjdXJyZW50VmFsdWVzW3Byb3BlcnR5TmFtZV0udmFsdWUgKyB0d2VlbkRhdGEudW5pdCArICcpJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHdlZW5EYXRhKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWVzW3Byb3BlcnR5TmFtZV0gPSBwb3NJbltwcm9wZXJ0eU5hbWVdICsgKHR3ZWVuRGF0YSAqIG11bHRpcGxpZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlW3Byb3BlcnR5TmFtZV0gPSBjdXJyZW50VmFsdWVzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlcy54IHx8IGN1cnJlbnRWYWx1ZXMueSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm1WYWx1ZXMudW5zaGlmdCgndHJhbnNsYXRlKCcgKyBjdXJyZW50VmFsdWVzLnggKyAncHgsICcgKyBjdXJyZW50VmFsdWVzLnkgKyAncHgpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50VHJhbnNmb3JtVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlW21peGl0dXAuZmVhdHVyZXMudHJhbnNmb3JtUHJvcF0gPSBjdXJyZW50VHJhbnNmb3JtVmFsdWVzLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYWZ0ZXJBcHBseVR3ZWVuJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyB0aGUgaW5pdGlhbCBzdHlsaW5nIHRvIGEgdGFyZ2V0IGVsZW1lbnQgYmVmb3JlIGFueSB0cmFuc2l0aW9uXG4gICAgICAgICAqIGlzIGFwcGxpZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcGFyYW0gICB7bWl4aXR1cC5JTW92ZURhdGF9IG1vdmVEYXRhXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBhcHBseVN0eWxlc0luOiBmdW5jdGlvbihtb3ZlRGF0YSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcG9zSW4gICAgICAgICAgID0gbW92ZURhdGEucG9zSW4sXG4gICAgICAgICAgICAgICAgaXNGYWRpbmcgICAgICAgID0gc2VsZi5taXhlci5lZmZlY3RzSW4ub3BhY2l0eSAhPT0gMSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1WYWx1ZXMgPSBbXTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlQXBwbHlTdHlsZXNJbicsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRyYW5zZm9ybVZhbHVlcy5wdXNoKCd0cmFuc2xhdGUoJyArIHBvc0luLnggKyAncHgsICcgKyBwb3NJbi55ICsgJ3B4KScpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5taXhlci5jb25maWcuYW5pbWF0aW9uLmFuaW1hdGVSZXNpemVUYXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVEYXRhLnN0YXR1c0NoYW5nZSAhPT0gJ3Nob3cnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFwcGx5IHBvc0luIHdpZHRoIG9yIGhlaWdodCBvciBzaG93aW5nLCBhcyB3aWxsIGJlIDBcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRvbS5lbC5zdHlsZS53aWR0aCAgPSBwb3NJbi53aWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLmhlaWdodCA9IHBvc0luLmhlaWdodCArICdweCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5kb20uZWwuc3R5bGUubWFyZ2luUmlnaHQgID0gcG9zSW4ubWFyZ2luUmlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLm1hcmdpbkJvdHRvbSA9IHBvc0luLm1hcmdpbkJvdHRvbSArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlzRmFkaW5nICYmIChzZWxmLmRvbS5lbC5zdHlsZS5vcGFjaXR5ID0gcG9zSW4ub3BhY2l0eSk7XG5cbiAgICAgICAgICAgIGlmIChtb3ZlRGF0YS5zdGF0dXNDaGFuZ2UgPT09ICdzaG93Jykge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZhbHVlcyA9IHRyYW5zZm9ybVZhbHVlcy5jb25jYXQoc2VsZi5taXhlci50cmFuc2Zvcm1Jbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlW21peGl0dXAuZmVhdHVyZXMudHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1WYWx1ZXMuam9pbignICcpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckFwcGx5U3R5bGVzSW4nLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIGEgdHJhbnNpdGlvbiBmb2xsb3dlZCBieSB0aGUgZmluYWwgc3R5bGVzIGZvciB0aGUgZWxlbWVudCB0b1xuICAgICAgICAgKiB0cmFuc2l0aW9uIHRvd2FyZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcGFyYW0gICB7bWl4aXR1cC5JTW92ZURhdGF9IG1vdmVEYXRhXG4gICAgICAgICAqIEByZXR1cm4gIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBhcHBseVN0eWxlc091dDogZnVuY3Rpb24obW92ZURhdGEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25SdWxlcyA9IFtdLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZhbHVlcyA9IFtdLFxuICAgICAgICAgICAgICAgIGlzUmVzaXppbmcgICAgICA9IHNlbGYubWl4ZXIuY29uZmlnLmFuaW1hdGlvbi5hbmltYXRlUmVzaXplVGFyZ2V0cyxcbiAgICAgICAgICAgICAgICBpc0ZhZGluZyAgICAgICAgPSB0eXBlb2Ygc2VsZi5taXhlci5lZmZlY3RzSW4ub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZUFwcGx5U3R5bGVzT3V0JywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIHRyYW5zaXRpb24gcnVsZXNcblxuICAgICAgICAgICAgdHJhbnNpdGlvblJ1bGVzLnB1c2goc2VsZi53cml0ZVRyYW5zaXRpb25SdWxlKFxuICAgICAgICAgICAgICAgIG1peGl0dXAuZmVhdHVyZXMudHJhbnNmb3JtUnVsZSxcbiAgICAgICAgICAgICAgICBtb3ZlRGF0YS5zdGFnZ2VySW5kZXhcbiAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICBpZiAobW92ZURhdGEuc3RhdHVzQ2hhbmdlICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uUnVsZXMucHVzaChzZWxmLndyaXRlVHJhbnNpdGlvblJ1bGUoXG4gICAgICAgICAgICAgICAgICAgICdvcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgbW92ZURhdGEuc3RhZ2dlckluZGV4LFxuICAgICAgICAgICAgICAgICAgICBtb3ZlRGF0YS5kdXJhdGlvblxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNSZXNpemluZykge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25SdWxlcy5wdXNoKHNlbGYud3JpdGVUcmFuc2l0aW9uUnVsZShcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgICAgICAgICAgbW92ZURhdGEuc3RhZ2dlckluZGV4LFxuICAgICAgICAgICAgICAgICAgICBtb3ZlRGF0YS5kdXJhdGlvblxuICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblJ1bGVzLnB1c2goc2VsZi53cml0ZVRyYW5zaXRpb25SdWxlKFxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgbW92ZURhdGEuc3RhZ2dlckluZGV4LFxuICAgICAgICAgICAgICAgICAgICBtb3ZlRGF0YS5kdXJhdGlvblxuICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblJ1bGVzLnB1c2goc2VsZi53cml0ZVRyYW5zaXRpb25SdWxlKFxuICAgICAgICAgICAgICAgICAgICAnbWFyZ2luJyxcbiAgICAgICAgICAgICAgICAgICAgbW92ZURhdGEuc3RhZ2dlckluZGV4LFxuICAgICAgICAgICAgICAgICAgICBtb3ZlRGF0YS5kdXJhdGlvblxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayB3YXMgcHJvdmlkZWQsIHRoZSBlbGVtZW50IHdpbGxcbiAgICAgICAgICAgIC8vIG5vdCB0cmFuc2l0aW9uIGluIGFueSB3YXkgc28gdGFnIGl0IGFzIFwiaW1tb3ZhYmxlXCJcblxuICAgICAgICAgICAgaWYgKCFtb3ZlRGF0YS5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHNlbGYubWl4ZXIudGFyZ2V0c0ltbW92YWJsZSsrO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubWl4ZXIudGFyZ2V0c01vdmVkID09PSBzZWxmLm1peGVyLnRhcmdldHNJbW1vdmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIHRhcmdldHMgbW92ZWQgaXMgZXF1YWwgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiBpbW1vdmFibGUgdGFyZ2V0cywgdGhlIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgY29uc2lkZXJlZCBmaW5pc2hlZFxuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWl4ZXIuY2xlYW5VcChtb3ZlRGF0YS5vcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIHRhcmdldCB3aWxsIHRyYW5zaXRpb24gaW4gc29tZSBmYXNpb24sXG4gICAgICAgICAgICAvLyBhc3NpZ24gYSBjYWxsYmFjayBmdW5jdGlvblxuXG4gICAgICAgICAgICBzZWxmLm9wZXJhdGlvbiA9IG1vdmVEYXRhLm9wZXJhdGlvbjtcbiAgICAgICAgICAgIHNlbGYuY2FsbGJhY2sgPSBtb3ZlRGF0YS5jYWxsYmFjaztcblxuICAgICAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGUgdGFyZ2V0IGlzIG5vdCBleGNsdWRlZCwgaW5jcmVtZW50XG4gICAgICAgICAgICAvLyB0aGUgdG90YWwgbnVtYmVyIG9mIHRhcmdldHMgYm91bmRcblxuICAgICAgICAgICAgIXNlbGYuaXNFeGNsdWRlZCAmJiBzZWxmLm1peGVyLnRhcmdldHNCb3VuZCsrO1xuXG4gICAgICAgICAgICAvLyBUYWcgdGhlIHRhcmdldCBhcyBib3VuZCB0byBkaWZmZXJlbnRpYXRlIGZyb20gdHJhbnNpdGlvbkVuZFxuICAgICAgICAgICAgLy8gZXZlbnRzIHRoYXQgbWF5IGNvbWUgZnJvbSBzdHlsZXNoZWV0IGRyaXZlbiBlZmZlY3RzXG5cbiAgICAgICAgICAgIHNlbGYuaXNCb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSB0cmFuc2l0aW9uXG5cbiAgICAgICAgICAgIHNlbGYuYXBwbHlUcmFuc2l0aW9uKHRyYW5zaXRpb25SdWxlcyk7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHdpZHRoLCBoZWlnaHQgYW5kIG1hcmdpbiBuZWdhdGlvblxuXG4gICAgICAgICAgICBpZiAoaXNSZXNpemluZyAmJiBtb3ZlRGF0YS5wb3NPdXQud2lkdGggPiAwICYmIG1vdmVEYXRhLnBvc091dC5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kb20uZWwuc3R5bGUud2lkdGggICAgICAgID0gbW92ZURhdGEucG9zT3V0LndpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5lbC5zdHlsZS5oZWlnaHQgICAgICAgPSBtb3ZlRGF0YS5wb3NPdXQuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBzZWxmLmRvbS5lbC5zdHlsZS5tYXJnaW5SaWdodCAgPSBtb3ZlRGF0YS5wb3NPdXQubWFyZ2luUmlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLm1hcmdpbkJvdHRvbSA9IG1vdmVEYXRhLnBvc091dC5tYXJnaW5Cb3R0b20gKyAncHgnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNlbGYubWl4ZXIuY29uZmlnLmFuaW1hdGlvbi5udWRnZSAmJiBtb3ZlRGF0YS5zdGF0dXNDaGFuZ2UgPT09ICdoaWRlJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBudWRnaW5nLCB0aGUgdHJhbnNsYXRpb24gc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgLy8gYXBwbGllZCBiZWZvcmUgYW55IG90aGVyIHRyYW5zZm9ybXMgdG8gcHJldmVudFxuICAgICAgICAgICAgICAgIC8vIGxhdGVyYWwgbW92ZW1lbnRcblxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZhbHVlcy5wdXNoKCd0cmFuc2xhdGUoJyArIG1vdmVEYXRhLnBvc091dC54ICsgJ3B4LCAnICsgbW92ZURhdGEucG9zT3V0LnkgKyAncHgpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGZhZGVcblxuICAgICAgICAgICAgc3dpdGNoIChtb3ZlRGF0YS5zdGF0dXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdoaWRlJzpcbiAgICAgICAgICAgICAgICAgICAgaXNGYWRpbmcgJiYgKHNlbGYuZG9tLmVsLnN0eWxlLm9wYWNpdHkgPSBzZWxmLm1peGVyLmVmZmVjdHNPdXQub3BhY2l0eSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVmFsdWVzID0gdHJhbnNmb3JtVmFsdWVzLmNvbmNhdChzZWxmLm1peGVyLnRyYW5zZm9ybU91dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2hvdyc6XG4gICAgICAgICAgICAgICAgICAgIGlzRmFkaW5nICYmIChzZWxmLmRvbS5lbC5zdHlsZS5vcGFjaXR5ID0gMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzZWxmLm1peGVyLmNvbmZpZy5hbmltYXRpb24ubnVkZ2UgfHxcbiAgICAgICAgICAgICAgICAoIXNlbGYubWl4ZXIuY29uZmlnLmFuaW1hdGlvbi5udWRnZSAmJiBtb3ZlRGF0YS5zdGF0dXNDaGFuZ2UgIT09ICdoaWRlJylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIE9wcG9zaXRlIG9mIGFib3ZlIC0gYXBwbHkgdHJhbnNsYXRlIGFmdGVyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdHJhbnNmb3JtXG5cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1WYWx1ZXMucHVzaCgndHJhbnNsYXRlKCcgKyBtb3ZlRGF0YS5wb3NPdXQueCArICdweCwgJyArIG1vdmVEYXRhLnBvc091dC55ICsgJ3B4KScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSB0cmFuc2Zvcm1zXG5cbiAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlW21peGl0dXAuZmVhdHVyZXMudHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1WYWx1ZXMuam9pbignICcpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckFwcGx5U3R5bGVzT3V0JywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tYmluZXMgdGhlIG5hbWUgb2YgYSBDU1MgcHJvcGVydHkgd2l0aCB0aGUgYXBwcm9wcmlhdGUgZHVyYXRpb24gYW5kIGRlbGF5XG4gICAgICAgICAqIHZhbHVlcyB0byBjcmVhdGVkIGEgdmFsaWQgdHJhbnNpdGlvbiBydWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ30gICAgcHJvcGVydHlcbiAgICAgICAgICogQHBhcmFtICAge251bWJlcn0gICAgc3RhZ2dlckluZGV4XG4gICAgICAgICAqIEBwYXJhbSAgIHtudW1iZXJ9ICAgIGR1cmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHdyaXRlVHJhbnNpdGlvblJ1bGU6IGZ1bmN0aW9uKHByb3BlcnR5LCBzdGFnZ2VySW5kZXgsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGRlbGF5ID0gc2VsZi5nZXREZWxheShzdGFnZ2VySW5kZXgpLFxuICAgICAgICAgICAgICAgIHJ1bGUgID0gJyc7XG5cbiAgICAgICAgICAgIHJ1bGUgPSBwcm9wZXJ0eSArICcgJyArXG4gICAgICAgICAgICAgICAgKGR1cmF0aW9uID4gMCA/IGR1cmF0aW9uIDogc2VsZi5taXhlci5jb25maWcuYW5pbWF0aW9uLmR1cmF0aW9uKSArICdtcyAnICtcbiAgICAgICAgICAgICAgICBkZWxheSArICdtcyAnICtcbiAgICAgICAgICAgICAgICAocHJvcGVydHkgPT09ICdvcGFjaXR5JyA/ICdsaW5lYXInIDogc2VsZi5taXhlci5jb25maWcuYW5pbWF0aW9uLmVhc2luZyk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxGaWx0ZXJzKCdydWxlV3JpdGVUcmFuc2l0aW9uUnVsZScsIHJ1bGUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHRyYW5zaXRpb24gZGVsYXkgZm9yIGVhY2ggdGFyZ2V0IGVsZW1lbnQgYmFzZWQgb24gaXRzIGluZGV4LCBpZlxuICAgICAgICAgKiBzdGFnZ2VyaW5nIGlzIGFwcGxpZWQuIElmIGRlZmluZWQsIEEgY3VzdG9tIGBhbmltYXRpb24uc3RhZ2dlclNlcWV1ZW5jZWBcbiAgICAgICAgICogZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSB0aGUgb3JkZXIgb2YgaW5kaWNlcyB0byBwcm9kdWNlIGN1c3RvbVxuICAgICAgICAgKiBzdGFnZ2VyIGVmZmVjdHMgKGUuZy4gZm9yIHVzZSBpbiBhIGdyaWQgd2l0aCBpcnJlZ3VsYXIgcm93IGxlbmd0aHMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMi4wLjBcbiAgICAgICAgICogQHBhcmFtICAge251bWJlcn0gICAgaW5kZXhcbiAgICAgICAgICogQHJldHVybiAge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICAgICAgZ2V0RGVsYXk6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZGVsYXkgICA9IC0xO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYubWl4ZXIuY29uZmlnLmFuaW1hdGlvbi5zdGFnZ2VyU2VxdWVuY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlbGYubWl4ZXIuY29uZmlnLmFuaW1hdGlvbi5zdGFnZ2VyU2VxdWVuY2UuY2FsbChzZWxmLCBpbmRleCwgc2VsZi5zdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGF5ID0gISFzZWxmLm1peGVyLnN0YWdnZXJEdXJhdGlvbiA/IGluZGV4ICogc2VsZi5taXhlci5zdGFnZ2VyRHVyYXRpb24gOiAwO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsRmlsdGVycygnZGVsYXlHZXREZWxheScsIGRlbGF5LCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge3N0cmluZ1tdfSAgcnVsZXNcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGFwcGx5VHJhbnNpdGlvbjogZnVuY3Rpb24ocnVsZXMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uU3RyaW5nICAgID0gcnVsZXMuam9pbignLCAnKTtcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlQXBwbHlUcmFuc2l0aW9uJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgc2VsZi5kb20uZWwuc3R5bGVbbWl4aXR1cC5mZWF0dXJlcy50cmFuc2l0aW9uUHJvcF0gPSB0cmFuc2l0aW9uU3RyaW5nO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckFwcGx5VHJhbnNpdGlvbicsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcGFyYW0gICB7RXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGhhbmRsZVRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcHJvcE5hbWUgICAgPSBlLnByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgICAgICBjYW5SZXNpemUgICA9IHNlbGYubWl4ZXIuY29uZmlnLmFuaW1hdGlvbi5hbmltYXRlUmVzaXplVGFyZ2V0cztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlSGFuZGxlVHJhbnNpdGlvbkVuZCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzZWxmLmlzQm91bmQgJiZcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5tYXRjaGVzKHNlbGYubWl4ZXIuY29uZmlnLnNlbGVjdG9ycy50YXJnZXQpICYmXG4gICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZS5pbmRleE9mKCd0cmFuc2Zvcm0nKSA+IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHByb3BOYW1lLmluZGV4T2YoJ29wYWNpdHknKSA+IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIGNhblJlc2l6ZSAmJiBwcm9wTmFtZS5pbmRleE9mKCdoZWlnaHQnKSA+IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIGNhblJlc2l6ZSAmJiBwcm9wTmFtZS5pbmRleE9mKCd3aWR0aCcpID4gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgY2FuUmVzaXplICYmIHByb3BOYW1lLmluZGV4T2YoJ21hcmdpbicpID4gLTFcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGxiYWNrLmNhbGwoc2VsZiwgc2VsZi5vcGVyYXRpb24pO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5pc0JvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2VsZi5vcGVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckhhbmRsZVRyYW5zaXRpb25FbmQnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge0V2ZW50fSAgICAgZVxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgZXZlbnRCdXM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlRXZlbnRCdXMnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlYmtpdFRyYW5zaXRpb25FbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zaXRpb25lbmQnOlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZVRyYW5zaXRpb25FbmQoZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2FmdGVyRXZlbnRCdXMnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHJldHVybiAge3ZvaWR9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHVuYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZVVuYmluZEV2ZW50cycsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGgub2ZmKHNlbGYuZG9tLmVsLCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIHNlbGYuaGFuZGxlcik7XG4gICAgICAgICAgICBoLm9mZihzZWxmLmRvbS5lbCwgJ3RyYW5zaXRpb25lbmQnLCBzZWxmLmhhbmRsZXIpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlclVuYmluZEV2ZW50cycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAzLjAuMFxuICAgICAgICAgKiBAcmV0dXJuICB7dm9pZH1cbiAgICAgICAgICovXG5cbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbkVuZEV2ZW50ICA9ICcnO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdiZWZvcmVCaW5kRXZlbnRzJywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gbWl4aXR1cC5mZWF0dXJlcy50cmFuc2l0aW9uUHJlZml4ID09PSAnd2Via2l0JyA/ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcblxuICAgICAgICAgICAgc2VsZi5oYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmV2ZW50QnVzKGUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaC5vbihzZWxmLmRvbS5lbCwgdHJhbnNpdGlvbkVuZEV2ZW50LCBzZWxmLmhhbmRsZXIpO1xuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckJpbmRFdmVudHMnLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgMy4wLjBcbiAgICAgICAgICogQHBhcmFtICAge2Jvb2xlYW59ICAgW2dldEJveF1cbiAgICAgICAgICogQHJldHVybiAge1Bvc0RhdGF9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGdldFBvc0RhdGE6IGZ1bmN0aW9uKGdldEJveCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHN0eWxlcyAgPSB7fSxcbiAgICAgICAgICAgICAgICByZWN0ICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBwb3NEYXRhID0gbmV3IG1peGl0dXAuU3R5bGVEYXRhKCk7XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbEFjdGlvbnMoJ2JlZm9yZUdldFBvc0RhdGEnLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBwb3NEYXRhLnggPSBzZWxmLmRvbS5lbC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgcG9zRGF0YS55ID0gc2VsZi5kb20uZWwub2Zmc2V0VG9wO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5taXhlci5jb25maWcuYW5pbWF0aW9uLmFuaW1hdGVSZXNpemVUYXJnZXRzIHx8IGdldEJveCkge1xuICAgICAgICAgICAgICAgIHJlY3QgPSBzZWxmLmRvbS5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgIHBvc0RhdGEudG9wICAgICA9IHJlY3QudG9wO1xuICAgICAgICAgICAgICAgIHBvc0RhdGEucmlnaHQgICA9IHJlY3QucmlnaHQ7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5ib3R0b20gID0gcmVjdC5ib3R0b207XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5sZWZ0ICAgID0gcmVjdC5sZWZ0O1xuXG4gICAgICAgICAgICAgICAgcG9zRGF0YS53aWR0aCAgPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIHBvc0RhdGEuaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLm1peGVyLmNvbmZpZy5hbmltYXRpb24uYW5pbWF0ZVJlc2l6ZVRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzZWxmLmRvbS5lbCk7XG5cbiAgICAgICAgICAgICAgICBwb3NEYXRhLm1hcmdpbkJvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkJvdHRvbSk7XG4gICAgICAgICAgICAgICAgcG9zRGF0YS5tYXJnaW5SaWdodCAgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxGaWx0ZXJzKCdwb3NEYXRhR2V0UG9zRGF0YScsIHBvc0RhdGEsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgICAgICogQHJldHVybiAgICAgIHt2b2lkfVxuICAgICAgICAgKi9cblxuICAgICAgICBjbGVhblVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi5jYWxsQWN0aW9ucygnYmVmb3JlQ2xlYW5VcCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlW21peGl0dXAuZmVhdHVyZXMudHJhbnNmb3JtUHJvcF0gID0gJyc7XG4gICAgICAgICAgICBzZWxmLmRvbS5lbC5zdHlsZVttaXhpdHVwLmZlYXR1cmVzLnRyYW5zaXRpb25Qcm9wXSA9ICcnO1xuICAgICAgICAgICAgc2VsZi5kb20uZWwuc3R5bGUub3BhY2l0eSAgICAgICAgICAgICAgICAgICAgICAgICAgPSAnJztcblxuICAgICAgICAgICAgaWYgKHNlbGYubWl4ZXIuY29uZmlnLmFuaW1hdGlvbi5hbmltYXRlUmVzaXplVGFyZ2V0cykge1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLndpZHRoICAgICAgICA9ICcnO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLmhlaWdodCAgICAgICA9ICcnO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLm1hcmdpblJpZ2h0ICA9ICcnO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9tLmVsLnN0eWxlLm1hcmdpbkJvdHRvbSA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNhbGxBY3Rpb25zKCdhZnRlckNsZWFuVXAnLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGpRdWVyeS1jb2xsZWN0aW9uLWxpa2Ugd3JhcHBlciBhcm91bmQgb25lIG9yIG1vcmUgYG1peGl0dXAuTWl4ZXJgIGluc3RhbmNlc1xuICAgICAqIGFsbG93aW5nIHNpbXVsdGFuZW91cyBjb250cm9sIG9mIHNhaWQgaW5zdGFuY2VzIHNpbWlsYXIgdG8gdGhlIE1peEl0VXAgMiBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5ldyBtaXhpdHVwLkNvbGxlY3Rpb24oaW5zdGFuY2VzKVxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKiBAcGFyYW0gICAgICAge21peGl0dXAuTWl4ZXJbXX0gICBpbnN0YW5jZXNcbiAgICAgKi9cblxuICAgIG1peGl0dXAuQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKGluc3RhbmNlcykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgICAgPSBudWxsLFxuICAgICAgICAgICAgaSAgICAgICAgICAgPSAtMTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpbnN0YW5jZSA9IGluc3RhbmNlc1tpXTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gaW5zdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxlbmd0aCA9IGluc3RhbmNlcy5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLmZyZWV6ZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Db2xsZWN0aW9uKTtcblxuICAgIG1peGl0dXAuQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgaC5leHRlbmQobWl4aXR1cC5Db2xsZWN0aW9uLnByb3RvdHlwZSxcbiAgICAvKiogQGxlbmRzIG1peGl0dXAuQ29sbGVjdGlvbiAqL1xuICAgIHtcbiAgICAgICAgY29uc3RydWN0b3I6IG1peGl0dXAuQ29sbGVjdGlvbixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbHMgYSBtZXRob2Qgb24gYWxsIGluc3RhbmNlcyBpbiB0aGUgY29sbGVjdGlvbiBieSBwYXNzaW5nIHRoZSBtZXRob2RcbiAgICAgICAgICogbmFtZSBhcyBhIHN0cmluZyBmb2xsb3dlZCBieSBhbnkgYXBwbGljYWJsZSBwYXJhbWV0ZXJzIHRvIGJlIGN1cnJpZWQgaW50b1xuICAgICAgICAgKiB0byB0aGUgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAubWl4aXR1cChtZXRob2ROYW1lWyxhcmcxXVssYXJnMi4uXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oW21peGVyMSwgbWl4ZXIyXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHJldHVybiBjb2xsZWN0aW9uLm1peGl0dXAoJ2ZpbHRlcicsICcuY2F0ZWdvcnktYScpXG4gICAgICAgICAqICAgICAudGhlbihmdW5jdGlvbihzdGF0ZXMpIHtcbiAgICAgICAgICogICAgICAgICBzdGF0ZS5mb3JFYWNoKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLmFjdGl2ZUZpbHRlci5zZWxlY3Rvcik7IC8vIC5jYXRlZ29yeS1hXG4gICAgICAgICAqICAgICAgICAgfSk7XG4gICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHNpbmNlICAgICAgIDMuMC4wXG4gICAgICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgbWV0aG9kTmFtZVxuICAgICAgICAgKiBAcmV0dXJuICAgICAge1Byb21pc2U8QXJyYXk8bWl4aXR1cC5TdGF0ZT4+fVxuICAgICAgICAgKi9cblxuICAgICAgICBtaXhpdHVwOiBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiAgICAgICAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlICAgID0gbnVsbCxcbiAgICAgICAgICAgICAgICBhcmdzICAgICAgICA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgdGFza3MgICAgICAgPSBbXSxcbiAgICAgICAgICAgICAgICBpICAgICAgICAgICA9IC0xO1xuXG4gICAgICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVNaXhpdHVwJyk7XG5cbiAgICAgICAgICAgIGFyZ3Muc2hpZnQoKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaW5zdGFuY2UgPSBzZWxmW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKGluc3RhbmNlW21ldGhvZE5hbWVdLmFwcGx5KGluc3RhbmNlLCBhcmdzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGxGaWx0ZXJzKCdwcm9taXNlTWl4aXR1cCcsIGguYWxsKHRhc2tzLCBtaXhpdHVwLmxpYnJhcmllcyksIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIGBtaXhpdHVwLk9wZXJhdGlvbmAgb2JqZWN0cyBjb250YWluIGFsbCBkYXRhIG5lY2Nlc3NhcnkgdG8gZGVzY3JpYmUgdGhlIGZ1bGxcbiAgICAgKiBsaWZlY3ljbGUgb2YgYW55IE1peEl0VXAgb3BlcmF0aW9uLiBUaGV5IGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgYW5kIHN0b3JlIGFuXG4gICAgICogb3BlcmF0aW9uIGZvciB1c2UgYXQgYSBsYXRlciB0aW1lIChlLmcuIHByb2dyYW1tYXRpYyB0d2VlbmluZykuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5PcGVyYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWl4aXR1cC5CYXNlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYmVmb3JlQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5pZCAgICAgICAgICAgICAgICAgICAgICA9ICcnO1xuXG4gICAgICAgIHRoaXMuYXJncyAgICAgICAgICAgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy5jb21tYW5kICAgICAgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hvd1Bvc0RhdGEgICAgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy50b0hpZGVQb3NEYXRhICAgICAgICAgICA9IFtdO1xuXG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLm5ld1N0YXRlICAgICAgICAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb2NTdGF0ZSAgICAgICAgICAgICAgICA9IG51bGw7XG5cbiAgICAgICAgdGhpcy53aWxsU29ydCAgICAgICAgICAgICAgICA9IGZhbHNlO1xuICAgICAgICB0aGlzLndpbGxDaGFuZ2VMYXlvdXQgICAgICAgID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzRWZmZWN0ICAgICAgICAgICAgICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNGYWlsZWQgICAgICAgICAgICAgICA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlckVsZW1lbnQgICAgICAgICAgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuc2hvdyAgICAgICAgICAgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy5oaWRlICAgICAgICAgICAgICAgICAgICA9IFtdO1xuICAgICAgICB0aGlzLm1hdGNoaW5nICAgICAgICAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMudG9TaG93ICAgICAgICAgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy50b0hpZGUgICAgICAgICAgICAgICAgICA9IFtdO1xuICAgICAgICB0aGlzLnRvTW92ZSAgICAgICAgICAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMudG9SZW1vdmUgICAgICAgICAgICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydE9yZGVyICAgICAgICAgICAgICA9IFtdO1xuICAgICAgICB0aGlzLm5ld09yZGVyICAgICAgICAgICAgICAgID0gW107XG4gICAgICAgIHRoaXMuc3RhcnRTb3J0ICAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLm5ld1NvcnQgICAgICAgICAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFydEZpbHRlciAgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMubmV3RmlsdGVyICAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXJ0RGF0YXNldCAgICAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXdEYXRhc2V0ICAgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMudmlld3BvcnREZWx0YVggICAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLnZpZXdwb3J0RGVsdGFZICAgICAgICAgID0gMDtcbiAgICAgICAgdGhpcy5zdGFydFggICAgICAgICAgICAgICAgICA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRZICAgICAgICAgICAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0SGVpZ2h0ICAgICAgICAgICAgID0gMDtcbiAgICAgICAgdGhpcy5zdGFydFdpZHRoICAgICAgICAgICAgICA9IDA7XG4gICAgICAgIHRoaXMubmV3WCAgICAgICAgICAgICAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLm5ld1kgICAgICAgICAgICAgICAgICAgID0gMDtcbiAgICAgICAgdGhpcy5uZXdIZWlnaHQgICAgICAgICAgICAgICA9IDA7XG4gICAgICAgIHRoaXMubmV3V2lkdGggICAgICAgICAgICAgICAgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0Q29udGFpbmVyQ2xhc3NOYW1lID0gJyc7XG4gICAgICAgIHRoaXMuc3RhcnREaXNwbGF5ICAgICAgICAgICAgPSAnJztcbiAgICAgICAgdGhpcy5uZXdDb250YWluZXJDbGFzc05hbWUgICA9ICcnO1xuICAgICAgICB0aGlzLm5ld0Rpc3BsYXkgICAgICAgICAgICAgID0gJyc7XG5cbiAgICAgICAgdGhpcy5jYWxsQWN0aW9ucygnYWZ0ZXJDb25zdHJ1Y3QnKTtcblxuICAgICAgICBoLnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuT3BlcmF0aW9uKTtcblxuICAgIG1peGl0dXAuT3BlcmF0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobWl4aXR1cC5CYXNlLnByb3RvdHlwZSk7XG5cbiAgICBtaXhpdHVwLk9wZXJhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBtaXhpdHVwLk9wZXJhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIGBtaXhpdHVwLlN0YXRlYCBvYmplY3RzIGV4cG9zZSB2YXJpb3VzIHBpZWNlcyBvZiBkYXRhIGRldGFpbGluZyB0aGUgc3RhdGUgb2ZcbiAgICAgKiBhIE1peEl0VXAgaW5zdGFuY2UuIFRoZXkgYXJlIHByb3ZpZGVkIGF0IHRoZSBzdGFydCBhbmQgZW5kIG9mIGFueSBvcGVyYXRpb24gdmlhXG4gICAgICogY2FsbGJhY2tzIGFuZCBldmVudHMsIHdpdGggdGhlIG1vc3QgcmVjZW50IHN0YXRlIHN0b3JlZCBiZXR3ZWVuIG9wZXJhdGlvbnNcbiAgICAgKiBmb3IgcmV0cmlldmFsIGF0IGFueSB0aW1lIHZpYSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5TdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIElEIG9mIHRoZSBtaXhlciBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGlkXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgICAgICcnXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuaWQgPSAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZmlsdGVyIGNvbW1hbmQgYXMgc2V0IGJ5IGEgY29udHJvbCBjbGljayBvciBBUEkgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGFjdGl2ZUZpbHRlclxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5TdGF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHttaXhpdHVwLkNvbW1hbmRGaWx0ZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBudWxsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuYWN0aXZlRmlsdGVyID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgc29ydCBjb21tYW5kIGFzIHNldCBieSBhIGNvbnRyb2wgY2xpY2sgb3IgQVBJIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBhY3RpdmVTb3J0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge21peGl0dXAuQ29tbWFuZFNvcnR9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBudWxsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuYWN0aXZlU29ydCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IGxheW91dC1zcGVjaWZpYyBjb250YWluZXIgY2xhc3MgbmFtZSwgaWYgYXBwbGllZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGFjdGl2ZUNvbnRhaW5lckNsYXNzTmFtZVxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5TdGF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICAnJ1xuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmFjdGl2ZUNvbnRhaW5lckNsYXNzTmFtZSA9ICcnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnQgdGhhdCB0aGUgbWl4ZXIgaXMgaW5zdGFudGlhdGVkIG9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgY29udGFpbmVyXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge0VsZW1lbnR9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBudWxsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgYWxsIHRhcmdldCBlbGVtZW50cyBpbmRleGVkIGJ5IHRoZSBtaXhlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIHRhcmdldHNcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuU3RhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7QXJyYXkuPEVsZW1lbnQ+fVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgW11cbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy50YXJnZXRzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGFsbCB0YXJnZXQgZWxlbWVudHMgbm90IG1hdGNoaW5nIHRoZSBjdXJyZW50IGZpbHRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIGhpZGVcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuU3RhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7QXJyYXkuPEVsZW1lbnQ+fVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgW11cbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5oaWRlID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGFsbCB0YXJnZXQgZWxlbWVudHMgbWF0Y2hpbmcgdGhlIGN1cnJlbnQgZmlsdGVyIGFuZCBhbnkgYWRkaXRpb25hbFxuICAgICAgICAgKiBsaW1pdHMgYXBwbGllZCBzdWNoIGFzIHBhZ2luYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBzaG93XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge0FycmF5LjxFbGVtZW50Pn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIFtdXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMuc2hvdyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBhbGwgdGFyZ2V0IGVsZW1lbnRzIG1hdGNoaW5nIHRoZSBjdXJyZW50IGZpbHRlciBpcnJlc3BlY3RpdmUgb2ZcbiAgICAgICAgICogYW55IGFkZGl0aW9uYWwgbGltaXRzIGFwcGxpZWQgc3VjaCBhcyBwYWdpbmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgbWF0Y2hpbmdcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuU3RhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7QXJyYXkuPEVsZW1lbnQ+fVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgW11cbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy5tYXRjaGluZyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgdG90YWwgbnVtYmVyIG9mIHRhcmdldCBlbGVtZW50cyBpbmRleGVkIGJ5IHRoZVxuICAgICAgICAgKiBtaXhlci4gRXF1aXZhbGVudCB0byBgc3RhdGUudGFyZ2V0cy5sZW5ndGhgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgdG90YWxUYXJnZXRzXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIC0xXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMudG90YWxUYXJnZXRzID0gLTE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSB0b3RhbCBudW1iZXIgb2YgdGFyZ2V0IGVsZW1lbnRzIG1hdGNoaW5nIHRoZVxuICAgICAgICAgKiBjdXJyZW50IGZpbHRlciBhbmQgYW55IGFkZGl0aW9uYWwgbGltaXRzIGFwcGxpZWQgc3VjaCBhcyBwYWdpbmF0aW9uLlxuICAgICAgICAgKiBFcXVpdmFsZW50IHRvIGBzdGF0ZS5zaG93Lmxlbmd0aGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICB0b3RhbFNob3dcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuU3RhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgLTFcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy50b3RhbFNob3cgPSAtMTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIHRvdGFsIG51bWJlciBvZiB0YXJnZXQgZWxlbWVudHMgbm90IG1hdGNoaW5nXG4gICAgICAgICAqIHRoZSBjdXJyZW50IGZpbHRlci4gRXF1aXZhbGVudCB0byBgc3RhdGUuaGlkZS5sZW5ndGhgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgdG90YWxIaWRlXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgICAgIC0xXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMudG90YWxIaWRlID0gLTE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSB0b3RhbCBudW1iZXIgb2YgdGFyZ2V0IGVsZW1lbnRzIG1hdGNoaW5nIHRoZVxuICAgICAgICAgKiBjdXJyZW50IGZpbHRlciBpcnJlc3BlY3RpdmUgb2YgYW55IG90aGVyIGxpbWl0cyBhcHBsaWVkIHN1Y2ggYXMgcGFnaW5hdGlvbi5cbiAgICAgICAgICogRXF1aXZhbGVudCB0byBgc3RhdGUubWF0Y2hpbmcubGVuZ3RoYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgICAgICAgIHRvdGFsTWF0Y2hpbmdcbiAgICAgICAgICogQG1lbWJlcm9mICAgIG1peGl0dXAuU3RhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEB0eXBlICAgICAgICB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgLTFcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy50b3RhbE1hdGNoaW5nID0gLTE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGxhc3Qgb3BlcmF0aW9uIFwiZmFpbGVkXCIsIGkuZS4gbm8gdGFyZ2V0c1xuICAgICAgICAgKiBjb3VsZCBiZSBmb3VuZCBtYXRjaGluZyB0aGUgZmlsdGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICAgICAgaGFzRmFpbGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBmYWxzZVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmhhc0ZhaWxlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgRE9NIGVsZW1lbnQgdGhhdCB3YXMgY2xpY2tlZCBpZiB0aGUgbGFzdCBvcGVyYXRpb24gd2FzIHRyaWdnZXJlZCBieSB0aGVcbiAgICAgICAgICogY2xpY2tpbmcgb2YgYSBjb250cm9sIGFuZCBub3QgYW4gQVBJIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICB0cmlnZ2VyRWxlbWVudFxuICAgICAgICAgKiBAbWVtYmVyb2YgICAgbWl4aXR1cC5TdGF0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUgICAgICAgIHtFbGVtZW50fG51bGx9XG4gICAgICAgICAqIEBkZWZhdWx0ICAgICBudWxsXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMudHJpZ2dlckVsZW1lbnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkYXRhc2V0IHVuZGVybHlpbmcgdGhlIHJlbmRlcmVkIHRhcmdldHMsIGlmIHRoZVxuICAgICAgICAgKiBkYXRhc2V0IEFQSSBpcyBpbiB1c2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lICAgICAgICBhY3RpdmVEYXRhc2V0XG4gICAgICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwLlN0YXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSAgICAgICAge0FycmF5LjxvYmplY3Q+fVxuICAgICAgICAgKiBAZGVmYXVsdCAgICAgbnVsbFxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmFjdGl2ZURhdGFzZXQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLlN0YXRlKTtcblxuICAgIG1peGl0dXAuU3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuU3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5TdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKi9cblxuICAgIG1peGl0dXAuVXNlckluc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1peGl0dXAuQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbnN0cnVjdCcpO1xuXG4gICAgICAgIHRoaXMuY29tbWFuZCAgICA9IHt9O1xuICAgICAgICB0aGlzLmFuaW1hdGUgICAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayAgID0gbnVsbDtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdhZnRlckNvbnN0cnVjdCcpO1xuXG4gICAgICAgIGguc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgbWl4aXR1cC5CYXNlU3RhdGljLmNhbGwobWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb24pO1xuXG4gICAgbWl4aXR1cC5Vc2VySW5zdHJ1Y3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuVXNlckluc3RydWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG1peGl0dXAuVXNlckluc3RydWN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mICAgIG1peGl0dXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzaW5jZSAgICAgICAzLjAuMFxuICAgICAqL1xuXG4gICAgbWl4aXR1cC5NZXNzYWdlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtaXhpdHVwLkJhc2UuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmNhbGxBY3Rpb25zKCdiZWZvcmVDb25zdHJ1Y3QnKTtcblxuICAgICAgICAvKiBFcnJvcnNcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgICB0aGlzLkVSUk9SX0ZBQ1RPUllfSU5WQUxJRF9DT05UQUlORVIgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBBbiBpbnZhbGlkIHNlbGVjdG9yIG9yIGVsZW1lbnQgcmVmZXJlbmNlIHdhcyBwYXNzZWQgdG8gdGhlIG1peGl0dXAgZmFjdG9yeSBmdW5jdGlvbic7XG5cbiAgICAgICAgdGhpcy5FUlJPUl9GQUNUT1JZX0NPTlRBSU5FUl9OT1RfRk9VTkQgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBUaGUgcHJvdmlkZWQgc2VsZWN0b3IgeWllbGRlZCBubyBjb250YWluZXIgZWxlbWVudCc7XG5cbiAgICAgICAgdGhpcy5FUlJPUl9DT05GSUdfSU5WQUxJRF9BTklNQVRJT05fRUZGRUNUUyA9XG4gICAgICAgICAgICAnW01peEl0VXBdIEludmFsaWQgdmFsdWUgZm9yIGBhbmltYXRpb24uZWZmZWN0c2AnO1xuXG4gICAgICAgIHRoaXMuRVJST1JfQ09ORklHX0lOVkFMSURfQ09OVFJPTFNfU0NPUEUgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBJbnZhbGlkIHZhbHVlIGZvciBgY29udHJvbHMuc2NvcGVgJztcblxuICAgICAgICB0aGlzLkVSUk9SX0NPTkZJR19JTlZBTElEX1BST1BFUlRZID1cbiAgICAgICAgICAgICdbTWl4aXRVcF0gSW52YWxpZCBjb25maWd1cmF0aW9uIG9iamVjdCBwcm9wZXJ0eSBcIiR7ZXJyb25lb3VzfVwiJHtzdWdnZXN0aW9ufSc7XG5cbiAgICAgICAgdGhpcy5FUlJPUl9DT05GSUdfSU5WQUxJRF9QUk9QRVJUWV9TVUdHRVNUSU9OID1cbiAgICAgICAgICAgICcuIERpZCB5b3UgbWVhbiBcIiR7cHJvYmFibGVNYXRjaH1cIj8nO1xuXG4gICAgICAgIHRoaXMuRVJST1JfQ09ORklHX0RBVEFfVUlEX0tFWV9OT1RfU0VUID1cbiAgICAgICAgICAgICdbTWl4SXRVcF0gVG8gdXNlIHRoZSBkYXRhc2V0IEFQSSwgYSBVSUQga2V5IG11c3QgYmUgc3BlY2lmaWVkIHVzaW5nIGBkYXRhLnVpZEtleWAnO1xuXG4gICAgICAgIHRoaXMuRVJST1JfREFUQVNFVF9JTlZBTElEX1VJRF9LRVkgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBUaGUgc3BlY2lmaWVkIFVJRCBrZXkgXCIke3VpZEtleX1cIiBpcyBub3QgcHJlc2VudCBvbiBvbmUgb3IgbW9yZSBkYXRhc2V0IGl0ZW1zJztcblxuICAgICAgICB0aGlzLkVSUk9SX0RBVEFTRVRfRFVQTElDQVRFX1VJRCA9XG4gICAgICAgICAgICAnW01peEl0VXBdIFRoZSBVSUQgXCIke3VpZH1cIiB3YXMgZm91bmQgb24gdHdvIG9yIG1vcmUgZGF0YXNldCBpdGVtcy4gVUlEcyBtdXN0IGJlIHVuaXF1ZS4nO1xuXG4gICAgICAgIHRoaXMuRVJST1JfSU5TRVJUX0lOVkFMSURfQVJHVU1FTlRTID1cbiAgICAgICAgICAgICdbTWl4SXRVcF0gUGxlYXNlIHByb3ZpZGVyIGVpdGhlciBhbiBpbmRleCBvciBhIHNpYmxpbmcgYW5kIHBvc2l0aW9uIHRvIGluc2VydCwgbm90IGJvdGgnO1xuXG4gICAgICAgIHRoaXMuRVJST1JfSU5TRVJUX1BSRUVYSVNUSU5HX0VMRU1FTlQgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBBbiBlbGVtZW50IHRvIGJlIGluc2VydGVkIGFscmVhZHkgZXhpc3RzIGluIHRoZSBjb250YWluZXInO1xuXG4gICAgICAgIHRoaXMuRVJST1JfRklMVEVSX0lOVkFMSURfQVJHVU1FTlRTID1cbiAgICAgICAgICAgICdbTWl4SXRVcF0gUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGEgc2VsZWN0b3Igb3IgY29sbGVjdGlvbiBgLmZpbHRlcigpYCwgbm90IGJvdGgnO1xuXG4gICAgICAgIHRoaXMuRVJST1JfREFUQVNFVF9OT1RfU0VUID1cbiAgICAgICAgICAgICdbTWl4SXRVcF0gVG8gdXNlIHRoZSBkYXRhc2V0IEFQSSB3aXRoIHByZS1yZW5kZXJlZCB0YXJnZXRzLCBhIHN0YXJ0aW5nIGRhdGFzZXQgbXVzdCBiZSBzZXQgdXNpbmcgYGxvYWQuZGF0YXNldGAnO1xuXG4gICAgICAgIHRoaXMuRVJST1JfREFUQVNFVF9QUkVSRU5ERVJFRF9NSVNNQVRDSCA9XG4gICAgICAgICAgICAnW01peEl0VXBdIGBsb2FkLmRhdGFzZXRgIGRvZXMgbm90IG1hdGNoIHByZS1yZW5kZXJlZCB0YXJnZXRzJztcblxuICAgICAgICB0aGlzLkVSUk9SX0RBVEFTRVRfUkVOREVSRVJfTk9UX1NFVCA9XG4gICAgICAgICAgICAnW01peEl0VXBdIFRvIGluc2VydCBhbiBlbGVtZW50IHZpYSB0aGUgZGF0YXNldCBBUEksIGEgdGFyZ2V0IHJlbmRlcmVyIGZ1bmN0aW9uIG11c3QgYmUgcHJvdmlkZWQgdG8gYHJlbmRlci50YXJnZXRgJztcblxuICAgICAgICB0aGlzLkVSUk9SX1NPUlRfTk9OX0VYSVNURU5UX0VMRU1FTlQgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBBbiBlbGVtZW50IHRvIGJlIHNvcnRlZCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0IGluIHRoZSBjb250YWluZXInO1xuXG4gICAgICAgIC8qIFdhcm5pbmdzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgdGhpcy5XQVJOSU5HX0ZBQ1RPUllfUFJFRVhJU1RJTkdfSU5TVEFOQ0UgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBXQVJOSU5HOiBUaGlzIGVsZW1lbnQgYWxyZWFkeSBoYXMgYW4gYWN0aXZlIE1peEl0VXAgaW5zdGFuY2UuIFRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uIG9iamVjdCB3aWxsIGJlIGlnbm9yZWQuJyArXG4gICAgICAgICAgICAnIElmIHlvdSB3aXNoIHRvIHBlcmZvcm0gYWRkaXRpb25hbCBtZXRob2RzIG9uIHRoaXMgaW5zdGFuY2UsIHBsZWFzZSBjcmVhdGUgYSByZWZlcmVuY2UuJztcblxuICAgICAgICB0aGlzLldBUk5JTkdfSU5TRVJUX05PX0VMRU1FTlRTID1cbiAgICAgICAgICAgICdbTWl4SXRVcF0gV0FSTklORzogTm8gdmFsaWQgZWxlbWVudHMgd2VyZSBwYXNzZWQgdG8gYC5pbnNlcnQoKWAnO1xuXG4gICAgICAgIHRoaXMuV0FSTklOR19SRU1PVkVfTk9fRUxFTUVOVFMgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBXQVJOSU5HOiBObyB2YWxpZCBlbGVtZW50cyB3ZXJlIHBhc3NlZCB0byBgLnJlbW92ZSgpYCc7XG5cbiAgICAgICAgdGhpcy5XQVJOSU5HX01VTFRJTUlYX0lOU1RBTkNFX1FVRVVFX0ZVTEwgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBXQVJOSU5HOiBBbiBvcGVyYXRpb24gd2FzIHJlcXVlc3RlZCBidXQgdGhlIE1peEl0VXAgaW5zdGFuY2Ugd2FzIGJ1c3kuIFRoZSBvcGVyYXRpb24gd2FzIHJlamVjdGVkIGJlY2F1c2UgdGhlICcgK1xuICAgICAgICAgICAgJ3F1ZXVlIGlzIGZ1bGwgb3IgcXVldWluZyBpcyBkaXNhYmxlZC4nO1xuXG4gICAgICAgIHRoaXMuV0FSTklOR19HRVRfT1BFUkFUSU9OX0lOU1RBTkNFX0JVU1kgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBXQVJOSU5HOiBPcGVyYXRpb25zIGNhbiBiZSBiZSBjcmVhdGVkIHdoaWxlIHRoZSBNaXhJdFVwIGluc3RhbmNlIGlzIGJ1c3kuJztcblxuICAgICAgICB0aGlzLldBUk5JTkdfTk9fUFJPTUlTRV9JTVBMRU1FTlRBVElPTiA9XG4gICAgICAgICAgICAnW01peEl0VXBdIFdBUk5JTkc6IE5vIFByb21pc2UgaW1wbGVtZW50YXRpb25zIGNvdWxkIGJlIGZvdW5kLiBJZiB5b3Ugd2lzaCB0byB1c2UgcHJvbWlzZXMgd2l0aCBNaXhJdFVwIHBsZWFzZSBpbnN0YWxsJyArXG4gICAgICAgICAgICAnIGFuIEVTNiBQcm9taXNlIHBvbHlmaWxsLic7XG5cbiAgICAgICAgdGhpcy5XQVJOSU5HX0lOQ09OU0lTVEVOVF9TT1JUSU5HX0FUVFJJQlVURVMgPVxuICAgICAgICAgICAgJ1tNaXhJdFVwXSBXQVJOSU5HOiBUaGUgcmVxdWVzdGVkIHNvcnRpbmcgZGF0YSBhdHRyaWJ1dGUgXCIke2F0dHJpYnV0ZX1cIiB3YXMgbm90IHByZXNlbnQgb24gb25lIG9yIG1vcmUgdGFyZ2V0IGVsZW1lbnRzJyArXG4gICAgICAgICAgICAnIHdoaWNoIG1heSBwcm9kdWN0IHVuZXhwZWN0ZWQgc29ydCBvdXRwdXQnO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0Jyk7XG5cbiAgICAgICAgdGhpcy5jb21waWxlVGVtcGxhdGVzKCk7XG5cbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLk1lc3NhZ2VzKTtcblxuICAgIG1peGl0dXAuTWVzc2FnZXMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShtaXhpdHVwLkJhc2UucHJvdG90eXBlKTtcblxuICAgIG1peGl0dXAuTWVzc2FnZXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5NZXNzYWdlcztcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG5cbiAgICBtaXhpdHVwLk1lc3NhZ2VzLnByb3RvdHlwZS5jb21waWxlVGVtcGxhdGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlcnJvcktleSAgICAgICAgPSAnJztcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSAgICA9ICcnO1xuXG4gICAgICAgIGZvciAoZXJyb3JLZXkgaW4gdGhpcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3JNZXNzYWdlID0gdGhpc1tlcnJvcktleV0pICE9PSAnc3RyaW5nJykgY29udGludWU7XG5cbiAgICAgICAgICAgIHRoaXNbaC5jYW1lbENhc2UoZXJyb3JLZXkpXSA9IGgudGVtcGxhdGUoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtaXhpdHVwLm1lc3NhZ2VzID0gbmV3IG1peGl0dXAuTWVzc2FnZXMoKTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiAgICBtaXhpdHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2luY2UgICAgICAgMy4wLjBcbiAgICAgKiBAcGFyYW0gICAgICAge21peGl0dXAuTWl4ZXJ9IG1peGVyXG4gICAgICovXG5cbiAgICBtaXhpdHVwLkZhY2FkZSA9IGZ1bmN0aW9uIE1peGVyKG1peGVyKSB7XG4gICAgICAgIG1peGl0dXAuQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2JlZm9yZUNvbnN0cnVjdCcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgdGhpcy5jb25maWd1cmUgICAgICAgICAgPSBtaXhlci5jb25maWd1cmUuYmluZChtaXhlcik7XG4gICAgICAgIHRoaXMuc2hvdyAgICAgICAgICAgICAgID0gbWl4ZXIuc2hvdy5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy5oaWRlICAgICAgICAgICAgICAgPSBtaXhlci5oaWRlLmJpbmQobWl4ZXIpO1xuICAgICAgICB0aGlzLmZpbHRlciAgICAgICAgICAgICA9IG1peGVyLmZpbHRlci5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy50b2dnbGVPbiAgICAgICAgICAgPSBtaXhlci50b2dnbGVPbi5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy50b2dnbGVPZmYgICAgICAgICAgPSBtaXhlci50b2dnbGVPZmYuYmluZChtaXhlcik7XG4gICAgICAgIHRoaXMuc29ydCAgICAgICAgICAgICAgID0gbWl4ZXIuc29ydC5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VMYXlvdXQgICAgICAgPSBtaXhlci5jaGFuZ2VMYXlvdXQuYmluZChtaXhlcik7XG4gICAgICAgIHRoaXMubXVsdGltaXggICAgICAgICAgID0gbWl4ZXIubXVsdGltaXguYmluZChtaXhlcik7XG4gICAgICAgIHRoaXMuZGF0YXNldCAgICAgICAgICAgID0gbWl4ZXIuZGF0YXNldC5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy50d2VlbiAgICAgICAgICAgICAgPSBtaXhlci50d2Vlbi5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy5pbnNlcnQgICAgICAgICAgICAgPSBtaXhlci5pbnNlcnQuYmluZChtaXhlcik7XG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlICAgICAgID0gbWl4ZXIuaW5zZXJ0QmVmb3JlLmJpbmQobWl4ZXIpO1xuICAgICAgICB0aGlzLmluc2VydEFmdGVyICAgICAgICA9IG1peGVyLmluc2VydEFmdGVyLmJpbmQobWl4ZXIpO1xuICAgICAgICB0aGlzLnByZXBlbmQgICAgICAgICAgICA9IG1peGVyLnByZXBlbmQuYmluZChtaXhlcik7XG4gICAgICAgIHRoaXMuYXBwZW5kICAgICAgICAgICAgID0gbWl4ZXIuYXBwZW5kLmJpbmQobWl4ZXIpO1xuICAgICAgICB0aGlzLnJlbW92ZSAgICAgICAgICAgICA9IG1peGVyLnJlbW92ZS5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy5kZXN0cm95ICAgICAgICAgICAgPSBtaXhlci5kZXN0cm95LmJpbmQobWl4ZXIpO1xuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaCAgICAgICA9IG1peGVyLmZvcmNlUmVmcmVzaC5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy5mb3JjZVJlbmRlciAgICAgICAgPSBtaXhlci5mb3JjZVJlbmRlci5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy5pc01peGluZyAgICAgICAgICAgPSBtaXhlci5pc01peGluZy5iaW5kKG1peGVyKTtcbiAgICAgICAgdGhpcy5nZXRPcGVyYXRpb24gICAgICAgPSBtaXhlci5nZXRPcGVyYXRpb24uYmluZChtaXhlcik7XG4gICAgICAgIHRoaXMuZ2V0Q29uZmlnICAgICAgICAgID0gbWl4ZXIuZ2V0Q29uZmlnLmJpbmQobWl4ZXIpO1xuICAgICAgICB0aGlzLmdldFN0YXRlICAgICAgICAgICA9IG1peGVyLmdldFN0YXRlLmJpbmQobWl4ZXIpO1xuXG4gICAgICAgIHRoaXMuY2FsbEFjdGlvbnMoJ2FmdGVyQ29uc3RydWN0JywgYXJndW1lbnRzKTtcblxuICAgICAgICBoLmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgaC5zZWFsKHRoaXMpO1xuICAgIH07XG5cbiAgICBtaXhpdHVwLkJhc2VTdGF0aWMuY2FsbChtaXhpdHVwLkZhY2FkZSk7XG5cbiAgICBtaXhpdHVwLkZhY2FkZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG1peGl0dXAuQmFzZS5wcm90b3R5cGUpO1xuXG4gICAgbWl4aXR1cC5GYWNhZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbWl4aXR1cC5GYWNhZGU7XG5cbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbWl4aXR1cDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbWl4aXR1cDtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93Lm1peGl0dXAgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cubWl4aXR1cCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3aW5kb3cubWl4aXR1cCA9IG1peGl0dXA7XG4gICAgfVxuICAgIG1peGl0dXAuQmFzZVN0YXRpYy5jYWxsKG1peGl0dXAuY29uc3RydWN0b3IpO1xuXG4gICAgbWl4aXR1cC5OQU1FID0gJ21peGl0dXAnO1xuICAgIG1peGl0dXAuQ09SRV9WRVJTSU9OID0gJzMuMy4xJztcbn0pKHdpbmRvdyk7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiaW1wb3J0IG1peGl0dXAgZnJvbSBcIm1peGl0dXAvZGlzdC9taXhpdHVwXCI7XHJcbmltcG9ydCBHbGlkZSBmcm9tIFwiQGdsaWRlanMvZ2xpZGUvZGlzdC9nbGlkZVwiO1xyXG5cclxuY29uc3QgbWl4ZXJDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucG9ydGZvbGlvTWl4Jyk7XHJcblxyXG5sZXQgbWl4ZXIgPSBtaXhpdHVwKG1peGVyQ29udGFpbmVyLCB7XHJcbiAgICBzZWxlY3RvcnM6IHtcclxuICAgICAgICB0YXJnZXQ6ICcubWl4J1xyXG4gICAgfSxcclxuICAgIGFuaW1hdGlvbjoge1xyXG4gICAgICAgIGR1cmF0aW9uOiAzMDBcclxuICAgIH1cclxufSk7XHJcblxyXG5cclxubGV0IGdsaWRlID0gbmV3IEdsaWRlKCcuZ2xpZGUnLCB7XHJcbiAgICB0eXBlOiAnY2Fyb3VzZWwnLFxyXG4gICAgcGVyVmlldzogMSxcclxuICAgIGZvY3VzQXQ6ICdjZW50ZXInLFxyXG4gICAgYXV0b3BsYXk6IFwiMjUwMFwiXHJcbn0pO1xyXG5nbGlkZS5tb3VudCgpO1xyXG5cclxuXHJcbmxldCBtcSA9IHdpbmRvdy5tYXRjaE1lZGlhKCBcIihtYXgtd2lkdGg6IDk5MnB4KVwiICk7XHJcbmxldCBzciA9IG5ldyBTY3JvbGxSZXZlYWwoKTtcclxuXHJcbmNvbnNvbGUubG9nKG1xKTtcclxuXHJcbmxldCBzbGlkZVVwID0ge1xyXG4gICAgZGlzdGFuY2U6ICcxNTAlJyxcclxuICAgIG9yaWdpbjogJ2JvdHRvbScsXHJcbiAgICBvcGFjaXR5OiAuMSxcclxuICAgIGR1cmF0aW9uOiA3MDAsXHJcbiAgICBpbnRlcnZhbDogNTAsXHJcbiAgICBkZWxheToyMDBcclxufTtcclxubGV0IHNsaWRlTGVmdCA9IHtcclxuICAgIGRpc3RhbmNlOiAnMTUwJScsXHJcbiAgICBvcmlnaW46ICdsZWZ0JyxcclxuICAgIGR1cmF0aW9uOiA3NTAsXHJcbiAgICBkZWxheTogMTAwLFxyXG4gICAgbW9iaWxlOiBmYWxzZVxyXG59O1xyXG5sZXQgc2xpZGVUb3AgPSB7XHJcbiAgICBkaXN0YW5jZTogJzMwMCUnLFxyXG4gICAgb3JpZ2luOiAndG9wJyxcclxuICAgIGR1cmF0aW9uOiA4NTAsXHJcbiAgICBkZWxheTogMzAwXHJcbn07XHJcbmxldCBzbGlkZVJpZ2h0ID0ge1xyXG4gICAgZGlzdGFuY2U6ICcxNTAlJyxcclxuICAgIG9yaWdpbjogJ3JpZ2h0JyxcclxuICAgIGR1cmF0aW9uOiAyNTAsXHJcbiAgICBvcGFjaXR5OiAwXHJcbn07XHJcbmlmKCFtcS5tYXRjaGVzKXtcclxuICAgIHNyLnJldmVhbCgnLnN0YXRzLWNvdW50ZXInLHNsaWRlVXApO1xyXG4gICAgc3IucmV2ZWFsKCcuYWJvdXQtdXNfX2ltZycsc2xpZGVMZWZ0KTtcclxuICAgIHNyLnJldmVhbCgnLmFib3V0LXVzJyxzbGlkZVRvcCk7XHJcbiAgICBzci5yZXZlYWwoJy5jYXJvdXNlbCcsc2xpZGVMZWZ0KTtcclxuICAgIHNyLnJldmVhbCgnLmNhc2Utc3R1ZHlfX2ltZycsc2xpZGVSaWdodCk7XHJcbn1cclxuXHJcblxyXG5cclxuY29uc3QgbmF2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25hdicpO1xyXG5jb25zdCBhcnJvd1RvcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcnJvd1RvcCcpO1xyXG5jb25zdCBzbGlkZXJQYW5lbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zbGlkZXJfX3RyaWdnZXInKTtcclxuY29uc3QgcGFyYWxsYXggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFyYWxsYXgnKTtcclxuY29uc3Qgc3RhdGlzdGljcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zdGF0aXN0aWNzJyk7XHJcbmNvbnN0IHN0YXRzRElWcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zdGF0cy1jb3VudGVyX19udW0nKTtcclxubGV0IHhTY3JvbGxQb3NpdGlvbjtcclxubGV0IHlTY3JvbGxQb3NpdGlvbjtcclxubGV0IGxhc3RTY3JvbGxQb3MgPSAwO1xyXG5sZXQgZGlzdGFuY2UgPSAwO1xyXG5sZXQgY291bnRlZCA9IGZhbHNlO1xyXG5sZXQgcGFyYWxsYXhQb3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc3RhdGlzdGljcycpO1xyXG5cclxubGV0IGRhdGEgPSBwYXJhbGxheFBvcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuY29uc3QgbWVudUl0ZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm5hdl9faXRlbScpO1xyXG5jb25zdCBtZW51QnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm5hdl9fYnV0dG9uJyk7XHJcbi8vIGNvbnN0IGJyZWFrcG9pbnRzID0ge1xyXG4vLyAgICAgc206IDMsXHJcbi8vICAgICBtZDpcclxuLy8gfTtcclxuXHJcblxyXG5cclxuLy8vIGNsb3NpbmcgbW9iaWxlIG1lbnVcclxuXHJcbm1lbnVJdGVtcy5mb3JFYWNoKChpdGVtKT0+e1xyXG4gICBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywoZSk9PntcclxuICAgICAgY29uc29sZS5sb2coZS5jdXJyZW50VGFyZ2V0LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudCk7XHJcbiAgICAgICBlLmN1cnJlbnRUYXJnZXQuY2hpbGRyZW5bMF0uY2xpY2soKTtcclxuICAgICAgIGUuY3VycmVudFRhcmdldC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnb3BlbicpO1xyXG4gICAgICAgbWVudUJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuICAgfSk7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gZ2V0RG9jSGVpZ2h0KCkge1xyXG4gICAgbGV0IEQgPSBkb2N1bWVudDtcclxuICAgIHJldHVybiBNYXRoLm1heChcclxuICAgICAgICBELmJvZHkuc2Nyb2xsSGVpZ2h0LCBELmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsXHJcbiAgICAgICAgRC5ib2R5Lm9mZnNldEhlaWdodCwgRC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxyXG4gICAgICAgIEQuYm9keS5jbGllbnRIZWlnaHQsIEQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxyXG4gICAgKVxyXG59XHJcblxyXG5sZXQgZG9jaGVpZ2h0ID0gZ2V0RG9jSGVpZ2h0KCk7XHJcblxyXG5cclxud2luZG93Lm9uc2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHJcbiAgc2hyaW5rTmF2KCk7XHJcbiAgc2hvd0Fycm93KCk7XHJcblxyXG5cclxuICAvLy8vLy8vIHN0YXJ0IGNvdW50aW5nIHVwIGluIHNlcnZpY2Ugc2VjdGlvblxyXG5cclxuICAgIGlmKGlzRWxlbWVudEluVmlld3BvcnQoc3RhdGlzdGljcykgJiYgY291bnRlZCA9PT0gZmFsc2Upe1xyXG4gICAgICAgIHN0YXRzRElWcy5mb3JFYWNoKGU9PntcclxuICAgICAgICAgICAgbGV0IGNhdCA9IGUuaWQ7XHJcbiAgICAgICAgICAgIGxldCB0aW1lID0gMztcclxuICAgICAgICAgICAgbGV0IGNvdW50VG8gPSBjb21wbGV0ZVN0YXRzW2Ake2NhdH1gXTtcclxuICAgICAgICAgICAgY291bnRWYWx1ZShlLGNvdW50VG8sdGltZSk7XHJcbiAgICAgICAgICAgIGNvdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG59O1xyXG5cclxuZnVuY3Rpb24gaXNFbGVtZW50SW5WaWV3cG9ydChlbCkge1xyXG4gICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICByZXR1cm4gcmVjdC5ib3R0b20gPiAwICYmXHJcbiAgICAgICAgcmVjdC5yaWdodCA+IDAgJiZcclxuICAgICAgICByZWN0LmxlZnQgPCAod2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKSAvKiBvciAkKHdpbmRvdykud2lkdGgoKSAqLyAmJlxyXG4gICAgICAgIHJlY3QudG9wIDwgKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSAvKiBvciAkKHdpbmRvdykuaGVpZ2h0KCkgKi87XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNjcm9sbExvb3AoKSB7XHJcbiAgICB4U2Nyb2xsUG9zaXRpb24gPSB3aW5kb3cuc2Nyb2xsWDtcclxuICAgIHlTY3JvbGxQb3NpdGlvbiA9IHdpbmRvdy5zY3JvbGxZO1xyXG4gICAgc2V0VHJhbnNsYXRlKDAsIHlTY3JvbGxQb3NpdGlvbiAqIDAuMSwgcGFyYWxsYXgpO1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNjcm9sbExvb3ApO1xyXG4gICAgLy9jb25zb2xlLmxvZyh4U2Nyb2xsUG9zaXRpb24seVNjcm9sbFBvc2l0aW9uLHBhcmFsbGF4UG9zLm9mZnNldFRvcCk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBzZXRUcmFuc2xhdGUoeFBvcywgeVBvcywgZWwpIHtcclxuICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3hQb3N9cHgsICR7eVBvc31weCwgMClgO1xyXG59XHJcbmZ1bmN0aW9uIHNldEJnUG9zWSh5UG9zLCBlbCkge1xyXG4gICAgZWwuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uWSA9IHlQb3MgKyBcInB4XCI7XHJcbn1cclxuLy8gU21vb3RoIHNjcm9sbFxyXG5cclxuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYVtocmVmXj1cIiNcIl0nKS5mb3JFYWNoKGFuY2hvciA9PiB7XHJcbiAgICBhbmNob3IuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmdldEF0dHJpYnV0ZSgnaHJlZicpKS5zY3JvbGxJbnRvVmlldyh7XHJcbiAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn0pO1xyXG5cclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgYWRkRGF0YUF0dHJpYnV0ZXMoKTtcclxuICAgIC8vc2Nyb2xsTG9vcCgpO1xyXG59LCBmYWxzZSk7XHJcblxyXG5jb25zdCBzaHJpbmtOYXYgPSAod2lkdGgpID0+IHtcclxuXHJcbiAgaWYoKGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wID4gODAgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA+IDgwKSl7XHJcbiAgICAgICBuYXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwwLDAsLjU1KSc7XHJcbiAgICAgICBuYXYuc3R5bGUucGFkZGluZyA9ICcxcmVtJztcclxuICAgICAgIG5hdi5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XHJcbiAgICAgICBuYXYuc3R5bGUuaGVpZ2h0ID0gJzgwcHgnO1xyXG5cclxuICB9IGVsc2Uge1xyXG4gICAgbmF2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XHJcbiAgICBuYXYuc3R5bGUucGFkZGluZyA9ICczcmVtIDIuNXJlbSc7XHJcbiAgICBuYXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IHNob3dBcnJvdyA9ICgpID0+IHtcclxuICAgIGlmKGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wID4gNDAwIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgPiA0MDApe1xyXG4gICAgICAgIGFycm93VG9wLnN0eWxlLm9wYWNpdHkgPSAnMSc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFycm93VG9wLnN0eWxlLm9wYWNpdHkgPSAnMCc7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLy8gU0xJREVSXHJcblxyXG5jb25zdCBzbGlkZXJCdG5zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNsaWRlcl9fdHJpZ2dlcicpO1xyXG5jb25zdCBzbGlkZXJJbWdzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNsaWRlcl9faW1nJyk7XHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBhZGREYXRhQXR0cmlidXRlcygpe1xyXG4gICAgc2xpZGVySW1ncy5mb3JFYWNoKChpbWcpPT57XHJcbiAgICAgICAgbGV0IG5hbWUgPSBpbWcuZ2V0QXR0cmlidXRlKCdzcmMnKS5zcGxpdCgnLycpWzNdLnNwbGl0KCcuJylbMF07XHJcbiAgICAgICAgLy8gYWRkaW5nIGRhdGEtbmFtZSB0byBpbWdcclxuXHJcbiAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnZGF0YS1uYW1lJyxuYW1lKTtcclxuICAgIH0pXHJcbn1cclxuXHJcbi8vIGdsb2JhbCAtIHRpbWVvdXQgZXZlbnQgZm9yIHNsaWRlXHJcbmxldCBzbGlkZUluUHJvZ3Jlc3M7XHJcbnNsaWRlckJ0bnMuZm9yRWFjaCgoZSk9PntcclxuICAgZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsKGV2ZW50KT0+e1xyXG4gICAgICAgIGlmKGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdha3Rpdm5vIGR1Z21vJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2xpZGVyX190cmlnZ2VyLmFjdGl2ZScpLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICBlLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgIGxldCBzbGlkZSA9IGUuaWQ7XHJcbiAgICAgICBsZXQgaW1nID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtbmFtZT0nJHtzbGlkZX0nXWApO1xyXG5cclxuICAgICAgIC8vIHJlbW92aW5nIGFjdGl2ZSBpbWFnZVxyXG5cclxuICAgICAgIGlmKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zbGlkZXJfX2ltZy5hY3RpdmUnKSl7XHJcbiAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNsaWRlcl9faW1nLmFjdGl2ZScpLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xyXG4gICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAvLyBpZiBzbGlkaW5nIGluIHByb2dyZXNzXHJcbiAgICAgICBsZXQgZWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnNsaWRpbmdcIik7XHJcblxyXG4gICAgICAgaWYoZWxlbXMgIT09IG51bGwpe1xyXG4gICAgICAgICAgIGVsZW1zLmNsYXNzTGlzdC5yZW1vdmUoJ3NsaWRpbmcnKTtcclxuICAgICAgICAgICBjbGVhclRpbWVvdXQoc2xpZGVJblByb2dyZXNzKTtcclxuICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoIWltZ1swXS5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpICYmICFpbWdbMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdzbGlkaW5nJykpe1xyXG4gICAgICAgICAgICBpbWdbMF0uY2xhc3NMaXN0LmFkZCgnc2xpZGluZycpO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0dGluZyBhbmltYXRpb24gZHVyYXRpb24gZnJvbSBDU1MgLy9cclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRBbmltYXRpb25EdXJhdGlvbiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGltZ1swXSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcImFuaW1hdGlvbi1kdXJhdGlvblwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGluIG1zXHJcbiAgICAgICAgICAgIGN1cnJlbnRBbmltYXRpb25EdXJhdGlvbiA9IHBhcnNlRmxvYXQoY3VycmVudEFuaW1hdGlvbkR1cmF0aW9uLnJlcGxhY2UoJ3MnLCcnKSkgKiAxMDAwO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIHNldHRpbmcgdGltZW91dCBldmVudFxyXG4gICAgICAgICAgICBzbGlkZUluUHJvZ3Jlc3MgPSBzZXRUaW1lb3V0KCgpPT57XHJcbiAgICAgICAgICAgICAgICBpbWdbMF0uY2xhc3NMaXN0LnJlbW92ZSgnc2xpZGluZycpO1xyXG4gICAgICAgICAgICAgICAgaW1nWzBdLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xyXG5cclxuICAgICAgICAgICAgfSxjdXJyZW50QW5pbWF0aW9uRHVyYXRpb24pXHJcbiAgICAgICAgfVxyXG5cclxuICAgfSk7XHJcbn0pO1xyXG5cclxuXHJcbmFkanVzdFNlcnZpY2VzU2VjdGlvbigpO1xyXG5cclxuLy8gQWRqdXN0IHNlcnZpY2VzIHNlY3Rpb25cclxuXHJcbmZ1bmN0aW9uIGFkanVzdFNlcnZpY2VzU2VjdGlvbigpe1xyXG4gICAgbGV0IHJvd0xlZnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucm93JykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueDtcclxuICAgIGxldCBzZXJ2aWNlc0xlZnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2VydmljZXMnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS54O1xyXG4gICAgbGV0IG1xID0gd2luZG93Lm1hdGNoTWVkaWEoIFwiKG1heC13aWR0aDogMTIwMHB4KVwiICk7XHJcblxyXG4gICAgc2xpZGVyUGFuZWwuZm9yRWFjaCgoZWwpPT57XHJcbiAgICAgICAgaWYoIW1xLm1hdGNoZXMpe1xyXG4gICAgICAgICAgICBlbC5zdHlsZS5wYWRkaW5nTGVmdCA9IChyb3dMZWZ0ICsgc2VydmljZXNMZWZ0KSArICdweCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0pXHJcblxyXG59XHJcblxyXG5cclxuXHJcblxyXG4vLyBtYWtlIHN1YiB0aXRsZXMgaW4gYSBzbGlkZXJcclxuXHJcbmNvbnN0IHNsaWRlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5taXgnKTtcclxuXHJcbnNsaWRlcy5mb3JFYWNoKHNsaWRlPT57XHJcbiAgICBidWlsZERlc2NEaXYoc2xpZGUpO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGJ1aWxkRGVzY0RpdihkaXYpe1xyXG4gICAgLy8gbGlzdCBvZiBjYXRzXHJcbiAgICBsZXQgY2F0ZWdvcmllcyA9IGRpdi5jbGFzc0xpc3QudmFsdWUucmVwbGFjZSgnbWl4JywnJykudHJpbSgpLnNwbGl0KCcgJyk7XHJcbiAgICAvLyBpbWcgbmFtZVxyXG4gICAgbGV0IGltZ05hbWUgPSBkaXYubGFzdEVsZW1lbnRDaGlsZC5nZXRBdHRyaWJ1dGUoJ3NyYycpLnNwbGl0KCcvJylbMV0uc3BsaXQoJy4nKVswXTtcclxuICAgIGxldCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgbGV0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDUnKTtcclxuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSAnbWl4X190aXRsZSc7XHJcbiAgICB0aXRsZS50ZXh0Q29udGVudCA9IGltZ05hbWUuc3BsaXQoJy0nKS5qb2luKCcgJyk7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGl0bGUpO1xyXG4gICAgbGV0IGNhdGVnb3JpZXNTdWIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XHJcbiAgICBjYXRlZ29yaWVzU3ViLmNsYXNzTmFtZSA9ICdtaXhfX2NhdGVnb3J5JztcclxuICAgICAgICBmb3IobGV0IGkgPSAwO2k8Y2F0ZWdvcmllcy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgbGV0IGNhdGVnb3J5SG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgICAgICAgICBjYXRlZ29yeUhvbGRlci50ZXh0Q29udGVudCA9IGNhdGVnb3JpZXNbaV07XHJcbiAgICAgICAgICAgIGNhdGVnb3JpZXNTdWIuYXBwZW5kQ2hpbGQoY2F0ZWdvcnlIb2xkZXIpO1xyXG4gICAgICAgIH1cclxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjYXRlZ29yaWVzU3ViKTtcclxuICAgIGRpdi5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG59XHJcblxyXG5cclxuXHJcbi8vIFN0YXRzIGNvdW50ZXJcclxuXHJcblxyXG5cclxubGV0IGNvbXBsZXRlU3RhdHMgPSB7XHJcbiAgICBmYXZvcml0ZXM6Mzg5MSxcclxuICAgIHBvc3RzMjRoOiAyMzMsXHJcbiAgICB0b3RhbFBvc3RzOjY0MyxcclxuICAgIGNhbXBhaWduczogNTY0LFxyXG4gICAgYW1hemluZ0ZlYXR1cmVzOiAxNTRcclxufTtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gY291bnRWYWx1ZShlbCx2YWx1ZSx0aW1lKSB7XHJcbiAgICBsZXQgaW50ZXJ2YWwgPSB2YWx1ZS90aW1lLzc7XHJcbiAgICBsZXQgaW5pdCA9IDA7XHJcbiAgICBsZXQgY291bnRpbmcgPSBzZXRJbnRlcnZhbCgoKT0+e1xyXG4gICAgICAgIGluaXQrPWludGVydmFsO1xyXG4gICAgICAgIGlmKGVsLmlkPT09XCJwb3N0czI0aFwiKXtcclxuICAgICAgICAgICAgZWwudGV4dENvbnRlbnQgPSBNYXRoLmZsb29yKGluaXQpICsgXCJLXCI7XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IE1hdGguZmxvb3IoaW5pdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihpbml0ID49IHZhbHVlKXtcclxuICAgICAgICAgICAgICAgIGluaXQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY291bnRpbmcpO1xyXG4gICAgICAgICAgICBpZihlbC5pZD09PVwicG9zdHMyNGhcIil7XHJcbiAgICAgICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IE1hdGguZmxvb3IoaW5pdCkgKyBcIktcIjtcclxuICAgICAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZWwudGV4dENvbnRlbnQgPSBNYXRoLmZsb29yKGluaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoaW5pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwxMjApO1xyXG59XHJcblxyXG5cclxuLy8gQmxvZyBob3ZlciBmdW5jdGlvblxyXG5cclxuY29uc3QgcmVhZE1vcmVCbG9nID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmJsb2dfX3JlYWRtb3JlJyk7XHJcblxyXG5yZWFkTW9yZUJsb2cuZm9yRWFjaChlbGVtPT57XHJcbiAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLChlKT0+e1xyXG4gICAgICAgIGxldCBvdmVybGF5ID0gZS50YXJnZXQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdO1xyXG5cclxuICAgICAgICBvdmVybGF5LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xyXG4gICAgfSk7XHJcbiAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywoZSk9PntcclxuICAgICAgICBsZXQgb3ZlcmxheSA9IGUudGFyZ2V0LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudC5jaGlsZHJlblswXS5jaGlsZHJlblswXTtcclxuXHJcbiAgICAgICAgb3ZlcmxheS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuICAgIH0pO1xyXG59KTtcclxuXHJcbi8vIGhhbWJ1cmdlciBtZW51XHJcblxyXG5cclxuXHJcbm1lbnVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLChlKT0+e1xyXG4gICBlLmN1cnJlbnRUYXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJyk7XHJcbiAgIGNvbnNvbGUubG9nKGUuY3VycmVudFRhcmdldC5wYXJlbnROb2RlLmNoaWxkcmVuWzFdLmNsYXNzTGlzdC50b2dnbGUoJ29wZW4nKSk7XHJcbn0pO1xyXG4iLCJpbXBvcnQgXCIuL2FwcC5qc1wiO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9